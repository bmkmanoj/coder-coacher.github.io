<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Azat Mardan: You Don't Know Node.js - JSConf Iceland 2016 | Coder Coacher - Coaching Coders</title><meta content="Azat Mardan: You Don't Know Node.js - JSConf Iceland 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Azat Mardan: You Don't Know Node.js - JSConf Iceland 2016</b></h2><h5 class="post__date">2016-09-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NLtL-EEclRc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">everyone so how many of you are
front-end engineers you work with mostly
on the front end okay how many of you
back-end engineers okay more about 60%
cocoa cocoa how many of you think they
know no js' but are still here okay so
you have enough time to go to the next
room so if you have computers if you're
not tired already from all this amazing
information you can code along with me
and because I have some code examples or
you can just relax and know that all the
slides are on the github so yep take a
picture it's their soul open source okay
so just to remind you why we here and
why it's good to know such thing as no
js' and JavaScript so generally software
is kind of becoming everywhere our
life's becoming digital so by building
better software we can actually improve
lives of other people a little bit about
myself
she already introduced me so I will skip
through the slides faster some of my
books practical node and Pro Express we
have them here my publisher a press they
currently provided the books so we will
do the giveaways and signing you can
find me on Twitter and blog and some of
the other highlights I've worked at
Storify and DocuSign early users of
nodejs
so I know what I'm talking about more or
less
Capital one it's famous for its Viking
commercials it's one of the top 10 US
banks I promise I'm not going to have a
lot of gifts only two more okay so let's
start with basics first of all like why
do we even want to use node.js right
because we might have people completely
new to know the ass
so there are typically two categories of
systems one is input and output bount
and another a cpu-bound so when we're
building web applications we're usually
working with the input and output bound
systems so what is input and output it
could be writing to the database as
making a request to a server or a third
party service or doing something else
which is usually takes a lot of time
just for the waiting for that process so
know just has the thing it's called
non-blocking i/o now or non-blocking
input and output why this is good so
when we're working with nodejs and
usually we're building web servers we
might have some clients making requests
so under the hood of nodejs we have a
vent loop which was borrowed from google
chrome v8 engine so that event loop is
always looking for things to execute and
then it delegates the actual jobs the
actual processes to some other systems
for example a file system or database
etc so when the delegation happens event
loop also passes the callback which is
typically some JavaScript or node.js
code and when the system is done it's
over it's finished that callback is
executed and usually that go back has
the code to send back the data to the
client if we're talking about web
servers so how many of your Java
developers or started with Java okay so
even if you're not hardcore Java
developer you kind of guess what is
happening here there is a sleep method
and the key here probably this is the
most important piece in like the whole
presentation the key here is that Java
process will be put into so to say sleep
so nothing will be executed until that
one second passes so 1,000 milliseconds
or one second blocks the entire process
game contrat that with this node.js code
where we're scheduling the process in
the future by using a callback so that
function is sort of a set timeout it's
not executed right away it will be
executed in the future so from step one
we skip right to the step two then one
second passes and we would see step
three so why this is good because we
could execute more code while the
waiting is happening so the waiting is
not actually sleeping
it's just scheduling in the future so we
would see step one step two then we
would see step four and then we would
see after 1000 milliseconds step three
and step five so this is probably the
most important piece from this whole
presentation not just allows you to
write faster applications typically
because we're utilizing that idle
waiting time so let's talk about web
servers a little bit so this is how we
would write a web server schematically
of course just a diagram using some of
those blocking i/o systems like Python
Ruby Java etc each subsequent request
would be blocked by the previous request
so you have the queue and they have to
wait in that queue I always like to give
this a knowledge of a coffee shop you go
to coffee shop and you order your drink
he or she the barista the cashier at the
register they would take your order they
would take your money and then they
would turn around and make you drink and
usually that leads to long lines people
are waiting in line because each person
before you has to order the drink and
wait for that drink right so you have
unhappy customers the line is blocked
your typical blocking input and output
system now let's take a look how things
are in no js' so we have event loop
again and event loop delegates the
processes to others underlying systems
so event loop is almost never
locked it's almost never blocked and
that's a good thing and it's also a
single-threaded we will talk about it in
the next slide but basically going back
to our coffee shop analogies this is how
Starbucks works and maybe Dunkin Donuts
which I've heard people like in Iceland
so people are happier they're sitting at
the tables because it's asynchronous we
have this non-blocking in input and
output system implemented so you go
order your drink they write down your
name and or maybe they give you number
and then you go back to your table and
you continue working on your JavaScript
application and they call you you go
back and get your drink right so people
are happy we don't have a line and also
this process tends to be a better at
scaling because the only way you can
actually scale the blocking system by
increasing the number of threads or
increasing the number of registers the
cash registers that will increase the
number of lines but in this example you
can increase the number of workers so
multi-threading it's not necessarily a
great thing sometimes it can blow up in
your face especially if you don't know
how to use it so it comes with
complexity and it was born out of the
necessity how you would scale a blocking
system right so the blocking system they
have to be multi-threaded in nodejs
it's a single threaded system so it
eliminates complexities such as
synchronizing the data between threads
deadlocks racing conditions etc but it's
still possible to write blocking code in
ogs so by just the knowing that no js'
is have the non blocking i/o it's still
not going to prevent developers from
writing blocking code let's take a look
at this example and you can run there is
a file blocking j/s so you can just go
into your terminal and execute that file
once you get my source code and I get
anywhere from 100 milliseconds to 1,000
milliseconds obviously most of the times
we don't get the blocking code
just obvious which is like a for-loop
this blocking code is buried inside of
the module I know that module that
that's how so the way to know that it's
a synchronous basically you need either
to read the documentation or read the
source code in this case FS the naming
convention
it has the word sink in it so we know
that it's a synchronous module by
looking at it another dead giveaway
signer that the content will be
available right there on the next line
so I can assign var and then the result
of read file sync and I can cancel log
that so we will go from top to bottom
just as in any other traditional
programming language in a synchronous
language so it's very easy to reason
about but this would not be very
efficient code this is much more
efficient code it's also in node.js but
now we're using a function which is read
file not read file sync and with this
file we're using callbacks so the trick
here is that the data would not be
available on the next line so council
log hello Ruby would not have the
content of the file available the
content of the file will be available in
the future when the callback is
happening and your result might vary so
first you might get the accounts or IP
addresses from IPS dot txt or you might
get IPS first depending on what file is
larger right so we're executing them in
parallel parallel and concurrency the
different terms but when it comes to
node.js they usually interchangeable so
node.js is typically much much faster
than other platforms and languages
because of this input optimization input
and output and optimization but let's be
honest how many of you actually hit the
bottleneck when it counts a performance
personally I don't experience that
problem if I have that problem I can add
RAM I can add CPU I can add workers
it's it's cheaper to scale than it used
to be ten years ago so I'm not building
the next Facebook or Google for me my
personal no js' benefit and a lot of
other developers also shared this is
that we can use javascript so we have
one language two rules to rule basically
the entire stack we can think faster we
can reuse code if I'm using lodash or
underscore on the browser can use that
on on the server as well and also if I'm
using the same API the same interface
all over the stack I'm learning quicker
I don't need to refer to the
documentation that that much so the good
thing about not just that most of this
classes the subjects they are available
as this right we have arrays drinks
primitives so if you know nodejs it's
very easy if you know JavaScript it's
very easy to get started with node it
could take it just like a weekend but
note is not triple equals browser so
there are a few differences we will talk
about them for example there is no
window object obviously there is no
windows when we work with nodejs right
but there is global so if you're just
working with the browser JavaScript
think about global as the window it can
surf everywhere it's kind of magical and
then it has properties by the way the
property it's also accessible without
the prefix without global dot so I can
just say understorms the score dual name
for example it would work so all the
properties of global they also kind of
global in themselves so file name would
give me the path an absolute path to the
currently running script the dear name
would also give me the path but without
the filename so we don't have that in
the browser right you don't want to
navigate the websites and you don't want
the websites to know your file system
what folder you're running the script
but on the server it's a completely
different picture we have that extra
information another thing we don't have
in the browser javascript is modules so
modules are native in nodejs
the way we work with them we have module
to export and then we have required to
import modules it's started from the
common J's where web standard the
browser standard but now it's more or
less the standard for nongenius some of
the other useful things that we can do
with node which we cannot do with the
browser JavaScript process or global
dead process it will give you a lot of
information about the underlying node.js
process and your machine for example you
can get the process ID we can get the
versions not just the version of node.js
but the version of the v8 engine for
example can get the architecture if it's
Windows or if it's some of the POSIX
systems if you're building a
command-line tool like web pack or grunt
you can get those options and
command-line arguments inside the vien
of your node process we can get
environmental variables things like API
keys passwords etc can get the app time
and current memory usage from the
machine as well and CWD that's very
similar to the door name but only if
you're running your node program from
the same file from the same folder from
the same directory in which you have the
source code so in some cases this value
would be different and then we can exit
the current process and we can also
terminate other processes that comes in
handy when we're scaling when we use in
clusters okay so this is a tricky
question so who likes and understands
callbacks okay it's like 40% what about
callback hell once in a while we might
get ourselves into this mess
right so developmental scalability that
means bringing more people more
developers to current projects having
more people work on a single piece of
code and callbacks they're not very
developmental scalable that that's how I
feel sometimes and working with
callbacks so there are other patterns
like promises and async await and
generators but they don't solve all the
problems they sold some of the problem
that callbacks have but what if you for
example want to execute something many
many times and you want to execute that
not just at the end like with callbacks
or promises but you want to execute it
in the middle or in the beginning of a
job or a process so please meet event or
event emitters they're a singleton pad
not a single term they absorber pattern
so no js' observer pattern a good thing
about events they are everywhere in the
core node.js modules so if you know how
to work with events you would understand
how to work with pretty much all of the
core modules of nodejs so we have our
subject we have an object and then we
have event triggers right so we have
three things working together so to
create an object all we need to do is
require events and then we using
prototypal inheritance to create an
object and then we can attach event
listeners so for example I want to
listen for the done event a good thing
about event listeners and like callbacks
or promises that we can have multiple
pieces of logic executed on a single
event so for example knock it's a single
event but I can have many many
functionality executed and the order in
which it will be executed is the same
order in which I define them now this is
very big
take example so let's see something more
real-life something more realistic so
let's say I have a job which is like a
job to send email and then I have three
different types of emails monthly weekly
and daily emails so I want to implement
the job module the way that I can
customize what is happening at the very
end so my job module will emit an event
job that Amit and then when I'm using
this module when I'm actually consuming
now I want to put that custom logic and
the way I do it by creating an event
listener so I know my module is emitting
this event I know the name is done do an
e so all I need to do is put an event
listener the good thing compared to just
callbacks if I don't specify this event
listener it's not going to crash right
if you don't specify a callback and your
module expects it right so the module
will crash another thing is that I can
remove event listeners I can get the
list of event listeners I can have many
of them not just a single callbacks is
typically just a single callback
I've highly highly recommend this book
node.js patterns oh it's not a book okay
just a blog post I'll have the link to
the book later ok so the next problem is
how to handle large data so if you're
working with files larger than 1
gigabyte you might heat the buffer limit
and it's just not a nice experience to
wait for the entire large data to load
so please meet streams they are
abstractions to allow us to work with
continuous chunking of data so we don't
need to wait for the entire large chunk
of data piece of data to load so there
are four types of streams writable
readable than the duplex which are both
readable and writable and then the
transform streams
so streams inherit from Aventa meters so
we will be using the knowledge which we
just acquired in the previous slides to
work with the Aventa meters so streams
they're pretty much in a lot of places
the HTTP requests and response their
streams when we're reading from standard
input and output those are streams as
well when we're working with files their
streams example of a readable stream
process that STD in there is a read
operation so this example will capture
me typing on a keyboard and my program
will output whatever I'm typing so line
by line so when for each line I would
have the console log chunk : output me
the previous line you can run this demo
on your computer's if you following
along now our streams has another
approach which you can also use so
readable that read it's a synchronous
method which returns the current chunk
of data and once the stream is finished
it will return null so we can put it in
a while condition so when it's now the
wild will stop working and it's it's
okay that it's synchronous because each
chunks is just a line of data if we're
reading from a file working with the
text data so it's not a big deal in this
case it's synchronous what about
writable streams so there is a write
operation so the next example will write
a an output to a terminal it's actually
very similar to what counsel that log is
using under the hood so what about HTTP
so when we're working with HTTP that's
where streams are really really
beneficial because now your clients they
can start receiving the data right away
or if you're consuming the data you can
transform the data right
way so in this case we're using invent
emitters and we're listening for the
data which is coming from the request
and then I have this function transform
let's say it's a transform stream and
maybe I'm writing this data somewhere or
just transforming it it's very very
useful another interface are using dot
pipe it's very similar to Linux command
line so you can pipe from one process to
another or in this case from one string
to another so to work with binary data
and no gel there is a type called buffer
in es6 there also in u67 they're also
adding this similar but so far it's not
as popular on the browser JavaScript so
think about buffers as the binary type
and when you're working with the file
systems or even working with HTTP
servers by default the data it's in
buffer so if you see we're string that
you're supposed to look like a normal
text but it's bunch of numbers looks
like an array probably you need to
convert it from a buffer to a string to
do that you can use a two string and
then pass an encoding so FS module by
default the data is the buffer and I
have a example of Server Express server
which uses two endpoints one with
streams and other without streams once
you start it you can go to slash stream
and slash stream slash non stream non -
stream and you would see the difference
in my case the response time was way way
faster for the stream endpoint and I
have the large picture I have eight
megabyte infographic so so that's
noticeable some of their cool stream
resources how to recommend stream
adventure and stream handbook it's all
open source free to use and view if you
know streams you pretty much can become
like a guru
of nodejs in your team maybe even in
your company if your company is not big
so okay so back to scaling how we can
scale node.js because remember it's
single threaded right and this is one of
the arguments which you might hear from
your co-workers from hardcore Java
developers like oh no just a single
threaded we cannot use it
well actually it's relatively easy to
scale nodejs what we can do we can have
one master process and then we can have
multiple worker processes so the master
will be just creating new workers and
listening when those workers are dying
or crashing to restart them and then the
workers they would be actually doing all
the heavy lifting they will be doing all
the processing there would be our HTTP
servers so the good thing about this
core module cluster is the core module
well that's a good thing probably the
only good thing so there are better
alternatives I have an example as well
I'm using load test so you can load test
your server with cluster and without the
cluster so other alternatives are strong
strong cluster control and PM to a lot
of developers like p.m. 2 p.m. stands
for process manager so basically you can
use PM 2 or a similar tool without
anything else just like that and your
application would be really really good
and robust in production so that's when
you want to scale and go to production
my personal favorite thing about PM 2
that you don't need to modify your
source code so you just use the source
code exactly the same as for the single
process PM 2 will create multiple
process and utilize the maximum CPU
power from each machine so that's a
vertical scaling I have some demos as
well in the source code so you can play
with that there are multiple ways to
start
a different process not just fork so
fork it's mostly for nodejs and then we
have spawn which is pretty much for
anything they work very similarly you
can process big big data large data with
both of them because they use stream and
exact it does not use dream it uses just
a callback so you don't use event
emitters and obviously if it uses a
buffer you will run into buffer limits
so usually exact it's for small command
here's an example spoon no js' program
yes so I can run a different node.js
instance for it very similar only don't
need to specify that it's note so it's
only going to work with node process it
an exact example I have a callback so in
the callback I would get STD out STD in
STD are from that process
okay so asynchronous errors they're a
little bit tricky because remember that
event loop from the first slides so
actually what happens when we use event
loop will lose the context so this is
how you would handle errors in
traditional languages and asynchronous
errors in JavaScript we will put try
catch but try catch totally useless when
it comes to asynchronous code because
that event loop when it schedules
something in the future it loses the
contents it loses the try catch so when
the callbacks come comes back we don't
have that try catch anymore so this will
fail miserably and this is how I feel
when I work with that and try to debug
is synchronous errors I promise this is
the last gift so how to deal with this
there are multiple things that consider
that I consider the best practice I
would not go into details about all of
them but I think the most important one
is uncaught exception so process
remember process how many of you
remember process
okay that's a good ratio half of the
room another half is already sleeping
ungass exception so process that on
uncut exception this is how we attach an
event listener so again process
implements event listener and the event
emitter pattern why this is good because
this is like the last step before
application crashes so we definitely
want to listen to this error handler to
this event we want to log it we want to
maybe send an email or a slack
notification and then we want to exit
gracefully so we don't want to resume
the application because the state might
be lost at this point okay here's the
domain which is softly deprecated
nothing scary about self-deprecation it
just means they're going to remove it
from the core but I'm sure it will be
like a standalone NPM module the way it
works we can put code inside of the main
dot run and even it's a synchronous code
it will still catch those pairs it will
still casual sizing cursors so if you're
building an express server you can wrap
all middleware all routes in the main
dog run or you can just rub a single
route I have a few examples in the
source code folder as well so this code
will run okay and then the last bonus
part we three minutes over the time so I
will move a little bit faster it's about
writing the C++ add-ons so a lot of
people think that no jess is just
JavaScript well actually there is more C
and C++ in nodejs itself in the platform
itself than JavaScript and it's very
very straightforward how to make them
work together if you want to write a
module or a driver to your database or
maybe some hardware device
all you need to do is have a simple aah
splat file obviously right
so I'm going to work if you don't have
the source code and then notice this
thing so this thing will output a string
and then I'm exporting my method so you
need to do two things inside of your C
code you need to well write your code
right and then expose it as the method
and then I'm creating this JSON file
which has the name of my add-on the name
of my library and my source code I'm
installing no gyp which will do the
compilation and run this two commands
configure and build and that's it boom I
would have this folder build release now
from the node all I'm doing is just
requiring this folder and I can use my
method so hello that's the same method
that I defined and exported in C++ so
that would output Capital One when I run
it so you can basically communicate
between two worlds two different
languages I think that's pretty pretty
cool if you want to hear more about
node.js at Capital One we are top US
bank there is a YouTube video and
30-second summary we'll make it like
three seconds summary so invented meters
streams clusters the main c++ add-ons
and streams so this slides on github to
search my name and also find it can
reach me on twitter and if you want to
learn more at node university I have I
would have this stock available there
for free all open-source as an online
course and also have a bunch of other
online courses and node.js as well one
last thing this is a quote from coding
horror dot-com and JavaScript is
everywhere and it could be a good thing
or it could be a scary thing
to think about Tesla running on
JavaScript but if you think about
terminators running on JavaScript
maybe humanity will have a hope thank
you everyone
enjoy the conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>