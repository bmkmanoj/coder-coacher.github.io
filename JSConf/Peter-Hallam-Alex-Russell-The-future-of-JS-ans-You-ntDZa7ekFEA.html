<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Peter Hallam &amp; Alex Russell: The future of JS ans You | Coder Coacher - Coaching Coders</title><meta content="Peter Hallam &amp; Alex Russell: The future of JS ans You - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Peter Hallam &amp; Alex Russell: The future of JS ans You</b></h2><h5 class="post__date">2013-01-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ntDZa7ekFEA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so how many of y'all were at Jess comp
okay so most of you may or may not have
taken the opportunity to see the closing
talk in which we announced tracer which
is a JavaScript of JavaScript compiler
written in JavaScript there are many
like it this one is different no it's
different because it's not just only
because it's written in JavaScript but
because the source language that it
consumes is some variant of what we hope
will be a set of features that are in
the next version of Java Script so it's
JavaScript of the future more or less to
JavaScript of today strictly speaking
es5 so browsers that running is 5 or
environments of running s5 like node can
take advantage of this and so we all the
demos we did for JS conf demo tracer in
the browser but tracer absolutely works
on the on node in fact we have a batch
mode that relies on node uses v8 to go
and automatically generate code for you
so you can run it to batch content that
you'd like to serve to the client
written in the future version or you can
run it online inside of node to make it
make it go so but today's talk is sort
of not just about what it is and what it
does for you but rather we want to sort
of peel back the layers a little bit and
show you kind of how it works because
fundamentally tracer is not about like
hey look everybody here's a great tool
for you to use it's a it's a tool that's
got an expiration date on and that
expiration date is when the language
gets much more awesome you won't need it
right because you're working a note on
the server your environments moving a
lot faster than the client-side
environment is you get to choose your
version of VA right you get to choose
your version of the language and as soon
as v8 get stuff or as soon as you decide
to change your deployment environment
you get all of the advantages of
everything you've just dumped into your
world which you don't get on the client
and the client side you're at the mercy
of whatever your your
users happen to have deployed and
they're going to move relatively slowly
compared to your server site environment
which is why I think there's this large
and growing population of alternative
languages for server-side development
including JavaScript thank goodness so
because they're the economics and the
and the constraints of the of the client
side are different than the server side
we can use that to help move faster on
the server and so this is the community
that's going to be able to try out this
new stuff faster use it first stretch
its legs and provide this sort of
detailed feedback we absolutely need to
make sure that the next original
language has all of the right stuff in
it and none of the stuff that we think
is buggy so harmony is pretty awesome so
the stuff that's already on the slated
for the proposals list for harmony gives
us modules it gives us proxies proxies
are amazing if you've used node proxy
you've seen it firsthand or proxies
under spider monkey harmony gives us a
bunch of syntactic fixes it gives us
semantic fixes for things like
asynchronous module loading or
apparently synchronous module loading
with asynchronous behavior the sorts of
stuff that you wind up doing all the
time in either no directly or in
patterns that you sort of carry around
with you in code that you're working on
so for example the node has its own
require system which is synchronous
right which is sort of mirrors the
apparently synchronous behavior of
what's happening under the covers in
harmony modules and so we sort of see
this this pressure being taken off of
patterns and off of libraries by the
language when we move to harmony
features and so that I just want to give
you a really simple example and sort of
we're going to walk through what happens
inside of a compiler from point A to
point B when we go from a source
language to the destination target
because what we really want out of these
compilers is for them to hopefully be
backwards compatible semantically like
we want the next evolution of the
language to be built on primitives that
we know and love right for instance when
we go and talk about classes we don't
necessarily want class-based 00 fused
into the language in a way that's that's
sort of upsetting to the prototypal 00
and object
composition styles of inheritance that
we know and love today some people do
want that but they tend not to be
JavaScript programmers already they tend
to be coming from a different place
those of us who love JavaScript I think
are much more in tune with the idea of
keeping prototypal inheritance and
giving it significantly better syntax so
that idea of sort of taking the
semantics we have giving it a better way
to say what you mean is exactly what we
want to get to I think broadly speaking
and I know that the the committee is
working hard to make to make that happen
in a bunch of places so let's walk
through how one of those features that
does exactly this that's got a great
expression in today's semantics can be
implemented through a compiler so this
is a pretty common example of a variable
arguments function variable arity our
function where you'd have to go to note
that in some other piece of metadata
like a jjs thought comment someplace to
note that this thing is going to take
more than one argument which is the
actual function dot length result here
and it's going to provide a default
value for format which you also have to
go document someplace else it's not
actually readable in your code and
you're gonna have to deal with this
parameter thing because you know
arguments isn't actually an array as
things are messy okay so harmony gives
us a much better answer harmony lets us
say I'm going to provide a default
parameter value so if I don't provide
one it's going to be defaulted to that
empty string and everything else that
you pass in beyond the initial is going
to be bucketed into a local variable
called params right that's pretty
awesome that means that no longer going
to be have to shuttling the arguments
object around to try and go pull stuff
out and try not to mutate it because
it's live instead you're going to have
an object that does what you want and
and gives you this really nice toast in
text which has a mirror on the spread
operator so that when you go to use it
in other places you no longer have to
use call and apply this is really nice
stuff okay so how do we get there well
let's let's take this code you know so
this is what we this is what we start
with and this is what we'd like to be
writing so let's take this code and sort
of run it through tracer so we've got
the tracer Ruppel over here and what
we've got right now is when we type this
in we've got
Pilar no right you can't see everything
let's let's fix that okay so wait when
you uh when you run this through the
tracer repple what you get out of the
other side is the sort of the exact same
thing except the function has been
rewritten for you right so the rest this
talk is about how the heck does that
happen right because a lot of us sort of
three compilers like there's some big
black box there a scary thing there are
things that compiler people do and we're
not compiler people we write
applications but compilers don't have to
be scary they don't have to be somebody
else's somebody else's bag there are
things that we can address so um yeah
again we can see exactly what's going on
there and I'm gonna yeah yeah so so I'm
going to hand it over to Peter to sort
of walk us through the rest of the
compiler life cycle but if you take
anything away from today's talk I hope
that you you start to believe that
JavaScript programmers can participate
in the process of evolving the language
not just by telling us what you want or
telling us what you need by helping us
prototype this stuff and we'll show you
how howdy hey I'm Peter helm thanks Alex
so I'm a compiled a guy so I'm just
going to try and walk you guys through
sort of the basics of the anatomy of a
compiler and basically you know a
high-level a compiler is just going to
take a source program that you've
written and convert it into something
else and you know some compilers you
will convert it down to machine code and
this compiler is going to turn take
source code that too with this risk
which is JavaScript plus new features
and turn into JavaScript sort of of
today and you know compilers is a pretty
well studied domain and so you know
there's some common patterns that you
use to sort of get yourself through a
compiler so the first the first stage of
a compiler is called lexing also known
as scanning or tokenizing and basically
what you do is you take the
our source code is an array of
characters and you turn it into an array
of tokens once you've got an array of
tokens you do the syntactic analysis so
you parse the tokens and turn it into a
tree I'll get a little bit more detail
of what this looks like once you've got
a tree that represents your program then
you can transform that tree from a tree
containing so each statement each node
in the tree is going to represent a
statement in your program and so a
transformer will take will take a nodes
that are not represented in the in the
output language and transform them into
nodes that are represented in the applet
language and then lastly once you've got
a transform tree then you just write
that tree out and cover it back into
characters again and I'll just walk you
through that pretty quickly here so the
first thing is lexing and as I mentioned
lexing is the process of basically just
taking characters and turning them into
tokens and here's the code snippet from
tracer that shows you basically the
basics of flexing or scanning and token
you know we start by skipping two
comments we remember the index of the
beginning of the token if we're at the
end of the file we just create a token
which is the end of the file otherwise
you've got the next character we look at
it if it's an open curly we create a
token which is an open curly and we note
the beginning of the token and so the
Craig token does pretty much what you'd
expect it creates a new object which is
a token its dash is the token type in it
and it stashes the location and if
you've got more information like the
token is like a string or a number it's
going to store the string or number
value into the end of the token object
but really at the end of the day this is
the sort of the core of what a tokenizer
does obviously there's a bunch of stuff
to scaffolding to kind of get you to set
this up but then the day it's it's
really tokenization is you know pretty
straightforward
so once you've got your tokens then the
question is how do you build a tree that
represents your program so you want to
have like one node say which is a
function and the children of the
function are going to be you know the
arguments of the function the name of
the function you know the body the
function well first thing you do is you
get your token stream and you ask
yourself hey what's the next token and
my soakin stream if it's savar then you
parse the variable statement if its
function your parts function declaration
and of course obviously there's a whole
bunch of other options in here but at
the end of the day this is the sort of
the basics of it a lot of folks you know
come out of college and in college they
tell you hey you got to use a parser
generator for this it turns out that
most of the guys I know that have been
doing compilers for a long long time
actually don't use parser generators and
there's a bunch of reasons for that the
first reason basically it comes down to
the fact that you know writing it hand
coded yourself is actually really not
that hard once you understand the
patterns and you know it kind of also
uses one of the arguments that that I
think folks are using for for no j/s
which is there's value add and having
just one language in your system you
know if you use a parser generator
you've got you express your grammar in a
language which is not your programming
language and there's a lot of value in
having just one language in your system
you know you make makes it much easier
to debug and anyway there's a bunch of
other reasons that I won't get into you
in terms of why I think parser
generators or perhaps is not the best
tool so again what happens when you want
to say parts of function well again it's
a similar kind of thing there's not a
lot of magic to it you stash away the
location of the start of the parse tree
so you can give good error messages you
eat a function token you check to see if
there's an identifier which is the name
of the function you know you eat a
friend eat your formal parameters a
close friend your function body and then
you create up a new object which is
basically just got all these values as
members and off you go so again there's
not a whole lot of magic
and just give you one more quick example
an if statement again you know looks
very very similar and this is code that
I just cut and paste from the compiler
you know you walk through you know you
just eat the tokens the token text types
that you're expecting you know the only
tricky bit here is that you know where
again we're peaking for the token to see
if there's an else clause or not and and
then we build a new node which
represents the the if statement so again
not a whole lot of magic here and once
you know you recognize the patterns here
you know it's actually pretty reasonable
and it's actually not not too bad
compared to say a B and F grammar and
again the nice thing about this is you
don't have to learn a new language to
express your length to express the
grammar of your language so transformers
transformers are where the real work is
done this is where you're taking a tree
the parse tree which represents your
program and transforming it into a
subset of the language which does not
include the the features that are not in
sort of JavaScript now and this is this
is one where I'm going to I'm going to
just switch to VI here quickly hello so
this is the this is the transformer for
rest parameters and basically what it is
is once you walk your tree and
everywhere that you find a function with
a rest parameter in it you basically
call this function and you do this
transform that's described here in the
comment a function with a rest parameter
here and it gets turned into a function
that looks like this and you can just
kind of walk it backwards you know we're
creating a function declaration it's got
the same name as the input function
we've transformed the parameters without
rest and you can sort of see that
happening sort of up here and of course
we transform the body
by adding a block to are adding the
extra variable statement which has the
call to array dot prototype flyff and
again it's it's a little bit you know
reading code that's building up trees is
kind of gnarly but again this is you
know there's not a lot of magic here and
once you understand the patterns you
know it's something that you can
actually you can actually read all right
and then lastly output so once you've
transformed your trees you've got a tree
that's represents sort of the output
that you want you just turn that output
into text and you know we've got some
simple primitives here you know where
you just say right so for a function
declaration you know you write the
keyword function which is just going to
write you know the text function you
know if it's got a name then we write
the name you know we read an open paren
we visit the formal parameter list close
paren function body again it's a pretty
straightforward system once you once you
once you look at it now of course the
trick to all this is a sort of knowing
the patterns and setting up the patterns
so that you can actually compose this
well but you know and once you've got
that then the actual me to the of it is
actually fairly straightforward now we
all right so I want to walk you through
a little more sophisticated
transformation which is the async
function or it's a called deferred
functions rather which is which is a
language feature that we're looking at
to try and help with async asynchronous
callback style programming and that went
through this a little bit and they in
the in the talk at at j s conf and i
want to kind of go into a little bit
more details or how the transformation
works and and and so why this is is I
think at least is helpful to you and
so here's a piece of callback code we've
got an animate function it takes an
element an HTML element this is a
browser scenario obviously and it takes
a call back to say hey once this
animation is finished call this callback
and what's actually happening here is
we're just setting the style of the left
margin of the element and in a loop and
then each time through the loop we wait
for 5 milliseconds until we get to the
left margin of 350 and then once once
we're done we want to invoke the
callback and so you know if I for folks
that are familiar with callback
programming this is perhaps relatively
straightforward to to read but it's a
anyways it's pretty reassuring are
pretty it does twist up the code quite a
bit and then so we want to in our
example we're going to animate the this
element and then we're going to when
we're done we're just going to have an
alert that says hey okay we're not so I
known the there's in the in the the
browser libraries there's this deferred
pattern also known as the promise
pattern and the promise pattern allows
you to compose of functions that async
Chris functions a little bit better
because by moving the call back out of
the argument list and returning an
object upon which you can add a call
back so this is again code is just all
equi script now so there's no X there's
no new features here but here we've got
a defer time out which returns a
deferred object creates a deferred
object calls window set time I set
timeout when the time it happens it's
going to going to signal the deferred
object and say hey you're done now so
call all people and then it's just going
to return that that object and the
animate is every time it wants to
every time it wants to actually wait for
five milliseconds it's going to
basically call 24 timeout with five
milliseconds and then it's going to say
when you're done add my continuation add
my callback to the return value and at
the same time this animate function is
going to is also going to return a
deferred and when it's done it's going
to just say hey I'm going to sick of my
deferred that I'm done and so the caller
of animate now doesn't pass in whoops
sorry doesn't pass in the callback it
just adds its continuation on to the
return value of of the animate function
so so this is kind of nice because you
can just say you know animate you know
it reads kind of nice right says I want
to animate something and then I want to
do an alert all right so it reads a
little bit more composedly unfortunately
when you start getting into for just
straight linear composition I want to do
this then I want to do this thing I want
to do this the then composition works
quite well but here what we're actually
have is essentially something very much
like a for loop but it's actually
unrolled so tanned to turn it into a
call back and there's I'm a compiler guy
and so I speak I speak compiler and
there's a transformation there's a
description of this transformation it's
called continuation passing style and
it's actually a very well understood
transformation in the compiler community
and it turns out that a lot of a lot of
times when you do this transformation
when you're doing these transformations
in compilers you actually use this
continuation passing style technique and
have it actually automated by the
compiler you know in the in the opening
talk you know it's mentioned you know
what is some of the biggest problems
with node well one of the biggest
problems with node is that you have to
turn your code inside out using
continuation passing style right using
callbacks and that's something that is a
real barrier to entry for folks in in
node
and so the question is well you know if
compilers can do this CPS for you what
can we do to make this easier for you
you know more readable and so what I'm
going to show you and so this is where
now this is the same every everything
you see here is the same function so the
defer timeout is exactly the same code
the way that animate is is chained on is
exactly the same but now you'll notice
that the animate function is using sort
of this proposed feature here which is
called a weight and what is happening
here is is when you any function that
contains in a weight or when you see a
weight of an expression it says evaluate
that expression and then attach the
continuation of the function i'm
currently in to the end of that deferred
object and then what i'm going to do is
I'm going to return a new deferred
object to my collar so semantically this
is doing exactly what was happening in
this previous slide all right but
instead of having to turn this into
continuation passing style with a call
back we can just write it like a regular
for loop and the hope is is that with
with this kind of language feature will
actually sort of takes a lot of the
difficulty and of sort of coming to the
callback style world out of out of out
of node out of note um all right how
much your transforms so i'll show you
what this is going to end up looking
like
just pop it into the ripple loop I'm
going to do is I'm just going to get rid
of this so that it shortens up okay so
this is actually showing the the
generated code that the compiler is
going to generate for you for this so
here's our defer time out which we just
kind of comment it out and here's the
animate function and what happens is the
compiler turns your function into a
state machine and basically every line
every statement in the input basically
gets turned into a single state in our
state machine and then the compiler sort
of knits the state machines together by
and and and and hooks it all up so so
for example you know our first our first
state here is left equals 0 then we've
got left less than 350 and then we've
got you know element style and then
we've got their weight so let's walk it
through and you can see here's our left
equals 0 then go to state six and then
state 6 says do the comparison based on
the comparison we decide to go which
which state we're going to go to next so
again there's no magic here and this is
obviously not as pretty as the the CPS
transform code that you would write
yourself but the nice part about this is
that you know you didn't have to write
this at all you know the compiler wrote
it wrote it for you anyway so that and
then I'll just take you through the
actual meat of this you know here we're
actually saying hey call the four-time
out and we're going to get a weight task
back get a variable back we're going to
attach a callback and an error back to
on to that object and then we're going
to return back to our caller and when if
you if the callback is called we're
going to go to say one if the air back
is called we're going to go to stay too
nice part about this is it actually
chains all your exceptions as well
question oh um are you asking about this
code here yeah so there's so there's
dead code in here and the reason why is
just that um the way that this code is
written is we we focused on trying to
make the transform simple as possible
and understandable as possible like the
transforming code i should say the code
that's generating this as opposed to
trying to generate completely optimal
output actual transfer marco ok so i can
i can show you the transforming code let
me do that good lord where is it hang on
sorry
so I think the important part to
remember here is what when you're
looking what's happening here in the
transformation it's sort of like this
library of hacks that you put together
to sort of achieve something in
JavaScript right where the job or
JavaScript has the semantics available
for you and you just have to put
together this large pile of code to sort
of make it happen in JavaScript and when
you're doing that that's the exact same
library of hacks that you sort of embed
into this transformation form of your
compiler you write it a different way
but if there's something that you want
to achieve through syntax in JavaScript
once you sort of walk through this set
of steps in the compiler chain the end
state for each one of those hacks that
you're giving syntax to is this
transformation it's exactly the same
code that you were going to have to
generate yourself or write out the long
hand yourself and the front of the
compiler tool chain is just there to get
you into a state where you can transform
this tree to generate that same thing
that you were going to write by hand so
if you think about it in terms of like
I'm doing this a lot I write it all the
time I want to stop writing it all the
time and then walk back from there it's
really easy in many ways to start
especially if it's all JavaScript
especial but it's all one language it's
really easy to start hacking on this and
say it'd be great if javascript did this
instead and makes it really
straightforward to start working on it
this is the worst case scenario so if
this it doesn't scare the heck out of
you you two can work on a compiler yeah
yeah so this is this is and this is the
this is actually like by far the
gnarliest of the transforms so anyhow so
this is you know and the trick is is
just to sort of break it down into into
cases and enroll it in yes our waiter
time okay and that's basically it if
you're interested in looking at the
Christian compiler here's the links um
and yeah thank you thanks for time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>