<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>David Khourshid: Simplifying Complex UIs with Finite Automata &amp; Statecharts | JSConf Iceland 2018 | Coder Coacher - Coaching Coders</title><meta content="David Khourshid: Simplifying Complex UIs with Finite Automata &amp; Statecharts | JSConf Iceland 2018 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>David Khourshid: Simplifying Complex UIs with Finite Automata &amp; Statecharts | JSConf Iceland 2018</b></h2><h5 class="post__date">2018-04-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RqTxtOXcv8Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Thank You Sean can y'all hear me alright
hold on there we go alright so yeah my
talk is simplifying complex UIs with
finite automata and statecharts although
I would have really liked to see a talk
called simplifying complex talk titles
with less words but that's okay I know
what you all might be thinking right now
this new react API a little bit scary
but I have some helpful advice for you
there's actually a really good book in
order to understand how to best work
with it and it's doing whatever Dan
Abramov says to do I read this book so
I'm totally fine with the API but funny
enough the second half of this talk is
sort of exactly what I'm talking about
today except in a more general sense so
I want to talk about it though not in
the context of react or view or angular
or any of the last three frameworks that
came out last week but I want to talk
about it in the framework list context
because this is an idea that doesn't
just apply to any framework or no
framework in general but really any
programming language as well and we
could see how it could help us simplify
our UIs
so I'm a pianist I've been playing piano
for about 20 years and so this is the
approach that I take to software
development just trying to approach it
with with how I learn music and so I
made the analogy that if software is
music than developers are composers
because we're taking that music and
we're composing it in a way that is
applicable to any language or any
platform and we do so in a variety of
ways however musics interesting because
with music you have music notation which
you just saw there let's go back and see
it so this stuff right here now this
music notation is hundreds and hundreds
of years old however the exact same
notation is used today to represent
music from baroque classical romantic
whatever the help
ork is it represents all of that in the
declarative sixteenth way so that you
could give them a musician who
understands how to read sheet music and
they will be able to play it and this
works for all instruments and you know
all musicians of all levels so I was
wondering what is the music notation of
user interfaces what do all user
interfaces have in common
and how could we represent that
declaratively so when we're working with
software we usually deal with ApS now AP
is at least good api's have three main
qualities first of all they're
well-documented you could read the
documentation and understand exactly
what's happening with the API they're
also very predictable the API is going
to work the exact same way every time
and they're also testable you could test
against an API they either provide mocks
for you or have a test database or
something like that so user interfaces
though user interfaces are really really
complex I mean does anyone find
developing user interface is easy
alright so those of you watching online
no one raised their hand which is good
because I would have called them out if
they did we have to deal with something
called a human API that's all of you
that's all of our clients everyone we
work with human API is undocumented
we're unpredictable and were untestable
and we're also extremely buggy if you
don't believe me just turn on an
American news network and you'll see
proof of that so I work for Microsoft by
the way I'm not relating Microsoft to
any of this terrible API stuff I promise
and at Microsoft we have more than
50,000 software engineers throughout the
world and at least seven designers I'm
sure and we also serve one and a half
billion customers and I think this is
just for Windows so it might even be
more
that and so when we're developing user
interfaces for 1.5 billion people we
have to just imagine all the different
ways a user could use the user interface
and you know this is different cultures
different languages
you wonder why diversity is so important
in tech it's because we have to reach
these 1.5 billion people so we don't
develop software for just one person
however when we're developing software
with just the happy path in mind then
that's essentially what we're doing
we're assuming that there's this ideal
user who's using our applications in the
exact way that we want them to but this
never happens so we're gonna take a look
at a code example here and I don't want
you to read too deeply into the code I
just want you to see if you sort of
relate to this in this example we're
going to be creating a sample app where
we query the Flickr API and then we show
the results so very similar to what Dan
was doing with movies in his last talk
ok so it's pretty simple right we we do
a fetch then when we get the data we
show it are there any bugs here are we
done well let's say the data takes a
long time to load ok so now we have to
set this loading flag loading is true
and then once we finished loading data
then we have to set loading to false
are we done no what if we have an error
well we have to hide the loading screen
show the error right but are we home for
yet no because we also have to make sure
that we clear the error once we try to
search again and so as you can see the
complexity is getting bigger and bigger
so now my answer to vent handler is
getting extremely huge and I'm sure that
many of you could relate to this code
and many of you say yes some of my code
looks like that
sure and so what if your boss or your PM
comes to you and says we actually want
the user to be able to cancel the search
because you know sometimes it takes too
long so
times they want to search for something
else so that logic gets even crazier I
don't know if you could read that I'll
zoom in for you but there's a lot of
complexity in just one event handler and
so of course you might know this as
spaghetti code where our code quickly
gets unmanageable and some of you might
be senior engineers and you might be
thinking I don't do spaghetti code all
of my code is modular and layered and
separation of concerns and all that and
it's true you might not write spaghetti
code you might write lasagna code which
is this is spaghetti code in layers so
this is called the bottom-up approach in
the bottom-up approaches whenever you
have an event like on click or on change
or something you do all of the logic in
that event and that logic could refer to
just so many different actions and some
of those actions might change the states
but you have to choose which actions are
executed carefully otherwise you know
you might edit the state in the wrong
way and you have to just add if-else
statements and switch statements
everywhere and it gets really bloated
really quick back there's a lot of
downsides to this first of all this
bottom-up code is very difficult to test
because all of the application logic
lives in your mind so when you're
writing your tests you have to just
output it from the developers mind onto
the tests and it makes it really hard to
work with other developers also the code
is difficult to understand the code that
I just showed you for showing and hiding
the gallery if you were to try to parse
that as a brand new developer working on
the project you would find it really
difficult to do so the code will contain
bugs for sure because there's going to
be edge cases that you might not have
considered it will also be difficult to
enhance just like we've seen with
cancellation and features such as
cancellation make the code worse they
explode the potential possible states
and actions that could happen in your
application so here's some intuition for
moving forward first of all we have the
realization that UI components are not
independent we have all these frame
that they isolate components and they
say these components fit in their nice
little box and we could just stick them
in the page anywhere and they're just
going to work however to the user
there's no such thing as isolation
everything they see on the screen is in
the exact same context and we have to
coordinate from components to components
so another realization is that actions
which is what happens when you do an
events are based both on the events
executed and the the current state so
the context and it's also that this
event action paradigm is too simple to
represent all the possible states our
app can be in so what's a solution
finite state machines and state charts
now I know that a lot of you might have
heard of these before or might have
studied it in school and the problem
though is that even though you might
know what these are you probably haven't
applied it to user interfaces and apply
the to actual software so looking up
material for this too could be a little
complicated so I'm a visual person I'm
going to do this in a very visual way so
that we could break it down so finite
state machines consist of five parts
first you have an initial state such as
it being idle and then you have your
finite number of states which represents
the states that the app could be in and
when an app is in one state it can't be
in the other state at the same time you
have a finite number of events such as
fetching resolving or rejecting a
promise you have a mapping from state to
state based on these events so for
example when you're fetching a promise
and it resolves you go to the fulfilled
state and same with rejecting the
rejected state and then you have a
finite number of final states which
we're not going to talk about too much
just because user interfaces can be you
know continuous we could just keep using
them and it's not like it says alright
you're done using it go uninstall
Instagram or whatever because you're not
going in the anymore
and by the way if you go to promise J's
org slash implementing it's going to say
promises are just a state machine so
that should give you a big clue of what
we're working with here
so the original app that I showed you
the gallery app can be modeled as this
state machine right here so we start in
the idle state and then we go to search
then we're in the searching state if we
try to search again it just loops back
because it's like hold on we're already
searching and then two things can happen
we could either resolve or reject the
search results and from those two states
we could search again and so this is
clearly seen by the arrows going from
success or failure back to searching
again and so the machine that they're
the same machine that I envision looks
sort of like this
it's a JSON object and I like Jason
better than just black box functions
just because you can enumerate all the
possible states all the possible actions
and be able to transition from one to
the other with a nice simple function
right here so for example if we're in
the searching state and I get a resolved
then I just look it up in this JSON
object just searching on resolved
success and so um you know JavaScript
they call this a I don't know in
typescript that sort of a record I mean
I guess it's the same in c-sharp work
actually it's a dictionary in PHP they
call they call for help all right so
here's an example of what I just showed
you so if I were to search for Iceland
or actually let's search for goats first
but let's say I don't want to search for
code so I'll just cancel that so let's
search for Iceland said there we go so
now you see we're in this uh we're in
this gallery state and when we do the
events of selecting a photo we have a
state transition that transitions from
gallery
it's a photo and then we could exit that
we could search again cancel search
just know it's cancer that I splint and
so you see it goes from state to state
and no matter how many times I try to
break this app it's it's not going to
deviate from this state machine that I
have here
and you see there's a few extra things
such as actions over here where you know
when I'm done searching update the items
we're gonna discuss that a little bit in
further detail and also this is part of
an article that I wrote which gives an
introduction to finite state machines so
I use um Visual Studio Live cher or I
don't use it I work on it I also have to
use it it's called dogfooding anyway and
this is sort of what it looks like and
so I don't know if we have Sarah and
Burke in here so here's Burke right now
and basically this you could think of it
as Google Docs for collaborative coding
it's right now in private preview at
Microsoft and I have no control over
what they're typing by the way and
they're typing this in real-time and so
with this live share we could
collaboratively code in the exact same
document at the same time and so these
are a complex series of events that are
happening at the same time and so we
have to manage all of these possible
events in all the possible states that
this could be in I no idea Oh God good
luck breaking demo well it probably will
but anyway so I'm gonna before it gets
too too crazy one of the big things I
had to work on in live share is this
whole sign-in flow because you would
think that signing in is easy and you
know signing in signing out all of that
but it's actually not once you start
drawing it out it becomes a lot more
complex so for example there could be a
sign in failure you know especially from
Iceland I'm so glad that worked in
Iceland by the way because all of our
servers are based in the United it's
and so when you have a signing signing
success then you go to the sign-in state
and from there you could go do two
things you could either share a session
or you could join the session and so
what I did was a couple months back I
refactored this part of the app so that
it uses an explicit state machine just
like this because we were getting a lot
of bugs we were saying what if we're in
the middle of sharing and the user signs
out or what if we joined the session and
then we decide to share a session at the
same time that shouldn't be allowed and
so we had all of these if else if
statements and switch statements
everywhere and I decided there has to be
a better way so I just did you know the
simple JSON object approach and we got a
bunch of benefits from that first of all
this state machine that you know I set
up it was very easy to add to lemon tree
to it so I added telemetry and then I
get this very nice visual showing
exactly the frequency of how users go
from state to state and so you could see
obviously most of the users go through
this initializing and then signing in
state and then you could either
externally sign in or you could sign out
and then you could see that users tend
to go to either joining or sharing you
know as about the same frequency and
yeah so it clearly shows - how many
users go to the arrow state and how many
users go to the success state for each
of these states as well now these are
very powerful insights because while
telemetry will only tell you an atomic
bit of data
here's telemetry that tells you the
entire user flow of what's happening and
so we could limit this to user and be
able to see a nice path of what the user
actually did in the app so it's sort of
like you know like those funnel diagrams
except even crazier we could also use
state machines for integration testing
and so this gets a little bit into graph
theory so bear with me a little bit
over here we would be using a shortest
path algorithm you could choose you know
your favorite one did did Jax Dijkstra
is he Icelandic like that sounds like an
Icelandic name bellman-ford aged a-star
searching any of these formulas for
finding the the shortest path and so for
those who don't know the shortest path
is just going from one state to the
other with the minimal cost and so you
can imagine each of these arrows have a
weight and so you just want to minimize
you know how long it takes to get from
one path to the other sort of like in
Google Maps finding the shortest DTA
from one point to the other
so analytics would provide these weights
and this represents all the happy paths
a user could take which means that you
know if we want a user to let's say
share a session and get to the shared
state we would imagine the user going
from signed in to sharing to shared just
that simple and so these could be
automatically generated from you know
the JSON structure or a finite state
machine graph just like this but
remember we're not just dealing with the
happy path so we would do a depth first
search algorithm to find all the other
paths a user could take so I know you
know some of you might be thinking like
oh these algorithm things I didn't think
I would need then you sort of do they're
really helpful and so these represent
all the possible user flows so you could
imagine that a user getting from state a
to state C might not take the easiest
route they might not go ABC they might
take a longer route to get all the way
to C and it also reveals all the edge
cases because when you model every
single possible state with every single
possible action and you get all of these
flows you're going to basically have
100,000% test coverage for anything that
could possibly happen in your app and of
course these could all be automatically
generated I'd caution against isso
because you would be generating
integration tests that I mean it would
generate
a lot of integration tests which isn't
necessarily a bad thing but when you're
doing continuous integration you don't
want your tests to take like 4 hours
long so it also makes software bugs
visually clearer by drawing them out
having them on the diagram you could
easily see when I do this event I'm
going to the wrong State or maybe I have
an unhandled events which does nothing
or maybe I have a missing transition and
so that's shown here too for example dan
was showing the example where when you
click a movie it just waits and waits
and then you get the next movie and
there's no loading state well you could
clearly see that in the state transition
diagram and also my favorite race
conditions these are just made
completely nil and void with state
machines because you explicitly say when
I get this event I go to this date and
if I get another event after that that I
don't care about it's not going to cause
a race condition because I will just
ignore that events and that's what state
machines can help with now I want to
talk about harel statecharts in honestly
this could go on for you know hours and
hours just because there's so much
information here so I'm just going to
give you an overview of what these are
and how these extend state machines in
order to improve the way we look at user
interfaces because user interfaces can
get complex and finite state machines
might not solve everything
so with state charts they're sort of
similar to state machines in fact
they're extension of it except we could
have actions two actions are the things
that actually do things to your state
into the app we can also have guards
which prevent States from going from one
to the other on the transition you know
if something doesn't match the condition
so for example if I'm trying to search
for something and the user didn't give
me a search query then I'm not going to
transition to the next state and so that
could be declaratively modelled as well
there's also the idea of nested States
and orthogonality so this is parallel
States I don't want you to think of this
as
concurrence states where an app could be
in two states at the same time but I'll
show you an example real quick it's more
a way of simplifying the number of
states you have so that your state
machine doesn't look all crazy and also
history which is a very common feature
that many users would want in order to
go back to their saved state so I
created this library called X States
which models finite state machines and
state charts in in a declarative way so
that all you would have to do is use
this JSON structure to model your state
machine and then you would get the next
state by just calling transition on the
current state and the action it's
functional it's peer so it's going to
work in any framework or no framework at
all it also has the notion of actions so
it will return you an object telling you
these are the next actions that you're
going to take once you transition to a
state
it also has guards so you could pass in
some external state and it will validate
against that external state and say okay
well this condition is met so you go on
to the next state
it also has hierarchies so that you
could represent and compose state
machines pretty easily
it has orthogonality so you could
represent parallel States and history so
that you could also represent remembered
States in this example let's say that
you're doing a payment flow and you're
either asking for cash or card the user
could switch between them then the user
goes to the review page you want to
remember to the user choose cash or card
so that's when you would just go to
method dot history and it would remember
that and this is a purely functional no
side effect type of thing and so you
know you could imagine the applications
of where you could apply this one
example of where you would use
orthogonal States is this typical
example of let's say you have bold
italic and underline a user could click
one of them or two of them or three of
them toggle all of them toggle none of
them and it's represented by all of
these eight states and you can imagine
if
we add more options such as align left
align center justify then it's going to
explode into even more states so with
high arc haha
sorry orthogonal state charts we just
have this very succinct representation
of each of these possible states so that
we know that you know we could go from
bold on to off italics on too often same
with underline and we could represent
all of those at the same time and also
hierarchy helps to reduce the number of
arrows that you have in your finite
state machine so for example both the
success and failure states we could
search again and go back to the
searching state we could simplify this
by just nesting them in a single state
the search State and so this is fully
supported by X date and yeah so you
could imagine how this would simplify
just really complex state machines so I
I released X date about six months ago
at a at reacts rally and since then
there has been a lot of development in a
lot of people actually using it to make
projects such as reactor tomada and and
others and so pretty soon I'm going to
be releasing another version minor
version or nothing crazy of X state
where we have improved the developer
ergonomics full se SC I I keep saying
sexy XML it's not sexy code is not sexy
at all SC XML support and conversion a
reactive interpreter visualization tools
and a lot more examples and so in order
to actually show you what I'm talking
about here's an example of a
visualization tool so that same JSON
object that you passed in to X date and
the same one that I use for my gallery
app this is one of the one example of
where you would use this so let's see so
from here my initial status start
and I could just hover hover over this
search action and go to this state and
then I could see the possible different
actions or sorry events that I could
take from the state so let's say I have
a search success and so I go into the
gallery view and then I could either
choose to search again or I could select
a photo and so so I could visually see
what's happening in my state machine
just by pasting in that JSON object and
so that's very hard to do with just a
function and that's why I decide to do
it in a more declarative way and so I'm
going to be releasing this soon I want
you all to enjoy the rest of the
conference before I you know release it
so that you could have time to play with
it afterwards that's my excuse at least
it's not out yet now it would be you
know sort of remiss of me to not talk
about sort of the downsides of state
machines and state charts but the truth
is that you all are already creating
finite state machines and statecharts in
your app already and you don't even know
it
however the ones that you're creating
are implicit they're full of bugs
they're incomplete and that's just a
nature of how we code so the advantage
of finite state machines and modeling
them in a very explicit way is that you
reduce a lot of complexity upfront just
by getting rid of your if else if
statements and getting rid of your
switch statements and just having a
direct mapping however that quickly
explodes into many many different states
sostay charts help manage that with a
little bit of higher complexity cost up
front but in the long run you're going
to see it's going to be very easy to add
features remove features and you know
handle different actions and different
possible modes of your application so um
of course there's a lot of advantage
- using statecharts and the ones I'm
gonna quote here are not actually from
me
they're from NASA see a few years ago
NASA had to send this little vehicle
right here all the way to Mars and they
did so using state charts and so the
advantages that they said was first of
all there's visualized modeling so you
could both model and examine the model
of a state chart using visual tools you
get these precise diagrams that tell you
exactly what's going to happen when
certain conditions are met when you're
in a certain state and this event
happens and when you're sending
something to Mars you can't exactly just
send it there and hope that it works
right you have to be absolutely sure
that your billion dollar project is
going to handle every single possible
state and so they also used a charts for
automatic code generation which I mean
I'm not a fan of but you could see how
you know it could be beneficial also
comprehensive test coverage by using
state charts they were able to generate
just all of these integration tests
where they could test each and every one
and ensure that every single state was
being hit and every single possible
action or event was being handled also
you know being on a big project you have
a lot of requirement changes like we
want to add this to the rover we want to
remove this functionality we want to
change the way this works and when
you're working on the big project and
you have these late-breaking requirement
changes then things can get really
stressful with state charts since you
could clearly see the full flow of your
application you could easily add and
remove features without worrying what's
going to break what's going to change
what's going to be affected so there are
some disadvantages as well and the
disadvantage is that my screen just went
black I guess that means there are no
disadvantages anyway since the breasts
my slides are forked I just want to show
you this real quick I talked about 1/2
years ago it was actually at JS conf
Iceland and it was about reactive in the
nations and funny enough this is where I
saw the primary use case for using state
machines and state charts because there
was this really complex UI design that I
really wanted to model and I found it
actually pretty difficult without using
an explicit state machine or state chart
and so what I'm doing here is I'm just
there's three different states this one
this one and there's different actions
as well so the user could handwrite but
just a little bit and so I handle that
as a transition from going from state a
back to state a if you know they didn't
move far enough but of course if they
move far enough it goes to the next
state successfully and also it handles
like if I'm going up and I decide to go
left and right it's not gonna do
anything because we're already going up
and down so it knows when this event
happens don't try to go to a different
state because we're already
transitioning to one state and yeah so I
also want to mention two very good
resources the first of first one is on
spectrum do it state its spectrum
vallejo slash state charts and this is a
community where we just talked about
state charts they're possible
applications and how they're used
everywhere in fact state charts are
nothing new they were invented by David
Harrell in 1987 which is what thirty
years ago and so this is not cutting yet
stuff and so if people are asking like
why aren't we using state charts
everywhere now well the thing is they
are in embedded systems or systems
programming people do you stay charts in
order to model their applications we
don't quite yet but I think it's about
time
we catch up to it and so Eric Mogensen
who started this community he made a
wonderful resource called
the unfinished world of statecharts and
so over here if you want to learn more
information there's a wealth of
information here including a ton of
resources somewhere but so that's at
statechart stock github I uh and so I
really want to encourage you to just to
just visit revisit your application
revisit the way you think about things
and actually try to visualize things
because you're going to see that by
visualizing your application all of its
possible States all of the events that
could happen that you're going to have a
clear representation of the possible
bugs the possible features that you
might add the user improvements and
everything else and so I want to thank
you all for having me unfortunately I
can't show you my last slide because
it's not working but thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>