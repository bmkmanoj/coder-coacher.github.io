<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>[JSconfEU 2009] Thomas Fuchs: Extreme JavaScript Performance | Coder Coacher - Coaching Coders</title><meta content="[JSconfEU 2009] Thomas Fuchs: Extreme JavaScript Performance - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>[JSconfEU 2009] Thomas Fuchs: Extreme JavaScript Performance</b></h2><h5 class="post__date">2013-06-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/g1hCfENbXFA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello so my talk is about extreme
JavaScript performance extreme just
sounds better so it's really about
JavaScript performance I think it will
take this out test test so in in the
program it says I will talk about
profiling and other stuff I left left
out the profiling part because I think
30 minutes is a little too short for
that instead I will give you a bit of a
general information about like how you
can make chava script faster and I will
show you that on some examples so the
first thing about performance which is
the most important part about
performance but it's JavaScript or
anything else is do not ever optimize
prematurely just only it's really never
optimize anything just because you think
it will be a problem in the future just
write your code so you can read it and
it's manageable in the future and only
optimize when you actually do have a
performance problem and in that case it
will help you to profile your code and
see what portions of your code actually
cause the problems the performance
problems so the code i use in the
examples of this talk you can get that
at this address trim / extreme j/s it's
a github gist so there's some code on
there just protein into an HTML file you
can look at that in your browser um so
JavaScript performance is very
interesting because it's not only like
you don't really have like a defined
environments your JavaScript Ramsey I
talk about JavaScript performs in the
browser especially
it would also apply to server side stuff
but let's see what's what browsers are
up there and what JavaScript engines to
have so first a spider monkey Firefox
it's pretty interesting they have done a
lot of stuff recently to make it faster
this javascriptcore in Safari and some
other WebKit browsers also very decent
JavaScript engine there is a chase
script which is like JavaScript without
the other yeah it's it works and we
heard already that like the IE guys are
like working on the next generation
engine that will come out like next
century and this of course we ate in in
chrome and we ate this is kind of an
exception because state Google like
really took the step ahead and to make
made a JavaScript ancient it like run
separately for each browser tab and
there's a lot of other features that are
very nice surprisingly except for chase
script each of those engines is kind of
like fastest in some situations so you
cannot say that moment is faster than
the other or you can like to general
that's like a general trend that
javascriptcore and v8 are the fastest
engines with with spider monkey like
trailing in close behind and chase
script is like somewhere else it's
really interesting if you look at the
examples anyway so my first tip is a
void function calls this is like the
beginners tip if you look at the code
here you see you have the square
function that returns the square the
parameter Square and if you do like
10,000 iterations it has to do like
10,000 function calls in there
except in JavaScript engines that in
line the code or like compared to that
if you do the statement correctly
directly in the code without the
function call in the second example so
basically what we do here we take the
function call and in line it into the
code it's it's an obvious performance
improvement because the function call
just falls away function calls are very
expensive in JavaScript normally but
this example also put also apply to like
basically every other language up there
what are the results here you can see
Firefox this is like for I don't know a
million iterations or something of this
code obviously much faster to inline
Safari also the difference is not quite
as high on aida is like a little bit of
a problem with the first method call and
but but you can see it's it's actually
faster than firefox i'm not quite sure
which version i used here but it's like
a recent version so interesting and
chrome like kind of beats the crap out
of the other browsers actually like with
with with both methods in of doing this
so you can see the differences in
browser performance are quite huge so
for the IE part but what happens there
this happens and interestingly this
morning comes up after one second of
running and I've got the same boring
like sometimes after five seconds of
javascript stuff that's running and
sometimes it comes up after one second i
don't i'm not quite sure what happens
there yeah so it'd be very careful with
with like tight loops that like
calculate a lot of stuff ok so we've
seen earlier that there's not a bad
worker stuff in some browsers which
might help you
avoid this kind of thing but you can
just optimize your loops and maybe like
you get under one second and then you
won't get those warnings and these
warnings interestingly behave
differently in every browser so you
manage really may vary with this anyway
secondly embrace the language what does
it mean really use JavaScript away it's
like it offers all those facilities it
has don't try to write JavaScript code
that looks like Java code or that looks
like C code or something right
javascript as an example of this if you
compare the performance of using
literals for arrays or objects with
doing new array or new object which is
see sometimes in bed code you will see
there's differences in performance these
things do not do exactly the same thing
but for all intents and purposes in
normal code they are exactly the same
how does this perform you can see
slightly faster firefox safari is like
much faster than firefox or IE quite
fast chrome is interesting you with with
like the new stuff it's it's slower than
safari but with the literals it's faster
than safari and overall it's the fastest
browser you can see you can get some
performance out of this um but but you
can do anymore let's look at this
example parse int 12.5 okay 12 that
actually should be a string here sorry
for that but you can most languages you
can do things like in a lot of ways
there's four examples pearl where to say
you can do everything in a lot of ways
probably in like infinitely many ways
it's probably not true in JavaScript
Patrick you can do stuff
differently for parseint its part in
this kind of an expensive operation
mostly because there's a function call
involved so what we can do instead is
this this does too for all intents and
purposes again the same thing what keg
what's what's going on here you might
might ask this is kind of like a bit
tricky so this is going on you have a
double bitwise not which floors the
number that it's given and 1 times a
string will coerce the string into a
float so it returns 12.5 and the double
bitwise not force the 12.5 to 12 bitwise
operations in JavaScript interesting in
this case because a bitwise interation
always forces the the input for the
operation into a 32-bit integer so you
can see sometimes you can use language
stuff to kind of abuse it but actually
this stuff is faster than just using the
powers in it and then some in most cases
also shorter code so we can see Firefox
faster Safari faster firefox is much
faster here it's like lot faster ie yeah
and chrome and Chrome actually passing
this faster so it seems they have
optimized the past and colander engine
to probably not be a function call but
something else direct coercion into an
integer so it's really interesting 5 x
50 times faster than safari for this
operation loops loops is another like
low-hanging performance fruit is a for
loop comparator of i loop this is two
loops to exactly the same thing except
one counts up data comes down
the vial I minus minus counts down the I
until I hit zero and then the expression
is false and then your code continues so
for for each code snippets it will add
still 10,000 times through the test
variable how is the performance as
easily explained the province is exactly
the same which means in this case you
probably should use the by loop because
the by loop is just short a code one
expression less than the for loop I
personally find it easier to read I
don't like the for statement that much
it's kind of I don't know it feels weird
if you can do something more elegantly
your mileage may vary but that's worth
much more interesting is this so this is
like a loop that counts down I 60 times
and increases J for each iteration of
course this is cole is completely
useless but makes nice example of what I
mean so here's the same thing so guess
what is faster so the unrolled loop is
like two times faster in Firefox it's
like three times fast ends of RA it's
two times faster and I eat like five
times faster on Chrome the fun part of
this is this even works if there's like
two thousand expressions there so the
JavaScript parses are very very
efficient in passing JavaScript but I
guess they are not very efficient in
doing loops kind of an interesting
finding so I actually did some
JavaScript code for in certain cases to
make it faster by unrolling loops and
just having the same statements repeated
over and over again it's very ugly but
it really helps in some cases again
think about the first slide that do not
optimized prematurely for f---ing cage
Global's it's kind of interesting if you
have this code if you compare it the
only thing we do is is Mukesh window in
a like local variable this gives very
interesting results like Firefox is
really slow with this stuff if you
compare that the speed it's quite
interesting so in this case so far is 20
times faster than firefox it's also
faster than chrome is in this case IE
works with stuff that's
kind of I don't know what's going on in
AE it ie always like delivers the right
results but you never quite sure about
the performance so what this stuff shows
that you cannot really say born browser
is faster than the other except that all
browsers are faster than i ii and but
actually found some cases where I is
faster than than other browsers I ease
pretty good with some regular
expressions I think the lib regular
expression library on Windows is pretty
optimized for certain things so it might
still not hold true that like all
browsers are faster than IE in most
cases they are but in some cases I email
might even beat them so it's more
importantly you really have to test your
code and all those problems especially
if you know that you have a performance
issue in one browser it's very likely
that you have similar performance issues
in other browsers and also try your code
unlike hardware that's like not the
latest and greatest stuff that you have
for development but that your users
might have expression tuning not a
low-hanging performance field-proven in
some cases it's easily explained it's
just like switch around that order a few
expressions in the way you expect them
to mostly be in most cases in this case
B is false so the end times end part of
this expression will never get evaluated
can see helps quite a bit on IE it's
like almost three times as fast on the
other browsers it's also slightly faster
and it's important to note that this is
a language feature it's not like an
engine optimization anything that like
second part of this expression will
never get evaluated
so in this code you see I'll define n to
be one and I say say if true and N
equals 2 which means the second part of
this expression will only be evaluated
if the first part is true and this is
true in this case so n will be set to
true but in the second part I say true
or N equals 3 so true is already true of
course and so the second part of the or
expression will not get evaluated and
will not get set to free you can use
that in some clever ways also to
optimize this size if you code and also
to make sure that no one ever will
understand your code again but in
certain cases it might be the right
thing to do if you really want to
optimize that last bit of performance
out if you go and finally we have stuff
that you should never ever do let's look
at the brief statement the beef
statement is kind of cool it allows you
to write shorter code but so if this
code again does the same thing let's
look at this hour Firefox mm-hmm looks
like five times faster to power a
slightly faster ie the same speech
interesting on Chrome it's like more
than x 10 times as fast without the Biff
it chose an interesting thing which will
come to in a second but let's look at
another thing that you should avoid
try-catch try-catch should probably only
be used in cases where you want to test
for browser features where you know that
like certain code might throw an
exception or like in very rare cases
where performance is not important but
you you really don't know if an
expression will succeed or not and you
don't have any facility to check
your input before you do your
expressions so what happens here so with
the try-catch you can see in Firefox
it's almost the same than firefox it's
not really a problem in safari or well
on IE same thing chrome again ten times
as fast it's more interesting to look at
this like this so you can see firefox
safari IE chrome what happens there by
it is like the same speed for both
expressions of football forms Biff try
catch without try catch on IE but not in
the other browsers the answer to this is
relatively simple in the browsers where
the difference is these are the modern
JavaScript engines that have just in
time compilers and like do a lot of
optimization on your code translated to
native code in most cases but certain
features are not supported by them very
well among them try catch and the beef
statement a a good way to like think
about this in a way of like how can I
avoid that these modern engines have to
switch to their like slower code paths
because I use features that they might
not support as well for just-in-time
compilation is looking at the
specification for the next version of
JavaScript it's equal to 60 to 50
edition draft whatever whatever of
course no one ever reads these
specifications because you have other
stuff to do like make a living stuff
it's you don't want to read this stuff
if you want to like leave this to other
people mostly these are a very good blog
post Jean rezek wrote about the features
in there especially about the strict
mode features and the strict mode is
very interesting so here's a link to the
Jones blog post basically avoid any
stuff that's not supported in the strict
mode and you will stand a good chance
that the code you write will be very
efficient in those new JavaScript
engines the strict mode for example does
away with the wave statement it still
has try-catch fall so it only works
partially but if you do write codes
that's would work with Java scripts new
strict mode you'll send a good chance
that Yoko will be very very optimized so
does anyone know what this code does
No
come on it's a JavaScript conference
so okay okay so this code outputs itself
it's just a little example whipped up
because I wanted to show you an
interesting so to say feature of
javascript javascript is very well
suited to meta programming and one
feature of meta programming is
introspection and one feature of
introspection is you can actually get
the source code of your code from within
your code so in JavaScript if you write
a JavaScript function that says
arguments dot co-leader to string the
function will output itself you will get
a string that contains the function and
with a little bit of like trickery here
we'd like to normalize this output
because this output is a little bit
different across engines and we can
alert the function itself so but what
does it mean so here's another function
you can see i define a function it
returns two times three I want to get at
the source code for this function so
let's have a look what their engines do
so javascriptcore gives you back
function return to them sweet Internet
Explorer gives you back function return
two times free chrome gives you back
function return two times three so what
does firefox to respect which 16
so I think this is WTF so they're in
Firefox actually there is another
function called to source which is not
in the specification but which gives you
back what you originally put into the
function this is an important thing to
say because the problem if this is that
if you write benchmarks browsers might
like to try to optimize your functions
for you and especially for benchmarking
this is pretty bad because you want to
know exactly what an expression does so
be very that like JavaScript engines
might rewrite your code actually and
yeah just note that this engines are a
little bit different so Amy and me wrote
a book on JavaScript performance you can
get it at xerox com so much for the
advertisement are again do not optimized
prematurely never ever thank
so any questions I can barely see her
this thing's a literary yes
so so the question was however the
measurements done obviously the
measurements written in JavaScript
itself in JavaScript you can measure
like a time period by using mutate get
time you get like the time unix
timestamp in milliseconds and yet like
you do it before and after the test what
I do is I do like a really long loop
that iterates like execute these
functions like a lot and mostly in like
100,000 times a million times if you if
you look at the sample code the
benchmark functions included there as we
described in the book we actually also
use like a different benchmark function
that also that's like a ramp up and ramp
down so it does basically they're like
1,000,000 executions three times but
only measures the second execution so
things like garbage collection and stuff
in JavaScript the kind of you can like
work around that a little bit but it's
still not like scientific but if you
execute it like ten times then the whole
thing you get a pretty good idea about
how fast the browser is the problem with
this comparisons as you as you have seen
sometimes they get very you get very
small numbers but because I need to like
compare ye to Chrome and stuff I cannot
use bigger numbers because i don't know
i want to go to bed at the end of the
day so and i'm sorry if i'm bashing IE
too much but this is like the heart
effects of javascript performance any
other questions
the question was if I like have like a
software tool that did like basically
optimize this code for me is that right
no i don't i just used like all those
programmer tools like brain and hands
mostly eyes I guess but there is some as
I said before if it probably don't have
enough time to like cover like profiling
tools but the thing is it's actually I
think more difficult to determine which
parts of your code actually like cause
the performance issues and then you can
go in and like try different things like
some of the things I've shown you today
unrolling loops trying to optimize the
audio of the expressions it's it's
different for every problem anyway I
guess you could write some code tools
that like just try certain optimizations
and compare them and know that like the
new like Google closure stuff has like
some of this stuff building when you put
your JavaScript into their compiler it
optimizes certain things I don't know if
like if it's exactly these things it's
too new for that but but yeah so it's
it's a bunch all that's available for
this would be like the Google closure
compiler actually I've tried it with
with some new column I'm writing called
Emil chairs which is like this mini
JavaScript animation library and it
broke the library so go figure by the
way I'm tomorrow at twelve-fifteen I
think able to talk in the underground
track No ok
I was told I was doing the talk okay so
maybe tomorrow able to a talk about Emil
J so you're welcome to that like I've
applied some of those things you've seen
today to petco thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>