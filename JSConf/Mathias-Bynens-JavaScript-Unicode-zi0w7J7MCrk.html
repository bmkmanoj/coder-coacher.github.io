<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Mathias Bynens: JavaScript ♥ Unicode | Coder Coacher - Coaching Coders</title><meta content="Mathias Bynens: JavaScript ♥ Unicode - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Mathias Bynens: JavaScript ♥ Unicode</b></h2><h5 class="post__date">2014-10-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zi0w7J7MCrk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">&amp;gt;&amp;gt; I'm going to talk about three of my things,
Unicode, JavaScript and gangster rap. I work
for software developer in software relations,
I like to collaborate on Open Source projects,
and one example of such a project is Punycode,
it's part of node G S, it ships, if you can
want to play around, just require it,you didn't
have to MPN install anything T puny ‑‑
internationalized domain name into pure ASCII
forms, so I want to write a JavaScript implementation
of, that I thought it would be really simple
because the algorithm is well defined, I figured
I would port that into JavaScript and that
would be it. But while I was working on this
actual emme opinionation I ran into lots of
new things, things I didn't know about JavaScripts
and that's what this talk will be about, basically.
But, first, does anyone know who this guy
is? Of yeah, of course, everyone knows it's
Jay Ze. He decided to write a JavaScript program
once and instead he ended up writing a song
about his frustration with the language, it
you might have heard of it before, it's called
99 problems, don't get me wrong I love JavaScript,
just like with any other programming language,
if you don't know language by heart, and really
who does, you're going to be surprised, that's
just what life as programmer is like, that's
why we have PHPWTF.org, list it is weird quirk
in PHP and similarly WTF.com for JavaScriptful
everything on these web sides can be explained
if you look at the specification, the PHP,
the documentation or implementationsh even
then if particular behavior of language is
confusing to a lot of people, that is a bit
of a problem, so I think the way JavaScript
handles Unicode is well, very surprising to
say the least. But before we get into that,
let's talk about Unicode itself, just to make
sure we're all on the same page. I'm going
to tell you the absolute minimum about Unicode
in order to work with strings in JavaScript
correctly and nothing else. It's easiest to
think of Unicode of a database that matches
any symbol you can think of to a unique number,
the code points and a you cane unique con
noncal name, it's easy to refer to any specific
symbol by using the unique name or code point,
you don't have to use the symbol itself to
talk about the symbol. For example, Unicode
map it is Latin capital letter A to U + 0041,
this is a hexadecimal number, usually four
code unit codes like this ‑‑ now, another
example is the letter ‑‑ Latin small
letter A, a different letter all together,
it gets it's own code point and it's own con
noncal name's a lot of stuff in Unicode, each
symbol gets it's own code point's a lot of
weird stuff, there's a snow man symbol in
Unicode, not sure why wow would you need it.
There's everyone's favorite character the
pile of Poo, that's the con noncal name for
the symbol. You can see it's U + 1F 4A 9,
you may be wondering at this point how many
code points are there what's the highest possible
code point value in Unicode, well the possible
code point value from 0 to 10FFFF that's over
one million possible symbols, to keep things
organized Unicode devised this range of code
points into 17 planes that consist of about
65,000 code points each. The first of these
plane s is called the BMP, the most important
pine one because it contains all the most
commonly used symbols, most of the time you
don't need codes outside of BMP to write a
text code with English, Spanish or German,
just like any other plane it contains about
65000 symbols, there's a grouping for the
other planes, they're called supple men tear
planes, totals up to about one million other
code points, the vast majority of the Unicode
code points base, these are called astral
planes or sup men tear plane, ‑‑ supple
men tear planes. Now, astral code points 
are easy to recognize because when ever you
need more than four hexadecimal digits to
represent that, it means it's an ascentral
code point. So, now that we have basic understanding
of Unicode, let's see how it applies to JavaScript
springs, starts with back clear X two hexadecimal
digit, grow know a bit about Unicode, you
know they refer oUnicode code points, another
way to represent the string ABC in all caps,
this is the way to represent the stringabc
in lower case, this is useful because you
have weird characters that are maybe hard
to type on your keyboard or avoid encoding
issues, if you save the file with different
encoding you can use escape sequences to represent
these characters, this is useful but we're
still limited to two hexadecimal, which means
can only be used up toFF.
There's a lot of other escapes, call Unicode,
starts with back slash followed by U and four
hexadecimal digit, we can make the same exescapes
but for four ‑‑ like 2661 which is the
code for white heart symbol, this makes it
possible to escape all these code points all
those in the BMP, actually. But, what about
all the other planes, what about those ascentral
code points we need more than four hexadecimal
digitter for them how do we escape them. What
about the pile ofpoo and other equally important
ascentral symbols of course. We can actually
escape those, it's kind of sort of come plait.
I will, in fact be really easy because you
have these things called Unicode code point
escapes, back clash you followed by braces
you groups six hexadecimal digit, enough to
represent any Unicode. You can simply escape
any Unicode symbol based on it's code point,
it couldn't be easier, if you need something
that works to day in ESF, the unfortunate
solution is to use surrogate pairs, each escape
represents the code point of a surrogate half,
only when that two halves combine together
it form it is symbol. The surrogate code points
they don't look like anything like the original
code point. Now there are formula that you
can use based on a given astral code point.
Here's a JavaScript implementation, you don't
have to learn by heart, you know this exists
if want to deal with string in javaScripts.
Any way the whole concept of using the escape
to represent BMP and two separate escapes
is a bit confusing and has a lot of annoying
consequences throughout the language. For
example say you want to count number of symbol
in a string, my first thought would be to
use the strings length property. In these,
indeed it reflects number of character in
the strick, if you escape the character in
thestring and count the number of escape sequences
we see there's only one escape sequences in
each of these strings, however, let's try
some other similar looking characters. This
is the mathematical bold capital letter A,
and mathematical bold B, they're different
code point, in this case they're ascentral
code points because of that they have a length
of two in JavaScript rather than one even
though there's only a single symbol there.
What JavaScript does it kind of exposes these
surrogate halves as if they were separate
characters, and this is really confusing because
we as human beings we think in terms of Unicode
characters or even Grapimeems, of and there's
a very obvious joke to be made here, instead
I'm going to show you a real world example
where this can actually break things, this
is Twitter while ago, it allows 140 characters
per tweet, their back end doesn't mind what
symbol, ascentral symbols, they all count
as one. Now, at some point they had a bug
in their front end and the JavaScript similarly
read out the string length without accounting
for surrogate pairs, it would decrees by steps
of two with each astral, it wasn't possible
to tweet more than 70 piles of Poo at a time,
it was absolutely terrible. Accountable.J,
counts the number of words, letter, paragraphs
and displies the numbers elsewhere ‑‑
displays the numbers elsewhere on the page.
I entered a pile of Poo and counted it as
two characters instead of one, these are just
some example, this is an honest mistake the
make because it's surprising, if you're write
ago JavaScript library that involves strings
whatsoever in JavaScript, you have to make
it work with all symbols not just those in
the BMP, sooner or later one of your users
is going to enter one of those Emoji or other
ascentral similar G. way to verify is to test
it with centrals symbols, throw some piles
ofpoo in there and see what happens. This
is what it felt like to enter that pile of
Poo,I just kind of new that something would
likely go wrong, you know. So ‑‑ yeah.
That's not good. Getting back to our question,
how can it be done, how can we accurately
count number of symbols in the Java string
or number of code points. One thing you could
use is a third party library like Punycoe.
The USC 2 decode method takes a string and
returns an away of code points one for each
point, you then get the length of the resulting
array rather thanstring directly this gives
a more accurate result.
No mat whareyou're doing you is to account
for surrogate halfs in JavaScript when you're
dealing with strings like that, you don't
have a choice, you have to do this. There's
a cementlator solution for this, you can use
array.from pass in the string and that would
return an array of string, one for each symbol
in an array of string, this would use the
ES 6 string iter raptor, and the it aerator
deals with whole code points when ever possible,
so you don't have to deal with the surrogates
yourself anymore. This is not the most efficient
solution to this problem, you could use a
regular expression if you need to count the
regular characters with ‑‑ but we'll
get to that later. Now, I've made a tool that
takes any string as input and shows the escape
e Wednesday within the string, so it's kind
of like a Hexdom, which is sometimes more
useful. Now, with this tool, it's really easy
to tell which Unicode characters the string
contains exactly, even if the symbols are
non‑printable or just wide space. Now, depending
on your use case,it's not that simple, we
know how to count code points correctly, but
if we're being really pen den tack counting
the symbols in a string is different. Visually
there's no way to tell that it's different.
What's going on, I took two strings and copied
them into the tool I just showed you this
is what I got. The first string using the
string F 1 for the end character with the ‑‑
N character with theTilde, and the second
one used U 0303 the code for combining Tilde,
they just get applied to previous symbol,
we don't care about that, if want to count
the number of symbol in the string we expect
six, so how can we make that happen. The answer
S. we can use Unicode normallytion, another
new feature in ES 6 it ships to day in home
and Opera, if you want to use it in other
browsers, use a poly fill called Unorm. Before
you account for these ascentral symbols you
called normalize on the stream, pass in the
normallytion form you would like to use, this
effectively gets rid of the look alike symbols.
Now, is this solution perfect, well, it kind
of depends, if you need to support stuff like
that, if which case I count nine different
symbols, this is basically a string with lots
of combining marks that get applied to the
previous character what's why it looks weird.
I count ninety, but our Pendanticl count is
16, if you need to support ‑‑ it beast
to use a regular expression that removes the
combining marks and then gets lengths just
like question before. We'll get to that later.
Another example is reversing a string? JavaScript,
it seems very simple, if you Google for it
you'll end up a solution that looks like this,
take the string, split it into an array, refers
to array and put it back together into a string.
And indeed this reverses the string Abc correctly,
let's try Manana, here we're reversing again,
reverse function seems to work as expected,
if we try to other Mana where the N and Tilde
are two separate characters we see it gets
applied to letter &quot;A&quot; ande instead of &quot;N,&quot;
also if we try it on an ascentral symbol like
the pile ofpoo we know they consist of two
surrogate halves, the first result is completely
unusable the surrogate halves are not in order
this is data loss. Reversing a string becomes
really strictly if you need full Unicode support
in JavaScript. Lucky for us a brilliant computer
scientist calledMissy Elliott came up with
a brilliant algorithm that accounts for this
issue. It goes, I put my Thng down flip it,
and reverse it. Indeed swiping the position
with the symbol they belong to, as well as
reversing any surrogate pairs before further
processing these strings all the issues are
avoided successfully, thank you Missy.
Here's a JavaScript ‑‑ S reverse, if
you need trovers a string in JavaScript, feel
free to use it. These were some examples and
this behavior really affects all the string
methods too. It's everywhere. For example,string.fromcharcode
allows you to use a string based on a Unicode,
but it only works for BMP range, if you use
it with an ascentral code, you'll get a different
result (Astral) you have to implement those
former lists that I showed you earlier, you
could use a third‑party library, this is
introducing dependency to create a string
out of a number which really shouldn't happen.
Luckily in ES 6 there's a solution for this
in the form of a new method, Storm.fromCodePoin,
this works properly including from Austria
symbols. Similar ‑‑ if you use characterat
to reSteve the first symbol in the string
containing the pile of Poo character you'll
only get the first surrogate half instead
of the whole symbol
is no solution for this inES 6 there, is a
proposal to add string.prototype.add which
would do the same thing as character add it
would deal with full symbols instead of surrogate
halves when ever possible. If you use character
code at to restreet the first code point or
the first symbol in the string you'll get
the first symbol of the surrogate half rather
than whole pile of Poo character, now, in
ES 6 there's a new method called string.pointAT,
it deal was surrogate halfs when ever possible.
The links at the bottom they point to poly
fills you start using today it works in every
browser that way. Now another example is you
want to loop over every symbol in a string
and do something with each symbol you'd have
to write a lot of boilerplate code just to
account for surrogate pairs to consider them
as a single character. Now, in ES 6 this will
be much, much easier because you can just
use for of this will use the new string iter
raptor, and this will deal with whole symbols
instead of surrogate pairs automatically.
Now, this behavior affects pretty much all
string methods so be really careful when you're
using them, really unfortunate, as 2PAC would
say, that's just the way it is, some things
will never change.
Another similar problem lies with regular
problems, so the dot operator in regular expressions
only matches a single character, because because
JavaScript exposes surrogate halfs as separate
characters it won't ever match an Astral symbol,
I would expect an answer of true here but
it's actually false. What regular expression
can we use to much any Unicode symbol, any
ideas? Well, we can't use the.operator, as
weave demonstrated that wouldn't match line
Riggs, we can fix that by doing something
like, this match any character but wouldn't
match Stral symbol ‑‑ Astral symbols,
because as far as JavaScript concerned that
is two characters, what is the regular expression
to match any Unicode point, like, this apparently.
Yeah ... so the first part of this regular
expression matches any BMP symbol that does
not store a surrogate pair the second half
matches a surrogate pair, in other words,
an astral symbol, this is not the type of
regular expression you would enjoy writing
by hand, let alone maintaining it, I use JavaScript
library to generate these for me, it's called
regenerate. Here I create a new instance,
I add the range of all Unicode, then I call
two string that produces a string that can
be used a expression literal I's supposed
to be used as part of a build script. Here
east another example, a bit more advance.
Start with all Unicode points, remove a range
of symbols based on their string values, then
remove a single symbol, then we call two string
on that to turn that set into a regular expression.
And apparently that looks like this. So, once
again, this is not a regular expression, you
would enjoy writing by hand or that you want
to maintain, imagine having to adjust one
code point to that set and rewriting that
whole thing, it would probably take a very
long time, it's much easier to change the
five lines of code, write above the regular
expression, store that in a build script and
run the build scrip again after you modify
et. Another example, say you need another
expression that matches all Greek symbols
in the Unicode standard
are BMP models that contain for each category,
script, block or property. If you combine
these with regenerate it's easy to build complex
Unicode aware Unicode expression.
So I'm just requiring all the Greek symbol
in Unicode 6.3.0 as an array than padsing
that to regenerate and turning that into a
regular expression. You may have noticed I'm
using the data for Unicode 36‑point .0,
justify weeks ago Unicode 7 was released so
this is out of date. I just need to change
a single line of code. Changing that regular
expression, manually would have taken a very
long time, now all I have to do is change
the Unicode version number, run the script
again, just like that an up to date regular
expression comes out. Getting back to the
dot operator, well ES 6 introduces a new flag
for regular expression, the U flag, it stands
for Unicode, it matches ‑‑ so it kind
of makes regular expressions work the way
you think they would work. Here's another
example, in character classes, it's possible
to use ranges, as I'm sure you know, probably
expect A, ‑‑ C to match A ‑‑ C and
C, so similarly, you might expect this regular
expression to match the pile of Poo, the flexed
buy accepts and the busy symbol, right, that
just makes sense, because that's the order
of the code point, it doesn't work that way.
If you run this code it will throw an error
on the very first line it will say the regular
expression is invalid, the range is out of
order. So what's going on there? Well, as
far as JavaScript is concerned, this is what
that regular expression looks like, so, it's
not trying to create a range between the two
Emoji, it's trying to create range between
the one surrogate and the other surrogate
for the other character, which is not the
right range, and because the range is not
in the right order, it throws an error. This
is really easy to fix, you can add the U flag
and that magically makes it work as you would
expect. If you need something that works today
in ES 5, you're stuck with using a tool like
regenerate to build the regular expressions
for you. But nowadays there's a better solution,
I just released this,it's called Regexpu,
Compiler for regular expressions that use
the U flag, it will look through your code
for regular expressions and rewrite them so
they're equivalent so they still work in Es
5. Hire's a demo of that.
This is live translation in the browser, you
can use it in node I've submitted a patch
through intersure, you can start using this
today. Write regular expressions theE is 6
way and compiling down to code that works
to day without worrying about it. So in summary,
I think it's fair to say that JavaScript has
a Unicode problem, rather than complaining
about it like JayZ did, we should probably
be doing this instead. We should just deal
with it and work around these issues because
it's honestly not that hard, and, you know,all
you have to do is add some pile of Poo to
your unit test, there's a lot of talented
JavaScript programmers here ‑‑ developers
here, if we would add a Poo request for any
library that you're using or you've written,
I think we can collectively discover lots
of bugs and help get them fixed. It's not
that developers don't want the fix these issues,
I think problem is they don't know about it
because it's such surprising behavior. Thank
you.</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>