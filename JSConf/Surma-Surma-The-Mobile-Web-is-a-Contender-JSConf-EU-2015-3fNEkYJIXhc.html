<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Surma Surma: The Mobile Web is a Contender | JSConf EU 2015 | Coder Coacher - Coaching Coders</title><meta content="Surma Surma: The Mobile Web is a Contender | JSConf EU 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Surma Surma: The Mobile Web is a Contender | JSConf EU 2015</b></h2><h5 class="post__date">2015-10-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3fNEkYJIXhc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">The web as a contender, what a provocative
title for a JavaScript conference, I trust
you all members in the church of Tim Berners-Lee,
any way who is the guy on stage, this is me,
Surma, I wrote with the Chrome team for Google
in London, I do webby stuff I enjoy a lot,
I'm kind of here to talk about new things
that are coming up on the web and some of
them are actually already there.
The first thing I want to show to you is the
home screen experience, it's something that
is actually not on the web really, it's something,
if you are on the home screen or you have
an icon on the home screen you expect the
app to open up and do it's job even off line,
I went into aeroplane mode and I can save
a voice memo, to the phone or disc rather,
I an even kill the app and reopen it and everything
will be there, all the status there, data
there, this is kind of what we expect when
something is on the home screen, this is also
something that so far it wasn't really plausible
on the web, this is a web app that a colleague
of mine wrote, Paul Lewis and so some of you
may have known the app or may have known that
this was possible, but I want to get everyone
on the same level and also clear up a few
misconceptions about the current state of
what is possible and what is not.
So let's start with a few numbers first, when
you look at Chrome, and I mean Chrome alone,
Chrome has over million users right now, that
is a lot and just, as a side note, 25 million
of these one billion users open DevTools every
week, not only do we have this huge amount
of users, you also, apparently, have you huge
developer user base who try to go through
the same experience as you too and you should
probably try and connect with them.
That was Chrome alone, if you add up all the
popular browsers and few unpopular browsers
you end up with a huge number of people on
the web, there is usually no way as you as
an indie developer to publish something there,
but they too give you a web browser, suddenly
you have a way to do something on this device,
with all these possibilities for people to
go on to the web, you actually find that the
biggest strength is reach, if it's the, the
web is everywhere, on phones, on computers
on Nintendo DS, in cars, even the ones without
Android auto, for the user really it's the
most generic platform, if you know something
is on the web you will pretty surely find
a way to access that thing, one way or the
other.
With all these possibilities you actually
end up with a most impressive number, that
is that the average user uses over 100 websites
a month, I've been assured by statisticians
this is a legit number, I hope they're right,
compare that to the corresponding native number
which is that that average user uses about,
between 12 and 20 native apps per month, so
there
is, native apps per month, there is a huge
difference, another strength of the web jumping
to several different apps in few seconds is
completely normal, try to imagine that experience
in the native format.
Then recently, a kind of older article by
bencher bead resurfaced and got a lot of attention
the headline read this: &quot;The mobile war is
over and the app has won&quot;, I was like what!
It was such a weird thing to say to me, for
the first time I feel like the web can compete
in terms of performance technology features
with the what native already have, secondly
did you hear the numbers I just said, how
can they possibly justify making that statement
and of course in the article they justify
it and it's this: the time you spend in native
apps takes up, up to 80% of your total time
spent on a mobile device, so web is dead,
right, we're done.
Then again, once again you can take a closer
look and you kind of realise it's not that
simple, of this 80%, 32% is for gaming, 80%
for Facebook alone and 20% entertainment,
these are activities really time intensive,
entertainment has something like Netflix,
an app open for 30 minutes, an episode of
a series but you don't interact with it really,
you have games that you obviously do interact
with and games is something that the web can't
really compete with in the long run.
If again you remove - let's just call them
special like corner cases, if you remove them
the landscape gets different and it's kind
of a 50/50 thing between the web and native.
Also very important, the statistics that these
graphs are based on, are actually based on
data from April 2013, so a lot of things have
changed on the web since then, these numbers
might have shifted and if they have not, the
things that I'm going to talk about, hopefully
and pretty surely will.
So yeah, let's talk about the things that
going to change, before that Peter Paul Koch
suggested a short while ago a one year moratorium
idea for the web, he was basically saying
the web is moving too fast and the browsers
can't keep up and we should just stop for
an entire year and give the browsers chance
to fix up, Jan Gruber, inventor, wrote a counter
of answer to that, I don't agree with everything
he said this,-said this, &quot;Native apps can't
out web the web&quot;, native and web seem very
similar they have very different fundamental
assumptions at their core, so we should not
try to just nail every feature that native
has on to the web, at least not and specially
not in the same way, that's something to keep
in mind.
An example for this would be, does every web
site get access to my webcam, on both native
and web you would say, of course not, you
would ask for permission just in time or for
native you can do a batch grant thing at install
time, right, does every website get background
sync, probably not, but do you want to bug
your user about it every time you want to
do back time sync, we don't have an installation
dialogue for batch granting or central authority
to check if the things that app is doing are
actually saying, everybody can publish on
the web, you see how this is like a really
big UI and UX challenge for the browser vendors
to face, they want to make it secure for the
users but give you the developers as much
capabilities as possible.
So just to make the app metaphor work even
better on the web, think about this way, the
phone has all the apps installed, once you
open them they actually get installed, downloaded
on the fly, this is how we can
think about web apps, the thing is right now,
we don't expect web apps to really work off
line not to have an address bar or be on the
home screen, these are the things I want to
address today.
Let's start with the fact that web apps are
usually hard to reach, you have to type in
a URL on your tiny, tiny keyboard or phone,
or you have a big one.
You can add them to your home scene, you actually
could have done that for a long time now,
but the feature is hidden, kind of like hidden
in the menu and therefore it's hardly used.
That's something that needs to change, what
has been proposed is app install banners,
basically if the user for fills certain criteria
and right now users your web app twice in
a timeframe of two weeks, this app, this banner
will be proposed to him and he can, with one
click, move it to his home screen and suddenly
you have combined the reach of the web with
like stickiness of native apps, because it's
now on your home screen.
On your side you have to fulfil things as
well, you have to have web manifest, it looks
something like this, a name, icon, a colour,
you have an entry URL, in this case I also
added a query path to the URL, so I can check
if people are using this, icon I defined in
the icon area, will be on my home screen in
distinguishable from the native apps.
Since I said in the gene beginning it comes
with certain expectations from the user, you
have to HTTPS, that the banner is shown in
the first place.
It's a kind of way for us to incentivise keeping
the whole home screen expectation thing a
solid thing.
Also by the way, just as a side remark, you
can delay the prompt, but there is no way
for you to prompt earlier for it, this just
something, otherwise spam sites will pop it
over hand over of you, it will just be annoying
right, so that's something to keep in work.
Let's talk about service worker, I've talked
about it twice.
Service worker, are kind of a silver bullet.
By themselves they don't really address any
shortcomings that we have, versus native.
So, they however give us the way that the
work, give us a common entry point or even
some API to all the apps, so they are really
a new concept in the framework of web apps.
So what they are really is just a background
process, a JavaScript background process that
decoupled from your apps main thread, it's
actually running separately, however it is
connected to every instance of your app that
you can think of that to every tap that is
currently open that is part of your app.
They are a background process but they are
not really long running, they're more available
and they are bound to a life cycle events,
foreground events and background events.
There is some communication going on, but
you don't do like long running work really.
Also the cool thing about this concept is
that they are progressive enhancement, so
if the browser doesn't support service worker,
everything will work as before, if the browser
does support them a whole new extended experience
is offered to the user.
A colleague of mine Jake Archibald wrote this
website, which is called is service worker
ready, it comes witness a lot of APIs and
I'll only be able to cover a few of these
in this talk, he has basically a listing of
all the service worker APIs, short tests for
them so you can see if your browser supports
this feature and a little bit of demo code
to see if you can use it or links to the official
specification obviously.
So let's start using service worker, it's
actually kind of simple, the first thing I
do is use feature detection I check if the
object is a call to service worker, I have
been it does I can ensure that service worker
is supported, then I call register with a
link to file, literally downloaded and executed
inside the service worker, that returns a
promise and once installation has been completed
and completed successfully, this promise will
resolve.
This service worker will be scoped to your
current website and the current path, you
can make the path narrower, so you are scoping
yourself to an even longer path but you can't
go upwards, it's just kind of a security feature.
So now we have the service worker running,
what do we too next?
They are a kind of network proxy for all the
requests that your site is doing.
So this let's you too like very sophisticated
caching and complex off line experiences,
even for the data from other origins, for
example in this graphic I hinted the image
is hosted on G plus, you can actually cache
the response, since another origin you can't
expect it, it's called an opaque response,
you know there is something in there, you
don't know anything about it but you can put
it into a cache, if it's your own data you
can manipulate the request and the response.
You could do wild stuff like templating in
service worker and have it go through to your
main site or do SASS compilation, although
keep in mind you should be trying to have
the progressive enhancement thing still going
on, which in this case would be breaking.
So here for example I define items the crucial
items I need for my site to be running offline,
I hook up to the install event in my service
worker, I open up a new cache which is identified
by cache name which is a string, and once
it's open, I just add these items via the
cache API.
The cache API has add all which is a convenient
function, just takes an area takes care of
both downloading and caching these things.
It takes a promise, then this promise is coupled
to the promise in the other thread the register
called.
The register called promise will only be resolved
once this thing actually finishes.
This means that once this is open, I already
have the important parts of my site cached.
The next step would be you can also do it
hooking up to the fetch new event, for each
request this fetch new event will be fired.
I take my cache, I match the request and the
cache API provides this match function for
you already, if it's returned something usable
I will just return that and otherwise will
use the fetch API to actually get the data
from wherever.
This is a simple cache implementation, my
app will start working offline immediately.
This obviously it's also, once you start caching
you will never look at the network again it
will grow stale pretty fast.
You have JavaScript at your hands you can
** are complex stuff here.
Again Jake Archbald wrote a great demo for
this is an offline Wikipedia, he gives us
a switch at the top to give you the ability
to cache the articles in a style format so
it works offline, and if he kind of detects
that the connection is flaky, he uses another
API or service worker which is called Background
Sync, he actually moves the downloading part
from the main thread to service worker thread
which enables you as the user to leave the
app and keep the download going in the background
so you don't have to stay in the app, you
just wait for the network to do something.
He does it in the background, pushes the notification
on the screen once the data is there and you
can look at it.
You can do uploads as well by the way.
A while ago Google published the toolbox which
is a swtoolbox, the service worker tools hence
the name.
It has a lot of caching strategies implemented
for you and also it has the router implementation
you can do this by just a little bit of routing
little bit easier to write these complex offline.
I said that service workers are available
not long running, the interesting part the
statement is they are also available if Chrome
is completely closed.
It means the browser knows he can't call these
events or the operating system.
If you are in the context of Android it can
wake up this particular service worker if
something comes in for, regarding or in relation
to your app, even though Chrome might have
no tab open whatsoever.
This is probably something that is most important
because this enables us to do push notifications.
Push notifications are kind of the Holy Grail
of user reengagement, until now you had no
way of letting the user know that something
important has come up on your side of the
app you just couldn't notify him if he closed
the tab.
It's been proven that this significantly increases
the engagement of the user and maybe to our
dismay it's part of every native app nowadays
but we kind of want to have them on the web
as well right?
And there are also not that hard to use.
So, the service worker itself has the push
manager attribute.
When you call subscribe you basically get
back an endpoint which in terms of a full
circle way you just put it on your backend,
save the URL there, now if you push data at
any point it will end up on the users device.
For Chrome this will also be type for a group
of cloud messaging, for Firefox it would be
Mozilla push services, so the only thing you
actually need to do is put a little bit of
data in your webapp manifest, so that the
browser knows what project you are related
to or that it actually hooks up for the right
events.
Once youâve got your subscription going
on, the only thing you need to do is to subscribe
to the push event in the service worker, and
this event will be triggered once a push notification
or push message comes in.
This actually works on both Chrome desktop
and mobile and then you can just notification,
put some URL in the data and once the user
clicks on the notification the notification
click event will be triggered you can pull
out the data from the notification again and
open it in a new window.
Or it's possible for you as the service worker
to just list all the open tabs and replace
the contents of one with a new one if you
think that's appropriate.
By the way the Facebook app, Facebook webapp
does this
already, so if you go to Facebook webapp,
put it on your home screen you will get notifications
from that app.
Which I think is really cool.
Again there's little demo online, it's called
a push demo the link is on the bottom right.
You can see me subscribing to push notifications
then I am actually literally closing all tabs
all of Chrome, and then I am triggering a
push notification from my desk open to the
console you will see it actually show up in
the bar.
I can click it, it will open up the URL that
embedded which in this case is the weather
of London which is not that exciting.
However, if you think about that, we just
got lots of cool features on the web to actually
write much more much broader experiences for
your apps.
One thing mentioned but have not really been
clear about is that for that you do need HTTPS
for service worker, you do need service worker
for basically all the features I just mentioned.
This might come as a let down first, but HTTPs
should really be used for everything in my
opinion it's not a reality right now but we
do have services like CloudFlare who offer
it for free so you just put them in front
and you have HTTPs.
It's due to launch in Q4 this year so I guess
any time now and they promise HTTPs encryption
for you own servers just to be just as easy
as CloudFlare.
At that point there really is no excuse anymore,
so start doing it now, so you won't be surprised
at that point.
Bottom line is, we just got very important
features to make the apps on mobile so much
better, and I encourage due to play round
because it's loss of fun, and give you a whole
new mind set when doing webapps so we have
this weird ability of incepting network requests
and doing weird thing with the response.
If you have questions feel free to hit me
up on Twitter, or come to me in person I will
be round for a while, with that thank you
for you tension.
{applause}</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>