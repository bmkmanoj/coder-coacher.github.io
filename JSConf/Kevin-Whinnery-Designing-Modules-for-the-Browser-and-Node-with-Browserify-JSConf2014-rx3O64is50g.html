<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Kevin Whinnery: Designing Modules for the Browser and Node with Browserify [JSConf2014] | Coder Coacher - Coaching Coders</title><meta content="Kevin Whinnery: Designing Modules for the Browser and Node with Browserify [JSConf2014] - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Kevin Whinnery: Designing Modules for the Browser and Node with Browserify [JSConf2014]</b></h2><h5 class="post__date">2014-07-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rx3O64is50g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">everybody my name is Kevin I work for a
outfit called Twilio and if you haven't
had a chance to use Tullio before it
lets you do cool stuff like make and
receive phone calls send and receive
text or picture messages and I enabled
what calling in your desktop browsers or
mobile apps and also I actually wrote
the note module for Twilio and I think
I'm actually gonna add a high-level
helper that is a one liner so that
Angelina Fabio brings you brings you
tacos as you saw in one of the last
talks so that was pretty awesome
great use of Tullio and if you think any
of that stuff might be fun to play
around with I just go ahead and NPM
install Tulio but that's not what I'm
here to talk about today I'd like to
talk a little bit about again one of my
favorite tools for use with node.js
which is browserify and for me it's
actually sort of the key tool which
unlocks the promise of node to allow you
to share code between the client and the
server side and it's also really useful
even beyond the browser really a browser
if I house you to do is to package up
the node.js module system and basically
create a single javascript file that you
can evaluate in any JavaScript
environment but lets you write your
javascript in such a way where you can
you know structure your code in as no
jazz style common J's modules so it's
really cool if you haven't used it
before I definitely encourage you to do
so because it allows you to start to
share culture if you will with both
declined in the server side in your
JavaScript code on just having the same
language on both ends of the wire is
pretty cool but if you actually want to
reuse
it should be written in the same style
and kind of live in the same ecosystem
as you know it has one another so that's
why I think browser if I really enables
a lot of the really cool stuff that we
sort of are hoping to realize with
nodejs so I if you are writing a node.js
module today that you're supporting out
on NPM a lot of modules with browserify
today will just work so it could be that
you have no work to do to make your
mount module browser a file but you
might want to do a little bit of extra
work if your module meets one of these
two criteria so if your if the
functionality that you're shipping in
your module has sort of complimentary ap
is that you can they're slightly
different that you can use both on the
client and the server side one example
would be the ws module the web socket a
popular web socket library for node in
the browser when you require it it gives
you a cross platform or a you know a
browser specific version of the web
socket implementation that exists on
that browser and and then on the server
side it gives you a WebSocket server
that you can then use so if your module
sort of could benefit from having sort
of nice nice interfaces that are that
are connected on both the client and the
server then you probably won't want to
look at some of the more advanced
features of browser five also sometimes
your module isn't just going to work so
if your module does any kind of a file
system i/o or something along those
lines obviously that's not going to work
a node or excuse me with browserify but
basra fidos provide shims for most of
nodes core libraries so a lot of the NPM
universe just kind of works today so
your module might be one of them if not
I would definitely recommend you know
taking a look at how you can make it
browserify compatible if that if that
makes sense
because a lot of folks are sort of
moving to browserify as an alternative
to some of the asynchronous module
loaders that are purely sort of live in
the browser
- again - to realize that promise of
having the same styled code exists both
in node and client-side code so there's
basically if you want to design a module
to work with browserify there's about
three things you
need to look at so the first thing is
sort of looking at the entry point for
your module and saying like you know if
if there is sort of a different
interface that you want to expose on the
client versus the server you can
actually specify in your package
touching on a different entry point
where your module begins so we'll take a
look at how you do that we also define
any shims that you need to insert so if
the HTTP implementation that chips with
browserify doesn't meet your needs
there's a way that you can create your
own custom browsers browser shim for a
node module that you use in your
application and we'll take a look at how
to do that we also have source
transformations that are available in
browserify so if your module is written
in CoffeeScript and you need a
CoffeeScript compile before your modules
were agent for use in browserify you can
specify that package to JSON as well so
at this point I wanted to actually write
some code to show you how that would
work so basically here I have two files
in browser a s and a server a s and I'm
going to create a node module that's
going to work in both of those
environments the server being just a
plain vanilla node program and then the
browser dot j as being a file but I'm
gonna package up with browserify
to ship and include as a script tag I
ain't a script tag potentially I mean a
web browser so let's create a new
directory I'll call that demo module and
go in there and do an NPM in it and
we'll just accept a lot of these default
values ok so now we have a package of
JSON for our program and by default when
you create a new NPM package there's
this main main attribute here which
which sort of specifies the entry point
for your module so if so when for how
certify packages up your module by
default it's going to look at this main
attribute first and that's going it's
going to use that as the entry point for
your module because it observes the same
module loading algorithms that that note
am/pm use so if you don't have a
different interface from browser to
server then that's fine and you can
leave that just
as it is so let's create index J s and
we'll open that up in a text editor here
not that one we're looking for this one
okay great so here's our demo module odd
directory and inside here we'll just
create something like say a hi and say
console log server or something along
those lines okay so here's my version of
the module that works in node and now if
I want to have a browser specific
version of my module I'll create another
file I'll call it client Jas and in this
one I'm gonna have a the same interface
say hi give that a function and alert
hello it was something along those lines
okay so on the brach in the browser I
want to use this as the entry point for
my module so the way that I specify that
in package.json is by providing another
attribute called browser so when
browserify processes your module it's
going to look for this attribute in your
package JSON if you set it to a string
it's basically going to be a relative
path to a file in your directory that is
you want to use as the entry point so I
can just specify client excuse me dot
slash client dodge answer so now I have
a module that I can use in this code
here if I go up directory server dot yes
well I don't actually have to go through
and type all that I think you guys are
kind of with me there so basically here
are my two entry points for client and
server now the other thing that you
might have to do besides sort of
specifying a new entry point there is is
provide some kind or provide some other
shims for other functionality or other
files that you want to override when
you're writing a module that's going to
run in the browser so the way that we do
that in package.json is rather than
setting this browser property to a
string I can actually set
to be an object so I still want to have
a different entry point for my
browserify package but in this case I'm
not going to sort of override main over
in the keys section of this of this odd
JSON object I'm gonna specify the file
that I want to override so I'm gonna say
dot slash index dot JSP loaded if my
module is going to be used on the server
but instead I want to load up dot slash
client jas so now I have you know that
was basically the same as just setting
this string equal to the browser
property before so now I have my
different entry point and then let's say
I have a custom shim for the HTTP
library in core node if I wanted to
specify something like that I would just
go dot slash now my HTTP jas and then I
would be able to implement my own
browser shim for the HTTP library as
well so those are kind of the two main
things that you'll have to do to prepare
your module for a browser if I specify
you know an alternate entry point and
any shims that you need another thing
that you might have to do is specify
some source transformations if your
it'll basically allow you to process
code in a stream and output a modified
version of that code that will run in
the browser and there's a lot of
existing transformers out there for
browserify one of the more popular one
more popular ones is coffee fi which
will basically process your coffee
script code convert it to JavaScript and
then included in your browser affine
module so the way that we specify that
is with the browser of five field of
package.json and inside this inside this
object we have a property transforms and
that's going to be an array of strings
which will point to modules inside your
project so let's if I had some
CoffeeScript that I wanted to process
before my module or as my module gets
browserify I just specify that I
want to ride through this transformation
and if you do have a transformation like
this one you also have to add it in your
modules dependencies will have to be
resolvable by browserify as a dependency
so you just add a dependency there for
coffee of five so pair your module
you're going to again just do those
three things specify a new entry point
shim any any core node libraries or
modules within your own application that
won't work in the browser unmodified and
then you can also specify
transformations for your code so those
are probably the things that you will
need to look at doing to make your
module sort of compatible with
browserify now the reason why I think
this is kind of interesting is sort of
specific to you truly oh and and what we
do with our module so with Detroit SDK
there's a server side component that has
a REST API which we provide sort of a
high-level object wrapper for in the npm
module but we also have this client side
sdk which lets you make voice over IP
phone calls which martially used to such
a great effect in her in her
presentation earlier so we have a
situation where we have an API that all
sort of hangs together and has client
and server-side components so I actually
kind of looked at an API that similar to
like what socket IO provides where it
has sort of a elegant way of including
both client and server-side
functionality at least initially it was
in a single package now it's in two
different ones but this seemed to be a
really good use case for Twilio voice
over IP so what we have to do today is
you know your browser code has to talk
to your web application to generate a
capability token which basically
empowers the browser to make phone calls
and then your note application has to
respond on to an ajax request and then
your browser talks to Tullio to initiate
the voice over IP call to leo talks to
your application to get you know
instructions brown and of a call before
ultimately you can actually place that
voice over IP phone call between your
customer and the person that you would
like to your browser and the person
you would like to talk to you so this
seemed to be a really great opportunity
to find a module using using browserify
that would provide two different
interfaces on both the client and the
server so I'd like to show you a little
bit of how I would envision this working
in an application so let's go ahead and
open up a simple demo so here we have a
note application pay no attention to
this basically this is just agility I
created that it creates sort of a
pre-configured Express for web
application so this is an Express web
app that is set up with some useful
middleware for you know automatically
browserify
certain files and applying less and
stuff like that so but it's basically an
Express for web app and then we require
a special version of the Tullio module
and then I can actually use the toilet
module to basically mount some server
side capabilities that will handle some
of that token generation and that other
song and dance that we saw before so
this is the API that I want to expose on
the server side and then on the client
side I wanted to sort of drastically
simplify the code that would be
necessary to actually create a voice
over IP call between two parties so here
we just include from a Twilio CDN a
javascript file which has sort of the
core basic j/s SDK and then here we have
a browser ephod file that we're loading
up from our web application and in that
file
we have jQuery that we've installed via
NPM so we can you know use that like an
NPM module and also the toilet module
again using a customized version of it
on my local file system and then we just
have a couple of handlers here that will
you know initialize the outbound phone
call with you know Tulio tile it'll hang
up when the user wants me to you and
then initially because this javascript
is being generated on the server I'm
able to just call Trulia connect and I
already
necessarily have to make Ajax calls or
une any stuff to you know fetch a
capability token or set up my server
side because my JavaScript was generated
on my server I know where it lives and I
can sort of automate that entire process
so what I'm going to do is fire this up
actually it looks like it's already
running and I do in order to do voice
over IP I need for this web application
to be on the public Internet
does anybody here use a tool called and
rock and rock it's a port forward or a
couple people okay so if you don't use
an grok and take nothing else away from
this talk it's an amazing tool it will
change your life definitely go install
it it basically assigns a public-facing
URL to a local port on your laptop so if
you have a local node server a rails
server or something like that you want
to quickly put it on the internet so
that your friends or clients can check
it out and rock is a great tool to let
you do that so basically what I have
running is a simple application that
will by default initiate a conference
call between somebody in their browser
sir would you mind being my guinea pig
in the front row I'm gonna come pick on
you would you mind going to kwn Gras com
sorry to pick on you like that but I
would I need at least one one person per
kwmg are ok.com and just click on that
button to say join a conference call and
Twilio x' Julio's planetside SDK will
use the WebRTC API is built into the
Chrome browser to initiate a phone call
waiting for that second party
I actually just hit the join the
conference
and if you're in there you magic of
WebRTC yeah I know
our voices are connecting through the
energy so so yeah basically the reason I
wanted to show that is it's it's one
example where you have a module and you
know that you're gonna have server set
IP eyes and client-side API is there
going to have to interact with one
another and if you and you can present
sort of a unified interface to both the
client and the server if you write your
breitner module in this way and in the
in this particular example of the Twilio
module I was able to share code between
the client side SDK that is being used
in the browser and the server side SDK
that I use that you would use to contact
the REST API or to generate capability
tokens on the server so I definitely
recommend that you check out browserify
it's a great if you're using node it
makes a ton of sense because you're
basically going to be using the same one
package manager one style of structuring
your code and you'll be able to realize
a lot more of the benefits of having
JavaScript on both the client and the
server so some of the documentation for
the browser if I specific stuff you see
is up here don't worry about copying it
down this is actually all on my
SlideShare account which is
slideshare.net /k whinnery if you have
any questions feel free to come track me
down but yeah yeah I think browserify is
a really cool tool and definitely worth
checking out if your music thank you
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>