<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Isaac Johnston: Simplicity through Functions - JSConf.Asia 2015 | Coder Coacher - Coaching Coders</title><meta content="Isaac Johnston: Simplicity through Functions - JSConf.Asia 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Isaac Johnston: Simplicity through Functions - JSConf.Asia 2015</b></h2><h5 class="post__date">2015-12-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lejV59XtPAE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you hello jazz conf Asia I'm Isaac
you can find me on twitter and github at
superstructure I live around here you
might recognize this as a scene from
Middle Earth and a lot of the Rings more
realistically known as in New Zealand
it's a beautiful country so if you have
the opportunity i highly recommend a
visit most of my recent commercial work
has been on a cloud security platform
called SMX the main product is cloud
email security used by the New Zealand
government the Defence Force in most
businesses so we have JavaScript engines
running inside our mail servers that
handle the majority of mail flow in the
whole country that's always so used by
other countries such as Australia Japan
India the average juggler can juggle
about three things at a time like in
this example but then he still manages
to set himself on fire
the most amazing juggler in the world as
a world record can joke about 13 things
at a time so it's not really a lot more
in the context of things if you think
about fifty or one hundred or a thousand
so if we think about this as an analogy
before our mental capability as
JavaScript programmers how many things
about your program can you think about
at any one time how many parts of your
program can you juggle most people can
think about around seven things at a
time or if you're a complete genius
maybe 14 but no one can think about 50
or 100 so the basic premise of this talk
is that compared to the programs we
create we're all extremely limited and
our ability to understand and reason
about the software how can we get to the
next level of software creation without
exceeding our mental capacities and this
talk will look at what reliability
simplicity and easiness means how these
things are related to solving the
problems on limits our mental capacity
then go through some code examples in
JavaScript to help mitigate these
problems in practice this is a technical
talk if your JavaScript programmer that
is based on concepts you already know
unfortunately there's no music robots or
live demonstrations it's a practical
talk on everyday JavaScript I'm not
going to assume you know any of this
already so if you do functional
programming which is going to be
discussed and haskell or closure or
something similar this will be quite
slow we might have time for questions at
the end but we'll see how it goes let's
talk is not original work that's
borrowing a lot from other languages and
it's based on a 75 year history of work
by other people just reapplying it in
the context of JavaScript especially
want to create rich Hickey they created
the closure programming language for as
explanation of simplicity versus
easiness which I'll summarize in this
talk as I assume some people might not
those definitions that he's talked about
I recommend you look up all of Ricky's
talks on YouTube even though they're not
about JavaScript they will help you
become a better programmer so first
let's establish some common terminology
of some important terms words mean
different things to different people and
there are a few words you'll need to
understand so I do email email happens
to be something users just expect to
work so the project I'm working on
reliability means that email is actually
delivered that is delivered quickly and
is accurate so for me it's primarily
about quality and correctness for you
reliability may have different meanings
such as software being delivered on time
or controlling the cost of building and
maintaining the software or being able
to confidently change the software and
the sense almost all of us here probably
care in one way or another about
reliability and that our software can be
trusted in one way or another if you
don't why not can you imagine a better
word start the sentence then simplicity
I can't we need to build simple systems
if we want to build reliable systems so
what does simple actually mean the root
of the word simple are some and flex
that means one fold or braids or twists
or untwisted what does one braid look
like it looks like no braids the
opposite word is complex that means
braided together or folded like twisted
together so we need to be able to think
about our software in terms of whether
it is folded together or not simple
things might have one dimension one
focus or one objective the important
word here is the braiding and the
interleaving not the word one simple is
not about only having one operation or
one instance of something simple is
about that there's no interleaving so
you can think about things in isolation
you can see on the left and right there
are the same number of strands it's four
strands on the left it is not braided
and the right it is so simply has
nothing to do with cardinality
simplicity is kind of objective you can
actually look at something and see if
it's connected to something else or not
so the bad thing about complexity is
though if you want to think about a
piece of your software and it's braided
together with something else then you
also have to think about that other part
and if it's braided to give this with
something else you start pulling all
these parts of your software in just to
solve a single problem you can't think
about just one concept or dimension and
isolation another word we frequently
confused with simple is easy which in
this derivation is from the leading word
adjacent which means to line Nia and be
nearby so there are several meanings
that you can take from this there's the
physical meaning of being near like it's
something right here by right beside me
is it in my toolkit or is it installed
on my computer there's also is it near
to our understanding or is it in our
current skill set the word in this case
is about being a familiar concept as
programmers we're so tremendously self
involved in these two meanings of easy
and we think about this far more than we
should and instead of thinking about
what is simple simplicity is not the
same as easy simplicity is not about
your personal abilities that's not about
your convenience and it's not about your
tastes so the first meaning of easy is
this notion of being physically nearby
we care so much about we can npm install
something and get it working in a few
seconds often we don't think about if
the thing we installing is a giant ball
of complexity just that we can get it
right now this is really easy but is it
good for the reliability of your
software conversely if something is
simple but it is not easy then because
it is not nearby then it is within your
control to bring it nearby by making it
part of your talk or installing it
I can't read this because i can't read
chinese we don't learn Chinese and New
Zealand school unfortunately does that
make Chinese unreadable there's Chinese
unreadable no I just don't know Chinese
so as programmers we're too fixated on
this notion of easy related to
familiarity like I can't read that for
this meaning I don't mean in regards to
our limits or mental capacity as I was
talking about earlier I just literally
mean is it near something I already know
if you want everything to be easy and
familiar you'll never learn anything new
because it cannot be significantly
different from what you already know we
also confuse this notion of easy with
simple all the time by saying that I
like to use some piece of technology in
my stack because it is simple when I
actually mean it it is easy excuse me
I'll just quit that and when I mean it
is easy I mean it is similar to
something I already know conversely to
make something you don't know which is
simple familiar all you need to do is
learn it that's totally within your
control to make it easy then there's the
third notion of being easy which is the
most interesting which is being near to
our mental capacity to understand
something because then this were all
very similar how many conceptual balls
can you juggle this makes developers
uncomfortable because we're in the field
of working and conceptual work so if we
talk about something being outside a
mental capacity it hurts our egos we all
have very similar limitations relative
to the complexity of the software we can
create so it's not so embarrassing after
all we all can't juggle like a hundred
balls this is the notion of easy you can
actually control to great benefit in
your software if you're willing to learn
some onion familiar ways to write
JavaScript you can drastically simplify
your software making it easier to
understand and ultimately more reliable
we're in the business of producing
artifacts for users but we think so much
about the constructs does a user look at
our source code and say oh that's so
nice that javascript is just so amazing
Wow no users don't care about that that
users care about usability correctness
performance and the ability to change
the software these are all attributes of
the artifact not the construct
complexity is endemic and software
because as developers were too often
thinking I like this because it's good
for me personally right now so we need
to start thinking about building
software in terms of the complexity of
the artifact we produce and give to
users not in terms of the easiness of
the construct so Ricky revived this
archaic word to describe creating
complexity and it means to enter leave
or into wine or two braids so when I say
something is conflicting or as complex I
mean it as breeding things together
whereas the act of creating complexity
complexity is bad so obviously
completing is bad just don't do it I'm
proposing that some concepts from
functional programming drastically
simplify the artifacts we produce
functional programming covers a wide
spectrum of languages there is no clear
widely accepted definition of functional
programming it's a collection of related
features that which work together to
form a very useful style using some
features from functional programming can
reduce braiding or complexity thus
making a program easier to understand
and increasing reliability some features
are already widely used in JavaScript
others require libraries and some are
just not possible due to language
constraints so different model
programming is object orientated
programming and this emphasizes the
encapsulation of learning moving parts
within classes and object instances and
oh you bundle up data with methods that
operate on the data whereas in
functional programming emphasizes the
use of functions to minimize the number
of movie
parts instead of encapsulating them and
functional programming you have
behaviorist functions that operate on
the data as arguments and return values
so on oh the central activity is around
classes objects methods whereas in
functional programming the central
activity is all around functions so it's
finally getting to some code this is
valid JavaScript code albeit not useful
both 42 and the string hello our values
I think everyone can see that values
don't change 42 is always 42 hello as
always hello values are also not braided
together with anything so they are
simple and JavaScript for the primitive
types such as if you add two numbers
together or concatenate strings you
always get a new value it does not
modify the original number 40 so 40 plus
2 creates 42 in addition to 40 and too
or at the original string hello so this
is all so simple if we bind the result
of an expression like 40 plus 22 I
identifier we get an identity
referencing a value so meaning of life
is an identity for the value 42 this is
all so simple there's no braiding here
now we have a problem the meaning of
life has changed because of the
different values of the time the program
has been executed the state of the
identifier referencing the value has
changed or mutated into something else
so we say the identify now is state and
that the program is stateful how would
you test this unless you step through it
in a debugger you cannot inspect the
runtime state or the identifier before
has changed you can only test the most
recent state state complex values with
time you don't have the ability to get a
value independent of time but this is so
easy and familiar and so many of our
programming languages and used by
default in JavaScript a lot of people
say state is bad because when threading
and multi-core
chips concurrency means you need to use
locks but in this case it has nothing to
do with concurrency state is complex
because it is completing the software at
a fundamental level the data is what
you're operating on to produce a result
Const creates a read-only reference to a
value it does not mean the value of
holds cannot change just that the
identifier referencing value cannot be
reassigned to a different value so this
is better for primitive types like
numbers and strings this effectively
does provide immutability because you
cannot modify those types anyway this is
simple because we're not conflicting
values in time
to represent some information using
objects as maps for key value records
for values as simple because data is
just data this is not braided together
with anything but despite using const
for a read-only reference to this map
object objects as values are mutable and
JavaScript this introduces a change of
state by setting a new field so again
this is conflicting time with values and
it is complex a way to give around us in
javascript is by using a library you can
get immutable data structures and
JavaScript this way with an immutable
collection modifying the collection in
any way returns a new value so after the
last line here of confidence it both
values persist as separate and isolated
values the set call does not modify the
value assigned to the comp reference
immutable collections are simple because
there are no conflicting of values in
time immutable collections can also be
used to do interesting things like time
traveling debuggers which can show the
state of values over the entire
execution of the program because you
never lose any changes this example is
using a library called immutable from
Facebook there is also a library called
Morey from the closure community which
is faster but immutable was used here as
it has more support within JavaScript
ecosystem so why immutability what do
you have to do if you want to reproduce
a bug in production or write a new test
recreate the state of the program at
that point in time because our software
is operating a data there's a huge
amount of state in our programs state is
the source of the majority of complexity
so using a mutable references and
immutable collections can resolve a
massive amount of the complexity in your
software not only does it make your
software easier to understand for some
optimizations that are possible with
frameworks like react it can be
something like 50 times faster because
of
cheap chicks 24 changes to the data
but what about memory usage if we keep
all these versions of the data around
modern mutable immutable collections
like the immutable library is the
feature called structural sharing for
example this means that when you add an
item to a collection the original is has
not been changed but a new value is
created with a reference to the original
value and only the new item that has
been added as stored in memory behind
the scenes the data structures share
common data between multiple values so
you don't need to worry that this is
costing a lot of memory or a lot of
inefficiency in copying copying data
around and memory does anyone know what
this is no it's magnetic core memory
that was used from 1955 until 1975 if
you ever wondered with the term core
dump for writing memory to a file came
from it was originally used with core
memory every ring you see is one bit of
memory made from iron that had to be
placed in that network of wires by hand
but by bet it was woven on a loom each
vet costs as much one as one dollar so
by that measure my iphone has eight
billion dollars of memory functional
programming was invented in 1956 when
this memory was on use so that time it
was just too expensive the only reason
we change locations in memory with
mutable references and mutable
collections is that we literally had to
think about where and memory we would
put something and then replace it when
we didn't need it anymore because we
didn't have enough available memory to
use a new place and memory we don't have
anything like these limitations anymore
memory is plentiful cheap and fast so
why we're using language decisions made
for obsolete hardware let's look at an
example that's a bit less trivial than
storing simple values this is a
sunflower a sub flowerheads follow the
foot Bonacci sequence of numbers which
is closely related to the golden ratio
to get a Fibonacci number we start with
two numbers one and one then each
subsequent number as the previous two
numbers added together
so the first number is one the second
number is 1 then 1 plus 1 is 2 for the
third number and one plus two is three
for the fourth number and so on this is
a function that will get the info
Bonacci number so if we want the fifth
number would pacify them as the in
argument not only is the state full as
variables a changing state but loops
also complex what you're doing with how
to do it and the four definition it's
checking if I is listening in on each
step and incrementing I which is the
iteration part and then inside the for
loop the step part is calculating the
value so loop represents conflicting
different concerns and as a source of
complexity could this be written so that
is stateless and not using a loop it can
be written this way it's not very useful
to write it like this but no variables
changing state and there is no looping
also despite having no state branching
complex with structure and organization
in the program so branching is not
actually simple there is a better way
this is a recursive algorithm where thug
calls itself until in as less than or
equal to 2 then it will return one and
stop calling itself no references change
state new references are introduced with
const but these are recreated every time
functions called so if you call this
function with 5 as the in value the
lines at the bottom are the calls it
will go through until is just adding
ones together you can test the state of
this function at any point simply by
calling it with the right value for the
in argument unfortunately until recently
JavaScript recursion does not perform as
well as there is overhead of creating
stacks new stack context for erie
function call in es2015 it is tail call
optimization which will make this fast a
tail call is when the very last thing
the function does before returning as a
recursive call to itself so this verb
function
is not optimized herbal because after
calling itself it calls itself again so
it's doing something else after it calls
itself the first time in the return
statement so let's rewrite the recursive
function slightly so that there is just
one recursive call and the return
statement this is now a tail call the
very last thing in the function is doing
before returning is calling itself at
this point why do we need to allocate
more stack space the current invocation
of the function will never need the spec
space again as soon as it receives a
value from the recursive call it will
return to the caller so instead of
allocating stack space we could simply
reuse the stake space used by the
current function invocation and inherit
the return address which will return the
Fibonacci number in the latest
JavaScript engines putting ears 2015
telco optimizations will make this fast
and efficient
so functions have a concept of purity
and functional programming we say a
function is impure if it causes state to
change outside of the scope of itself
this is also referred to as side effects
because there is an effect outside of
the scope of the function and pure
functions are complex because yet again
there's conflicting values in time over
your program but you see the style of
mutating outer scope variables all the
time in JavaScript
conversely a pure function only takes
arguments and returns values it does not
modify any other script state pure
functions are easy to test in isolation
because you only need to provide
arguments to test the result there's not
some otoscope state to set up and check
and obviously pure functions don't
complete time with values so simple so
without loops and modifying values how
do you convert one collection of values
into another collection of values one of
the most fundamental functions and
functional programming is map which is
used to convert one collection and to a
related one by running the same function
against each member of the collection
any function that takes a function as an
argument or returns a function as a
return value as known as a higher-order
function in general so in this example
double is a function that is passed to
the map function to run against each
number this is simpler than loops
because it does not conflict what you
are doing with how to do it I put
simpler with an R here because it's not
as simple as it could be first I could
be using immutable collections instead
of the JavaScript mutable arrays in maps
second I'll talk later about how common
collection functions like map complete
to the inputs and the outputs of the
data with the steps or transformations
you're performing on the data produce is
a more general higher-order function for
collections then map allows you to
produce any new value from a collection
so each invocation of the add function
receives the value so far and returns
the new value that would be passed into
the next invocation of the add function
in this way a value is built up over
each member of the collection
filter is another example of a common
higher-order function for collections
they will produce a new collection with
any items that do not pass a truth test
removed that as even function will be
invoked for each member of the
collection and if it returns false the
member will be removed from the
collection returned by the filter
function
I want to make special mention of for
each here which is technically a higher
order function for collections because
it takes a step function as an argument
for each is basically a loop with a step
defined as a function because there's no
output value because there's no output
value the only user can have as an
impure step function that changes state
or has side effects so the only possible
valid use of this is pressed with
debugging or intentional side effects if
you can't do it another way and it's
definitely simpler to use reduce fill to
a map or some of the functions for
working with transforming collections so
this is complex methods actually like
stateful functions most of the time but
even if methods on classes and instances
do not mutate any state object
orientation complex a lot of things a
complex state identity values methods
complete functions state and namespaces
this is claimed to be required to
encapsulate the data with its
implementation but latitude and
longitude here in this example are just
data what implementation do they
actually have and reality this is
braiding together the operations on the
data with the data itself object
orientation in general is very complex I
agree with GK leave earlier who said
their classes are not necessarily always
bad that's how you use them it's just
the most common use of classes for
encapsulating data has promoted as good
practice as part of object orientated
programming but I think this is obsolete
and complex
why not just use data as values and
namespaces of pure functions this is
easier to test and easier to reason
about this is simple because there's no
conflicting of state identity values and
namespaces lock with object orientation
there's also feature and functional
programming called Korean unfortunately
it's not as yummy as curry in real life
but it was very useful it's named after
the person who created it from a
different programming language so the
naming has no relation whatsoever to
what it actually does carrying is the
process of converting functions that
take more than one argument and two ones
that when supplied with fewer the
arguments then they require will return
new functions that accept the remaining
arguments so in this example if is a
function that is already has a set a to
1 so that when we call F with 2 we get
the result of 1 plus 2 carrying is
simple because it enables us to untwist
or unbraid applying arguments from
function and vacation so you can do
these two things separately whereas with
normal function invocation you have to
provide all the arguments that cool time
different versions of currying work
slightly differently but in the ram
dealer library implementation you can
pass any number of arguments at any time
to the curried function when the total
arguments past have not reached the
required number you'll get back a new
function if you reach or exceed the
number of arguments you'll get back the
final result users of more advanced
functional languages will insist this is
not carrying but something called
partial application that is partially
applying function arguments to the
function but for us i think that serves
the role of carrying just fine
compose as a function that can join
functions together into a new function
so in this example calling if is the
same as calling power then the gate and
then increment on the values composed as
simple because enable us enables us to
remove braiding between using the
behavior of multiple functions together
as a named reference from the actual
function invocation so we can join these
functions together and give it a
reference and then call it later
this is commonly done in web browsers in
JavaScript it past callbacks to event
handlers to do something in relation to
the mouse moving or someone clicking a
button passing callbacks event handlers
as completing the producer and the
consumer of events as the producer is
the document that's firing the mouse
move in and the consumer is the callback
so there's this massive web of direct
relationships between the things that
produce events and the listeners it
creates fragmented logic there's
difficult to reason about or control the
flow of it's also conflicting the
asynchronous or synchronous nature of
the event source with the consumer logic
the consumer logic is directly bound to
the asynchronous asing recently so this
is complex
communicating sequential processes or
CSP for short as a model that D braids
event producers from event consumers and
allows intermediary transformations as
functions it was originally introduced
in the go language then put it to
closure and then put it to JavaScript
this allows you not to be concerned
about the source of data or for as
asynchronous or synchronous these are
basically multi reader multi writer
message queues so you can pass the
endpoints around as values put events on
to the endpoints the inputs do some
logical transformations in between and
take events out I'm not going to go
through CSP and detail as that would be
a whole talk in itself but I will
provide a short example this function
given a Dom element a name of an event
type and a CSP channel will put the Dom
events on to the CSP channel so this is
an event producer
so for this example I'm going to use
mouse events so we can filter to only
consume Mouse events that are on even
pixels on the page and I don't want to
deal with this complex event object are
just like a simple vector of the x and y
coordinates so we can use a mapping
function to transform each event and to
array
finally I can use a recursive loop to
take events from the cs p-channel so
this is an event consumer and print them
to the JavaScript console so you can see
that as a mouse would be moving around
on the screen each filtered and
transformed event would be printed to
the console this is probably more lines
of code than the event Kovac example but
it's about the lack of interleaving
being able to understand and test these
things in isolation not the number of
lines of code
in real life if we want to take some
luggage there's going on or off a plane
remove the bags that contain bombs
because bombs are not cool then label
the bags with a barcode removing bombs
is like a filter function and applying
labels as like the mapping function it
transforming the bag by putting a label
on it in real life the instructions for
removing bombs contain or bomb
containing bags and labeling bags with
barcodes don't care about if the bags
come from a conveyor belt or trailer the
bomb dog doesn't say oh man that bag
came from a trailer and I'm only used to
conveyor belts I just don't want to do
with that the collection functions like
Map Reduce and filter that I showed
earlier actually have some remaining
complexity and that they're tightly
interleaved with the type of input and
outputs for example I might expect to
get data synchronously from an array and
provide results as an array you know but
what if i want to get data
asynchronously from a CSP channel and
provide results as an array you know i
have to rewrite all my code again
because the input has changed and then
again for every possible combination of
inputs and outputs so there are these
things invented by rich ricci enclosure
that were subsequently ported to
javascript called transducers a
transducer is a function that can
operate on data collections or streams
independent of the types of the sources
and outputs they specify only the
transformation in terms of a single
element they don't care where it comes
from or where it goes I'll show some
examples but again I can't go into them
in detail as that would be an entire
talk so you can use transducers with
immutable collections from the immutable
library that I showed earlier and much
like their original higher-order
functions I showed earlier apply some
map and filter transformations so in
this example map and filter are
transducers that are composable with the
function composition
that I also showed earlier and the
resulting function can be used with any
type of inputs and any type of outputs
so you can even reference the exact same
code you don't need to copy and paste or
rewrite it in any way a relevant of
where we are using it this is quite a
high level of abstraction so it can be
difficult to understand at first but it
is extremely simple we've got into the
essence of map and filter which is to
apply a step to transform an item
so yeah the interesting part is you can
use those exact functions that were just
used with immutable collection even
direct references to the same code to
transform an asynchronous CSP channel as
well it doesn't matter that it's a
synchronous it doesn't matter with
different data source
so I certainly didn't cover everything
all the possible techniques or concepts
within the subject I hope it has been
demonstrated that if you look at
javascript code objectively there are
simple ways to write things that are not
interleaved and there are complex ways
to write things that are braided
together functional programming features
can achieve code more closely tied to
the actual problem domain with
straightforward unit testing and easier
debugging do you want to build a lego
castle as on the left or a knitted
castle like on the right ask yourself
which way is going to help you impact
the most positive change in the world
Thank you Thank You Rosie thank you I
just want to ask Allah someone has been
asked about I stairs or CSP which one is
better since they are all tagged to
manually to the event stream so i have a
herd of a surgical chair also my
question too so that's a really good
question the question is what's the
difference between eric's jayus like
assume bacon juice in the libraries and
CSP a tough question answer in a short
time but there are known cases where r x
JS doesn't cover things well that you
can do in CSP i'll have to show some
code examples to be more clear but i'm
happy to put those up with my slides
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>