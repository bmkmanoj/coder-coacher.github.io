<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>[JSConfUS 2013] Remy Sharp: Lessons from the experimental edge of technology | Coder Coacher - Coaching Coders</title><meta content="[JSConfUS 2013] Remy Sharp: Lessons from the experimental edge of technology - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>[JSConfUS 2013] Remy Sharp: Lessons from the experimental edge of technology</b></h2><h5 class="post__date">2013-07-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/f_9nDBtSInI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so yeah I'm here to talk about my my let
the lessons I learned on the
experimental edge and it's mostly WebRTC
that I worked on a project recently and
learn a few things with WebRTC that I
want to share originally the talk though
wanted to give was about tinnitus and
web technology by didn't have enough
research to kind of put it all together
properly so if any wants to talk to me
about that I'm still doing it at some
point but talk to me later on in the day
so um this whole thing came together
with basically Google has some people
approached developers and basically said
we want you to build an experiment we're
going to pay you some money to do it we
want you to use cool technology in
mobile browsers we're going to show it
off at Google i/o you interested so I
was like demo where be paid hell yes so
pretty easy decision and at that point
there was no real spec it was just used
whatever technology you want so it could
be WebGL it could be 63 d CSS and I
chose to use WebRTC i'm running the the
game in the background just get me an
idea of what I actually built one idea
that we had was to use to mobile phones
it's kind of lightsabers so you use your
orientation events and kind of the web
AP the Web Audio API to kind of work out
that the two phones are collided in an
invisible light saber but in the end I
like the idea of them actually putting
someone's face inside of the the mobile
phone and having having people kind of
throw things at that face and it was
based off of them I don't know if anyone
remembers the the yahoo face ball game
we're from about two thousand eight
pretty simple game you sit opposite each
other and you throw balls at each
other's face it's called faceball so I
kind of ripped off that idea and the
idea is simply throw balls each other
space first one or three wins it uses
web RTC audio/video peer-to-peer data
orientation events and a whole bunch of
other bits of technology so it's a real
kind of just demo we're basically
have got one big caveat for this talk as
well I'm not going to be talking about
cool words like stun servers which just
makes me think Star Trek turn servers or
turn the security protocols this is a
this is from a web developers point of
view it's what we can do with those what
I did with those broad in building
bricks how I kind of cobbled things
together without really fully
understanding all the technology there
and how I got away with it and like I
was watching my son and put some move
forward yeah put some bricks into this
this this wall he's got and I realized
that my development approach is pretty
similar where I basically just take a
piece of technology I Ram it against the
wall until it fits through I just keep
turning and pushing and eventually it
drops through and that's basically my
programming approach he's got it you
know age 20 months and then occasionally
you take a shape that doesn't quite fit
in a hole and just push it in a fits
anyway it's like you know it works so it
means that I will quite happily take
WebRTC and put it into a project without
needing to understand how it's doing all
its communication just to know that it
actually works and this is that this
high level version of that talk
basically so that doesn't mean that
retrospectively I won't get back look at
the technology and trying to understand
it it's just that it's so new that I
just need a kind of a shortcut and
wanted to come in at a high level
basically so there's there were two
tranches of work in this project that
urn that caused me pain I guess it's a
pretty the best way of putting it the
real-time communication side of things
so WebRTC which this talk we mostly
about and hopefully I'll have time to
get onto the graphic stuff a few few
notes but graphics and performance and
because the target platforms because it
was for google i/o it was a you know
google nexus 4 and 7 those are their
hero products i found out some
interesting things in terms of
performance there and again because it
was a it was demo where only had to at
least work in google chrome for android
beta and this technology is under a you
know
settings facts you actually have to
physically go in and enable this so it's
great for me in terms of a playground
but obviously it's not kind of works in
every single browse at this point in
time but at the moment the game works on
chrome for android beta I do plan to add
support for iOS you know that old the
old browser the older platform and it
should work in firefox but I not test it
so you know if you do have a look at the
links at the end and doesn't work in
firefox is because i haven't tested it
at all but planting so WebRTC this
amazing technology it's a bit too early
to do kind of dangerous singing right
there's three main api's inside of
WebRTC there's get media get user media
which is access to the webcam the
microphone basically the thing that
flash had for you no soy 10 years and I
think well certainly getusermedia was
kind of starting to emerge last year
it's it's the API is kind of stable you
can use it in evergreen browsers today
quite happily and I've got some example
code but the real the the WebRTC side of
things are the two other AP eyes which
are the peer connection API which is
once you've got a stream from your
machine we can send off to another user
in the room so it's literally
peer-to-peer which means there are known
that you don't need a server for that
day to go from one device to another so
my laptop can stream video to your
mobile phone inside of this local
network without going virus server and
then the third API is the data channel
API which is the say it it's basically
sockets over that peer-to-peer and the
interesting part is it's its ability to
do UDP which is an appeal for game
developers and I appreciate it i built a
game and i'm not a games developer i'm
i'm very much just a hack and see what
sticks but i know that we UDP is is
supposed to be good for games so that is
landing in browsers now
so like any good or bewildered developer
I first turned to JavaScript libraries
to actually solve the problem for me to
give me a head start basically so this
isn't extensive and I expect more there
are more JavaScript libraries out there
now and this will grow but these are
some of the ones that came across and I
knew that I wanted to do the project in
java script from top to bottom so i want
to note at the back end and i found you
know peered up jess seem to only do data
this may not be accurate this may change
all this may not be completely accurate
because i was working under a deadline
but pjs seems to just do data but does
it very simply very easily simple a
simple web RTC just did video and didn't
do data and I wanted both because I want
to be 0 send messages saying I've thrown
the ball at your face and that be the
data part and easier are easy RTC I
didn't look out because i found that
WebRTC got I ojs was a nice node library
that came with a client side library and
just kind of dropped in and the really
appealing thing for me is there was a
nice simple demo that was very very
hackable and I got a prototype of this
project up and running in a couple of
hours by hacking their demo which I'll
show you in a moment the thing of it
extremely wary of is this is super new
technology these were the versions of
the modules are working with you know
not even not point one this is a very
that the libraries are evolving really
quickly at this point i'm so pretty sure
the libraries i mean i deployed a month
ago already out of date now there's been
fixes and I Cassie fixes that that I
could plug in myself so that side this
is my it's my prototype and so this was
literally an hour's worth of hacking I
just took a photo of a drawing i did and
stuck my face on so this is a screencast
of my desktop and the video feeds come
from my mobile phone and the orientation
events are being streamed from the phone
directly into the desktop and just doing
a CSS rotate very simple and that was my
proof of concept that i could build this
game easily which was completely
underestimate the amount work but it was
a nice of proof of concept
like I said the this was hacked from the
WebRTC IO demo and the nice thing about
these libraries is it kind of levels out
all the different interoperability
issues there's hope several versions of
the pier data implementation as time
went on if you look at the code that's
things like Pierre de 200 or peer data
or WebKit peer data and and so on and it
does things like try to do interrupt
between Firefox's video and Chrome's
video as well for you so you don't have
to do that yourself so that to replicate
this this simple example there's really
only three steps first one is creative
room for two people to join in because
I'm doing a two player game I want some
kind of discoverability to say this is
in terms of the game i had a pin code so
i say write my pimco's one two three
four you would join that will play
against each other you would listen for
remote connections coming in and you
would send your own video going up the
white and again this is with a library
so this isn't all the way down to the
Royal JavaScript I'll show you some that
in a bit but pretty straightforward here
I'm creating a web socket to a secure
web socket and giving it the pin number
so the room number basically so it has a
connection while sat this will emit
event saying I'm connected and whilst
that's happening I will then add an
event listener to listen for when a new
stream comes in so I get to two objects
coming in more most importantly the
actual video stream is that stream
object and the the WebRTC i/o library
has a helper called attached stream
which you give it a stream you give it
an idea of an element on the page and I
just put the two together but it's as
simple as doing video duck sauce equals
URL dot create yer ole object I've got a
slide in the moment that shows you how
to actually do that by hand but that
will just put a video feed together and
the third part is actually capture the
video from your your laptop or your
phone or whatever device and send up the
stream as well and this is all tucked
away for me so I just do RTC got great
stream video yes audio yes or no and in
the case of my game because only one of
the opponent
face on the game and not my own I just
throw away the actual stream I don't do
anything with it and behind the scenes
the library is basically set that up the
peer to peer connection and it's
streaming it to the other user that's it
so the lessons for me here where
libraries are super good when you're
fumbling your way through the actual
code right there's not a lot there and
I've got that prototype working I've got
peer-to-peer data working already but
the lesson here is libraries also hide
away a lot the technology and there were
bugs in my code that I hadn't realized
even existed in the first place and in
my experience that's the right way to
approach like if you don't understand
the technology take a library start up
with that the older thing and then
understand what's going on it's kind of
a long blog post about using going
beyond jquery it's exactly that i would
start with jquery and work my way back
to how it all works but the really the
big thing for me was peer-to-peer data I
seem to have this impression in my head
the peer-to-peer must be faster all
right and if if we tried it here if I
had a the game running here one of you
wanted to connect to the game it would
work out the rock we're on the same
network so be really quick but this game
I wanted to work between you know the UK
in the US or one of you play people over
the open web and that's not particularly
faster that's still going a long way
over the wire so because my game already
has this tiny little face the other end
I don't want to be I'm not doing a skype
clone right I don't he sent an HD video
down the wire don'ts in this massive
video down the wire so initially I
didn't think it was any way of actually
controlling how much data goes over the
wire but you do have a way of saying
here are some options beyond just saying
true I want video you can say i want the
max width of the video to be you know
160 in my case so that the actual it's
kind of like a thumbnail video it goes
down the wire less data is if you need
if you don't need as much data that's
good right it's less data on your mobile
device it's less bytes over the wire for
your mobile device to process and I
looked at on my android looks the amount
of data that chrome had gone through and
it was gigs worth of data when I was
testing so imagine gigs worth of dates
are on a
normal cell network it's going to get
expensive so this is kind of an old good
one but you know only serve what you
need and in this I found that because i
was using a library this didn't work i
was giving it these arguments saying
only serve this 160 video but inside the
library i realized that it was just
looking for the presence of a value on
video and if i had an object there to
said yeah it's true so send the whole
thing so it's sending by default 640 by
480 which isn't really HD but it's a lot
bigger than I needed but I can do you
know pull requests and fix it but only
found that out after i finished with the
the library you probably spot already
that it's not entirely client side as
well so you do need you don't absolutely
need a server you can do it entirely in
the client side but you need to be able
to know what the IP address of the the
person you're trying to connect to and
typically you want to be a give someone
a pin number or a color to connect
through right so the game is enter pin
and you have that discoverability so you
still need you still need the server and
literally this is all the code i have my
server side i have not for the entire
game but for the WebRTC part I've got an
express server once that's created I
just wrap it up with the web RTC library
and the other library is very similar
they just kind of wrap around your your
web server and they do all the work for
you I in my live production code have no
more than that to do with the WebRTC
stuff it's just that one line so just
handles it for me it create it handles
creation of rooms handles trying to work
out the discoverability part and it's
it's all magic from my point of view and
if I wanted to add fullback support for
iOS for instance that didn't have the
peer connection API I would use this
socket to send messages up to it so when
someone took a photo there their face it
would send up their web socket here I
would send it down to the connected
client and I could add fullback support
using this web socket this was the
interesting part to me the RTC data
channel there's no permissions for this
you just create a PSP connection and at
the moment there's there's not
shins object that he pass in the sets
either reliable to true or reliable to
false reliable true means you have a tcp
connection which is it according to the
spec is default so if you don't pass in
that Valley you have a tcp connection if
you set reliable to force then it
creates a UDP connection ok and I did
read a comment inside of some code that
says that chrome at the moment doesn't
support TCP reliable connections but
it's quite likely that if someone's
watching this in the future that that's
not sure anymore that's fixed it's quite
likely that the comments already out of
date because it's moving so quickly if
if you guys and girls are already using
WebSockets hopefully you're doing this
already you actually test that the
WebSockets open before you start trying
to send data over that WebSocket you
have to do the same thing with the data
the data channel in this case I'm
looping over my date channels and saying
it is the ready state open and if it is
then I will use it if it's not the game
isn't ready in the first place right the
weird thing is the ready state such as
string whereas I'm kind of used to ready
so it's being an integer bits it's just
part the spec and hopefully you're doing
this with WebSockets anyway originally I
wanted to stream the orientation events
directly over the pier data API which
would have I mean if you've ever looked
at the orientation events are just it
just bombard the device with data just
pours out and I was like oh that's a lot
of data I'll throttle this and only
sender every 250 milliseconds which is
in the end there's no point right it
there's three states in my game the user
is standing up there either left or the
right or left or right so why not
actually put that in need the client
side so instead of sending that data and
having the pier work out if they've
tilted left to right just I put then all
the logic on the client side and try and
send as little amount of data over the
wire as possible and in this case I say
if the user's phone has tilted over to
the right then a state has changed send
that one message for the pier ok so
you're still sending bytes over the over
the Internet I had this misconception
that pier data would be so much faster
and so much eat a such less data but
it's it's not it's just closer there's
no there's that if we're in the same
network than great
but it's you should be over the wire so
I just want to explain the the mechanics
of this game before I kind of show you
the biggest ball like I hit basically
before the game can start you need I
needed to open a web socket for the game
discovery connect to the video and audio
stream once that was done I test if the
the piers the peer connection was
actually open and I could talk to it it
was an already state and if that's the
case then the game is ready to be played
and you can throw balls each others face
so my game was a multi-page website
you'll be you get this welcome page it's
had two buttons that's kind of join the
game or start game if you start a game
then it would automatically create the
room before you give you a pin number
and your go and tell your friend will
the pin number is and your friend will
say okay I'm gonna go join a game and
they'll enter the pin and when they hit
refresh or when I hit submit it will go
to this waiting state and the start game
would be in a waiting state would have a
hanging xhr on the server side and when
the server side state machine went from
waiting to ready it would close the xhr
request which record both pages to
reload into the play the game and once
we're playing the game I then asked for
the streams from both users at the same
time and try and connect them but that
didn't work what happened is I get to
the game I see the video and it would
instantly vanish
so yet to quite a while to work out what
was actually going on I haven't analogy
and I've explains to my wife who doesn't
do tech at all and she kind of got it so
I'm hoping that you guys and girls can
get this as well and if I don't just ask
me afterwards so this is my analogy I
want to make a call to you okay I've got
my paper cup phone I got both ends i got
my paper cup the string and they paid a
cup at the bottom and you have the same
thing i put my paper cup up set up to my
ear I hand you the other end and you do
the same thing you put your paper cup to
up to your ear and you hand me the other
end I'm like okay right I'll take that
and i'll put up to my ear and take out
take off the end that I was holding
before and you do the same thing you
take the phone off me and put up to your
ear putting down the other end and we're
both standing there with dangling phone
so we're not actually talking each other
we've just got this kind of longer thing
no one's talking to each other the point
is it was happening at the same time and
the connections were kind of missing
each other now I don't know because I
haven't dug into this deeply enough if
this is a bug in the library that i was
using whether it is a bug in the
workflow or what's more likely that it
was a bug that I was hitting because of
the way I was developing and because of
the deadline I was against I needed it
needed to be live for Google i/o so I
need a solution to get around this
problem of the two users trying to
connect the exact same time so I create
a single page app and what that did is
it as soon as you go to start the game
it would immediately asked you for your
your audio and video stream so you say
yeah okay and you've got the pin number
then you say to your friend here's my
pin number and because of that time
delay between that those two points the
stream is already open and it's the
streams already being fed into that room
let's imaginary room in the cloud or
wherever it is they enter their pin
number because it happens not the same
time at there's some delay then that
user can connect to you properly and
there's no both of you trying to connect
at the same time it worked that was the
important fit
but there is some there is a point to a
single page app if you have created a
web RTC stream or things like going
fullscreen and as soon as the page
refreshes that gets broken so once if
you if your app is in full screen mode
when you hit refresh it drops out a full
screen so these things that use these
kind of persistent states in the browser
you might need to actually make a single
page app that can loads in each one of
these pages now I only my app is still
on my site is still a welcome page and
then the rest of it is a single page app
which meant that I couldn't just add
full screen I add a full screen right
the end I would have liked to have on
the welcome screen go to full screen go
to full screen and then start playing
the game but because i have a refresh
between welcome and join i can do that
and also this can get a bit annoying in
your game like if you if you do refresh
the game so once once the game's over
you hit reload and you start again if
you add ssl the desktop browsers won't
keep asking for permission to access the
the webcam on the mobile device this was
true when i started the project and it
was forced by the time I end of the
project and it's not like it took a long
time it was probably months worth of
death but because i was working in beta
this stuff changed underneath my feet
and what happens on mobile is because
there's no visual cue that there's a
video stream open on the phone they
can't they always ask you for permission
ok on a desktop you have a light
generally that tells you your webcams on
on a mobile phone you don't have that
and even better than that i found that
when i had an open stream i could turn
my phone off or put it in standby mode
put it down and walk away and forget
that that's that camera is still on and
feeding a stream to the remote peer so
your phone can be off and the camera
will still be feeding data over the wire
makes you phone really really hot so
i've got a bit time to talk about the
graphics side of things and i'm not i'm
a developer in terms of I I know like
black white and gray that's as far as my
graphic skills go and i'm not a 3d
program
and it kind of is a bit of a mindfuck so
I'm gonna go into that detail basically
i knew that i had a 3d scene i had this
little character in the background had
this idea of like old school 80's Tron
style you know floor and you throw balls
into the 3d space and hit me in the face
and my original plan was to do this all
with a Dom I was like well I can just do
you know scale on that make it smaller
and you'll be fine and I sat down with
them I are said lead Lyle who's speaking
I think on Friday towards the end if he
just kind of give me some advice on the
3d stuff and the first thing he said is
no that's going to be probably not
a direct quote but I need to use 3gs to
do this work and I'm not familiar enough
with 3gs so I sat down with him he gave
me a couple of hours of his time and
create this beautiful scene where I had
this kind of 3d floor and the caps was
in the right place and all the
perspective felt right as well like my
character wasn't too big for the the
angle of the camera and so on it looked
great so I went away with that
information you know my awesome 3j
s-seen put it on my mobile phone and the
frames per second went down about seven
frames per second everything was like
the slow-motion ball throwing through
the air is horribly horribly slow and in
fact at this point I had two canvases on
the screen and one video and everything
was going to complete crap but even with
one canvas and 30 GS it just wasn't
quick enough during that initial initial
test and this is on a nexus 4 as well so
it's kind of that you know hero product
so I started looking at the css3
renderers and but because I'm on an
experimental browser that says beta on
it it's not you know it's not gonna be a
perfect perfectly working browser I
found that when my floor was in front of
me completely you know flat it was fine
but as soon as i filtered it forward
into a 3d space it was just vanish and
kind of a problem but then it turned out
that there was just a bug that had been
fixed over the weekend at the coming
weekend i found the issue and it was
just fixed but i decided not to use a 3d
render because i had the performance but
the floor was missing so I found that
actually the problem was I was rendering
too much of a canvas constantly honest
I was doing I was doing my loop to
redraw the entire thing which includes
like a big background my character the
ball and so on so I basically create 22
views one was for the static background
that got rendered once or every now and
then but I needed to update the
background and in one separate canvas
that it as little as possible which is
basic the ball that bounces down and
throws towards the face and I found that
putting two videos and a canvas on a
mobile phone is probably a little too
much with all the streams going on and
when I had two videos the frame rates
weren't right down I've got rid of one
of the videos because I have the local
video in there for some reason no just
no good reason just it happened to be in
the Dom took that out and my frameworks
rates went back up to I think actually
I've about 50 frames per second on Nexus
4 which is which is pretty good the
nexus 7 on the other hand is a little
bit not as not as strong on the
performance side and but I had a lot of
this praying like hacking around with 30
Jess and and all the real-time stuff
going on at the same time and my
rendering I would basically get this i
just changed something and yeah at work
and once I good at that I just move on
that's quite happy for me I've got
deadlines to work too so I kept going
some useful really useful tips i got
have stabbed actually was to create
meshes to understand what's going to
collide with something else sofa
collision detection I had this debug
view so I could see where the ball was
going and if the carrots are tilted to
the left occasionally that face thing
we're just kind of launched off to the
side and I can see I had a bug in my
code so it's nice to have a debug view
for that that 3d part of the game and
probably the hardest part the entire
game was taking my mug my face and
making it appear at the right height and
width in the 3d space Stephen Whitson's
who's talking as well try to give me
some help in projecting that into a 3d
space there was a lot of ugly code that
eventually did it and most of it was
Serb and some some kind of lead from
Stephen as well but 3d is not my space I
was good at the the real-time stuff this
was really difficult but I managed to
submit it and it did go live it did end
up
being shown at Google i/o as one of the
experiments but the biggest lessons I
got from this entire project they
weren't code base they actually turn our
will be planning based the the time to
actually work on such a new technology
at this point in time there's not that
much information out there there's some
good videos but they're very deep dive
in videos I expect that a change with
time the google engineers are actually
really good for all this new technology
they want developers using this stuff
and they won't answer questions and give
you a hand I was really surprised at how
much help I got it wasn't you know they
won't write my code for me but they're
giving me feedback and suggestions Paul
Kinlan helped me with that the the
single page app solution he was looking
at it and he managed to work out where
it was happening and and and basically
said I need to move to a single page app
which was a pain but you know I did it
and the biggest thing was maybe the
horse came before the cart like I think
I focused a lot on the technology and
didn't really think too much about gains
mechanic at the game mechanics I'm not
hundred percent sure if it's a good game
like I could have quite easily tested
the game without any of the technology
but I focused on that tech and now I
have a game is playable and it's cool as
a demo but whether it's like one of
those addictive games I'm not sure I
really would love to say WebRTC is
really ready for prime time I don't
think it's quite there yet for
developers and the bottom it does say
check the expiry date like that's going
to change quickly and I'm pretty certain
in 12 months time we will be a place
where we can quite happily use WebRTC in
big projects and we're going to see it
in a lot more I'm confident we'll see it
a lot more places the resources will
there be more tutorial with spring casts
more talks on web RTC and Mobile's
looking pretty pretty good microsoft
support i have no clue what's going on
there so i don't know what
interoperability to going to look like
but it works so you know yay us
and I wanted a hit on a high note so
that's kind of my way of saying WebRTC
is actually pretty cool to play with but
it's maybe kind of a playground at the
moment there is code and all the source
code is online so you can kind of help
yourself don't judge me too much when
you're kind of like what what really
what where the comments that kind of
thing there are tests that coming and
but it's it's all online you can have a
play I don't think I've got time for
questions but you can kind of ask me
anything later on I'm sure I'll have a
beer in my hand at some point Ilana so
with that I think my times up and thanks
listening
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>