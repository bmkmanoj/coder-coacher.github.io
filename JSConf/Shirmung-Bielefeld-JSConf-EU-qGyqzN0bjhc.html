<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Shirmung Bielefeld: == ? === ??? ...#@^% | JSConf EU | Coder Coacher - Coaching Coders</title><meta content="Shirmung Bielefeld: == ? === ??? ...#@^% | JSConf EU - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Shirmung Bielefeld: == ? === ??? ...#@^% | JSConf EU</b></h2><h5 class="post__date">2014-10-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qGyqzN0bjhc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you um hi I'm Sherman I'm a
software developer at Bart box in New
York City where we focus on creating
products that help keep dogs happy and
healthy um speaking of dogs this is a
picture of my dog small talk and me this
is a picture of a picture of meeting
noodles and this is a picture of small
talk eating noodles now that you know
all about me let's talk about type
coercion in JavaScript I've been
programming predominantly with
JavaScript over the past couple of years
and I've gotten pretty familiar with
many of its courts so one of those
quirks being type type coercion today I
hope to provide you all with a better
understanding of how exactly JavaScript
converts between types and the various
situations in which it performs type
coercion but let's back up let's talk
about type conversion in general so
wikipedia says that type conversion
otherwise known as type casting or type
coercion is implicitly or explicitly
changing an entity of one datatype into
another so what does that mean more
simply that's taking a type for example
an INT and converting it to another type
a string so how does javascript handle
type conversion javascript is
dynamically typed as many of you know
which means that variable types are
determined during script execution at
runtime so here type conversion can
happen in two ways they can be
explicitly specified by the developer in
the code like for example directly
calling parse in which converts a string
in this example to an integer or two
string or they can be implicitly
performed by javascript during script
execute
this kind of type conversion is
typically referred to as type coercion
and type coercion is what we're focusing
on today so why do I have to learn this
honestly it's very much built into the
language and it kind of comes with the
territory of JavaScript being
dynamically a dynamically typed language
for example type coercion is happening
even with something as simple as a basic
if statement so in this example here we
know that it's successful value doubt
length will return an integer so that
would be the length of the value however
the if statement here is expecting a
boolean condition an integer is not a
boolean so javascript implicitly
converts the integer into a boolean in
order to evaluate this expression type
conversion can also offer more
flexibility and it can be convenient at
times like when you're dealing with user
input and finally get to know your
language better it's always important to
understand what's happening underneath
the hood so let's build some
foundational knowledge let's talk about
converting types there are two
categories of types and JavaScript so
you have the simple types which are
numbers strings boolean's the values
true and false null and undefined
everything else in JavaScript is an
object so these are arrays and functions
regular expressions and of course
objects are objects the next in the next
three slides I want to try to define how
JavaScript typically implicitly converts
between its different types and we'll be
using this knowledge for the remainder
of the talk so how does JavaScript
convert from simple types to numbers for
Strings there's an attempt to parse the
string to a number otherwise it returns
an en or not a number for boolean true
is converted to one false is converted
to 0 positive 0 no null is also converts
positive 0 and undefined is converted to
down a number so what about converting
simple types to boolean x' numbers are
converted to true unless the value is
positive 0
negative zero or not a number these are
obviously converted to false and strings
are also converted to true unless the
value is of course the empty string
which is converted to false null and
undefined or both convertibles and
finally what about objects how are
objects converted when converting
objects to numbers or strings javascript
will try to convert the object to a
primitive value by implicitly calling
value of on the object or if value of
isn't defines or didn't return a
primitive type when called it will try
to call to string on the object inside
converting objects to boolean x' is a
bit simpler they're converted to true so
let's take these guidelines and apply
them to a few situations and let's start
with conditional statements first but
let's quickly just make sure we all
we're all on the same page about truth
and false policy values in JavaScript so
some examples of values that evaluate to
true in JavaScript are the integer 1 2 3
or 123 the string small talk the boolean
true and objects some examples of values
that evaluates to false in JavaScript
are the introduced 0 not a number the
empty string the boolean false no and of
course undefined the conditional
statements if for while and do-while all
expect to evaluate boolean conditions if
the expression does not return a boolean
its operands or it's implicitly
converted to villians using the
guidelines that we just defined earlier
so for example in in this example VAR
value equals document dot get element by
ID small talk get element by ID is a
function that looks for an element with
a particular ID in the Dom so it will
either return an object if it finds the
element or it will return null if an
object is returned the if statement will
implicitly convert it to true and if
null is returned if same and will
implicitly convert it to false
so switch statements are a bit special
here swimmer to an if statement they
expect to evaluate boolean conditions
but unlike if statement when evaluating
the switch cases case switch statements
case statements no type coercion is
performed so in the previous if
statement value is curse coerced to true
or false depending on whether or not get
element by ID returned an object or not
here value will not be coerced to true
or false it will be treated as its
original type and because of that it
will never never satisfy the case
statement true since neither object nor
no are equal to the boolean true and it
will instead enter the default case
logical operators which are of course
and an or like the conditional operators
logical operators implicitly convert
operands to boolean x' depending on the
context but unlike the conditional
operators the operon itself is returned
and not the boolean value so
incidentally this can be great for
sending default values in this example
var value is equal to zero or Apple
value is sorry the or operator is
looking from left to right for the first
true operand to return the zero is
converted to false the string Apple is
converted to true and some value is set
to the string Apple mathematical
operators which are of course the
addition and subtraction signs the
multiplication division signs and of
course the modulo operator here operands
are implicitly converted to numbers
except for dates which for some reason
are converted to strings and in this
example var value is equal to true plus
no plus five going from left to right
true is converted to one null is
converted to zero and one plus zero plus
five is of course six value is set to
six
the interesting operators who took a
take a look at here is the addition sign
the addition sign is overloaded in
JavaScript so that means that not only
can I do addition between two numbers it
can also do string concatenation so in
the case of string concatenation when
one operand is a string and the other
operant isn't the other operand is
converted to a string in this first
example a VAR value is equal to the
string small talk is plus 2 the value is
set to small talk is 2 because the
integer 2 is converted to a string 2 and
then concatenated but keep in mind that
this is happening from left to right so
in the second example 1 plus 2 are added
together because javascript is unaware
of the string that follows and then the
1 plus 2 which is equal to 3 is
concatenate to the string small talk and
the value that's returned is 3 small
talk relational operator time and those
are greater than less than greater than
or equal to and less than or equal to
similar to the mathematical operators
operands are converted to numbers but
here even dates are converted to numbers
an exception is that shrinks are
compared via lexicographical string
comparison which just means that
characters are compared sequentially
similar to how you might order words in
a dictionary keep in mind here that any
comparison involving not a number will
evaluate to false in this example VAR
value is equal to false
less than the string 1 2 3 false is
converted to 0 1 the string 1 2 3 is
converted to 123 and Vata value is set
to true because of course 0 is less than
123 now for the more meaty stuff you
call the operators but let's quickly go
over what equality means in JavaScript
values are considered equal if they are
identical boolean values so true is
equal to true but it's not equal to
false if they're identical strings the
string ABC is equal to the string ABC
but not to say ABCD they're also
considered equal if they're numerically
equivalent numbers one is equal to one
and I also wanted to note that positive
zero is equal to negative zero in this
case and values are considered equal if
they are obviously the same object and
again a number is special here it's not
equal to anything including itself and
as you'll probably know there are two
sets of equality operators in JavaScript
the double equals operator and the
triple equals operator the double equals
operator compares for equality
after doing any necessary type coercion
if it determines that the types are
different the double equals operator
follows what's known as the abstract
equality comparison algorithm which is a
series of 22 steps that it uses to
determine equality so when the
expression meets one of the step
conditions JavaScript will return true
or false accordingly otherwise when it
reads otherwise if it reaches the end of
this series it will return false we'll
get into a bit more detail about how
type coercion czar performed here but
first let's walk through an example so
fire value is equal to no greater than
or equal to zero using the knowledge
that we obtained about relational
operators this seems pretty
straightforward the relational operator
implicitly converts two numbers so null
will be converted to zero and of course
0 is greater than or equal to zero so
values that to true well let's look at
another example VAR value is equal to no
double equals 0 this returns false what
the hell how does that make sense
everything we've learned so far
implies that Noah would be converted to
0 here
but in short no let's treated in a
special way by the double equals
operator it only choruses to undefined
this is only one of the many strange
cases that involve the double equals
operator but this is all due to and can
be explained by following the abstract
equality comparison algorithm so the
abstract equality comparison algorithm
is defined really quite clearly in the
ACMA script language specifications I
don't want to overwhelm or bore you with
all 22 steps but I did want to kind of
walk through what happens after dava
scripts has determined that the two
types are different and attempts to type
course which are incidentally steps 14
through 22 in the algorithm null equals
undefined its null is equal to undefined
sorry and if one operand and the next
step is if one operand is a string and
the other operand is a number the string
will be implicitly converted to a number
if one of the operands is a boolean the
boolean will be in implicitly converted
to a number and if one of the operands
is a string or a number and the other
operand is an object well the object
will implicitly convert it to a
primitive so the triple equals operator
behaves similarly to the double equals
operator except no type coercion it's
done it uses the strict equality
comparison algorithm which is nearly
identical to the first thirteen steps of
the abstract equality comparison
algorithm but obviously leaves out all
the bits related to type coercion types
must be the same initially in order to
be considered equal otherwise the triple
equals operator will return false since
there are no unexpected type curtains
being done when using the triple equals
operator we kind of more faith in the
results and it can be much safer so one
needs to lie came across while I was
preparing for my talk was this
JavaScript equality table it graphically
displays the results of comparisons
using the double equals and triple
equals operator so I
means the expression evaluate to true
white means expression evaluated to
false so inclusion I want to leave you
all with a few tips try to savor the
triple equals operator over the doubles
equal operator as I mentioned earlier it
can be dangerous to use the double
equals operator if you're not sure what
you're doing try to perform explicit
type conversion when you're able to do
so so that was for my earlier slide
calling parse in or to string and use
the JavaScript console and the ACMA
script language specifications as
resources this talk was meant to provide
foundational knowledge of type coercion
and JavaScript but it's of course
missing details the ACMA script language
specification goes into this into this
in depth and is surprisingly actually
not too terrible to read thanks guys um
come chat with me later if you'd like to
discuss any of this or tell me about
your dogs</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>