<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Marco Rogers: Finding Patterns Across Front-end Frameworks [JSConf2014] | Coder Coacher - Coaching Coders</title><meta content="Marco Rogers: Finding Patterns Across Front-end Frameworks [JSConf2014] - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Marco Rogers: Finding Patterns Across Front-end Frameworks [JSConf2014]</b></h2><h5 class="post__date">2014-06-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Bp3Jy177NvU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Marco Rogers I work for
Yammer and this talk is about as he said
finding patterns in front-end JavaScript
development so we spend a lot of time
talking about JavaScript libraries and
frameworks you know which one to choose
when to use them when to write your own
which is hopefully never but
unfortunately I'm not actually going to
give you answers to any of those
questions today what I actually can do
is give you a peek into the way I think
about front-end development today
because there was a point where I
realized that there are lots of shared
patterns and if we if we look at those
shared patterns it'll give us better
insights into the landscape of how we
build things today so see we can move
forward a while back I wrote this on
Twitter tweet sometimes and the question
that I got back most I had some people
agree but the question that got back
most was what are the patterns that you
see like people wanted to kind of
discuss this which I thought was great
so my goal with this talk is to provide
sort of a mental model for pulling out
these patterns being able to identify
the core concepts and being able to to
kind of discuss them across different
libraries and frameworks this is gonna
be an incomplete list because the stuff
is still evolving and and because I'm I
don't know everything unfortunately but
I think the best outcome for me is when
I get done with this that you're like
super annoyed that I didn't get to go
further into it and that you want to
continue the conversation because I
think that that we need to so let's
let's kind of talk about the three main
buckets that I put these into the first
is common patterns right so this is
these are kind of the core patterns that
people or at least in my mind the core
patterns that people are referring to
when they say NBC or MV star is kind of
thing right so we're gonna take a look
at one of those and it's gonna be kind
of a baseline for how what I mean by via
these are these are shared patterns
across frameworks I'm gonna dig into the
advanced some of the more advanced
abstractions on top of the MVC ish thing
this what I think will be interesting
for illustrating what I think a lot of
us are doing today when we're trying to
build complex web apps whether we're
using a cohesive framework like like
ember angular or whether we're using our
kind of custom-built thing that is about
five years old and which nobody really
wants to use anymore and yet it's still
kind of hanging around I think you see
the same patterns across all these
things right and then finally we'll look
at some emerging patterns these are ones
that are less common but I think are
coming up more and more frequently as we
try to build apps with with more
sophisticated capabilities so let's kind
of jump right in so two common patterns
and they they look like this right so
models views I want to be pretty obvious
I hopefully should be pretty obvious to
the folks in this room controllers the
sea is always kind of nebulous but I
think routers and controllers are kind
of kind of come with that and routing is
probably the more important feature for
building single page applications right
being able to route to a particular view
and then like restful api access because
obviously you need to get some some data
and shove it shove it into your UI I
think these should be pretty familiar to
people we're gonna jump into one of them
so I can kind of illustrate what I'm
talking about so let's talk about models
right this will be a rehash for folks
and it comes with these capabilities
generally at least this is my contention
this is how I kind of outlined this
pattern in my head you get some objects
that represent your data model right you
can expect the properties on that object
you can read and write them usually you
can persist data to the server because
because that's handy sometimes and then
the most important part that I think
makes this into a pattern and not just
kind of the thing that we do with
JavaScript all the time is that
this model layer is going to fire change
events it's going to tell you when these
models have changed allow you to
register a callback so that you can
respond right and that allows us to take
this model layer decouple it from the
other parts of our app whether it be our
our views templates what-have-you but
still be able to make it do do
interesting things right so does it make
sense to people it's not making sense
rehash Thanks that's probably good so
let's take a look at how backbone does
this backbone should be familiar to most
people this looks pretty straightforward
you create a new backbone model right
give it some data ID this latest reply
ad which is kind of a date string you
can inspect these properties by pulling
out the ID and comparing it to some
other things in anger our backbone wants
you to use a getter for this and then
you can register a callback right and in
backbone it looks like this it uses this
nice kind of event listener pattern that
was popularized by by jQuery and nodejs
depending on who you talk to and so when
latest reply at gets updated this
callbacks gonna fire and we can we can
do things and then finally we can we can
update this model by calling this setter
and when we do that then our callback
send a fire just this isn't a surprise
to anybody right this is kind of what we
do is it's kind of the core of backbone
models but let's kind of compare it to
what I work with everyday which is you
know the the internal framework that
Yammer uses which we call y MJS or
sometimes affectionately yam juice and
it looks like this I mean let me go back
here's backbone our framework looks like
this that slide did change they're very
similar but it did change and you can
kind of see that it's actually doing
exactly the exact same thing we're
creating an instance of this destroyed
model given it some data we can read the
data directly from the property without
using a getter because that's how our
framework works but it amounts to the
same thing then you got this
funky-looking
hook thing where we're asking when this
thread has an update register a listener
right it's not as nice as the the event
listener pattern that we we all know and
love but it's essentially doing the same
it's allowing us to listen for changes
and then we want to want to change this
data we have to go through this setter
method called update and instead of
changing one property we changed
multiple at a time by passing a hash and
we need to use this setter so that we
can get our RF in hooks five time I'll
tell you a story about that what happens
when you don't use it so this when I
recognize that this looks pretty similar
to the other frameworks that I was I was
seeing this is when this idea of pattern
started to develop in my head because
anything that you can do with this this
core concept and backbone you should be
able to do with our framework and you
should be able to do with other
frameworks that say they have a model
layer for you right but it doesn't
always look this similar and so I wanted
to pull up a different example that
looked looked a little bit different so
his angular write angular looks
different and depending on how you talk
to you it's like interesting different
or like annoying different but it's
different but the outcome is actually
not that different right it's doing the
exact same things instead of having this
object that you create you just use
plain JavaScript objects and you shove
them on to this special scope object
that angular gives you but then you can
read properties off of that thing and
you can set properties on that thing you
can see at the bottom there and you set
them directly just by updating
properties like you do on JavaScript
objects but when it comes to that that
last that last thing that I said was
really important I'm listening for
changes angular wants you to do that a
little bit different when you shove it
when you shove your model objects onto
this scope you can take advantage of
this watch function that they give you
which says anything that's attached to
this scope where we're constantly
checking for changes and you can
register for those updates by by giving
us this expression right so I'm
registering this watch expression for
latest reply ad and it's gonna do the
exact same thing as these other slides
right I when I first looked angular I
thought it was kind of crazy town and
then as I started to develop this
pattern or what a model layer was and I
went back to angular and I said how does
angular let me do this stuff that I know
that I should be able to do
then it started to make sense because
I've started to know what I was looking
for in terms of you know finding these
capabilities and so this example started
to look a lot like the other examples
which is good for me because I need
things that look similar I'm not that
smart
so so now I can kind of do the things
that I know how to do with model layers
in my framework and in backbone and now
an angular to it to a certain degree and
and each of these has has you know
further capabilities that they want to
use to distinguish themselves and some
of them are really useful but at the
core these are the these are the
capabilities that you should be looking
for because if we go back to what I
outlined is my understanding of a model
pattern it's just these four things
these are the things that I'm trying to
do when you tell me that you have models
right and I can do that in any framework
did I pick up today and if I can't then
that that's gonna be an indication that
maybe it's not for me right if we know
these core concepts you can start to
have a better basis for evaluating these
frameworks this is Megan sense so far
cool so let's kind of jump into advanced
patterns obviously won't be able to hit
everything today but I've got kind of an
example for each one of these as apps
get bigger and more complex these core
MVC patterns they start to fall short
right like they're not cutting it as
your app gets bigger as you have to
maintain more complexity you want better
abstractions on top of these core
patterns that allow you to to manage
that complexity and this is where you
get into two advanced patterns right
this is what advanced patterns look like
to me this is I think kind of at the
core of what I look for when somebody
says that they have a new framework that
I should check out right nested views
this is the idea that you're gonna take
what is what the outcome is a big
complex UI and you want to break it down
into something that's more modular and
and still compose together such that you
can kind of treat it as a single entity
and we'll look at that example so you
see what I mean
complex rendering comes into into play
right it's very easy to take your one
model and smash it into this one
template and like if that works out it's
great but sometimes you have to do more
things sometimes you have to maintain
the state of whether this item was
collapsed or closed
and sometimes you have to like format
dates and sometimes just to do this
these other things that eyes aren't just
like kind of a straight mashing of
templates and a framework should
hopefully help you do that stuff model
relationships this is the idea that when
you're when your clients that app
becomes more complex you you want to
take this model layer they're familiar
with and start to have better tools for
representing your entire data domain
right so maybe you have some messages
and you need to know which users sent
them you want to be able to take that
message and say get user and it'll give
you back this this particular user kind
of automatically right so you start
creating these like has many
relationships and these belong to
relationships and essentially kind of
recreating your schema on the client
because it sounds like a like a really
awesome idea and then later you might
regret it but in the meantime you're
like you're like really jamming and and
this is the kind of thing that I
consider a really advanced pattern that
when it's working well it works really
well
local data caching you know this is the
idea that you you've routed to a new
view and maybe it's one that the user
has seen before you've got all the data
for that view nothing has changed but do
you still have to make another Ajax call
just in case right do you know if
something's changed or not
are you caching all that data locally so
that you could just reuse it right and
allows you to do things like like fast
UI switching so local caching and and
two-way binding I think is is on
everybody's minds today and a lot of the
big frameworks are pushing it because it
allows you to make complicated updates
to your UI without writing a bunch of
glue code which is sometimes nice so
let's kind of dig into one of these I
like nested views it's it's the it's the
advanced pattern that I think needs to
go on top of every framework and if I
don't have it I'm really annoyed but
first a quick refresher on what I mean
by the kind of core view pattern it
doesn't do much render some markup to
your Dom right response to user input
from your Dom and subsequently when
things change update your Dom with with
some things right pretty straightforward
I hope this is non-controversial what we
want to do is put a pattern on top
that says we're gonna allow you to take
this core view and compose them together
to create more complex structures right
and the nested view pattern kind of goes
like this
so you can take these views you can
organize them to a parent-child tree
right when you render at the root of
that tree it's gonna recursively render
down all of the children without you
having to do much work rather than you
having to go and touch every part of
this UI and create this object for your
views and passing models and whatever
all that done wants Pyrrha cursing down
the root of this tree and and more
importantly but harder to define this
tree has a shared lifecycle and what I
mean by that is this rendering process
you can reason about you can say when I
call render on a roo this tree either
it's synchronous and when render comes
back all of my children are rendered or
it's asynchronous and it's gonna say
okay I'm gonna return immediately
I'm recursing to this rendering and when
it's done I'm gonna fire an event and I
say you've rendered some things and then
you know what the state of this tree is
right and subsequently when you're done
with this tree you can take that route
and you can call destroy or remove or
dispose or whatever it is you decided to
name it that week and it's going to
recurse and cleanup for you
right it's gonna go through those
children take those objects destroy them
unhook listeners there's all these
implementation details but you want that
thing to be nicely able to be reasoned
about otherwise you're gonna have like
huge memory leaks because you know that
that happens to some people that that I
know who are not me so so you know this
this idea of nested views I think is
really important and I want to jump into
it a little bit so I want to talk about
um juice first
this is actually an illustration of a
Yammer threaded conversation right you
get a you get a list of these in your in
your group feed and so we want to render
this thing but we don't want to do it
all at once in one kind of huge module
we want to break these pieces down into
things that can be kind of reasoned
about independently so we've got the the
the first kind of thread starter message
and it's called out its more prominent
might have little attachments on it and
whatever else and then at the bottom
you've kind of got the list of replies
which are less prominent there's a list
of them you can tell who we replied to
who and
and they've got a different look and
feel and so we end up with three primary
views - in order to render this we've
got our kind of high-level thread list
item we've got a thread starter that
encapsulate the starter message and then
we've got multiple message message list
items for our replies and we want to be
able to handle this in a way that's nice
so this is what it looks like in yam
juice it's not that nice but it's been
working out for us right so you create
this thread list item ask me later while
that's called a backbone component we're
definitely in the middle of replacing
some of these patterns with standard
backbone implementations so you create
this dread list item but inside this
thread list item you're gonna do a
couple of things you're gonna add your
thread starter as a child view so you
create your new thread starter and you
prepend it to this this thread list item
and then you're gonna loop through all
of your message replies and you're going
to turn those into message list items
and you're going to pin those also so
these views have all been accentuated
and they're now all composed together
underneath this thread list item and
then all I have to do is create this
thread list item and call render and
when I'm done all this stuff's done
looks like that and it's great right and
I didn't have to go through a lot of
munching or whatever I just have to set
these up once create this parent-child
relationship and this just happens for
me right not magically but in a way
that's like a nice abstraction okay is
this is this the thing that people are
generally familiar with or seen in
various places cool so when we look at
other frameworks we can see it being
similar in some ways I chose marionette
because I think it's one of the more
popular advanced pattern frameworks that
are built on top of backbone which i
think is cool and it allows you to do a
very similar thing for your message list
items which is your list of replies
you're going to create an item view and
for your thread list item which is your
kind of you know encapsulating view
you're going to create a composite view
because marionette says if you're
creating a positive view we know that
we're gonna render some children
recursively and it has that whole thing
kind of built in and you've got less
boilerplate involved you can just pass
it you can say I'm gonna I'm gonna do a
message list item underneath here and
then you create this thread
them and you give us some collections
and like boom like things start
happening right so you just call render
and you get the right thing I haven't I
haven't used marionette as much as I've
used some of these other frameworks but
as soon as I looked into it I said I bet
marionette does this as soon as I looked
into it I found all the right elements
to be able to create the thing that I
was trying to create the thing that I
knew that I should be able to do if this
is a serious framework right so people
are having these same ideas right
independently of of each other because
these are this is a pattern that's kind
of emerging in people's minds and it's
and it's not a new thing right like this
is this is based on prior art like we we
know that these things are useful when
you're building complex UIs and we're
just learning how what what are the what
are the right ways or what are the most
interesting ways to build them in
front-end JavaScript right
so these think these things look very
similar but I always want to kind of
pull one that looks less similar and I
wanted to mess around with with images
some more and the ember.js
example looks like this for this I
decided to use custom components instead
of nested views right and this is the
thing where you know you can kind of
stick these these kind of custom names
into your template and they're they're
an encapsulated version of the view that
knows how to render itself and has this
encapsulated behavior but allows you to
still kind of nest things just like you
do with with HTML with normal HTML and
Amber's tracking this against the the
web components standard that's that's
developing right now so within bar I
kind of created this this component
called a method list item for the
internal one I left out the thread
starter but you know you kind of get to
drift and then your high-level thread
list item template looks like this so
I'm making a thread list item first
thing I do is kind of stick my thread
starter in there and like that's all I
saw ly really have to do as long as it
has access to the right model for that
thread starter it knows how to render
itself like this template doesn't need
to be bothered with the details but
they're now composed together right and
then I loop over my replies and I do the
same thing I create message list items
and I pass in each reply and it knows
how to render itself and you should get
something that ends up looking somewhat
similar to to the threaded conversation
that I had before and yeah
in fact when when the amur was
evaluating new frameworks this is
basically the exercise that I went
through I pulled every framework that I
thought might be interesting and I tried
to build a hammer feed with it right I
tried to see how far I can get applying
these same patterns that I've already
ever used with what the internal
framework that we have and I'm like this
framework should allow me to do all
these things in a similar way or at
least one that I can reason about and I
got to varying degrees of success based
on based on the factors of the
opinionation of each framework but it
was a really useful exercise when I
start to see these patterns emerge so
the outcome here is very similar right
we get we get this kind of nested view
but the thing that I think is really
interesting here is that I think a lot
of people get thrown off because this is
template driven rather than JavaScript
driven in bura angular both I think
prefer to be template driven they kind
of want you to think about what your
markup is and give you hooks into it
that allow you to kind of hook into your
behavior but I prefer the opposite right
I prefer to organize my JavaScript
objects right JavaScript code that does
what I want and then have these
templates kind of be a side effect of
that that that kind of orchestration
going away that I wanted but the outcome
is the same right like the the nested
view pattern I think applies in both of
these even though they don't look
anything alike you can reason about
reason about them in similar ways right
so if this is starting to kind of sound
repetitive like that's great that's
exactly what I want it like I want this
stuff to look the same because I think
that's what we want and when we were
talking about these shared patterns is a
kind of a way to look at these
frameworks that look very different and
I really trying to differentiate
themselves and I say well if I have this
this kind of shared model in my head if
I have this mental model of how these
things are supposed to work because I
know how the front-end works then I can
use that as a basis to understand
anything that these frameworks are
trying to trying to throw at me
right and that doesn't always work but
it definitely gets you a step ahead so
let's kind of round it out with some of
the emerging patterns these are things
are the more interesting ones and ones
that I think are
harder to kind of find the patterns or
at least establish the patterns today
but definitely worth looking at because
they're coming up more and more often
they kind of like this they're less
common they're coming up more and more
frequently these patterns aren't built
into every framework yet although the
big major ones are trying I know Amber's
doing things and angular is doing things
around around making a real-time more
standard and recognizing these patterns
can help you kind of look across the
field and see how these how different
frameworks are trying to solve these
problems that like I know some of you
have today and help you evaluate those
right so custom components we kind of
looked at with with ember but polymer
and reactor are doing are kind of at the
forefront of that I think real-time
updates which we're going to talk about
people's go-to Julie socket IO but
there's definitely other other things
that you can grab like pusher real-time
sync which is related in kind of a you
know save your models locally and then
have this always-on syncing thing going
with your server and then also similarly
related to that is kind of going full-on
offline cache right where your your
model layer is persisted locally at all
times and then there's this the syncing
thing that that pushes it to the server
if and when it can but but offline
access is kind of a first-class citizen
you know hoodies kind of leading the way
with that and then finally device
capabilities because you want to kind of
access you know hardware capabilities on
mobile devices like your camera or
geolocation when you look at this stuff
and you think yeah I've had to do that
you've probably also gone through this
exercise where you're like well how do I
do that with framework X whatever one is
using even if it's your your custom one
and so people are kind of gluing these
together with you know custom code
that's hard to maintain and so this is
why I feel like there's a pattern
emerging here because lotsa people are
doing it but it's not a thing that you
recognize and the thing that looks the
same or at least I thought so right so I
want to look at real time because
everybody wants to be real time these
days and in fact I was I was laughing
because I noticed that the the go-to app
which was like the the to-do app that
people were using as a tutorial for
their framework has now switched to the
real-time chat tutorial right so all
these frameworks have chatted
differentiates themselves by having you
build something in real time because
they know that's what people are looking
at right but when I looked around at
this pattern I was surprised to find a
little bit more consistency than I was
expecting for something that I thought
was just an emerging pattern the way
that people are integrating it actually
seems very similar to me but as a
pattern now so it felt like there was
something missing so if you look at
these bullet points obviously you can
subscribe to real-time updates from the
server but the the thing that I think
makes this the pattern the thing that I
think is really useful here is the idea
that those real-time updates get
dispatched through your normal model
layer in a way that's very familiar to
you and they you don't have to spend a
lot of time reasoning about real-time as
separate from not real-time right we'll
kind of see what that looks like you can
you can register for four events just
like normal models so I looked at
angular first I didn't I didn't write
these examples I kind of googled around
and looking for what people were doing
with real-time and angular and I found
this so this is kind of an example of
how you might kind of build a blog that
gets real-time updates or whatever right
and so you're kind of going into your
angular controller you've got your scope
there and you give it an empty list of
items that you're gonna presumably fill
and you have this this initial method to
retrieve your initial data right so just
do a regular HS call get your items back
and shove them on that scope and you're
good to get started right but then to
add the real-time component they pulled
in this service angular wants you to go
through these services to access data
and so they've got this this pusher this
pusher service that exposes this
subscribe method and instead subscribe
to you know whatever whatever collection
on the server will give you real-time
updates in this case just called items
and register a callback and every time
there's a real-time update of items
we're gonna fire this thing and all I'm
doing dealing here is pushing it onto
this this items alright and if you
remember this is this is there's not
much else here because angular is
listening for changes to this scope so
all I have to do is push these items
here and all the stuff that's listening
for changes is going to
and in this case they're gonna update in
real time and sometimes that's really
all you need right like that's really
all you want is to say for this
particular list I want it to update as
soon as these objects come in so as fast
as possible and that that's all it takes
in this case and I think that's pretty
nice it's very explicit which is which
is cool but it's also kind of you know
like it could be better it could be
encapsulated a little bit better I don't
have to always worry about you know
setting up this subscribe and every
controller that I need this just real
time stuff right so I jumped over to
ember googled around a little bit and I
found something extremely similar right
completely unrelated but extremely
similar this is from the discourse folks
who are heavy ember users and they're
doing a similar thing building a blog
wanted to be real-time updates such and
such and they do kind of the same thing
right so you're there in their
controller create this subscribe method
that's going to give them real-time
capabilities and they're using this this
library called a message bus which you
know if I'm not mistaken is a JavaScript
client that kind of connects to this
Ruby back-end that gives you real-time
updates and it just just exposes this
subscribe method and it says subscribe
to whatever thing on your back-end you
want to get real-time from you you know
you register a callback and where's
gonna give you data and then you take
that data and you you shove it into the
the part of the model layer that you
want to fire of its fire update events
and in the case of ember kind of looks
like this the the controller model stuff
and ember is still a little sketchy to
me but like you don't need a lot to
understand this when you get some data
here's where you put it it's gonna
update in real time no fuss no muss
right I put citations for these these
two that aren't mine so you can go and
check them out so I was surprised that
these things looked look pretty similar
but you know they're still pretty
explicit they're still not encapsulated
well and so this I think is an
interesting place to look at em juiced
again we didn't talk about how ya induce
models are created but it count looks
like this you just define a new model in
this case we're making a feed which is
you know kind of that list of threaded
conversations and we're associating it
with a real-time feed client
appropriately named this is gonna say
this is gonna get real-time data for you
and
surface it in a way that you can use and
in a completely different file this is a
pretty sophisticated system which means
that it's a it's kind of overgrown and
hard to maintain and a completely
different file you have your base real
time client which has this connect to
real time method and look there's your
subscribe like like it's it's it's the
same right like if you haven't gotten
the point yet cuz stuff is the same so
here's your subscribe you give it an ID
and it's gonna fire this call back when
your data is ready but how does it
surface that data right that's what this
is where the difference comes in and
this is where this pattern is a little
more complete than the ones that we just
looked at because this is buried right
this is an abstraction that's wrapped in
our model layer so the usage looks
different the user just looks like this
you just create your your model like you
like you do in any other place and then
you hook on to this on thread update
that says if there's if there are new
threads coming into this this feed
collection let me know and that's it
like you don't have to mess around with
the real-time this could be a regular
Ajax call this could be real-time we
don't really care all of our our UI is
just hooked up to this method that says
if there's new stuff I'm gonna render it
and so we're we're you know encapsulated
from dealing with the real-time elements
of this and so those real-time elements
could change the implementation could
change right like our our real-time
requirements could change and none of
this stuff has to change right that's
that that's ideally what you want from a
pattern is something that's actually
modular and encapsulated like this
so I hesitated to put this this light
these last slides in because I've been
doing these investigations of these
frameworks but I wanted to look at
meteora but I didn't I didn't get very
far because I think something about
media or kind of twist my brain in a way
that is not very cool so I only got so
far with this but I did I did recognize
that media or I think is establishing
this real-time pattern in a way that I
think makes a lot more sense right so
this is the meteor example in that you
just create you know this this meteor
collection of messages right you do a
query on it by saying find and it's
gonna going to give you back some
initial data if you have it cache
locally but it's also going to open a
real time
connection or rather the way that meteor
works is that there's always this
real-time syncing going on so this query
that you get is it's always going to
fire these these changes that you can
observe and you do that by calling
observed changes funnily enough so
you're gonna get updates when when
things are added or removed but this is
like a normal message collection that
you can then send into templates right
and instead of just you know you loop
over the messages that are there if you
look at you know this is our message
list you loop over the messages that are
there they're gonna get rendered but
also any any messages that get synced
subsequently from the server they're
gonna get rendered like this is all kind
of hooked up in a nice way in a kind of
magical way but it's also kind of nice
right and this is what I think we want
the the real-time connection to be is
the thing where we go through our models
we use this pattern that we already know
the basic one that everybody in here
said yeah our you know how to do that
but you get real-time with the same
capabilities right so I hope I've kind
of Illustrated how these patterns have
kind of helped me evaluate these
different frameworks and I want to wrap
up here but I like this quote this is
from our VP of engineering and when he
said this I knew that he had captured
the the the core of why I felt like this
would be a good talk because rather than
kind of being inundated by all these
solutions that we have to evaluate it's
much better to kind of get really
acquainted with the problem right the
thing that we're trying to do and how we
expect to be able to do it and evaluate
these frameworks against that right
rather than kind of saying how do I do
this an ember how do I do this thing and
angular my question becomes I know I can
do this thing right
like I want angular to enable me to do
this thing so I know what I'm looking
for right I'm looking for my models I'm
looking for how I can inspect them I'm
looking for how I can register callbacks
and I'm looking for how I can nest views
and I know what to expect right that's
been a huge win for me in terms of doing
these evaluations right and so what I
want to leave you with is like let's
find a way to talk more about these
shared patterns let's let's get these
examples let's like use github let's get
people to contribute let's find out how
far these patterns are
reading across our community and used
them as a context for for having a
stronger basis for front-end development
and that's basically it
wish we had more time for questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>