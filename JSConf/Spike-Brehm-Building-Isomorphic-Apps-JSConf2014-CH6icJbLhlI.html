<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Spike Brehm: Building Isomorphic Apps  [JSConf2014] | Coder Coacher - Coaching Coders</title><meta content="Spike Brehm: Building Isomorphic Apps  [JSConf2014] - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Spike Brehm: Building Isomorphic Apps  [JSConf2014]</b></h2><h5 class="post__date">2014-07-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CH6icJbLhlI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks for the introduction
all right so I'm spike I like like he
said I work at Airbnb based out of San
Francisco I've been there for three
years writing JavaScript of Ruby and I
just wanna say I'm super stoked to be
here really proud this is such a great
event the best tech event I've ever been
to and just really happy to be part of
it so let's get started we're gonna talk
about isomorphic JavaScript and so
probably if I were you the first thing
I'd be thinking is wTF is isomorphic
JavaScript what is this big fancy
sounding word well it's simple really
the way I see it it's just JavaScript
code that can be shared between
different environments so I'm mostly
interested in the client in the server
I'm a web engineer so sharing code
between the web browser and something
like nodejs but as we've seen the last
few days there's a million different
JavaScript environments these days
JavaScript runtimes so you can imagine
also something like narwhal sharing code
with Narwhal because I've heard of
Narwhal it's the new Java eight
JavaScript runtime it's a successor to
rhino just to note there's not actually
an official Marvel logo so I thought
that was appropriate also native
platforms so Android iOS these can run
JavaScript really well these days and so
you can imagine we need to share code
between your web app or your server and
native platforms but also things like
spark and tehsil these are we've heard
about these last few days little devices
that can run JavaScript why can't we
share a piece of code with those two and
you want to get really crazy and
futuristic
you can share code with your cars so I
don't know if anyone's heard at the qmk
specification I learned about this a
couple months ago there's actually the
the automotive industry is coming up
with a spec to use web technologies to
build displays in cars so I'd like your
driving directions your radio
air-conditioning all that so but really
today we're just going to focus on
client-server so a really high-level
kind of overview of how I imagine this
works is you've got some code that runs
in the client side you've got some code
that runs in your back-end and there's
some layer that's shared between the
client and server so there's certain
things that would only exist in the
client side make certain you know user
interactions logging whatever and your
back-end could be node but it could be
Ruby or Python or you know peach whoever
the idea is it's just a persistence
layer in an API and then there's this
shared layer in between which can be
running both sides and this could be
views so templates or components or view
logic whatever it could be application
logic so models or whatever arbitrary
logic and it could be routes for example
but by the way that timer hasn't started
so I'm just gonna keep going forever so
let's talk about briefly the etymology
give the term isomorphic JavaScript so
just to be really authentic here's the
dictionary definition of isomorphic
corresponding or similar in form and
relations right that makes sense so if
we look at the latin forms to be further
pedantic ISO means same and morph means
form so same form so code that can share
a form between these different
environments but really we've got to
give credit to Charlie Robbins for
popularizing this is the first time I
ever heard of isomorphic JavaScript was
in his blog post scaling isomorphic
JavaScript code back in 2011 so charlie
is index zero on Twitter he's one of the
founders of new Jitsu and is he's got a
great blog post kind of describing the
different MVC versus mvvm versus MVP
patterns and how it could apply to
isomorphic code
but when I when I first started talking
about isomorphic JavaScript I released a
blog post last year and on Hacker News
most people were saying you're using it
wrong like isomorphic comes from
mathematics or it's a chemistry term or
it's this or that and they're saying
really what you mean is monomorphic or
actually hetero morphic is more
appropriate for what you're describing
or homomorphic is more correct or
polymorphic and I'm gonna say I don't
like whatever it's a word you can refer
all questions to Charlie Robbins there's
some more playful trolling as well I
don't know if you know Dee Shaw
if he might be in the audience today but
uh he he likes to make fun of me
whenever I use that term he calls it a
five-dollar word and every time I say it
he finds me five dollars in virtual
currency and so by the end of today I'm
gonna own him a couple thousand dollars
so just as an introduction let's let's
look at some apps that are using this
approach today and then we'll dive into
how you can build isomorphic apps so a
great example is Flickr I don't know if
you've seen that Flickr redesign
recently after they were bought by Yahoo
but this is their photo page so this is
like you search for silly cat and you
get this this list page and then you
click on one of one of these and it's
rear-ended in the client side right it's
like a single page app client side app
whatever rear Enders but the cool part
is if you were to refresh either this
page or the previous page it would all
come rendered from the server so each
page can be rendered fully on the server
or can be rendered in the client side
and Flickr does this using Yahoo's
modown libraries I think there's some
mowed down developers in the audience
from Yahoo but basically it's a
collection of loosely coupled modules
kind of based around Express that lets
you build apps like this and it's a
successor to mojito mojito was Yahoo's
really ambitious large project that that
attempted to build the isomorphic apps
it's something they used internally a
few years ago but it never really caught
on more broadly because it's so
monolithic and it's very Yui ish so
Instagram is another cool example you
might not have realized this but
Instagram comm is all built using react
and if you land on someone's histogram
page
it would be rendered on the server-side
you click on a photo would be rendered
client-side you refresh rendered
server-side it's same thing and so this
was built using Facebook's react library
as someone mentioned earlier today react
can be executed both on the client and
the server on the server it emits HTML
on this on the client it emits Dom notes
but what's really interesting about this
case is Instagram calm is a django app
so it's written in Python and they used
a node service running on the web on the
Python box and you would hand it a
template and some data and it would come
back at you with some HTML but there's
an asterisk here because instagram.com
no longer uses this they disabled the
node process from what I understand it's
because they there were bunch of Python
developers didn't want the overhead of
maintaining the node service but it's
possible another example I have to plug
Airbnb this is our mobile website and
about Airbnb com same story server
rendered but it's also a single page app
so as you navigate around and to be
rendered client-side and so we developed
a library called render based off of
this experience and render lets you take
it back one app and pull it down to the
server side and run your your models and
your views and your templates on the
server using Express but it's also a
full client side app and one of my
favorite examples is asana has anyone
heard of asana it's a really awesome
task management project management app
and it's all real time and super
advanced and stuff but what's really
special about asana is it takes a
different approach than these other
things that we've seen the entire
application runtime is synced between
the client in the server so they've
spent a couple years and rd on this and
what they come up with was a system
whereby every single user session has a
corresponding javascript process on the
server a dedicated process on the server
for every user session and as the user
navigates around in the app those those
actions are synchronized to the server
side and the server side will compute
all the same stuff it'll execute the
views and it'll fetch data and and do
all the same stuff it throws away the
HTML what at once is the state so they
have got they've got off
picture of the application state on the
server side as it exists on the client
side and it enables some cool stuff now
this took them a few years we can't all
do this because we were not all founded
by the youngest billionaire in the world
asana was founded by one of the Facebook
co-founders and so they they had a bit
of a runway to work with there but for
the rest of us we can use meteor so in
many ways I see meteor as a kind of an
open source take on what a saunas
building and if when I understand a few
of their engineers used to work at a
sauna and they brought over some of the
concepts but I'm sure most of you have
heard about meteor by now but it's a
real-time app framework and it does some
really cool stuff with sharing code
between client server so why would you
go to the trouble of doing this there is
some trouble you got to jump through
some hoops to share your code properly
so the first thing for me in my opinion
would be performance and this applies
mostly to the cases like Flickr where
you're rendering the whole page on the
server side even though it's a single
page app now that that comes from the
the initial page low speed is so much
faster and it feels so much faster
because you're not waiting in all the
assets to download and fetch and
initialize and and fetch data before you
render the page and you might remember
that Twitter used to be client-side
rendered right there's a hash bang in
the URL and a couple years ago they
switch back to server-side rendering and
they said they saw a five times
improvement and perceived performance so
that's that's great another reason could
be SEO so many of us I'm sure I have
built a single page app just to be told
that any needs to be crawlable by a web
crawler and if by default your entire
app can be rendered on both sides it's
not really concerned there's an asterisk
here because you may have seen last week
Google wrote a public blog post saying
that actually their web crawler has the
capability to execute JavaScript it's a
headless browser we've kind of known
this for a while but they've their
explicit about it now so it's this is
less of an issue but I'm sure there's
still a long tail of both crawlers that
don't have that capability
flexibility is another one because you
could run your code on either sides it
opens up a lot of doors for doing new
things and I think that meteor and asana
wouldn't have been possible if it
weren't for this ability and
maintainability I think a lot of us have
tried to share templates between client
and server for example in different
languages say in a ruby or in Python but
you end up duplicating either part of
the template or the template engine or
your view helpers or at some point
you're duplicating code and that's never
a good thing
so there's a number of use cases for why
you might want to use isomorphic code
the first would be templating I think a
lot of us when we first explore this we
look at templating we look at sharing
our code between the client and server
and so I think of templating as the
gateway drug to isomorphic JavaScript
because you start with sharing a
handlebars template or a mustache
template or whatever but pretty soon
everything that goes into populating
those templates needs to be shared so
things like internationalization you
need to translate strings on the client
and on the server date and currency
formatting at Airbnb we had a bunch of
handlebars helpers that helped us do
stuff like this and once you try to
share that you know you need to you want
to be able to render that on both sides
to arbitrary application logic that's it
could be anything right it could be
model logic or any sort of application
logic routing once you start sharing
your view layer between the client and
server you don't want to have to
duplicate your routes between say
backbone router and your rails app right
you want to have a single set of a
single source of truth for your routes
model validation how many of us have
written form validation in the client
side so there was instantaneous
you know feedback good user experience
but then duplicated some sort of like
form about our model validation in your
API I think it's pretty common API
interactions a lot of times we want to
make calls to an API either a first
party or a third party API using
EP or some other transport and we might
need to make that call on the client for
whatever reason we might need to make
that call on the server but if it's all
in the same language and we can share
that then there's only there's a single
a single set of semantics for doing that
and then anything else I mean whatever
you can imagine whatever is necessary
for your app your use case potentially
you could share some code between client
and server so it's important to note
that isomorphic javascript is a spectrum
there's no one way to do it there's this
a lot of different approaches so if this
is our spectrum if the blue side is like
the side where you shared just a few
bits of a view layer or a little bit of
logic and the pink side is the entire
view layer is shared right your entire
application is shared your African kind
of fall anywhere along the spectrum
depending on your use case in your
ambition and so for this side you don't
really need a lot of abstractions if
you're just sharing like some templates
for something it's pretty
straightforward to do that but the
further you go along that spectrum you
need to build more abstractions because
the client and the server are very
different environments you need to
abstract away those differences whether
it's like accessing cookies or or
anything and we'll get into that a bit
more and so for some examples Instagram
comm would be would be on this side of
the spectrum where they just shared
their view layer they had a totally
different server-side technology for
their most of their app whereas asana is
like all the way like the extreme where
the entire application is is Sheridan I
also see two categories for isomorphic
JavaScript code it could be environment
agnostic or it can be shimmed per
environment so an environment agnostic
code does not depend on any browser
specific properties like the window or
any server specific properties like the
process or request or response
stuff like that and an easy example
would be handlebars or probably any
templating library
it's just dealing with primitives
strings arrays objects functions so
there's no reason this shouldn't be able
to be executed in any any environment
that's like a proper JavaScript runtime
so here we're creating a template which
is a string compiling it to a function
and executing the function getting back
the rendered HTML so the other category
and the more interesting category is
shimmed per environment so these
libraries provide shims for accessing
environment specific properties so your
module can expose a single API for use
on both sides so this could be let's say
you're you're writing like a routing
library and the client side if you want
to see what the current page URL is you
would do something like window dot
location dot path name and on the server
side you'd have to access the request
request that path or or that this isn't
what you do in Express and a great
example of a library like this would be
super agent so super agent is an HTTP
client library lets you make HTTP
requests and in this example we're
saying super agent get so it's a get
request to some JSON endpoint and end
and we pass in a callback and the
callback takes the response and the
response has properties like the status
code HTTP headers the body all this
stuff and it's great to be able to use
the same API on the client in the server
so how many times I mean typically we
use like jQuery AJAX for our Ajax needs
in the client side and then on the
server we've used HTTP module or that
request module or or whatever and so
this is a great example of a module
that's shimmed per environment and it
actually provides under the hood
different implementations for the two
different environments but it exposes a
single API to the developer
so there's a few HAP's tractions that
I'll mention a simple one would be the
user-agent so let's say you're doing
something you're writing like some
mobile web app or something and you need
to determine what platform the user is
on and the client side you'd say
navigator.useragent on the server you
actually have to look at the HTTP header
the user agent header that's attached to
the request cookies is a great example
if you're trying to set a cookie in the
web browser you just say document dot
cookie equals and then some string some
specially formatted string on the server
side you got a set a header set an HTTP
header and the header name is set cookie
so you would say response that set
header set cookie and then the cookie
string and you can imagine why we'd want
to do this on both sides like a lot of
times you need to set a cookie on the
client side in response to some user
interaction and we're constantly setting
cookies on the server side redirects is
another example so but if you're doing a
full page redirect in the browser you'd
say document dot location dot href
equals and then the URL or if it's a
push state application you might use the
html5 history API and say window dot
push state some arguments and then the
URL but on the server side we need to do
a full HTTP redirect response that
redirect and there's an additional
complication and that on the server
there's there's different HTTP status
codes right so there could be a 301
redirect 4-3 to redirect and so if
you're trying to build an abstraction
around a redirect in your app you need
to accommodate for those differences so
let's get to the fun part how to ice
some morph how you can build isomorphic
JavaScript today so what we're gonna do
together is we're going to write a
module that that solves the cookie case
that abstracts out the setting of
cookies and provides the same api on the
client in the server
so we want to make you an API that looks
like this set cookie cookie name the
cookie value that's it super simple so
as we mentioned before this would turn
into in the browser return it to
document dot cookie equals my serialized
cookie string and on the server it would
be we'd be setting an HTTP header
response that set header set cookie and
then this that same exact serialized
string but it gets more complicated
cookies have additional options there's
a path you can set a domain you can set
an expert header or expert property and
so then the cookie string can look
something like this document dot cookie
equals my cookie the value you know all
the stuff and when I see that you know
what I think I think yeah like I don't
want to do that like that's a lot of
edge cases there probably it's probably
years of RFC's to weed through and try
to do that right so luckily there's a
module that does this for us already the
cookie module on NPM is used by Express
and connect and 108 other libraries
according to NPM so let's just use this
because someone's already written it so
NPM and browserify to the rescue we've
heard a bit today about how awesome it
is to use browserify NPM and your
funding code and we're gonna we're gonna
continue along that among that theme so
a browser fie lets you use common js2
require your modules in the browser but
more interestingly it lets you package
up your dependencies from your node
modules directory so we can npm install
the cookie module into our into our
application added to our package JSON
and then we when we do a browser if I
build that will being pulled out of our
node modules directory and insert it
into our build
so the next step is we need to figure
out how we can make a shrimper
environment module so we're building a
little module that provides a single API
to the client and server but there's
different implementations under the hood
and the solution is to use the
package.json browser field so there's a
little-known feature of the of
package.json and the way it interacts
with browserify that lets you actually
specify different behaviors for browser
versus server so if this is our package
dot JSON are a real bare-bones package
JSON for our setcookie module what we
can do is we can add a browser field
here and it takes a few different forms
so if it's a string if it's if it's just
a single file name then it'll swap out
the entire implementation for the client
side so it'll ignore all of the rest of
the code and your your package and when
you browserify that bundle it will use
the Lib client das file instead but you
can get more fine-grained to so in this
example we've got an object and so you
can swap out a specific file for a
different file so if you've got like a
Lib nodejs module and you're within your
package you can swap that out for Lib
client yes
and you can also swap out dependencies
so we're gonna be depending on the
cookie module but let's say for whatever
reason the cookie module will work too
well on the server side but it had a
quick or it you know tried to do
something it shouldn't and it didn't
work well in the client side well if
there's an alternative module on NPM or
within your node modules you can swap
out that entire module for a different
one and so with with this with the
browser field we can do all sorts of
cool stuff and it opens up a lot of
doors on how you package up your modules
for different environments so what we're
gonna do is we're going to build the
setcookie module I actually already
built it you can look at the source code
if you want it's at my github page but
we're gonna we're gonna step through it
here so this is the structure of our
really basic set cookie module we've got
an index that is which is like the main
entry point for the node module we've
got a Lib directory and and I live
directory we're gonna have a setter
directory and that setter is gonna
that's going to be the implementation
that actually sets the cookie and we've
got one file for node and one for the
browser and so the index dot JSP the
node version and the client chest will
be the browser version and then of
course we're using cookie as a
dependency so that's going to exist on
our node modules directory so this is
what our index KS will look like the
entry point at the top we're requiring
the cookie dependency and then we're
requiring setter and you can see where
it's a relative path require Lib setter
and so as I'm sure you know if you if
you require if setter is a directory and
there's an index file inside of it
you can just use that semantics and it
will require that so by default it'll
use the index dot J is the node
implementation and then all we do here
we export our public API it's a function
that takes the name the value and an
options argument and so because the
cookie string is the same on the client
in the server
right the way that we see realized that
cookie string is exactly the same so
here we can use our cookie module and
say var cookie string equals cookie dot
serialize and pass it the name value in
options and then we hand it off to the
setter to actually set that string so
here's what the note version looks like
Lib setter index thas so it takes that
cookie string and the options and and
what it does is so so one thing I didn't
mention is with a node you can't just
like set a cookie right you I mean you
can't set do anything with HTTP without
the context of a specific request a
response so that's one big difference
between the client the server and the
client it's all global right like you're
only ever dealing with one context one
user session on the server side you've
got you could have hundreds of user
sessions happening at the same time on
your server and so you always have to
inject through the request or the
response so the API for the server side
you would add a re s a response option
to the options argument and if you don't
supply that will throw an error but
basically we're just saying response
that set header set cookie in the cookie
string and then here's what the client
version looks like it's pretty
complicated it just sets document.cookie
and so in our package JSON the browser
field would look like this we're
swapping out live setter index js4 live
set our client j s and this is exactly
what super agent does so a super agent
actually has two completely different
implementations for node versus the
browser and just to highlight if you
look back at our entry point our index
is there's there's our require this is
the require that will be affected by
that package JSON field
so in a nutshell that's how to ice um or
does it seem pretty easy so far that's
obviously a kind of a trivial example
it's a rich topic with many ins and outs
and I encourage you to reach out about
it and we can we could dive into the
nuts and bolts and all that but for now
that's all I have so I want to say thank
you and there's more resources about
isomorphic JavaScript at spike
technology which is my my website and I
since I have 5 minutes so if you've any
questions you can tweet them at me but
thanks very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>