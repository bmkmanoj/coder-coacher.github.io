<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Sam Dutton: WebRTC: Real-time communication without plugins | Coder Coacher - Coaching Coders</title><meta content="Sam Dutton: WebRTC: Real-time communication without plugins - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Sam Dutton: WebRTC: Real-time communication without plugins</b></h2><h5 class="post__date">2012-11-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mYQNEaOfqGI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">great to see everyone here yo got like
30 minutes get a really really quick run
through a very big project you know
we'll be around today so please come and
talk if you have questions about the
api's or anything to do with WebRTC we
really really need your feedback at this
stage we want to know what you think of
the api's and what you want from them I
just want to get a quick check from the
audience of you know what kind of stuff
you've used is there anyone here in the
audience who's actually built a web app
with getusermedia okay few people there
has anything done anything with like our
tcp connection previously known as peer
connection going to build an app ok I
think that's a no one if anyone knows
what those abbreviations mean then I
take pity so you know I think there's
been this incredible explosion in in you
know the availability of media api's
over the last few years we had the video
and audio element which a huge shift in
the way you could do things more
recently we've had stuff like web audio
media source the track element so on and
so on and a stack of technologies that
we can use with that stuff you know just
CSS but also things like canvas element
WebGL and so on and I think you know the
combination with these AP is and these
technologies and these different kinds
of media come together we can get
something you know really really
exciting and that's what I think is
going to be particularly interesting
with WebRTC I just wanted to give a
little example of the kind of thing I
mean this has absolutely nothing to do
with web RTC but I thought I'd show it
anyway this is a an example of using the
track element a guy at the Google campus
in California it you know I cycled
around the campus and he took video and
he got GPS I put it together with the
track elements it's pretty
straightforward he cycles around and the
map changes and you can change the
position on the map and the position the
video changes so you know it's not
revolutionary stuff but you know what
interested me about doing that was that
the track element you know it wasn't
invented
those reasons it was invented so people
could do initially it's just captions
and subtitles but you know you get these
interesting things I think with
JavaScript when you get these kind of
unforeseen things when api's come up
against each other with different types
of you know different kinds of media and
data so you know traditionally if we're
thinking about real-time communication
it's been it's been sort of closed and
corporate and hard to get at it's kind
of out of the reach of you know kind of
mere mortals like like you and me so
what's what's happened is that you know
there was there's been this big project
there's kind of collaborative effort to
bring something that was open source and
unlicensed so you could get it right
there in the browser the very short
version of WebRTC is that lets you do
you know real-time communication between
browsers so stuff like video chat and
you know real time gaming and so on but
you know hopefully even more interesting
stuff than that if we go back a bit the
you know we had kind of HDD p which is
sort of the basis of the web we can make
requests to serve as get stuff we could
do stuff with put and post and then we
had Ajax which you know talk about six
years to take off but people did really
interesting stuff with it and then more
recently WebSocket as let us do
bi-directional communication with a
server and again you know be interested
to see what comes of that what WebRTC
enables is communication between
browsers and communication of real-time
streaming data as I'll explain servers
are involved but you know the point is
you're having what you're setting up is
a communication between two browsers so
you know this communication not via a
server so we have these you know these
open standards and the idea is that you
could have this stuff directly in your
browser you know would it be great if
you could just have like a video chat
application in your web application that
would be fantastic one of my colleagues
said you know that something like
human communication should be as normal
a part of a web app as like entering
text in a textbox and you know I think
what's interesting is the what we'll see
like beyond the scenarios as well so
when RTC is kind of two different
efforts as well as the implementation
stuff we have the IETF work which is
kind of protocols and formats lots of
documents and the w3c api's for the web
apps I mean at the moment you know kind
of everyone's doing it with with
real-time communication the problem is
that you know like hangouts and skype or
whatever work pretty well but for start
they use plugins with the problems that
they have these are closed you know
there ra p is for these things but these
are kind of closed systems and as we all
know they they don't work perfectly
either so WebRTC aims to make this stuff
open but ready to go beyond this to do a
better job and like I say you know
what's really interesting is what
scenarios will see beyond the simple
video chat stuff so we're looking to
build a common platform I don't think
the participants really know what will
come out of it but they're developing in
collaboration these big projects and you
know i think that the internet has
revolutionized the way we communicate
and we experience and consume media I
you know I really believe I've said this
before but that WebRTC can democratize
and decentralize the the tools we have
for communication but also for content
creation and you know I'm thinking not
just about things like gaming but also
things like video production I've seen
some really interesting ideas from the
BBC about collaborative news editing for
music making and so on and so on so I
think this could have a really
transformative effect someone told me
that the communications industry is like
it's like a two trillion dollar industry
something like that so you know WebRTC
could be a big thing
least it you know it could well be the
end of telephony as we know it just sort
of smaller example of this this is
something called tether with it's built
by a company based in Europe called
voxeo done great stuff with real-time
communication this is a kind of simple
idea it's a kind of communication system
in a box so what they use it for is
disaster communications so
communications in a crisis where there
is no telephone network what they have
is an open cell phone network built
using something called open BTS like
this is an open source cell that you can
set up yourself and they have that in
that little box it's on the right of the
computer and you can communicate with
that from any kind of phone like any old
feature phone whatever and then from
that box you can communicate with a
computer using WebRTC so yeah this is
amazing to me it's telephone telephony
without a carrot you know without a
carrier I kind of DIY telephony and
that's great but in this situation
disaster communications that you know
really makes a huge huge impact so any
kind of real-time communication needs a
bunch of different things so firstly
obviously you need to be able to acquire
streaming data somehow you know you need
a source like from an audio audio from a
mic or video from a camera or some other
source of streaming data and then this
middle bit which is actually really
really hard is to communicate that data
in real-time the streaming data between
peers and to do that in a way that
performs very well and copes with all
kinds of network disasters the third
part of this process is is something
called signaling and that's the process
by which you can exchange messages about
what you're doing and how the handshake
process all that stuff exchanging data
or kind of metadata about what it is
you're communicating so here's a really
I just love the simplicity of this this
is kind of
the syntax that works in firefox this is
a really simple example of getusermedia
you can use it now in firefox night
please but i'll show you the same we
have the same syntax working in lots of
different browsers we can't see much of
the page here can't get to anything
either let's have a look at opera so
yeah we've got the same syntax running
an opera and the same code again running
I've actually put this code here in
actually run it from Firebug using a
video element in in Firefox what I
discovered a silly thing is that like if
you don't play the video Firefox
actually records the stuff you're doing
so if you then play back what you've got
you get a whole bunch this is me earlier
you get the idea it's like playing back
the stuff you actually recorded with
getusermedia so kind of similar syntax
or virtually you know that on all those
different browsers working the same way
so that's a way of getting media what
we've what we've seen is also a stack of
stuff I might not go through these now
but if anyone's seen Phil Nev stuff
great like photo booth apps we've also
got some really nice stuff I don't have
anyone seen the magic xylophone let's
see if we can make that work hold on
let's see we get this magic xylophone
this is kind of cool you can play a
xylophone by waving your hands and
there's motion detection yeah using
getusermedia it's kind of simple but
it's quite beautiful actually I better
turn it off otherwise it will drive
everyone crazy I just in case no one's
seen this you know this is the the Phil
Nev stuff there's been a miracle if it
works with connectivity but you know
it's really simple again doing filters
and lots of silly stuff just straight
stuff and you can take photos as well oh
my god ok enough of that
so you know lovely stuff just that's
just come out of getusermedia you know
that's just the first very first part of
WebRTC what's really exciting a couple
of weeks back we had integration of get
user media and web audio this means you
can use get user media as an input for
web audio so essentially using the
create media stream source methods on a
stream that you got from say a
microphone I'll try and do a demo of
that and work by one of my colleagues
let's just say nice um a guy called
Chris Wilson check out his stuff is just
fantastic this is a really simple
example it's just a pitch detector
excuse me while I try to sing ah okay
you get the idea it's a bit grim he's
also done some sorry this this will if
you have tinnitus this will just do
wonders for it this is okay you get the
idea we're getting sort of weird effects
and so sorry it's impossible without
that with the echo so what you're
getting there is like I say input from
getusermedia from the microphone locally
into Web Audio you could also be getting
you know media stream doesn't define
that you have to get it from the local
microphone or camera you could get it
from any source of streaming data so
huge potential there like I say once
again 11 API coming up against another
we have here his vocoder demo which is
kind of similar and will probably sound
even worse okay anyway you get the
general idea getting horrible effects
there okay right so lovely stuff there
check it out the the you know the
combination of web audio and get user
media um so like I say WebRTC needs to
do these three different things I've
shown you the first one which is getting
streaming data we also need to
communicate the data somehow there's got
to be a way of doing that and then this
way of exchanging
control messages so the API is for this
media stream and what's now called RTC
peer connection and something called
data channel these are the three
components of the WebRTC project i've
talked about media stream for getting
streaming data RTC peer connection is
the part that does the communication of
audio and videos so this is doing a lot
of different stuff things like coping
with bandwidth changes enabling
encryption and so on that there's a lot
in this as i'll show you the the third
part of this puzzle which is sort of
kind of part of the peer connection
stuff as well it's called data channel
and to me this is potentially the most
exciting thing of all what this allows
is you know PR TCP connection is all
oriented really to audio video and
particularly to voice and of course you
know there's a bunch of telephony has
gone into this but data channel allows
streaming communication of any arbitrary
data so this could be really interesting
for a you know for gaming I also think
of sort of scientific applications you
know getting data from CERN to your
local university you know interesting
stuff there I heard some web at sea
engineers talking about this saying that
you know in a good day with WebSocket I
think you can get something like maybe
50 millisecond latency say within Europe
if you're really lucky and what they're
talking about with data channel is to
try and get it to really you know where
they've got what you call it you know a
speed of light problem so they're
getting very very close to the physical
constraints which is stunning stuff and
we'll that is coming it's not there yet
there are some polyfills if you want to
have a play with it but I think that'll
be incredibly interesting the two things
that aren't part of the WebRTC project
these processes of peer discovery and
signaling by peer discovery I mean
actually finding someone to talk to you
know if you want to make a telephone
call you have a telephone number and you
use
there's all sort of a lot of magic that
goes on in telephony systems with
handshaking and so on and it's the same
with WebRTC or any kinds of real-time
communication you know a really simple
kind of user discovery mechanism that
it's actually you know is used by some
of the the existing demos is you take a
unique URL and you put it in an email
and you send it to your friend you know
you've discovered the user you've
exchanged this URL and then you can
communicate via a server using that URL
because essentially discovery is all
about it's all about setting up the
means to do what's called signaling so
to do any kind of real-time
communication but thinking about WebRTC
you need to be able to set up this
channel to do signaling so essentially
what you need to do is you need to
contact your friend and say hey I want
to do like say video chat just like you
do with hangouts or skype or whatever
and then there needs to be a mechanism
that you can use to set up a signaling
channel so what people have done is done
stuff with WebSockets and also examples
using xhr plus the data channel API in
Google App Engine so you make contact
with your friends and then basically
you're saying let's use WebSocket via
this server to exchange signaling
information now the content of the
signaling information is is twofold
there are two bits to this there's
information about the local setup that
you have the capabilities of your
machine but also information about the
media you're going to communicate when
you actually start communicating
directly between the browsers it's not a
really good analogy but if you think of
HTTP make HTTP requests and there are
headers that tell you about capabilities
and the content and then there's the
payload which which is the actual
content you're trying to exchange and
the second part of that is that we need
to be able to work out how to contact
ate each other how to actually set up
the network connection and that
information is exchanged via signaling
to
so you know it's peer-to-peer but at
this point in time we do need servers
sadly you know you can't just kind of
shout into the internet begin exchanging
data with my friend Heinrich you know
it's just not it's not going to work
sadly so here's a diagram it kind of
shows this it's called this architecture
is called jcf there's been this
deliberate decision to have the
signaling outside the core WebRTC stuff
so I mean kind of all this shows is that
you know you set up a session signaling
between the two browsers and you
exchange like session information
signaling data and so on and once that's
happened you can do this bottom bit
which is actually communicating directly
between the two browsers and that's done
using you know if it works over RTP over
UDP if that's not possible it kind of
falls back to other mechanisms which
I'll talk a bit more about Anna moment
this very complicated looking diagram is
really just there to show you that it's
really bloody complicated you know this
is what peer connection does and it does
a stack of stuff and the other point
about this is that shields a lot of the
complexity from the developer so yeah
peer connection this is the stuff that
does the video and voice audio calling
and it has to do a lot things like
packet loss concealment noise
suppression what's called gain control
so your volumes don't go up and down too
much image cleaning coping with you know
changing bandwidth a stack of other
stuff this thing called dynamic jitter
buffering so you need to do really
clever buffering to avoid some hiccups
the video and audio you'll also notice
that in this diagram there are codex but
there is nothing in the specs that that
refers to specific codex this is you
know this is essentially the
implementation as it exists in chrome so
a good place to start you know if you
want to have a look at web RTC I would
recommend a really simple example here
which I actually nicked from masam
colleagues let's just close that stuff
so what this page does and I'll just
show you that well I'll show you the app
and then I can show you the code
essentially what this is doing is it's
doing web RTC but within a page so
there's none of the signaling mechanism
you're actually you just signaling from
one object to another within the page
you're not having to set up some
WebSocket channel or whatever so yeah if
I start this off then it's it's getting
the local stream and that's being
displayed in the left hand side there
I'll then call my friends who's actually
the same on the same page the same code
and yeah now we're having communication
but you know it's sort of fake because
it's on the same page if we look at the
code this is you'll see it's it's it's
really pretty simple stuff you know
that's that's it so that's actually all
you need to do within a page to do peer
connection like that so I'd say that's a
really good place to start if you want
to start getting your head around web
RTC you know I'll make no bones about it
there is some complex stuff in this and
it can be quite hard to to get your head
around the whole the whole set of stuff
um so yeah this is the most complicated
bit so just just to warn you this is the
process whereby once you've created a
peer connection object you actually make
exchange of data about session
information between the caller and the
corlee so what you do is you make this
thing called an offer which uses
something called the session description
protocol you send that via whatever it
was that you set up as the signaling
mechanism to the coulee the person
you're trying to speak to you and then
when they get that they can set that and
go all right this is the conditions at
the other end of this conversation then
they make their own session description
which is called an answer and then I
send it back again and once that process
happens
you can begin to communicate stuff now
simultaneously there's another process
that goes on with our tcp connection
which is called finding candidates the
idea of a candidate is essentially an IP
address and a port a way of connecting
with someone else out there in the world
and again this is a sort of similar
process that happens when you create the
work the rtcp connection object you
create this thing called a nice
candidate you serialize it you use the
signaling channel to send that to the
other person they set that they do their
own one and they send it back again now
once those two things have happened
those two processes and you know there's
a kind of pinging process to check it
all going to work then you've got
communication then directly directly
between the two peers not via the
signaling server not via anything else
directly between the two peers at the
moment the way it's been implemented is
like one to one but there's no reason
why it couldn't be essentially
many-to-many this is just some of the
code we saw before and just thinking
back about the servers we've got as i
said to you we have to use servers at
this point I can't see a situation where
this would it might be decentralized but
essentially we still need these
mechanisms for user discovery and
communicating with the other person you
know to say hi I want to do video chat
or whatever and we also need a signaling
channel now the two are there are two
other bits to this we need to be able to
for this all to work with in things like
corporate networks so we need to be able
to traverse Nats firewalls and so on and
for that we use something called stun
which is essentially just a way for a
peer behind a NAT or whatever to get its
external IP address and so on now like I
said WebRTC tries to do RTP over UDP
directly between the clients there are
situations where that can fail so it
hasn't been implemented yet but you will
be able to use what's called a turn
server a turn server is a kind of relay
server
be able to specify the address of that
when you create your peer connection
object and that is a means for
exchanging data of via this intermediary
relay if the direct connection doesn't
work so essentially what you're doing is
you're falling back to TCP here's a
diagram of exactly that which shows yeah
the communication happening via the
relay server not directly between the
peers so where can I use this stuff well
you've got it in chrome you've got get
user media and our TCP connection peer
connections stables still behind a flag
operas got get user media like I showed
Firefox has get user media and the night
please I think Opera Mobile has get user
media and Firefox i think on some of
firefox mobile i haven't seen it that I
believe that's there as well rdc
peerconnection told is coming to Firefox
in January 2013 and of course in IE you
can use chrome frame but you know what
this means is that by in the next few
months most you know if unless the sky
falls on our heads we will have the
ability to do WebRTC in most of the
world's browsers we hope say I think
that's very exciting just one thing we
talked about web but you know there's a
whole C++ aspect to this which is
incredibly you know rich and and it's a
great API and have a look at that
there's lots of information on the web
RTC org site this enables you to do
stuff like set up a web RTC client on a
server so to speak I've also seen a
couple of weeks out there's on YouTube a
cutie cute app that's built using WebRTC
so you know great for doing stuff with
WebRTC in your C++ apps so just a last
couple of demos I'm not sure this will
work in this situation but let's try it
out anyway just close some of these
windows so I'd say once you've got your
head around the peer connection stuff
that has showed before then the next
best place to go is
to have a look at a party see appspot
com and what this has is the full
signaling setup so if we have a look at
this this is actually this might I'll
turn on the mic a bit but it's going to
go let's see chug chug yeah is it going
to work I don't know essentially what
you've got there is let's just try that
again so what you've got is is peer
connection plus signaling so like I say
this is a really great place to look at
the whole picture of web RTC you notice
there that we're getting the little the
confirmation box so there is an aspect
of this which is you know we have to
think carefully about this in terms of
user information okay it's been hard to
see on this monitor but essentially
we've got you can see there I've got
both clients and the the audio is going
really hideous but you know that's a
working video chat application using
using a party see so you're using WebRTC
so yeah check that out as the I'd say
the next place to stop if you're trying
to understand this stuff I won't show
this now but WebGL meeting is a
beautiful implementation using WebGL of
two clients and sort of old-fashioned
televisions and have a look at play here
my game this is lovely work from agency
magnetic north who did this for us at
Google i/o it's a game the old game
where you put a name on your head you
have to guess who you are so if you want
to find out more about WebRTC you know
have a look at web RTC org I'd really
recommend Justin a Bertie's google i/o
video there's also a great video on
vimeo from and that from erickson so
yeah a great introduction there and
check out the stuff on html5 rocks I i
do tweak quite a lot about WebRTC so I
tweeted at sw12 and you know usually put
most of the big kind of news stories for
their
and please we you know we really want to
know your experiences of using WebRTC in
chrome so please if you're using it
firebugs tell us what you want and tell
us what you need from the api's you know
I really hope this is going to have a
really intro you know a disruptive
effect on on media so so please ask me
questions now slightly run out of time
but you can speak to me now speak to me
in the break yes Peter yes there is a
rumor on the internet that there might
be some kind of hackathon going on a
long run remember 30 did you confirm
that yeah yeah I've heard some words
about that there is an event in london
on the thirtieth of november at campus
london and Peter may have something to
do with that so if you're interested
give me or Peter and shout we're going
to have a big intense day of web audio
web RTC hacking hackathon with like the
the kind of core WebRTC boffins there
and some really interesting people
designers and performers as well so at a
campus London 30th of November good one
awesome we're running out of time for
questions but remember this face if you
have questions about awesome WebRTC
stuff and we have a next speaker coming
right on and one more and then we have
lunch so hold on for one more talk and
thank you so much damn ok thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>