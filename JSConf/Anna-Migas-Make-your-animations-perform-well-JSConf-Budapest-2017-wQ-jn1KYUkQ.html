<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Anna Migas: Make your animations perform well | JSConf Budapest 2017 | Coder Coacher - Coaching Coders</title><meta content="Anna Migas: Make your animations perform well | JSConf Budapest 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Anna Migas: Make your animations perform well | JSConf Budapest 2017</b></h2><h5 class="post__date">2017-12-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wQ-jn1KYUkQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">does it work yeah it works well that's
big
so hello my name is Ann amigas I work as
a front-end developer and designer in
lunar logic we are no management
software house based in Krakow Poland
which is not far thankfully we built
apps in rails in elixir in react and
whatever technology suits our clients
needs best the title of my talk is make
your animations perform well and I had a
pleasure to create and maintain free
open-source libraries you can ignore the
CSS name in the name stir and before I
give you the first tip on animation
performance I need to share a short
story about my life so about two years
ago I bought my very first own apartment
and I decided to decorate it on my own
and what I found out it's that like
decorating your house is very similar to
designing a website you just need to put
many things together that go well what I
also realized is that most of the things
that are out there in furniture shops
are not the things that I want in my
house I just didn't like the things that
I could afford and the things that I
couldn't afford I liked so kind of it
didn't much so this is my lamp in the
living room after two years and if I had
to compare it to something on the
website is it's this just text that says
low thing that she puts in a place where
the low there should be it just kills
you that's something like that is there
anything about it every time I see it
that you should actually put something
real there so it's good because at some
point you're going to replace it the
next piece I have is this beautiful
coffee table when I found it after light
year and a half I told that it's perfect
because it was affordable what color was
matching my place it has this shelf to
put all my art albums there so it's just
it's just perfect and I assembled it
myself so I feel it's like really
powerful after that and if I had to
compare it it would be comparing it to
the animation that just helps user to
understand the app better it just guides
him at some context so everything that
the user is doing there so it's just
really good thing and I have this chairs
well this countertop is of irregular
size the regular chairs are just too low
and regular hookers are too high for it
so I have to choose from like very small
pool of chairs I found this online and
they're like why it's for the ball and
kind of like simple so it's they're
going to be kind of okay
but it turned out they're kind of okay
it's not enough for me I just hate them
I never sit on them I prefer to eat
standing up the only moment that they're
in use is some the big part is when
someone gets like really drunk and
decides to sit on them and I can't get
rid of them because like I have chairs
they're like everything is fine about
them but it's just me that don't like
them and my friends whispering them
crazy just throw away and have nothing
there and what I could compare it to
it's just animation that you put
something out there without really
thinking about it and it just stays
there forever you have no time to
replace it because you know you already
you already put something there and you
have different priorities so it's like
laggy you make all your users just
downloads thousands of assets and it's
not really helping anyone it makes the
experience worse in like all cases
basically and it's going to stay there
believe me
so the first rule of performance of an
animation is just to not use them if you
don't really need them just don't force
you
to download many assets to make the
whole up more junky okay now that we
have the most important rule of CSS and
JavaScript and any kind of animations
behind us the important thing is to
choose the right tool so there's this
debate CSS or JavaScript animations some
people prefer this or that actually to
be honest they're both perfectly good
tools but they suit different purpose so
if you have CSS animations they're just
great if you have something simple up
simple to put up like I don't know
something that just needs to slide up
the screen this is perfect then during
the native to the browser they get all
the GPU acceleration from the browser
there's a need to put prefixes for them
unfortunately but it's not much and the
only bad thing about them is that if you
need to schedule more than like one or
two animations in CSS it's just a pain
and this is where the JavaScript
animations actually shine they're really
good at scheduling and timing so if you
need to put more than one animation and
schedule them one after another this is
great
and there are many ways how you can
implement JavaScript animations during
like pure JavaScript it needs some
optimizations I will talk about the
trick later there's web animation API
which is my personal favorite because it
takes the best things of both words it's
it's got this GPU acceleration from the
browser and at the same time it get the
scheduling and timing unfortunately it
still needs to be poly field so until
like all the browser vendors decide to
have it there well you need to polyfill
that and there are frameworks but you
need to decide if they're really needed
in your app because well it's some code
that you're downloading and well it can
be heavy like music is amazing platform
but it's really heavy so for small apps
with notes many animations is not good
choice and MJ
can be a good choice then okay so so we
have the choice of Bustos and the the
most important tip behind us but before
we actually start optimizing our
animations it's good to know what's
going up what's going on in the behind
because it makes us realize that some
optimizations can can can make things
better or worse actually
so how actually browser paints a website
let's talk about this for a moment like
very briefly so first step is the
browser makes get request and it gets
HTML or in turn then the h2 the hTML is
parsed and Dom is created document
object model it looks like a tree it's
got all the notes from the HTML in it
they're visible in this way after that
the styles are applied it's from the
user agent from your style sheets inline
Styles the don't is taken out and we
have a render tree render tree is very
similar to the Dom with this difference
that render tree has all the Styles
applied and there are only things that's
going to be actually visible on a page
so for example if the image elements
here had display:none and a paragraph
element had a pseudo class that's what
would happen
they'll be it would be also represented
in the render tree and then the layout
is calculated at this point the browser
is trying to figure out how much space
each of the elements is going to take
and it actually features it as a
collection of vector boxes here we need
to remember that the parent size affects
its children size after this points when
browser already figure out how much
space each element is going to take we
have everything rasterized and put into
layers you can think of layers as of
something like layers in Photoshop that
if you have things on two different
layers
then you can move them around if things
are on the same layer then there is not
much of what you can do actually they're
just glued together so yeah so our our
our collection of boxes moves to to this
two layers layers are going to be
represented as this box shadow I hope
that you appreciate how cheesy this is
okay and the last step is compositing
and at this step this is the first step
that browser takes advantage of the GPU
so it optimizes its its way around here
so the the layers that we had actually
get glued together into one frame that
is then shell to the our end user dude
it's good to one frame one picture so
this was the first render but actually
you must understand that every time the
user makes any change on the on your
page so by changing I mean like
scrolling hovering over element that
changes and hover or just clicking
something that gets a class somewhere
else then the browser needs to go
through all the steps again with the
small change that instead of having
instead of having this request at the
beginning there can be some JavaScript
that's introduces the change so there
are different types of change that you
can actually introduce and some of them
are more important for performance and
some of them are a less performance so
let's go through them the first type of
changes when we change layout
it's when we animates with height
margins left or right properties and in
this case browser needs to go through
all the steps because it needs to figure
out how much space each element is
taking and unfortunately it's it's a
very costly change then there is when we
change the paint properties the browser
knows how much space each elements takes
so it can skip this step so it's a bit
more performance
these are changes like background color
color shadows things like that and there
is the most performant type of change
when we only change compositing in
compositing its transforms or opacity in
this case we don't change layout or
paint so this is the most optimal kind
of change which means that these are the
two properties that you should be
animating like in in most cases they're
like perfectly fine to anything you want
to do in animation all right why is that
so why this should be the only purpose
is for for animating first it's this GPU
acceleration that I that I said that's
happening at the compositing stage and
the second one is layer creation so at
next to last step we had rasterizing and
creating layers but actually you need to
know that that by default browser puts
everything into one layer so we need to
figure out ways so that the browser
would create smaller layers and by
default when we have this when we have
these different layers like things can
be moved around and they don't affect
other things so it means that that the
animation is smooth so what creates
other layers frizzier perspective
transforms animated this is a keyword
animated 2d transfers or opacity if
element is top on the top or it's a
child of the compositing layer that was
already created accelerated CSS filters
and in special cases video canvas or
plugins like flash or Silverlight this
is what creates layers so we have a
small problem here and I'll give you an
example to understand it better let's
say that we have here an animation is
applied to the button and it's
it rotates the button all the time so
it's fine we have two layers button is
just moving around notes and that's
actually affecting anything around but
in most cases you would want the button
to actually be moved only for example if
someone hovers over the verse over it so
that's the point where you want the
animation to happen so the problem here
is that the browser doesn't know that
this animation is bound to happen so
it's it puts everything on one layer and
when user actually actually just hovers
over over the elements it only has to
create the new layer so everything needs
to be repainted and what users is of
course not
like the button doesn't disappear
anywhere but there is a small lag and it
can make user think that your your app
is responsive or it's just slow and the
worst part is that after animation is
done it's also pushed layers together
again so if a user hovers over it again
it will do the same thing repaint things
so there is one more thing that can make
your browser create a new layer and this
is the will change property and it can
help us with the prone that we've had
using it is very easy you just need to
apply it to the element that is going to
be changed and explicitly say like we'll
change transform browser will we'll know
that it needs to listen for a change it
will create the new layer for this
element so so we can change things
without being worried that and you learn
it to be created at the moment of of
user actually interacting with the
website there are a few rules that you
need to follow with will change first
one is you need to give a browser a
moment to think so let's say that you
want to apply some animation in hover
you cannot add like we'll change
transform for the hovered element you
need to be one step ahead of the browser
because when user hovers over element
the browser already is like making the
best optimizations it can for for it to
happen and actually putting will change
at this point could could interrupt the
browser so please check at least added
one moment before you want this change
to happen like here to just button you
can't also try to optimize too many
elements you might think that well why
just no ads will change to everything
and have everything on different
separate layers and just move things
around without affecting anything else
don't ever do this here was a nice
spider-man quote on the slide but I had
to remove it because it was just already
on CSS conf two days ago I would just
hint you that it was Uncle Sam saying
that things about responsibility so
every layer consumes memory starting to
use them wisely if user has a less
powerful device like low end phone
actually having too many layers can
trash his his or her browser and well
the experience won't be very good then
write another rule that you need to
remember is to use use will change
inside sheets only if the change is
bound to happen constantly if you have
animation that will happen only once
it's better to move I think the will
change property to JavaScript and if you
have changed like hovering over elements
that will happen all the time for
example I don't know we show something
on hover on each element on the page
then it should say in your style sheets
and those it's a good idea to actually
remove this hint once once you're done
with your animations so that browser
wouldn't have this layer and it wouldn't
just listen for user to interact with
your page you can do this easily just
grab the element that is supposed to
have the animation on that
put two even listeners here for example
we have Mao Center so on Mouse
intelligence ad will change property to
the lemons and when the animation and
event fires you just remove this just
remove this will change property by
setting it out and of course it's not
supported in I am edge but you can use
the fallback which is transform
translate Freddie - we just add this as
I said 3d transfer is also creating a
new layer so it's kind of a hug but it
works exactly the same as will change to
be honest all right the next technique I
wanted to say is more of a principle
it's called flippity-flip States stands
for first last inverted play and it's
just what we were doing here so
basically if you wanted to pull element
from point A to B you don't push it by
200 pixels to the right you first pull
it 200 pixels to the left and then let
it slide to its original position it
could be implemented very easily with
transforms as you can see just as in the
example and if you would for example had
some kind of many that's that we wanted
to show in this way we would just
position it absolutely then we would add
some transform to move it out of the
viewports add some transitions so it
would slide not just show up in the
place and add for example a class of
active that when applied with just let
the elements slide to its original
position you might ask why would we do
that like what's the point there is this
100 milliseconds gap that happens in
between the moment that the whole page
is loaded and the moment that user is
able to interact with your page it's
just how our brains work we are not able
to interact with
and I think like on such short notice so
we're taking advantage of this hundred
milliseconds gap and even though it's
like optimize we're using transforms
there's still some small calculation
that's browser needs to make to figure
out where's the destination point of
this elements and here if we first move
element out and then let it slide or
general original position then actually
where we're having this animations than
up front so the browser did the
calculation this gap and when the user
clicks on elements the change happens
instantly the calculation doesn't have
to be done in this moment so the flip
technique actually can make a difference
on less powerful devices and low-end
phones so it's where where you should be
using it also you should use it only for
the animation that happens when when
user interacts with our with our
websites and there are free useful
resources that you can use there is a
flip J's library by Paul Lewis from
Google there is my library that is
actually a collection of examples how
you can use it and there is a really
good article by Paul Lewis who is
actually a creator of the technique as
well okay do you remember this this was
how the browser went through all the
steps to show the page to the browser to
our user but actually it's just one
frame and to have our animation looks
smooth we should serve this frame every
16 milliseconds why 16 milliseconds 60
frames per second is what our browsers
can do for for our animation so this is
how fast we should be serving the frames
to the user so that animation would look
good
one second is just thousand milliseconds
and when we divide tiles and by 60 it
gives us 16 milliseconds truth be told
it should be more like 10 milliseconds
because after after the browser goes
through all the steps there are still
some you know cleaning up to do but I
don't want to scare us
stay with 16 if we don't we if the
browser fails to provide us with this
frame every 16 milliseconds the
animation will just look not smooth it
will look junk like it there will be
junk the user might feel that actually
your application is not responding very
well so now imagine that browser is
trying to meet this 60 millisecond
deadline it's already at layout part
it's figuring out how how much space
each element is going to take and then
the JavaScript comes in like something
needs to be changed so the browser needs
to go through all the steps again like
it needs to recalculate the styles and
the layout again well things happen try
to meet that in 16 milliseconds browser
is probably going to miss the deadline
and the frame is going to be lost
animation will look terribly fortunately
there is a thing that can help us with
that and it's the requestanimationframe
function finally is something like truly
JavaScript e right
what requestanimationframe does it's
just it makes sure that all the
JavaScript that is about to somehow
influence the frame is going to come in
in the first possible moment of each
frame so this is how it works and it's
quite easy to implement this is like the
easiest case that we could have that we
just we need to just fire this function
with something that is about to be
repeated and then recursively call the
function from the inside and of course
as with everything that's cool in the
web there a requestanimationframe has
some rules it needs to vendor prefixes
and it needs polyfill for the
less-fortunate browsers fortunately
polyfill takes care of vendor prefixes
so if you're using polyfill you don't
have to care about that
also if you're using green sock or
web animation API or jQuery free bundle
and hire you also don't have to remember
about requestanimationframe because it's
already there it's inside inside these
tools there is canceled animation frame
which is like complementary function
that will just stop your animation from
happening and it's way better than using
set interval actually set interval is
what what is in the polyfill but browser
doesn't optimize for first set interval
it doesn't take that interval into
consideration when it's scheduling up
the frame and setting the role is just
guessing that in next 16 milliseconds
then your frame will happen but if
something offsets and goes wrong is
still much mr. frame and the last thing
I wanted to say to you about it is to
test your animations before actually
optimizing because things that you think
might actually be needed for your
animation might might make it worse and
things that should be smooth might
actually not work very well so test your
test your animations and of course the
best thing to the to do testing is to
use dev tools both in Chrome and in
Firefox at least that's what I'm using
for example in Chrome it can enable the
rendering top you need to click this
free small dot menu and just in more
tools you have friends ring tab and all
the cool things and then you'll be able
to actually see for example where the
layer borders are to see paint flashing
or you can see the FPS meter or any
strong performance issues that you could
have also you can use the timeline tool
to record your animation the shorter
they're recording the better because
it's easier to investigate what's going
on if you have the green small blocks at
the top it means that your animation is
actually smooth then there are like
really new shiny tools there like to
things that I just discovered like month
ago that they're there
layers tab which shows you why every
layer in the website was created it says
for example that is the root layer or
it's it's the layer is because it's on
top of other layer or it's because it's
animated transform it's really really
useful thing and there is the new
animation tab in in chrome that lets see
for example run your animation so we're
just record it and investigate it too
Firefox also has animation step and it's
also very similar but it was there first
as well you can run your animation bit
slower or you can if you if you inspect
an animated element it will show you if
it's optimized by this small lightning
bolt icon next to it or if it's not
optimized it will give you a warning
what's going on in there why it's not
why it's not okay so to sum up please
don't overuse animations if they are not
going to help your user and they are
just there for your pleasure of the or
the pleasure of a designer try to skip
them not make the user feel the junk
junk eNOS of Europe animate only
transforms and opacity because they are
the most performance in that way try to
take leverage of will change flip and
request animation frame wins applicable
don't overuse layers don't overuse the
wheel change property test your
animations animates elements that are on
top layers don't animate things that are
behind something because it will make
all the things up on them to be create
like to go to the other layers and yeah
test animations before optimizing the
most important one here are some
resources I'll post the slides after
this talk maybe tomorrow we'll see and
thank you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>