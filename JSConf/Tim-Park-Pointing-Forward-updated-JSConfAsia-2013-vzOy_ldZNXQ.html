<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tim Park: Pointing Forward (updated) - JSConf.Asia 2013 | Coder Coacher - Coaching Coders</title><meta content="Tim Park: Pointing Forward (updated) - JSConf.Asia 2013 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tim Park: Pointing Forward (updated) - JSConf.Asia 2013</b></h2><h5 class="post__date">2013-12-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vzOy_ldZNXQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">you
as we go mentioned I'm going to talk a
little bit today about how how we
interact with the web is changing I'm
going to do that just there's just a
start out I'm gonna start out with a
super mr. obvious slide and that is that
web mobile browsing is exploding the
interesting point though is that this
year there are more people browsing the
web with touch than there are we using
mouse and the other implication that may
not be really apparent is that people
are starting to use are using touch on
desktop as well so windows 8 now has
touch built-in and even you know
platforms like I'm going to have have
touched integrated into the platform and
so if you have a touch capable laptop
you can start using the web on your
desktop as well with touch and so this
curve I expect or the number of people
using the curve the implication of this
curve is that a number of people using
touch on the web is only going to
accelerate and so we did a lot of
research and what just really this talk
is about is the first part is a little
bit about the research we did with
surface and the second part is about
pointer events but but as part of doing
the the building the surface device we
did a lot of research and what was going
on on the web and I keep hoback you can
delete this slide because i think it's i
think probably for most people's is a
pretty elite audience this is pretty
obvious but there's things that stop
working when you win when you are using
the web in a touchable manner right so
when you hover is a terrible thing to
use and you have a touchable web it note
upstart not hover but hover hover menus
and things like that where the
interaction requires that you're able to
hover over a device or over an element
on the page when you're using you're
using the web page in a touch manner
that's impossible so some patterns like
this stop working and you need to think
about that which can sometimes be
challenging when you develop doing most
your goal and obviously on a laptop so
you need to reconsider which message are
using on the web as you develop for the
web for the touch another thing we did
is we did a lot of research on what's
the optimal touch target size so we
obviously a mouse has really fine
grained control over you know clicking
elements on the screen and obviously
touch doesn't
people have fingers of various sizes and
what we discovered is that we did we
need research that there is there people
had fingers that went from eight
millimeters all the way up to 19
millimeters with 11 millimeter adder
average basically and what we found is
that we use different touch target sizes
and we found that as the touch sighs got
below five millimeters people started to
make a lot more mistakes so that seems
to be a kind of the asymptotic kind of
curve and which you know people start to
have a lot more trouble using using your
website and it's not only if they have
more trouble clicking the target they
actually spend more time trying to zero
in on the target as well so those two
things combined together to be you know
to make it very much more difficult and
so what we discovered in that research
is that something between seven
millimeters and nine millimeters is kind
of an ideal touch target size and so
that's what that implies kind of depends
on the the density of the screen but
from a lot of the common screens right
now that's 40 to 50 pixels your touch
target should be in that range going
above that obviously is easier to touch
but then you start using up more screen
real estate for your touch targets so as
you design your applications you should
think about you know people using it for
touching that and making sure that touch
targets are the right size another part
that we did that not a part of the
researchers did with the surface was
looking at where tarts targets are
positioned and so those of you that are
have seen Windows and Windows 8 we have
this this this kind of this pattern
where we have things on the left and the
right that you can you can click and
this comes directly out of the research
on one where people's hands are and so
the green regions here are where it's
easy for people with with the smallest
hands to reach touch targets and as you
see it's kind of all run the it's in the
middle of the tablet it's did you know
obviously to the right and the left
usually and so for the touch targets
that you wanted your users to use the
most these are the best positions for
that you should you should have and you
know as things get more to the senator
to screen a big more difficult for
people to use and so when people at
Microsoft are thinking about building
building websites and building
applications we have this general kind
of set of guidelines and so the first
one kind of comes out of the last one
put your touch targets to the side
towards the middle if possible if it's a
static screen or doesn't scroll and on
the on the phone it's exactly the
opposite right so you're using your
thumb as opposed to fingers it's it's
the best interaction zone is actually in
the middle and so then you kind of flip
that around when you start thinking
about where the best areas are for
people to read things on on mobile
devices for the tablet it's it's it's
best up top their hands aren't obscuring
it they can you know that it's easier
from the read and the same thing on on
the phone as well and so you know people
bring expectations now you know the
explosion of apps in mobile and desktop
has brought expectations of what the you
know touch touchable apps mean to the
web as well and one thing that the web
really hasn't you know to date hasn't
kept up with is multi-touch so the
ability to have multiple pointer events
going on at once and so this has led us
in in in conjunction with Mozilla who's
been a great partner in his proposal to
propose to the w3c something called
pointer events and what the idea of
pointer events is is to evolve the
current Mouse events model to unify this
across the other types of point of
pointers that are available so we're
talking about mice are talking about
touch we're talking about pens and
things that we can't we don't even
haven't even dreamed up yet so this is
moved is to move very quickly through
the w3c it was a working draft and I
think March of this year I believe this
year and in five months it's been two
candidate recommendation the good news
is it's really an elbow volution so
we've taken what you already know from
mouse events and essentially have you
know there are more or less drop-in
replacements there's really only one
thing that we've added and that's
pointer cancel pointer cancel is an
event you get when someone changes an
orientation
or or a couple other scenarios where you
want to or accidental input that has
been detected by the device where you
want to cancel the inputs you want to
cancel this particular pointer event
otherwise it's more or less which you
expect these events from from you know
using Mouse events for many many years
what it does add is it adds more
attributes so I'm going to walk through
each of these in a little bit more
detail so it adds more the set of
attributes that are available on each
each event so that you can you can do
some you know much more richer
interaction model of with with touch and
other other pointer devices and so the
first one is the first set is is width
and height and this is the recognition
that a lot of pointer events beyond the
mouse have our point of devices beyond
the mouse have a real physical world
width and height right so when you put
your finger down on the screen depending
on how much you you're pressing on if
you're using your thumb or your index
finger it's going to have a different
geometry on the screen and so this
passes us through to your web app so you
have access to that and you can respond
appropriately you know likewise for some
devices and in particular the pen there
there you know it might be important to
have the pressure and a tilt that it's
that the deploying device is at this
allows you to do kind of stenographic
you know calligraphy style things with
the with the pen and so you can you can
reflect what the users real intention
was with using the device and finally
there's there's two other things you can
use so if you know most cases you
probably want to handle pointer devices
the same button you know in the case
that you don't you want to handle a pen
differently from a touch device or a
mouse you have the ability with pointer
type 2 to do device specific actions and
then finally because this now is a model
where there can be multiple pointer
devices in action at where and play it
once there's actually an ID which is
kind of the thread ID for that one that
one pointer event
sorry that one pointer device being used
in the system so you can keep track and
you can keep them separate as they as
you're using them alright so I'm going
to jump out I'll jump in right now and
just show a little bit of code or how
this how this works and I'm going to
have to do that over here unfortunately
we have to do as little dance because my
screen is not actually high enough
resolution to do a 1080 80 presentation
I'm just sort of annoying get a new
laptop when I get back anyway so so what
I'm showing here is essentially i'm
going to build a finger painting
application so i'm using a canvas i'm
essentially there's a little bit of
boilerplate down here because in ie10 we
had a vendor prefixed implementation of
this and now it's shifted over to the
draft recommendation events but i've
been essentially in that canvas i'm
adding a set of event listeners so
there's a event listener for pointer
down and there's an event listener
pointer move and up and cancel and so on
and so what I'm going to do is I'm just
going to when there's a pointer down i'm
going to start paint and just to
initialize things I just have a list of
four points and so what I'm going to do
is as I move I'm going to paint along
that path so I just do a busy a curve
between those four points and we'll just
continue to do that as the user moves
and when I lift the when I lift or
cancel meeting an orientation change
usually I'll end the paint and it'll
stop the it clears this list essentially
and so if we look at you know how does
that how does that look how does that
work and I need to go off full screen
wait so I have to this is really
annoying but I have to come over here
actually do that no I can I can do with
the so i'll do the so i'll start out
with just the mouse so this is one
pointer event right now i'm going to do
this little dance over here and use my
touch screen on my laptop which is
really annoying but to do the same thing
so i just touched my laptop it's not
really a parent to you in this case but
essentially I drew on the screen as well
so we use two different prototypes they
reacted in a way that you know makes
sense it did you know essentially drew
the line followed the curve that we were
talking about the problem is and I can't
show this in real time is that if i use
both my fingers the way i've implemented
it it doesn't work right what happens is
it essentially jumps between the pointer
events in each of the the streams of
events were getting and so to fix that
essentially we just need to use the
pointer ID that i mentioned earlier so
with multi-touch essentially here's
another implementation of that and
essentially i'm just using now instead
of just having a single list i maintain
a list of points that we're going to
draw that curve between using you know
index by this pointer ID that you're
getting as part of the as part of the
pointer event and otherwise it's the
same implementation we're drawing the
curve through that that that set of
points and so if i go back and drag this
back over here and you have to trust me
that I'm using two fingers makes you can
tell now there's different colors now
that's handled correctly and actually
manage those as two separate streams of
points that it's drawing but you know
what cinching about this is is still the
same size right so even though i was
using a i have pretty big fingers
globally big fingers and but it was
still kind of a you know a small kind of
you know pointer side or a mouse-sized
death thing and that's because i'm not
using the physical geometry of that
particular pointer device and so looking
at this you know just one final tweak
i'm going i can make this is i can
actually hear i can just say you know i
just use some sort of heuristic right
add the width and the height of the
pointer to buy
and multiply enzyme 3 or use the
pressure or just you know use some kind
of default and doing that it allows us
to have a real world you know have some
real-world element to it so on the mouse
you still get the kind of the narrow
line but if I if I use my finger my
giant my giant thumb in this case you
know we get a giant line that looks you
know appropriately matches my giant
thumb so so that's just a quick example
so all of that is up on you know it when
you jump into using pointer events all
of that is up on github jump back to
presentation so I I have that those
three examples run on github if you want
to have a look at them and you know in
terms of getting started so I eat n had
vendor prefix support that I I talked
about briefly I 11 now is the UNPROFOR
it based on the draft recommendation
there's a chromium WebKit prototype at
this the shortened URL but for most of
us were probably you know for the
immediate future we're going to need to
use use polyfills so there's two
polieville is available ones written by
a microsoft ER hann j/s it's available
there and then google a googler has
actually written a polyfill as well
called point cas so you get started
today those work roughly obviously
without native support there there's
there's some approximation to exert
their interpreting Mouse events in order
to kind of build up same model but you
know to to a first approximation they
work pretty well and if it is supported
natively on the platform it uses that
and both those polyfills so that's what
I had I'd love you know I'm happy to
take any questions about pointer events
and yeah thanks for listening to me
again
does anyone have any questions for Tim
oh we have one question over here so did
you say these new events i'll go and
become part of the specification yeah so
the day they're there a draft
recommendation in in the w3c someone
could someone else could probably answer
better what that exactly means what it
at that point it's usually my
understanding is that means that it's
something that that people are going to
implement and so the for instance in the
blink project there's an intention to
implement I think that's the right term
so it should be should be landing in
chrome obviously Mozilla co-sponsor
torko proposed it with us so i expect it
lands and firefox at some near future
okay and will these work existing with
touch start in those ones as well and
i'm sorry the one um will they work
alongside the touch start touch end and
all those it oh yeah yeah yeah it's
pretty terrible parallel yep cool okay
anyone else with questions more yeah in
the back we have one
are there aren't there any proposals for
natively supporting multi-touch events
like inch and you know drag stuff like
that so that so gestures are not in the
spec that was that was that was
something that they talked about but
didn't didn't make it into this into
this particular spec I think that was
that that's a question they were not
gestures are gonna be part of the
pointer events but there's no there's no
default there's no pinch it or or or
kind of higher level gestures just just
the raw events that you get back that
was something that was discussed during
the standardization positive we didn't
get it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>