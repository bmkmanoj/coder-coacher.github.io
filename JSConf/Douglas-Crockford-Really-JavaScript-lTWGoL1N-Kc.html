<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Douglas Crockford: Really. JavaScript. | Coder Coacher - Coaching Coders</title><meta content="Douglas Crockford: Really. JavaScript. - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Douglas Crockford: Really. JavaScript.</b></h2><h5 class="post__date">2013-01-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lTWGoL1N-Kc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">ah
are are really so JavaScript who'd have
thought that you could get a bunch of
people together in any city to talk
about JavaScript how really unlikely it
has become the world's most popular
programming language they're more of you
writing in JavaScript today than any
other programming language if they're
it's running on more systems than
anything else and it's not just in the
browser it's all over the place at the
same time it's the world's most
unpopular programming language if you
ask any group of programmers what
language do you hate the most by far the
most common answer is going to be
JavaScript probably pretty equally
between people use the language and
people who don't um
and it's all because of this guy this is
Brendan Eich he was hired at Netscape to
make the Netscape Browser work like
hyper card and the approach that he took
was really audacious he started with
Java because they told him it had to
look like Java took the best parts of
scheme and the best parts of self which
were two languages which had no
commercial success but he poached
features from them and put them together
into a new language called live script
never told anybody exactly what he had
done and what the consequences of his
design decisions were but they were
amazing for reasons we don't have time
to discuss today it was renamed as
JavaScript in order to deceive the world
as to the importance of the language and
that very nearly succeeded it then
became one of the problems with the word
JavaScript beyond the obvious ones is
that it's not open it's a proprietary
trademark which now belongs to Oracle
Corporation so you know it's the
language of the open systems but it is
not itself an open name so it may have
become generic by now it may have been
aspirin dorkly next or xeroxed but just
in case it hasn't we can always call it
Xmas crypt which is another synonym for
the same silly language now I don't know
if you remember the dot-com bubble
anybody alive when that was going on the
web was a big disappointment as an
application delivery system page
replacement was obviously too expensive
Java applets failed the java community
doesn't like to remember this but java
had the first shot at being the language
of the internet fell flat on its face
hard one of the most amazing significant
profound failures in the history of
software not well remembered but in fact
it happened and javascript was there too
but nobody understood javascript at the
time so it was pretty clear that the web
failed as an application delivery system
the consensus at the time this was
around 2000 was that the web was dead
that it was going to be replaced similar
to the way that hypercard had been
replaced that things are great for a
while and then something will come and
go better so the future was obviously
not document retrieval it was going to
be distributed programming what some
people at the time were calling the X
Internet
one of the proponents of that was George
colony who was the CEO of Forrester
Research and he wrote on their website
another software technology will come
along and kill off the web and the
Judgment Day will arrive very soon
in the next two to three years he was
right and he was also not completely
right but he was influential by the way
this is not on the Forrester site
anymore but you can find it on
archive.org so it's still out there so
Microsoft heard this and believed it ok
the web's gone just like everything else
goes away so we'll start working on
everything else so they disbanded the IE
team because the web was finished and
put them to work on Avalon and other
things which are going to be more
focused at the X Internet and then we're
blindsided by the web a second time when
Ajax came up in 2005 with that
JavaScript got a rare second chance
in a perfect world javascript would have
died as a proprietary language with
Netscape when Netscape died but it
didn't it got a second chance and Ajax
succeeded because of the goodness in
JavaScript if JavaScript had been as
crappy as everybody had thought it was
from the beginning
Ajax could not possibly have succeeded
but it did succeed because of that
goodness so despite that a lot of people
hate JavaScript and there may be some
good reasons and some bad reasons the
good reasons are that it has bad parts
it has a lot of really bad parts some
the worst ideas and history programming
languages can be found in JavaScript and
this is a direct consequence of the
language having been designed in about
ten days I challenge any language
designer it's not engineering it's a
quickfire challenge it's a stunt and
it's amazing that he managed to get as
much goodness into a language given the
amount of time he had to think about it
some people hate JavaScript because the
Dom is so awful um and that's a good
reason to hate the Dom it's not a good
reason to hate JavaScript a lot of
people hate JavaScript because it isn't
C or C sharp as C++ or Python or Ruby
because it isn't a language that they
know and like again what can you do
about that and there's some people hate
JavaScript because it didn't die but it
had good reasons to not die on the other
hand they're good reasons to like
JavaScript it has good parts on the best
parts I've incorporated in a programming
language and the combination of those
parts is absolutely amazing
what JavaScript is fundamentally is a
functional language with dynamic objects
and familiar syntax and if that's all
javascript is it's an amazing
accomplishment and and that's why it
works it scales from beginners to
masters which is very rare it's hard to
make a language which is suitable for
either of those extremes but JavaScript
meets those and everybody in the middle
at the same time that's again an amazing
thing
javascript is especially effective in
event-driven applications which
is a lot of what we're doing functions
with callbacks that's a very easy thing
to express in this language and it is
the right way to write interactive
applications programs in JavaScript can
be significantly smaller than equivalent
programs in other languages but only if
you think in JavaScript you can come to
JavaScript thinking in Java or thinking
in Python and you can actually make a
lot of progress but you're not going to
get the great efficiencies that this
language provides you unless you can
think in JavaScript the language is now
finding success in lots of non browser
venues it's been in desktop applications
for a long time for example most of the
Adobe suite has JavaScript built into it
it's built into operating systems now
their widget systems in both Windows and
Macintosh that use JavaScript it's in
databases now like couchdb lets you run
javascript in the database amazing it's
finding a lot of use in mobile
applications it's finding its way into
consumer electronics there are now
television sets with javascript in them
and perhaps the most interesting thing
is we're now in servers javascript was
in the first commercial web server I
don't know if anybody remembers that the
original netscape livewire server had
server-side javascript the sun
eventually got control of that project
and killed it off replaced it with a
java and that's where j2ee came from but
server-side javascript is back there's a
lot of really interesting work going in
there I'm very encouraged by that so
javascript obviously has a lot of bad
parts so the constantly raises the
question can we make JavaScript a better
language there are certainly good
reasons to want to do that
the difficulty is the web itself once
something gets into the web it's really
hard to change it in particular their
older browsers out there that will
continue to run so you can have a new
language or new versions of language
but the old browsers won't understand it
and so that introduces a lot of pain and
misery for web developers I found that
the most effective way to make
JavaScript a better language is to
simply remove the bad parts and that's a
difficult thing for ACMA to do we can't
easily remove bad parts from the
standard because the bad parts are not
useless parts they're just unnecessary
and dangerous and because they're
unnecessary and dangerous they're widely
used all over the web because that's
sort of the way the web works and you
could argue that the programs that are
written using those bad features deserve
to be broken but a tech now we believe
that we should try to not break the web
and so we can't take those things out
but you can as developers you get to
choose what subset of the language you
want to use so simply by saying I will
not use the bad parts you get to use a
better language and that's a great thing
and to help you do that I wrote a
program called jslint which will read
your programs for you and painfully
point out the cases where you're using
the bad parts I highly recommend you use
jslint part of the bargain that you have
to make with jslint is that you have to
avoid forms that are difficult to
distinguish from common errors which is
something you should be doing anyway you
don't want to be writing programs that
can't be easily distinguished from bugs
the less your program looks like a bug
probably the more likely it isn't buggy
so if you can do that jaslyne can help
you write much better programs so there
are so the ACMA script committee tc39 is
now working on our project called
harmony which could become the next
edition of the language it's difficult
to talk about what's going to be in the
next edition it's irresponsible for a
standards body to pre-announce what's
going to be in a standard before the
static standard has been ratified
because you don't know if it's actually
going to ever happen there are some
things that we're looking at which are
likely to be put in and there
other things that were debating so we'll
go through some of that first we'd like
to correct the block scoped problem as
you may have discovered JavaScript
syntax appears to support block scope
but in fact it doesn't so a block in
javascript is not scoped only functions
have scope so a var which is declared
anywhere is visible everywhere within a
function and it turns out you don't need
block scope in order to write good
programs so that's good but if you think
a language has block scope and it
doesn't then that's a source of errors
and we'd like to fix that so we'll
probably be adding a new left statement
and a Const statement which will replace
the current var statement and those will
respect blocks we're looking at better
support for functions with a variable
number of arguments right now we've got
the arguments array which never worked
right and has some really really bad
implications it's terrible for
performance so we want to get rid of
that and add some new syntax which will
let you deal with variable number of
parameters in a much nicer way so you
don't have to splice the parameters
anymore to get the stuff you want you
can just ask for it and get it now the
problem with both of those things is
that they require new syntax and new
syntax is completely useless if you must
support the older browsers new syntax is
a syntax error on browsers that don't
recognize it you can't if around syntax
means the whole thing doesn't run and
where I work if we get a syntax error on
the page we don't get paid so we can't
tolerate that so the problem that the
major problem is ie6 ie6 is fading very
slowly five years ago I predicted that
it would take five years for ie6 to fade
away it's still here it its market share
has diminish some since then but it's
still hanging on and it looks like it's
going to be hanging on for a lot longer
there are more obsolete versions are
more obsolete ie users out there than
users of opera Safari and chrome
combined so if you're making decisions
about which browsers do we want to
support it's really hard to say we're
going to support opera and Chrome and
Safari and not support ie6 but ie6 comes
with this terrible backward
compatibility burden ie6 is hanging on
basically because we we are allowing it
to hang on because we've done such a
good job of supporting it and keeping it
going it's going and so we can talk
about changing the language and adding
new features and removing the bad
features and correcting all that stuff
but it's just a waste of time as long as
ie6 still has dominant market share so
that's why I come to you and say that
ie6 must die we need to get rid of it
it's causing us a lot of pain and we'll
get back to this in a moment so the one
of the most reported bugs or the most
reported bug in javascript is a
variation of the problem point 1 plus
point 2 is not exactly equal to point 3
which would only be a problem if you're
living on a planet where people use the
decimal system and you know where we are
on one of those planets this is
obviously wrong it's wrong because we
are using the I Triple E binary
floating-point standard and this is not
just wrong in JavaScript it's wrong in
every language that uses it which is
basically every language that was
designed over the last 20 years it was a
bad design choice it was a popular
design choice but we need to get rid of
it we had considered replacing the
JavaScript has one number type and that
turns out to be a huge advantage most
languages come with a lot of member
types basically a call back to assembly
language and most of them work wrong
like most integers if you it's possible
to add two positive numbers and get a
negative result
that's insane how could anybody have
ever thought how could any engineer any
mathematician think that's a good idea
javascript does not have that defect so
hooray for JavaScript I Triple E
proposed another standard for a decimal
floating point type which solves this
problem so that's good but in current
implementations it comes with a
performance penalty of hundreds hundreds
so we couldn't convince any of the
browser makers to implement it so we had
to reject it the reason we were looking
at that format was IBM was saying you
have to use that format we're hoping IBM
will become more reasonable now that we
can consider other decimal formats and
we can go on with something better
there's a lot of interest in making
javascript a better target for
implementation it has become the virtual
language of the web we always thought it
would be the the Java VM or maybe the
the CLR but it turns out javascript is
the common runtime so we've been there's
a lot of interest in adding new features
to the language to make it easier to
compile other languages into JavaScript
for example putting in int so that the
errors that are in other languages can
be more easily reproduced in JavaScript
programs we're probably not going to do
that our first mission has to be to the
web and to the users of the language as
the language but we still feel a lot of
pressure there there's also a lot of
interest in an intermediate
representation the theory being that if
we could right now in JavaScript you
send the source file to the browser it
gets compiled and executed on the
browser if we could send some
intermediate representation then we
don't have to pay for the compilation
step and everything should go faster
Java made it really clear that that just
isn't true
when Java does that in the startup time
for Java applications is appallingly
slow so Java Script actually got that
right and I think will probably continue
to get that right another reason for
having an intermediate representation
for example abstract parse trees would
be that
you'd have a version of the program
which is more easily manipulated and
there might be some value in that
particularly if we used it to create a
macro system we're under a lot of
pressure to add new features to the
language but a lot of those features
would be made unnecessary if we had
macros in the language so essentially
you could define your own language in
the language and then the committee
doesn't have to worry about that stuff
anymore and one way that macros might
work is by working on the syntax trees
so that's something we're looking at we
get a lot of requests for having threads
and I'm pretty confident we will never
do that because threads are evil like
many evils they're sometimes a necessary
evil
and so in operating systems at the
system level it makes sense maybe to
have threads in the system at the
application level it makes no sense at
all you should never have threads in the
application though and I think one of
the design errors of Java was that it's
trying to be a system language and an
application language at the same time
and so threads leaked into the
application level where they're evil one
feature I'd like to get in is tail calls
which is the optimization of the form
where you return the result of calling a
function it turns into a go to basically
so it can make recursion a lot faster
and it can introduce new versions or new
programming models like the continuation
passing style which is a really elegant
and wonderful way to write programs it
comes with a terrible cost though and
the terrible cost is that debugging
becomes more difficult because we
short-circuit these calls turning them
turning them into jumps and so the call
stack is incomplete so you can't look at
how you got here you know you were here
then somehow you got there and there's
no record that the debugger can see that
shows how you got from there to there
that's a huge trade-off and we haven't
figured out how to resolve that yet
there's a lot of interest in making
JavaScript more like other languages my
advice to people who want to be writing
in other languages is write in those
languages I mean there's no reason why
you shouldn't be able to do that
we shouldn't have to make this one
assume all of the features of every
other language I think that's an unfair
burden to put on any language there's a
lot of interest in exciting new features
but it's really easy to go off the rails
with that kind of stuff so in reviewing
those my personal criteria for for
improvements that are worth considering
are changes to the language witching
significantly increase the readability
of programs if we can read programs and
understand what they're doing better
than we can now then that's maybe a
worthwhile thing to do also if we can
significantly increase the productivity
of the programmer so that something that
you'd now do in ten lines you can now do
in one line go yeah that kind of
amplification I like that so taking
something you can do in ten lines and
doing it in nine lines I don't think
that's a win I think that's probably not
worth doing the most important thing and
possibly the only thing I think we
should be considering is security
because the biggest problem in in the
browser platform is its susceptibility
to cross-site scripting attacks there is
no more urgent thing to work on than
that
so cross-site scripting attack means
that an attacker can get some script
onto your page and then he essentially
gets control of everything so what
exactly does he get to do first off the
attacker can request additional scripts
from any server in the world there's the
same origin policy in the browser it
does not restrict his ability to go
anywhere in the world to get more script
it takes only a tiny amount of
JavaScript or a tiny amount of HTML and
you can then load megabytes of
additional programming that can come in
and and complete the attack once it gets
a foothold it can obtain all the
additional script it needs the attacker
can read the document the attacker can
see everything the user can see and also
things they use it can't see you can see
all of the source you can see all the
comments it
can see the hidden fields' and the
values in those fields it sees
everything that was delivered to the
browser
the attacker can make requests of your
server now if you're smart your server
is looking for secret tokens of
authorization which say this is an
authentic request and I will only
respond to these things but the attacker
has access to those same tokens there is
no way you can distinguish honest
requests from evil requests you cannot
tell if you're using SSL and you should
he gets access to your secure channel
your server cannot detect that the
request did not originate with your
application if your server accepts SQL
queries then you have given the attacker
access to your database now if you're
constructing SQL queries using
information that you obtain from the
browser you probably gave him access to
the database it's because SQL was
optimized for SQL injection attacks the
attacker has control over the display
and can request additional information
from the user one common technique when
an important request comes from the
server you ask the user or it comes from
the browser you ask the user to enter
their password on the assumption that
the attacker doesn't know the users
password but the attacker has control
over the display so the attacker can ask
the user what's your password and the
user will tell them because particularly
if you have a site which routinely asks
the user for the password what you're
really doing is training the user to
give up the password anytime anybody
asks because that's just how it works so
it makes it really easy for the attacker
to get at that now browsers today are
coming with a lot of anti-phishing
chrome which is a really nice thing
except most users don't pay any
attention to it but if they are paying
attention to it that chrome will say
this is a legitimate request give it up
the attacker can then send all the
information it has obtained from
scanning the page from querying the user
in
from attacking your database and send it
to any server in the world again the
same origin policy does not restrict his
ability to distribute this ill-gotten
information the browser does not prevent
any of these things now I'm not talking
about bugs you know obviously there are
the web is famous for its bugs and there
been lots of security mishaps but I'm
not talking about that I'm talking about
standards the problems that I'm talking
about are a direct consequence of the
web standards web standards require
these weaknesses if you do not have
these vulnerabilities in your browser
you are not web standards compliant the
web standards are wrong and have to be
fixed the consequences of an attack are
horrible there can be harm to customers
there can be a loss of trust there can
be legal liabilities in some cases there
can be criminal liabilities and it's
just waiting
everybody here is susceptible to these
attacks and it's just a matter of time
before you get clobbered cross-site
scripting attacks were invented in 1995
they were enabled by the Netscape 2
browser have been copied into every
browser since then we have made no
progress on the fundamental problems in
14 years and this is intolerable we've
got to change this so why do we have XSS
what what are the causes of it with it
in any complicated problem that you
can't identify a single cause but these
are the major contributors first the web
stack is way too complicated there are
too many languages like HTTP HTML CSS
JavaScript URLs all with their own
encoding commenting escapement
conventions they can all be nested
inside of each other as a consequence
it's really really hard to look at a
piece of text and determine if it's
benign or not in addition that the
browser's do heroic things to try to
make sense of malformed content they did
that early on to gain market share so
that incompetent webmasters would
not make them look bad but today those
features really benefit nobody except
the bad guys but they're still there and
are now being institutionalized in html5
we have dependence on template based web
frameworks that are optimized for XSS
injection on all of the peas ASP JSP PHP
all these templating systems make it
really easy to insert evil script and
send it back it's possible to use all of
these frameworks correctly but it's much
easier to use them incorrectly and so
that's the way they're often used the
JavaScript global object gives every
scrap of script the same powerful set of
capabilities so all script is the same
on now as bad as the browser is at
security it is a vast improvement over
everything else it's way better than the
desktop in terms of managing the
security of the user
the problem with the browser is that it
does not anticipate that there are
multiple interests on the page more
interests than the user and the site and
that is the the root cause of the cross
side scripting problem so fundamentally
cross-site scripting is a confusion of
interests it's dangerous it needs to be
corrected now solving the XSS problem
should be our number one priority in
looking at web standards we cannot
tolerate web standards that make things
worse which so mashups are
self-inflicted cross-site scripting
attack mashup is an application made up
of programs representing multiple
interests that cooperate together in
order to create some benefit for the
user it's the most interesting thing
we've seen in software development I
think in 20 years but it's not safe yet
because of the cross site scripting
problem turns out advertising is a
mash-up and advertising is the way the
web pays for itself but advertising is
another self-inflicted cross-site
scripting attack and we've seen lots of
cases where
problems in the ad system have caused
sites to get attacked we have made a
little bit of progress on the mashup
problem with the security avec subsets
there are a number of these two of them
are kaha which is a Google system it's
being used heavily at Yahoo and my own
ad safe they're both based on the same
theory but take different approaches to
achieving it kaha translates JavaScript
into JavaScript adding stuff which adds
indirection to access of global
variables inserts runtime checks to make
sure that this doesn't get bound to the
global object things like that
unfortunately that causes a lot of
inconvenience to the developer and can
make the code run more slowly ad safe is
a static verifier it's built into J's
lint it enforces that you're using a
smaller subset of the language which
excludes use of global variables
excludes use of this and limits use of
bracket notation so there's some
inconvenience there but there's no
runtime penalty both work both make it
possible to add third-party code to any
page and have confidence that that
third-party code cannot get out of
control and do all the things I just
described both have informed
Eckman Script fifth edition strict mode
which ACMA script fifth edition was
approved last November features of it
are starting to appear in the newer
browsers now hopefully by the end of the
year we should start seeing it
completely implemented es5 strict makes
it possible to have static verification
of third-party code without over
constraining the programming model so
basically we get the best of kaha and
add safe where we can do static
validation on some guest code but
allowed to use a much larger fragment of
the language there's still a lot of work
left to do yes five strict does not
protect pages from cross-site scripting
injections so that's still a
vulnerability we still need to fix that
it can protect the page from widgets but
it cannot protect the widgets from the
page so that means you can't put a
banking widget where or an add-on to a
potentially dangerous page so that's
still a problem but it is an important
step toward a programming model in which
multiple interests can cooperate for the
users benefit without compromising each
other or the user so again ie6 must die
because we can't use any of this es 5
strict mode doesn't do us any good if
people are still running ie6 because it
will never have us 5 on it so we have to
get rid of ie6 the the right thing to do
would be to have everybody look at what
browser is coming to them and if it's
ie6 send them to a page saying here are
five new browsers that you can download
in their free go and do one of those and
come back right now nobody is doing that
because basically Google doesn't want to
be sending its ie6 users to Bing and
Amazon doesn't want to be sending them
to Barnes &amp;amp; Noble
so we all have to agree to do it at the
same time and I proposed the day we do
that is 30 days after es5 is complete in
all five browsers that day is not far
away and when that day happens ie6 dies
um now es5 strict does not solve the XSS
problem that's still there it only works
for good guy code code that we invited
onto the page code that we did not
invite is still there and it's still
dangerous so we still need to fix that
and we're looking at doing things in the
next edition of Vecna script that will
solve that getting rid of the global
object entirely stuff like that but we
also have to fix the Dom fixing Xmas
script and not fixing the Dom doesn't
accomplish anything so I don't want to
risk anybody in these bubbles but
the DOM is an awful API is anyone
discovered that yet it inflicts
tremendous pain on developers and it
enables XSS attacks it's bad it's got to
go so that brings us to html5 html5 is a
big step in the wrong direction there's
a lot of stuff in html5 but security was
not solving the cross side scripting
problem was not one of the goals of
html5 they did not accomplish it I think
instead they make matters significantly
worse and they make things worse in
three ways
first html5 is complicated complexity is
the enemy of security they significantly
increase the size of the attack surface
which is going to make it even easier
now for the evildoers to hide their
stuff and get it in their second when
the attackers are in there they get more
capabilities because they get to take
advantage of all the new stuff that
html5 provides which cannot be
restricted from the attackers and so
they get access to your local database
they now have sockets they now have
inter-process communication they can do
a lot more bad stuff and they used to be
able to do third html5 is going to take
a long time to complete because it's so
bloated and grotesquely big so if the
solution to this problem has to wait
till HTML six how many years do we have
to wait before we can start work on that
so I think we need to do a reset on
html5 I recommend that we throw the
current html5 proposal out and start
over from scratch we start with a new
charter which makes the timely solution
of the XSS problem the highest priority
and the old html5 set can be mined for
good ideas as long as they do not
undermine the prime objective so my
proposal for the next browser standard
is that it have two modes in it first
the compatibility mode which contains
HTML 4 and Ekman script 5 and that's
there to support the old application so
that we can have continuity on the web
more importantly it's got a new opt-in
safe mode
that has a new HTML language which has
Ekman script six or seven or whatever
the next number turns out to be and a
new Dom and I recommend that the new Dom
should look like an ajax library because
the old Dom doesn't really work it's up
the wrong level of abstraction Ajax
libraries are wonderful the current Ajax
libraries were not designed for
capability security but I think we can
take the things we've learned from the
Ajax libraries and make one that's good
easy to use powerful expressive and safe
now a lot of people despair when you
talk about security because nothing has
ever worked you know there is security
by inconvenience which you see at the
airport where they qsr like cattle and
it's provably
inadequate it does not work but they
make us take our shoes off anyway
because they have to have the appearance
that they're doing something that turns
out doesn't work in computer systems
we've seen secured security by obscurity
which doesn't work we've seen confusion
of identity that if somehow we know who
everybody is then we can make good
decisions about security that turns out
not to work so we're reduced to security
by vigilance which means you have to be
aware of every potential thing that can
go wrong and actively work against that
now the corpus of things that can go
wrong in the browser platform is way too
big for developers to manage we're
constantly learning new things that are
wrong with the browser and expecting
everybody to stay current is just
impossible so we've gone to
specializations and now we have
computers but our security specialists
and the developers but that doesn't work
either because it's too difficult
because now the developers are not
responsible for security someone else is
and it just doesn't work it turns out
everybody needs to be responsible for
security but in order for that to work
that the whole process has to get
simpler the good news is that I think
security can fall out of good software
design it turns out really good software
is also secure software and if security
becomes part of your design model then
it it's a lot easier to manage so I'm
going to share with you a model of
computer security based on information
hiding information hiding means
need-to-know
I highly recommend that you go to Yahoo
in Google for this paper David Parnas on
the criteria to be used in decomposing
systems into modules it's an old paper
it's from 72 it's one of the software
engineering classics you really need to
read this paper um parts of it are dated
for example he he says that you
shouldn't do flow charting when he wrote
the paper everybody did flow charting
that was the way we were told to design
software we don't do it today because of
this paper you know so the things in
this paper that are dated are because
the paper was so good so you need to
read that um taking the stuff that
Parnassus suggests and taking it forward
a reference to an object or a reference
to a function becomes a capability the
right to interact with that function or
object and that becomes the basis of
security so now we're not just doing
information hiding we're doing
capability hiding and distributing
capabilities but on a need to do basis
um so in an object capability system
which is what we're evolving ECMO script
into they're exactly three ways to
obtain a reference by creation by
construction and by introduction so by
creation means that if a function
creates an object it gets a reference to
that object and that's just necessary
construction means that an object may be
endowed by its constructor with
references that this could include
references in the Constructors context
and inherited references and then three
the interesting one is by introduction
so here we've got three functions a B
and C a has references to B and C B and
C do not
but it's an eighth interest for B to be
able to call C so a does an introduction
a calls be passing it as a parameter a
reference to C and when that call
completes B now has the ability to call
C it has the capability to call C so
that's why the style of security is
called capability security this is
really simple stuff I mean you do this
stuff all the time this is what happens
with callbacks this is what happens when
you store a function into an object it
turns out you can build secure systems
out of this stuff if you just put some
constraints on it if references can be
obtained by creation construction and
introduction then you may have a
capability safe system and if references
can be obtained in any other way you do
not have a safe system and that's where
we are today
that's why cross-site scripting attacks
happen so ACMA script is being
transformed into an object capability
language we made some important steps
toward that with es5 strict I expect
will do even better
eventually removing the global object
which is the primary source of of
capability leakage remove that from the
language and we must also transform the
browser into an object capability system
I believe that we can do that in our
lifetimes I think we could even do that
before the decade is out I don't think
it's all that hard we just need to make
it our first priority for more
information on on the object capability
programming model I highly recommend
marks tiegler's
talk they gave it at Google last month
you can find it at YouTube the lazy
programmers guide to secure computing
really really good talk so now in
conclusion the web is important enough
to fix html5 does not fix the web I
think it makes it worse
we need to reset html5 and start over
thank you and good night
so are we doing questions we do
questions yeah okay yes so I'm
interested in what you're saying about
trying to solve XSS but you seem to be
kind of putting two issues together
there's in a mash-up you have code and
resources from multiple sources multiple
interests and you want to shelter them
from each other so they can't interfere
that's a very noble goal but as somebody
who professionally broke into a web app
for eight years like it's like the main
way we dead end is through in motivation
we inject code in and so we are in the
interest of the application so doing
things like removing the global object
or this kind of sequestering it doesn't
happen we get around it does matter in
the capability model you could sneak
some new text in there but that text you
know each of those pieces of text is
going to be a separate compilation unit
will not have access to the global
object so um if anything could cause it
to run it'll run but it cannot
communicate with anything else on the
page so but a lot of times what
cross-site scripting attacks can do is
not necessarily steal information from
the page for example you can use making
image requests and on error and onload
actually ports and internal networks
right I'm saying it doesn't get access
to those because those are on the global
object it can't see them so what would
be the model of saying this or this
operation unit how do you I'm saying all
compilation units nothing has access to
the global environment so the page can
then explicitly introduce each of the
compilation units that it wants to have
access to those capabilities but nothing
gets those capabilities by default and
if there's code on the page that the
page is unaware of it doesn't have the
capability to give it an introduction so
that page is necessarily isolated or
that code is isolated cannot cause any
damage
yes follow up on that a little bit it
seems like it'd be tricky reconcile with
having generic code like xmlhttprequest
that you can use to make a request
against any string URL that's on the
current domain so if that got passed you
got a service to that website right so
one of the capabilities in the system is
going to have to be the ability to
communicate and be able to further
constrain what you can communicate with
so having all code instantly being able
to communicate globally that's probably
a capability we need to shut down
anybody else yeah yeah um it's really
hard to say the html5 committee is
behaving as though it's a done deal
w3c appears to be powerless to inject
any management responsibility or
discipline on the process so there's
some view which says it's doomed to
succeed the thing that could derail it
is if this community if the web
community stands up and says no this is
not responsive to our problems we need
something better
I think w3c would listen to that yes as
far as the beaches of they were looking
for I mentioned very attic functions is
there any support method
yeah we are looking very carefully at
that that turns out to be a useful
capability pattern you have an object
that wants to be able to relay requests
filtering some and passing through
others and so having that kind of
mechanism is going to be very important
all right well thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>