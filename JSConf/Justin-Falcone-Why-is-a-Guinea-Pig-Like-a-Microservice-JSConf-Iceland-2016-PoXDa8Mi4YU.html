<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Justin Falcone: Why is a Guinea Pig Like a Microservice? - JSConf Iceland 2016 | Coder Coacher - Coaching Coders</title><meta content="Justin Falcone: Why is a Guinea Pig Like a Microservice? - JSConf Iceland 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Justin Falcone: Why is a Guinea Pig Like a Microservice? - JSConf Iceland 2016</b></h2><h5 class="post__date">2016-09-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PoXDa8Mi4YU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so these are my critters
allegra and claritin now about a year
ago i started a project well i started a
Pinterest board called guinea pig fairy
village my my critters have a fairly
large cage but you know I dream bigger
my vision was that instead of just
having a regular cage they could have
something that was I know somewhere
between like the Keebler Elf tree and
the village from The Hobbit and then I
thought like well guinea pig their
social animals if I if I'm building a
hobbit village and why stop at two
career so I gotta have a whole colony of
them you know I hit some roadblocks
almost immediately three problems one as
the name suggests i am quite allergic to
them to a given i can barely clean off
after two guinea pigs there's no way I'm
going to keep up with like a whole
village and three I am not particularly
handy and I don't think that they sell
this at IKEA um but you know I'm a
programmer I'm a problem solver I might
be a lazy slob but I can work with that
so I at first I think well maybe I can
just release a bunch of dung beetles
into the village and they can I can just
let nature take its course but then but
then I think why would I build anything
all I'm a programmer I could make a
virtual guinea pig village that critters
could live in cyberspace and then when I
start thinking on this I think no oh no
if this thing I could do this as an app
I can do in app purchase it could be to
take off i can start making that the Kim
Kardashian bucks but but before I get to
all that I'm not really I'm not here to
talk about getting rich with free to
play games i'm i am here to talk about
my design process and now I the last
couple of years I've seen an interesting
progression I mean I used to be you know
full stack but a lot of what I was doing
in the full stack has moved to the front
end but you know even though the work
has shifted entirely client-side I'm
still applying the same client server
patterns within the client just at a
smaller scale it's like yo dawg i herd
you liek client-server architecture so I
put yell you know as
gone into the reacting co system I keep
seeing things like this and parallels
between the what we do on the client and
what we used to do in the whole system
and I'll encounter something new like
frp or events or sing or sagas only to
discover that they've been around for
like 20 or 30 years in the back end
world and this got me thinking about the
the history of ideas and the way that
the way that they spread and mutate on
though the everything is a remix so as I
walked through my design thinking on
this virtual critter village and try and
trace the history of these patterns and
ideas my hopes are that if we can
recognize the parallels between then and
now I will be able to identify where
things can go wrong without having to
make those mistakes all over again so
let's call this product critter ville
hopefully I can think of a better name
before I get a cease and desist from
zynga now now in this this game or toy
or whatever it is uh the the the goal is
that you you you have a you build a
village for guinea pigs with no fixtures
like food dishes and houses and toys and
stuff and your goal is to attract
critters to the village and then keep
them fed and healthy and happy now as
far as how I'm modeling the critters you
know guinea pigs are not particularly
sophisticated animals they have uh you
know and you know the way my modeling
this with very simple behavioral
feedback loops you for example when they
cross a hunger threshold they'll try and
eat food also they poop constantly which
the user needs to clean up and happy and
healthy happy and well-fed critters are
friendly to you and each other but a
jeté tanned hungry critters get
aggressive and eventually leave the
village so I think I'm ready to start
expecting this out so but where do I
begin what kind of artifact do I want to
use as my reference ah there's a couple
of different design approaches I've seen
now I to work a lot in agencies and
design process it seemed to be I would
get a mock-up and then be told to like
work down the stack from there where I'm
supposed to figure out how it works
based on what it looks like now there's
there's obvious problems with that but I
think the opposite approach doesn't work
either you know a lot of times when
engineers are tasked with like
cataloging requirements we think okay
we'll make an erd and you know well it
will have
this giant database schema and we'll
figure everything out beforehand then
we'll build up the stack from there I
get why people follow these approaches
by say tended to major problems with
them first is that they the commingled
the ideas with the implementation I want
to map out the problem of modeling a
guinea pig village that that has nothing
to do with page layout or whether I use
like a var char instead of a text second
both uhh both comps and databases Davis
schemas they answer what it is but not
so much what it does I you know in
addition to like the facts i also want
to identify things like what are the
commands i can issue one of the
questions i can ask in other words like
what are the messages between me and the
computer going to be so the design
artifacts i'm going to start with the
sort of like the core principle of this
guinea pig system is a vocabulary of
these facts and messages I don't think
of these as technical terms they're not
this is not again it's not
implementation details this is all about
this is all about the domain of the
problem this is this is an idea i'm
lifting probably incorrectly from eric
Evans's ubiquity domain-driven designs
ubiquitous language now this again this
isn't this is similar to like a an API
or a schema but those are more
implementations of a vocabulary for the
computer to work with I'm trying to
think more an abstract level right now
like like what terms am I gonna use in
the documentation what words would I use
on buttons and labels now make this a
little less abstract let's think about
what the doms vocabulary is I mean we've
got we've got the HTML tags attributes
and properties input types events uh you
know but and also we have the the terms
that we use for categorizing them you
know tags attributes props inputs events
those are those are all part of
vocabulary as well I think this is
actually the harder part of the
vocabulary is defining the like that the
taxonomy it's easy to identify like the
concrete terms of the domain but it's
it's tricky when you need to talk about
things that are more abstract or more
about categorization I mean if you need
any example of this I mean how many
people here know what the difference
between an attribute in a pro
is I see one hand I when I was working
on this I I feel like I might know what
it is I think it's one of those like
instance versus class type things but
I'm probably wrong and that's why I'm
just lumping them together now another
Chanin challenge of managing the growth
of a vocabulary over time is uh you know
how do you grow it how do you how do you
grow it in a way that's organic but not
haphazard this is another problem that a
lot of people have with the Dom there's
there some places with it works out
really nice like I think it's nice that
all the input types are you know the
inputs are basically have they share
very similar interfaces and then you
know all the the fancier inputs will
degrade into a simple text input but
then we also have things like text areas
and and selects which are you know sort
of artifacts of you know the the
thinking in 1991 where it's like oh well
HTML is not gonna get any bigger than
this we don't need to add sub
categorizations and you know then they
have their own totally different
interfaces and then you it it adds
complexity to have this or or another
example would be the way that we have
like three different systems for doing
document outline we have like the h1
through 86 we have like nested lists and
then we also have the what's that like
the nested sections and then sections
and sections having sections are suppose
to have their own document outline but
note that was never implemented now in
you encounter a lot of these
vocabularies in in our day-to-day work I
think as much as we think of programming
in terms of like oh well it's its stem
it's it's it's just it's a it's all just
math and algorithms and stuff most most
of the work that I do especially maybe
as just as a front-end developer is
thinking about like the the thing that
this from a linguistic perspective and
like you know maintaining and learning
and creating vocabularies um you know
that you know if every domain that we
work in has its own terms and sometimes
they sometimes terms have similar
meanings but or as they 44 sometimes
terms will have different words for the
same meaning or domains that intersect
like the dominate GP will have like
intersect will have different terms for
the same thing or you know weird meshing
issues and you know at the risk of a
circular definition though I think that
what makes something understandable what
would make something recognizable as a
problem domain is that we can say that
we have a vocabulary for it so before
before I even get the implementation of
critter ville I want to think about what
the vocabulary for critical is going to
look like so I've got my mind's the
entities in critter bills if I'm gonna
add another kind of creature like dung
beetles for example that would go in
this column but then I have to think
about if I'm going to add a lot of
creatures or a lot of different fixtures
do I want to break that into
subcategories I also have my verbs these
are these are the actions that are going
to be performed by the user or the
critters I mean and I have these
categorized by subject but you know
maybe I'm going maybe if I have a
different kind of thing that can you
know have actions and I me I'll need to
think about like do I want to add this
to the this set or do I want to create
another layer of taxonomy and then I've
the the traits the you know the
qualities that affect the state and
behavior some of these are going to
apply only to critters and like fear and
hunger others like position those apply
to you know everything your poop has a
position even though it doesn't have a
lot of other traits every poopit for the
purposes of critter ville simulation and
say every poop is the same that's not
actually true don't don't at me now
something you may have noticed is that a
lot of the vocabulary been talking about
is is it's related to the interfaces of
the respective domains you know the
these are all terms that I'm
encountering as a user of HTTP or of the
Dom not as someone who's building it I'm
I'm sure that a well-organized
vocabularies really useful for the
implementers but it's absolutely crucial
for the consumers and this is because if
I'm working on the browser the only way
to interact with the page is through the
doms interface I can't write to the doms
memory you know kangas gives you a
little bit of that but Candice has it
have it has its own interface it's just
lower level you know in order to work
with these interfaces I need to send and
interpret messages that conform to their
protocols now for example let's look at
the HTTP the hypertext transfer protocol
for transferring hypertext
a typical HTTP interaction has the you
know client sends a request server then
sends a response back so a request I
mean this is you know what do we have in
here this it's just we have the method
that would get the path version and a
couple of other headers for metadata and
then we've got the the response which is
the unity htp version a status code more
metadata and then the actual page that
was requested another another kind of
message is a again with the Dom we Dom
events have a different purpose in a
different context and HP requests
because they're on the same computer and
they did the data doesn't need be
serialized into text but they share a
fundamental rationale communicating
between two isolated environments in
this case the native browser UI in the
JavaScript runtime in both cases there
are security rationales behind this air
gap in HP's case there's there's an
initial goal of network efficiency but
the goals of both these protocols are to
enable communication between two parties
without intimate knowledge of each
other's innards they only need to speak
the same language then JavaScript when
we deal with these messages it's often
in terms of like events and event
handlers where we run a call back
whenever a received message mapped as a
particular pattern and now terminology
note I'm sure there's a distinction be
made between events and messages and
actions and all that stuff but for for
our purposes they are basically the same
I think that this here the this jquery
event listener is how a lot of people
first encountered this I mean this is
when when when I got into web
development this was jquery was king as
i would have used the the native Dom
version but it's actually too long to
fit on to a lot of blank vids legibly as
this handler is for listen listen to DOM
events of type click sent to that button
and then a call show menu and we see the
same pattern in so this is like Express
a interesting thing here is this is
matching on both the post HTTP method
and the path users and ID then node uses
the same patterns for signals and
streams and I know if anyone saw the
bb-8 talk
person who gave it us in here if you saw
the bb-8 talk the inter process
communication works in very much the
same way that's not the only way that we
encounter events in JavaScript so like
react and old-school HTML of course they
have their in line handlers react also
has its life cycle events it's because
because they're met we there operate the
operators methods we don't necessarily
think of them as event handlers but they
totally are in fact this is how events
are handled in most you know typical
object-oriented languages and then Redux
is actions redux those are also you know
another events or messages or whatever
and it really doesn't offer you any sort
of pattern matching that leaves it
totally up to the developer so it just
sends you it sends you every action to
every reducer and then you know you're
up to you know whatever right a giant
switch statement to match on that
pattern now the biggest advantage of
message passing is concurrency many
messages can be flight at once this is
also one of its biggest challenges it's
as you can see it's easy to get confused
about you know what messages are in play
and create race conditions because
messages aren't being handled in the
order you expected so when one of the
big challenges in development today is
how do we manage messages so that we can
you know deal with them in an orderly
fashion now another another problem you
encounter with messages that they're not
always meaningful in isolation this is
something that we encounter all the time
I think about what a pain in the asset
is to make the flow of form validation
feel right or like have you ever tried
implementing double clicking from
scratch it's a huge pain in the ass it's
it's your messages might need to cancel
each other out or happen in a certain
sequence or within a particular time
frame or trigger sequences of other
events like the the force traveling
through the balls of an executive desk
toy if messages are the balls what are
we go what do you call the force anyone
sees everyone seen this ad on Twitter
right this you have no idea how much
anxiety this gives me anyways maybe an
even more basic question is where where
are the messages coming from and where
are they going who messages the
messengers
now I mean I'm gonna call these I'm
gonna just gonna say call them processes
what is the process an entity that sends
and receives messages from an outside
perspective that's all it needs to it's
it's totally black box you know
processes purpose is to contain and
confine computation so you can you can
model a process something that like D
bounces clicks into double clicks of the
process you can also model a whole
server as one now I name this with with
UNIX processes in mind but it also
describes you know web workers have the
same interface like actors in Erlang
even a lot of the code like that upholds
these boundaries like a redux store
retext or has has its interface of like
it you know reads from dispatch and it
writes to get state and you know of
course a lot of languages that have
their their term for an entity with
private state that communicates through
message passing is an object you know
what else fits this model oh boy it's
microservices so every time I give this
talk I feel like I understand
microservices less and less it appears
to be you take a big box and you split
into a bunch of little boxes in
sometimes the boxes are hexagons and of
course now microservers is a totally
passé I think the next time I give this
talk at all I'm gonna have to change
into like how is an ant farm like
service service architecture but the
technical reasoning behind microservices
is that by splitting up a monolithic
server into a bunch of little
independent ones you have more
flexibility for scaling in redundancy
but but the stronger motivator behind
this kind of architectural rewrite is to
enable or I guess force team
independence now why do we want
independence is this is this like a
libertarian thing I mean it's it's
definitely a less familiar way of
designing software and it's you know
it's a lot more complex why are we going
to the trouble of encasing every little
thing in a suit of armor we do this
because conceptual boundaries enable
material boundaries fit no boundaries
across time or boundaries across space
an independent process can be made to
run on separate cores or on separate
continents but conceptual boundary
also enable cultural boundaries you know
what well-defined boundaries allow me to
use your software without knowing
anything about how it works that's the
same whether we're on different teams
within a company or if we're in like
working on totally different projects if
you're if I'm using your open-source
work but there there is absolutely a
trade off these boundaries have a cost
especially we don't need them it's easy
to look at what's happening now I think
that we're seeing a steady trend from
Spencer realized centralized to
decentralize as mana lists are split
into micro services but we're not it's
we're just in a downward swing of the
pendulum a a turn of the Hegelian
dialectic the react world is on the same
cycle but oddly enough it seems to be on
the opposite phase so right now we're
actually centralizing state management
out of individual components into a
single store now where we have the same
trade-offs that apply you know
simplicity of the whole versus
simplicity parts or we you know our our
culture is has just you know for the
moment decided that like the one is more
valuable than the other but maybe this
means we can see the future we know that
there's that there's this pendulous
motion this we can look at something
like elixirs Phoenix framework and how
it employs you know it combines things
it's a synthesis it you know it employs
some of the conventions of like a rails
monolith but in you know in a language
that is built for a fine rings and
currency and distribution it's it's
neither as holistically or individually
simple as either of the ideas that
synthesizing but the compromise is an
improvement over either extreme so what
would this look like for a front-end app
the big performance bottleneck in
JavaScript of course is single threading
but the big conceptual bottleneck is
around managing you I data and
networking in a single brain now a
specter is haunting front-end
development the specter of service
workers I see a world where data and
network management everything that is of
interest or not everything is interest
everything that is like data intensive
and an app gets moved as a service
worker that's a completely independent
entity from the UI do you I can become
you know go dumb again now when the
advantages here is like once you force
the separation of
why and data into like totally different
processes you can put them on different
machines I mean maybe maybe this is the
the step that we need to take another
crack at like the meteor or the hoodie
approach of having you know synchronized
clients and servers and now I did
something uh you know occurred to me as
I was working on this if I have critters
running over the network does that mean
I'm making a massively multi-core online
rodent petting game sorry oh wow that's
a lot of stuff I feel like I just I i we
just went through one of those like 15
shorts about like oh gee whiz I didn't
realize springs were so important except
except about message passing but you
know I think that JavaScript has been
going through an interesting cultural
shift in the last I know like three
years or so now we've never had a PA
strong culture around object-oriented
programming and you just don't see talks
about design patterns or solid
principles at javascript conferences but
we can begin more and more interested in
functional programming you know first
with underscore and then with underscore
doing it wrong the things really really
took off with react and now there's a
bunch of JavaScript developers still a
minority but a hell of a loud one
getting interested in like immutability
and referential transparency and monads
and compiled the jas languages like
closure script and elm there I'll bring
this to the browser and granting us as
humble JavaScript erza you know a
glimpse into into this this this this
future futuristic world but along with
that comes dogma now of course there's
the usual suspects with them I paradigm
can beat up your paradigm I mean what
can i say redditors gonna read it but
we've also got seemingly respectable
members of our community saying that you
know if use classical inheritance your
company will go out of business but
javascript is it's fundamentally
incompatible with ideological purity if
you want to go fully full-on year 0
there have never been more options to
choose from but javascript isn't
necessarily a big tent language that has
to solve needs beyond our own hey
javascript has to go continue to solve
the needs of people going back to
nineteen ninety-five you know so we
don't break the web
and as far as object oriented
programming goes I think there's a lot
of useful wisdom in the in the last 40
years of study you know the the date on
that last screenshot is October 12 1977
we should think about how we can
synthesize that with our newfound love
of functional programming and this was
my big awakening with react and redux
you know sure component renders and
store reduces those are pure functions
no side effects no mutations but
everything supporting them is the
opposite you know the reactant react
component state and lifecycle read X to
subscribe to this crap dispatch these
are all about side effects react and
redox aren't a rejection of
object-oriented programming so much as a
reinvention of it instead of thing of
about functional and object-oriented
programming as competitors we can cinema
is operating on maybe different parts of
the problem or at different scales we
can stop thinking about objects as smart
data structures to start seeing them as
systems for communing coordinating
communication you know processes
microservices actors workers
bureaucracies guinea pigs a zombie with
no conscience wait that's the last one
what does it mean when we can see all of
these through the same lens it means new
avenues for understanding new
possibilities for collaboration
vocabulary of front-end development
becomes so much richer or we can adapt
patterns and terminology from
distributed systems into client-side
apps running cross web workers and the
scales fall from our eyes we can finally
see how the Internet of Things is just
it's just object orientation made
horrifyingly literal you know JavaScript
defining characteristic whether for good
or for ill is that it is always
accumulating never removing but this is
you know this is how society functions
you can't roll back the clock hogatha
you don't have to start from scratch you
just keep moving forward and and just as
event sourcing is where you know current
state is a left fold of her previous
behaviors society is a left fold over
ideas and dogma is toxic to a society
dogmas terrible is toxic to culture and
we need to we we need to be thinking
about we need to be seeking out new
ideas but we also we need to be
synthesizing and compromising those
ideas into our primary knowledge and
experience
yo hey you never know when the new idea
you've discovered is actually uncovers
the hidden wisdom of everything before
it thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>