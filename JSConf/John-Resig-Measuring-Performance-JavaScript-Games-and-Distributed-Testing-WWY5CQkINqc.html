<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>John Resig: Measuring Performance, JavaScript Games, and Distributed Testing | Coder Coacher - Coaching Coders</title><meta content="John Resig: Measuring Performance, JavaScript Games, and Distributed Testing - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>John Resig: Measuring Performance, JavaScript Games, and Distributed Testing</b></h2><h5 class="post__date">2013-01-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WWY5CQkINqc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I guess it's a secret topic that
that's kind of allies because I was very
lazy and actually thinking of a topic so
this is uh I guess kind of merge
together three different things that are
interesting me as of late measuring
JavaScript performance creating
JavaScript games and then distributing
JavaScript test Suites I have a lot of
slides a lot of content to cover so I'm
going to just try and go through them as
quickly as I can if there's any
questions please just raise your hand
and hopefully we can tackle um right
away so as a mention of measuring
accurately measuring JavaScript
performance has been of great interest
to me especially since I've been working
on things like jQuery and trying to
improve its quality so a the typical
technique that's used for analyzing
performance is to measure the
performance JavaScript from within
JavaScript itself and you use the the
typical you know like a new date get
time so getting the current timestamp
and then doing some sort of diff in
between two times that's one way to as
our to measure performance but the
problem is that it's it isn't
fine-grained enough that you're
measuring at best in a millisecond range
but the thing is is that it can still be
very useful for some general analysis so
one of the things that did is I created
a plug-in called a stack profiler for
jquery one advantage to jquery is that
it has a very flat api that has
essentially one namespace and there's
tons of methods that exist within it but
that makes it very easy to analyze in
the profile so in this case this is a
it's cropped off here but it's the
github a homepage and I stuck the
profile or inside of it and what it does
is it goes through an analyte and it
clicks every single a jquery call that
occurs within the website so in this
case you can see that
let me see here there's a number of
methods a I called but there's one down
there the end called out face box so
it's the face box jquery plugin that's
getting pulled in and that's taking up
17.6 percent of the execution time on
page load so simply the fact that they
are including facebox slows down their
load by almost twenty percent and so
this tool is i think is especially
interesting since then you can use it to
start to dig in and get a better picture
of where all the resources are going
within your web page so this is
something you can do with very basic you
know get time analysis now the problem
is though is that timers in javascript
the reported time is not very accurate I
mean if you think about it you're
measuring the performance of JavaScript
from within JavaScript itself and that
is just you know there's so much room
there for for bugs to occur and so
something that starts to occur is so
what we have here let me zoom in a
little bit this is on OSX and we have
four different browsers Opera Safari so
for us of WebKit nightly and then
firefox 3 and these are running some
just some very basic tests nothing too
complicated and we can see at the time
is being reported out here these are
report in times of how long each the
test took to run so in this case there's
a lot of them run in 0 to 1 milliseconds
and then you have these little humps of
however many milliseconds it takes the
results here aren't terribly exciting or
interesting is just what it is but what
it when it starts to get interesting
though is that when you look at this
type of result and the compared against
what you get on Windows so this is a
very similar result or the same same
tests but they're running on Windows XP
in this case in an IE Opera Safari and
then WebKit and you don't see those nice
little curves anymore of where the
results were coming in so because if you
think about it if you're going to run a
test again and again you know sometimes
look at 10 milliseconds sometimes look
at nine sometimes we've got 11 sometimes
we get seven you know there's some
fluctuation there as there should be and
you see that very clearly and
our site results but in the XP results
you see that they only come in every 15
milliseconds there is no variation there
is no nice little humps and that's
because of this of a problem at least
with the most implementations on windows
XP which is that they only update their
timer every 15 milliseconds so it
doesn't matter how many times you call
get time it'll only update every 15
milliseconds so that means if you have
something that runs in less than 15
milliseconds that means is always in
report 0 and if you have event and
sometimes maybe it will report you know
a 16 and so if you look at you see this
happen in a lot of different test Suites
when this happens a lot in is the slick
speed a CSS selector analysis sweet and
if you run it on like internet explorer
you see like 00000 16000 and you're like
well this thing is so fast look at all
the great times are getting yeah I
average about you know two milliseconds
total and but the thing is is that it's
a lie and in fact that since the results
end up getting bend like this you have a
mass of air right in this case that you
can expect air rates of you know 50 to
seven hundred fifty percent on your
results which is just horrible so it's
something to be a very careful of the
the better alternative is to use a
performance tools this has talked about
a little bit earlier especially with a
Firebug in the Safari profiler but the
profilers that are provided by browsers
are definitely preferred to analyzing
the the quality of your code within
JavaScript itself and this is good
because browsers have started to release
more tools to make this easier I mean
there's been the the Firebug profiler
which has been around for you know some
time now they're the new safari profiler
it's in safari for is really good and
it's a it's about comparable with our
bug in some some areas and definitely
excels and then the new I ate profiler
and again this is uh this is something
that's brand new it won't help you for
i7i six but they're very least to have
some
sources for analyzing Internet Explorer
JavaScript performance so all these are
great and they're available now another
technique that I've been going on now
recently is instead of attempting to
attack but performance in strict
millisecond times are units of time is a
look at it another way I wrote an
extension this is actually an extension
for Firebug which is in itself an
extension for Firefox so it called fire
unit and fire unit it's a primarily a
testing framework a JavaScript testing
framework and you can use it and you can
run tests and log your tests results
inside Firebug itself but what is the
one feature that I added to it was the
ability to get profile data now what
this means is that in Firebug you get
these dumps in these in these little
tables so whenever you profile a piece
of JavaScript code you end up with this
table that you can sort and search
through but that isn't very useful in
and of itself I mean you could read the
results and interpret them but it would
be better to be able to programmatically
interpret those results so what I did
was I added a method called get profile
another it takes that table of data and
dumps it as a just a JSON data structure
and now you can use that structure and
so you have things here like iam time
and standard deviation or not this time
average time minimum time stuff like
that you can use that to create other
things this case and went through a
number of the jQuery methods and I
wanted to see how complex they were so
in the case of jQuery methods act
against a set of elements so in this
case add class is acting against 98
different elements i created a test page
with 98 elements on it and so that way
when you call add class it ends up
calling 542 functions somewhere in
either in jquery or elsewhere and so
that means that for every single element
there you're adding a class to that
you're going to be guaranteed at least
six function calls
so this call it sort of a big o notation
going back to computer science and that
for every single time you are performing
action how many you know at what rate
does it um a rape at what rate doesn't
scale so 6n isn't that bad it could
definitely be improved I would say so
because six functions for every single
element but then you go down you see
stuff like this so you have to remove
method and that is 2n plus N squared and
that is not good at all so that means
that for every method it was calling n
to the N squared times met other
functions so that is a problem right
there and that what's interesting though
is that that is something that did not
show up in my normal profiling when you
look at normal profiling you're like
okay the time seems pretty reasonable
you know it doesn't seem you know that
slow but once you you pull it out in
this way it becomes very obvious where
the problem is so in this case I went
through and started to reduce complexity
so I knew right away that remove had to
be improved so I've worked to improve
remove and as it turned out empty use
remove and HTML used empty so whenever I
ended the improvement in this case i
went from N squared 2 just 3 n 4 remove
method all these other methods benefited
and they started the scale much much
better and they perform much better and
so in this case these are improvements
that are becoming in the next version of
jQuery so I think this is important
because nowhere in these results do you
see time there's no milliseconds being
measured and I think this is important
because in the case of jQuery a lot of
the methods and jQuery are very specific
to the jQuery style of coding and they
can't really be compared from one
framework to another so comparing them
would be just Ingenuus and when the fact
jquery just needs to be compared to
itself in a very real way but i mean
this isn't specific to jquery this is I
think very a very general problem and
that if you want to know how to make
your code better you need to see where
not only words performing bad but also
when it's scaling poorly okay so any
questions real quick before I go on and
talk about games
okay so another thing that I've been
interested in lately is constructing
JavaScript games and as it turns out I
found to be much harder than I
anticipated for a number of reasons now
I think browser based games are
especially interesting because users can
all they have to do is type in a URL or
click a link and they can begin playing
instantly and it makes it really easy to
play at work and so lots of people you
know they'll be playing games during
work and just open it keeping a tab when
you know whatever and I think that's
great I love casual gaming so one of the
big questions is is why not flash you
know why because there's so many browser
based games that are developed a flash
and I think there's a couple reasons one
is that the the technology that using
javascript is becoming quite quite
portable and that not only if you
develop it as a browser game you can
then make it a desktop game using you
know either titanium or air or a
technology like that but it can also
translate well to mobile devices you
know on iphone pre other mobile devices
it'll work on the wii it'll also work on
a constrained devices like the oil pc so
i mean javascript is very very portable
while at the same time it's inherently
you know it's an open technology so all
this you know interest me a lot you know
the ultra portability so i think that
any game i mean this this isn't
necessarily just JavaScript but i think
a good browser based game should be a
multiplayer and can't be casually
cheated it works well everywhere and
it's addictive now the one of the the
major problems is that you know
javascript itself is you know anyone can
view this source yeah and it doesn't
even have to be in terribly technically
competent to be able to view this source
and in fact anyone who has Firebug
installed just you know go and change
score to 1000 and then
yes a they won so I mean JavaScript
games are just you know hard I said but
going back here so the III think
multiplayer is important because it
helps to make games really addictive and
that the people no longer feel like
they're alone and they want to keep
playing more and more so I break down
browser based games in three different
styles strategy games intelligence games
and accuracy games and a show how they
work well in JavaScript or not strategy
games they inherently they require
strategy then created to think and to
plan ahead and in that way it makes it
really hard to cheat so even if someone
was sitting there you know tinkering
with Firebug or writing a bar or
something it's really hard to cheat a
strategy game since you have to be
writing like an AI in order to to beat
it and so then son of itself is good I
just well there's a couple games here I
wanted to point out this is one called
war fish it's sort of a risk like clone
has a little bit of JavaScript not too
much this is other one called now online
this one's more of a trading game yet up
trading with partners along the nile for
resources this one has more JavaScript I
think they use prototype and rails
remember correctly so both of those are
very much strategy games but the thing
with sarah g games that they are very
much server-side heavy games and that
the vast majority of the logic is taking
place on the server and so that way it's
it's pretty hard to cheat since the only
way to cheetah is develop some sort of
intelligence to play against it and but
at the same time it's not very open you
know people can't read it and learn from
it and you know try to understand how
the game works so the second type of
game is intelligence games so as I
mentioned that you do see a lot of
JavaScript based strategy games this is
definitely the most popular use case
where you see JavaScript being used for
a game simply because most of the logic
is not contained within JavaScript
strategy of intelligence games are
usually games that are like you know
dictionary based or number bay
based on but the like sudoku you know
stuff like that but the thing is is that
this is it's very easy for people to
casually cheat these games so in the
case of like when the popular ones is a
scribe euless for example and that was
on facebook that was a flash game but
the thing is is that anyone could sit
there play against their friend and then
open up a dictionary in another window
and just sit there and spell amazing
words that they would never be able to
think of otherwise so again here's a
couple games these are JavaScript once a
weird twist is really fun it's like a
boggle game and you spell out words
really quickly Babel is another one this
one is similar but it takes place over
an entire day there's one game per day
and everyone works together to solve the
puzzle another thing I like about this
one is that there's a chat room in the
side and everyone talks and works
together to try and solve solve the
board and then this is by the same
people but this is a Sudoku again with
JavaScript so these accuracy games um
I'm sorry okay so as you mentioned that
accuracy games are another branch of of
games and but they have some very
specific requirements and that's the
require a very low latency and that they
have to be quick in that these are all
games that require the user to move
quickly to respond to specific events in
the game and the problem here is that
with JavaScript you have garbage
collection cycles javascript is
constantly trying to clean up memory and
is taking it will cause the browser to
freeze I'm sure many of you have seen
this where you'll be working then
suddenly it'll the browser of fries
momentarily and then you know the words
keep typing or what have you and this
sort of stuff is absolutely killer for
normal games since you the user can't
you know have their the game freeze
while they're playing so I I created one
game I want to pull it up here create a
little guitar hero clone may see here
so what I did was is I oked into YouTube
and the davidr youtube has a JavaScript
API for the flash videos so that
whenever you play you start playing a
flash movie you get you get a JavaScript
event and whenever it stops you get
another event and then play a pilot you
get you get you get javascript events
for all of these so hooking into that I
created a little game let's see if we
can give it a try here I don't know if
the audio is going to work it's
ridiculously hard I I'm so bad at it
there we go oh my god yeah so so uh when
you see it turn white that means i'm
getting one right yeah sorry i got one
there yeah okay so so this is really
hard you can see them like it ends up
being like really really choppy and it
just notices flying past and it's you
know the framerate is this just too low
in this case is just the canvas area
here so the way I'm drawing this is um
so yeah this is canvas i'm using the
processing jas although this is simple
enough that you know you don't really
have to use anything complex but i'm
getting the information from there's a
game called up frets on fire for windows
it's a guitar hero clone for windows and
you play on your keyboard and but what's
interesting about it has a whole
community around it of people who make
who take existing songs and then write
MIDI note files so that they'll have the
note files the midi of the midi song
will have five notes in it for each of
the keys you have to press and then you
sync it up and frets on fire you can
play your songs so what it is i wrote a
little python program it's a midi to
json converter so amid e is a bizarre
format as it is so anyway you get this
giant you just you get this JSON dump of
MIDI notes and then if I go through and
I'm just playing these notes and then
sinking it up with the video now when an
interesting side effect of this I think
it's pretty cool is that you can scrub
ahead and the notes will sync with it so
since everything is synchronized here
and I think that's pretty neat so but
ultimately I ended up abandoning this
game I just created as a little demo and
actually you can find it now if you go
to the jQuery home page and enter the
konami code this will pop up but the so
yeah but this is uh i was interesting i
had i love the initial idea oh this is
the amazing it's gonna work great but
ultimately I I had to throw away it just
simply could not render the notes well
enough or fast enough and without
that these garbage collection cycles
just destroying the game so I thought it
was an interesting proof of concept at
least so yeah another thing is that at
least in interacts for you be drawing
using the X canvas and that has issues
of its own so it's probably a certain
that at least as it stands now that
there's creating a JavaScript game is
really hard and that no matter what
style of game you're picking you're
going to be hitting some roadblocks
strategy games inherently are very slow
and they require a communication with
the server when the server has most a
logic anyway you're not writing your
game in JavaScript be running and
something else intelligence games are
very easily cheatable either you know
using like a dictionary or some other
technique and accuracy games are just
too hard to implement like in the guitar
hero one is this too hard at the notes
synchronized and everything so the
optimal game is gonna be one that's a
combination of all of these things and
so because of that i feel that
javascript games can't be like other
games in that um inherently they are
much harder to create and have their own
special characteristics so i wanna show
a couple games at least that i think has
a few JavaScript games that embody these
values and are still fun so and also are
easy you know can put me play quickly
have some sort of points have a high
score or head-to-head competition things
like that this is one game this one's in
JavaScript and I think I actually uses
xjs it's called out words play and this
is another another bottle game but the
difference is from the other boggle
games is that you're competing
head-to-head with other players and so
when you hit the page actually
connecting via comment stream in the
background and you're typing in your
words and at the same time other people
are typing their words as well and yours
seeing who can get the higher scores at
the end of the round it's very
interesting it's very fun and you're
playing head-to-head with all these
other people
I thought it was very interesting um
this is a game let me pull this up this
is one that are I created with some
friends let's see here if you have a
laptop feel free to pull up this URL as
well it's it's multiplayer and it the
game cycles every couple minutes oh and
started right now so the way works is
called a Tring go it's a combination of
Tetris and bingo and the way it works is
you you get random Tetris pieces called
by a caller and you have to drop them
and get 2 by 2 2 by 3 or 3 by 3 squares
and when you do so in this case I'm
going to drop one here and that's gonna
get me a 2 by 3 there's no pretty
visualizations yet but the premise is
there so the thing is that if anyone
else opens up the URL they'll be playing
the same as that game at the same exact
time and we'll all be competing
head-to-head for scores so I think it
this is an interesting i think it is
pretty interesting it could probably it
definitely could use some improvement
but it's a it's a different style of
game that may work well in the
JavaScript space obviously everything
here is created with JavaScript the back
end is incredibly simple it's just
sticking stuff and I think it's in even
in a flat file its really crude yeah so
I think that this is one type of game
that may have potential in that sense
everyone's playing the same thing at the
same time there's a sense of competition
there a really good challenge okay
another game that I've been working on
is called a deeply and this is one it
ended up accidentally leaking out about
two weekends ago I threw up a URL for a
friend and then it got spread around and
then a hit stumbleupon and then I went
crazy and so this one is sort of like
scrabble but with a speed aspect I'll
pull it up here to show you and I think
this is another type of game that could
work very well at which I usually just
JavaScript all right let's see here
okay so in this case its social edge
grab we have tiles but the the towels
are constantly dropping so you're
working against the clock in order to
make sure that you nothing I'll show you
what happens here so you see the letters
turning red ants about the drop-off and
when you do you you lose points so
you're trying to work quickly sooo
pumped right so you spell words and
you're working against the clock here
and a very competitive way well so each
game has a unique ID and you can share
your games with each other and in
challenge other people to play specific
game let's see so one of another thing
that I've worked in this game is kind of
hard to see but the more consecutive
words you get right it's sort of like a
guitar hero and that the more kasai
towards get right to hire multiplier
gets so yeah if there was someone
spelled some ridiculous words like oh
yeah equivocally and this thought it's
like one of the last words ended up
getting like almost three thousand
points for the word is ridiculous so I
think I think this is a game that that I
think has some potential I brought a
designer on board i'm going to make it
not look really bad but yeah so i think
um another thing that I'm doing is to to
prevent cheating so I accepted this
there's two types of cheating there is
sort of the the outright blatant
cheating so let that's the changing
score to 1,000 cheating you know and I
want to be able to prevent that but at
the same time I don't want to exclude
people who write you know in a bot or an
artificial intelligence to play the game
because I mean if you're doing that then
good for you that's pretty hard to do
anyway so to combat blatant cheating
what I'm doing is is that every single
move and the game is recorded and sent
back to the server and then saved and
when that occurs of the server then
after all that said and done the server
takes all these moves and then goes back
through and plays a single
asian of the game over again so it takes
each of the moves the specific time and
it says all right at this time these
letters were played yeah was that a
valid move at that time and then goes to
in checks each each individual move now
what's interesting about this is that
this is a case where you can use server
side JavaScript to verify the integrity
of the input coming in from the client
side and so one of the one of the things
I did to make this possible is I
actually used a random number generator
that what that wasn't the browser's
built-in random number generator it was
it's one that's it's predictable we can
all if you put in the same seed you'll
always get the same result but that way
I can run the same simulation on the
client and on the server and verify the
results what I think is pretty cool one
good side effect of this go of this
though is that since I'm saving every
single move that the user is doing I can
use those individual moves and I can
play them back so like for example let's
say what going on at the screen like
while you were playing on this side
there there were you can see other
players you know making scores and then
moving up automatically what's
interesting is that that could be
simulated that could be created without
the other players actually playing at
the same time since i since they're all
their moves are recorded the server
could play them back and so what you're
actually doing is a playing against the
ghosts of people who were playing which
I think would be pretty cool since the
players don't necessarily know that yeah
there to see other people challenging
them at the same exact time and they're
frantic and they want to keep going and
get better scores but the same time
those people don't actually exist and
they played maybe you know five days ago
so it doesn't really matter but I think
that's pretty interesting in our self oh
so another thing I think is interesting
bout de little shape in particular is
that it's not inherently an English game
most scrabble games are just only
English and in this case what I'm
pulling the dictionary in from open
office and I can actually poured it to
another language like Spanish or French
in a matter of seconds so it's really
quite cool
okay so before i move the next topic any
questions I kind of moving frantically
through all these various different
topics you said before they didn't want
to have a bunch of state logic on the
server to so that people can view source
and tested but it isn't your work aid
how do you make sure people are
achieving you replay it later and just
mark to get our decision so so the thing
is is that the the code to verify the
cheating or not is the same exact
client-side code I'm is the server all
the server is going to do is it's just
going to have a very minimal driver to
it where it's just going to you know
push you know say at this time these
keys were pressed and then it will just
try to play the game again so in fact
it's going to use the same exact
client-side files to create that
simulation so in that way it's um there
is no significant extra logic like the
game logic isn't on the server side
that's all in the client side the only
other logic is you know determining if
something is in the dictionary or not
but again I mean that's not something
back and I can put the entire dictionary
up I mean but I mean that that's not I
don't think that's significant logic at
least you know if people want to know
how the game works they can view the
full source and understand that external
with mobile beeps epoch electrons both
the devices you doing just browse the
basic ones currently assume just hot
cross buns but once i reach mobiles
evening located notable if you have to
avenge this place Hank can ask you
something special I have not
experimented with that in particular
this game were deeply Paz right now
works on the iphone I can pull it up and
I can sit there and gameplay but I have
not looked at incorporating other things
like geolocation and stuff like that
that'd be interesting absolutely if it's
probably be easier I'm sure that'll be
probably talked about tomorrow phonegap
gets hot talk about
okay so to my last type of care I want
to talk a little bit about distributed
JavaScript testing but before I go into
that there's one thing I want to talk
about which is determining the browsers
that you want to support you every
developer and every corporation that
does web development has to make some
sort of determination as to what
browsers they're going to support in
their application so either this is um
you know all companies have to sort of
you know draw their line in the sand
somewhere let me say you know we're
going to support I sick we're not going
to support IE five we will support I 51
support IE for the line has to be drawn
at some specific point the way I usually
recommend do that is making some sort of
cost-benefit analysis so this case the
cost is the amount of time required to
develop your application and
specifically the amount of cost required
to support a specific browser the
benefit is how much market share you
could gain from supporting that browser
so I mean this is just a a markup that I
mock-up that I did here now the thing is
though is that just because in this case
the cost of ie the cost of ie6 outweighs
the benefit does that mean you shouldn't
support it obviously obviously since it
still consumes a large amount of year in
this case market share so again this is
I think a good first step to determining
you where exactly what browsers you want
to support but from there you kind of
have to build and make a smart
determination so uh Yahoo I like what
they've done in that they've they've
drawn their line in the sand and they
say these are the browser will support
on these platforms and you know they
make it and you know very specific and
very public and I like this this is I
think a very smart strategy jquery we do
it similarly but a little bit
differently
in that um we tend to so yahoo basis
there's mostly on market share and that
once a browser drops off significant
amount of market share they just won't
support it anymore or at least not as a
a great browser for jquery what we do is
we tend to support the current release
of a browser the previous release and
then the next release the upcoming
release so this leads to results that
look something like this and the
previous release jquery these were the
browsers that we ended up supporting
Foley we in that in that when we say
support Foley that before we publish
before we release the final wheel
version the test suite is a hundred
percent passing in all of these so in
this case this is a lot of browsers we
have one two three four five six seven
eight nine ten eleven different browsers
and that's not including older versions
of opera and then the beta version beta
version was kind of rocky and then in
this case a really old version of Safari
but that's a large number of browsers
and you know this is a pretty you know
universal problem in that if you want to
make sure your JavaScript code works
well you have to test it in a lot of
browsers and probably in a lot of
browsers on a lot of platforms in the
case of jQuery we're up to the number of
tests means that we have to run is
starting to grow dramatically so like we
have our main test suite which is an
HTML webpage served in standards mode
but we're going to have another version
that is HL pays certain quirks mode
another one that is HTML pays served
with sorry an XHTML page serve with a
proper mime type XHTML serve without a
proper mine type and then so I mean you
start to permute these different types
out and then another version that
includes other frameworks and to make
sure we don't conflict with our
frameworks it really starts to add up in
that all we have all these different
frameworks that we are all sorry all
these different test Suites we need to
run and we're going to make sure that
jQuery works properly not only that that
we have two one in just a ton of
browsers there's no way that one person
after or say
after or before every commit is going to
sit down and run six test Suites and
eleven different browsers it's just not
going to happen you know stuff slips
through the cracks so ideally all the
test suites are going to be run in all
the browsers on every commit and even if
it was designed optimally on every
commit for every patch and for every
plugin so this way you could have a new
very solid knowledge of how your code
base is working but the thing is is that
at least in this current this current
state javascript testing doesn't scale
well so this is a problem that's been
bothering me lately so one thing I've
been looking at is the concept of
distributed testing so being able to
take a test suite and distribute it out
to a number of computers and have them
run the tests and then return the
results so in this way I call this
project test warm and the structure is
is relatively simple there's there's the
core hub server and all the clients come
they connect to the server they've asked
for new tests and they run the tests we
turn the results and one thing I like
about this in particular is that it can
even be run in mobile browsers so you
can load up a mobile device and open it
there one thing we've been looking at is
a so for example nokia is using jquery
and so we were looking at the problem
you know how do we test against you know
physical nokia devices well make sure we
don't want to run in a simulator we want
to make sure that the code works on an
actual device because there's always
weird differences there so that we're
talking to nokia they're like well we
have tons of phones i mean we have more
phones than we could possibly want and
we're like well that's good so one of
the things we're going to do now is we
could just take like 10 phones connect
them all to test warm and have them all
just wanting the test suites that we can
push to them so this way that someone
doesn't have to sit there and physically
fiddle with the device and load the test
suite or whatever able to this all
happen automatically assume that if we
were really rich we'd have a whole bunch
of iPhones as well we can just run it I
guess
but for now maybe there's a simulator
will work so this is sort of the basic
structure and that you have the the core
test forum server the whole bunch of
clients connect to it from a whole bunch
of different browsers you push test
Suites to it test Suites get set out to
the clients and then come back the
results come back let me I'm going to
try and do a live demo let's see how
this works so this is a the main page of
test form here let me just see it reload
and see how it looks so we can see here
these are the browsers so we have chrome
firefox internet explorer Opera Safari
and the little red number is how many
clients are Colonel connect it's only a
few clients right now some of them are
my clients here locally on this machine
summer on a machine back at home it just
kind of spread out at the moment and
this way so you can sort of see get a
picture of like how did the health of
the swarm at the moment so one of the
things i want to do here is this is the
page to submit a new job and that you
can a resolution you can name your job
and submit it say how many times you
want to run if you want to have multiple
run multiple times in this case and then
you can you can write out say list all
your tests feats that you want to run
one of the things that I did is I took
the jQuery test suite the jQuery Destry
is broken up with sub modules what I'm
doing is I'm running each sub module
individually and I'll show you why in a
second so I'm going to submit this to
test form and it presents me with this
page and we'll probably start to get
results here within a few seconds there
we go I you stick to the first on board
yellow means it's running so you can see
there's 2i you six instances connected
in this case operas 96 was the first one
to get something to pass and you see the
results to start to trickle in here so a
couple browsers haven't connected the
clients ping the server every 30 seconds
or so so the more clients that are
connected the more likely in
need to have this finish quickly so one
thing here is that a notice no fire box
three tests running that's because
there's no firefox 3 client connected so
i'll connect here I'll show you what
it's like to join the swarm I'll put in
my username and I'll say join it's very
crude right now you can see that it just
goes connects and it's literally running
an iframe it's nothing that fancy and it
takes results that runs it when it
completes it sends real results back to
the server and it just wanted sounded
queries the server back again but we can
jump back over here and we can see the
firefox 3 starting the results are
starting to come in here so you start to
see some passes so again you can start
all this in a trickle in and it doesn't
take that long maybe a minute or so and
this is like with like one client
connected of each if it was like 23 or
even let's say 100 clients connected
from an x 46 you know it said that you
things will finish within a matter of
seconds ah with these models different
browsers on when your games so someone
that comes when I say some surf playing
background rape your boss while I run a
test every song happy other people
coming to different route there's this
ready desert and they say stop I mean
well they probably wouldn't be the wiser
you know they want to know as long as
the test didn't uh you know like put up
an alert or something yeah I don't know
so in this case I left an error in that
there's one I knew this isn't happen
this is ok so a one there's two tests
failing in internet explorer you know
explorer 6 and the selector module so
for one of the things i did is is that
since i can't see the results um you
know I don't have a screenshot anything
was I I dumped all the results from all
these so I can go in and I can view the
internet explorer 6 results so this is
literally what was submitted back from
the client and this in explore 6 this is
running on a machine back at home in
Boston so this isn't running here
and I can go down and I can see up you
know there's the actual failure oh and I
can see the results and I can debug it
or what have you you know this is as
good as I could get back at home but I
don't I don't have to have access to the
IE six or seven machines in order to run
this so I think this is a pretty
incident I think this is a good first
step but the ultimate direction you want
to go in is it's just a house something
like this and this is sort of what I
call into the tender box this is
suddenly we have at Mozilla when
business this is commits by browser so
you see each individual commit and how
or if it changed the you know the tree
so in this case we can see that you know
at least in the last couple commits the
the tree is burning no Linga mentions
burning in I you six but everything else
is currently passing all the other
browsers so in this this way you have
now have sort of a complete distributed
continuous integration for for your
libraries or your projects or what have
you so you can get you can just load
this up and see that everything is
working a ok and that's ok to commit or
you can find out who broke what and go
and blame them or you know or what have
you so I think this is like the ultimate
you know good result of test one but the
thing is that ok well you're doing this
testing before you're doing
if you're still in development when you
fire off the tests the tests one have
you thought where everybody's to
monitoring and after deployment in
production that'd look very sure so so
there's there's definitely a couple of
cases where this could be used there's
um okay they said there's before pre
commit so you have some code you want to
make sure it works you submit it it
verifies the code that is surpassing
there is post commit so making sure that
once the code is actually putting pushed
out that you know everything the green
you know that the tree is still green
and then at least for live stuff I'd
imagine that that would apply more to
like application development in that
case of where you'll be running a
something like selenium look they
actually has a test driver where it's
clicking things you know simulating
clicks and stuff like that but yeah you
could absolutely uh you know set it up
to some sort of timer some sort of cron
job or what have you and just you know
tell it to rerun these tests every 20
minutes at this URL yeah I don't see why
not so the thing is that there's going
to be the main test war hub and at least
for the main hub it's only going to
accept at least for now only going to
accept open source projects that are you
know where the sources it is publicly
available and at least the developers
are pretty reputable because the thing
is that since you have the ability to
run code on hundreds of machines you
want to make sure people are at least
pretty well behaved but the thing is is
that the test forum itself is going to
be completely open source so if if a
company wants to take the server and run
it on intranet and then have all the
developers this open up browsers to use
locally they could do that in the end it
would be totally free and easy to use
but one of the things I think isn't me
pretty cool is that test form does not a
test form does not require that the test
be run automatically
one of the things going forward is I
want to have the ability to do manual
testing so in the default case the test
one is just going to sit there the
clients is going to sit there and run
these automated tests as they come in
you know just disquiet lean in the
background but every once in a while
like this is a problem that comes out at
least four we want to test jquery-ui we
want to test the user interface and you
could write automated tests for the user
interface but ideally the best situation
is to have actual humans there yeah when
you say you want to have a human drag a
dialogue from here to there and make
sure that it works correctly in that it
didn't like jiggle or opacity got weird
or you know there are only things that
can be determined by a human and so the
thing is is that the test form starts to
expand now and so while users sitting
there and their browsers just on their
desktop they could pop up a notification
say hey we have five new manual tests
that we need to run would you be
interested in clicking through these
niggas I sure you know dry dialogue here
there that work yes or no yes and the
niggas go through knock up a couple of
these and then this way you start to
distribute out the manual load testing
of your projects which i think is pretty
cool um and is in order to you know get
people excited about this one things can
do is start to give incentives so the
polite for example like the top manual
tester on ie6 maybe he'll get like a
t-shirt and like a mug you know it's or
maybe some books or yeah you know
whatever whatever or maybe people who
run more obscure browsers like maybe
people who are doing mobile testing
Mabel they'll get you know I don't know
a gift certificate for something because
I mean those are things that are going
to be pretty hard to do and it's really
worth their while in some ways um it's
it's it could be even possible to take
the manual testing and then just tap it
straight into something like mechanical
turk and then having a turkish sit there
and clicking through your results and
you can be paying you know fifty cents
you know for a whole batch of tests and
yeah and so everything could work out
that way so i think i think this
interesting because this is a way to
solve the difficult scaling problem
javascript both for automated and manual
tests and in a way I think that is
fairly reasonable yeah so uh I can't
think that's about it so any other
questions about tests warm games or
performance analysis or anything else
really I want to use that swarmed out to
eos look at past UTC on what you can
make well and first one either so i am
the one of abuse to surge right now
isn't the scaling of test form it's it's
very cruelly written at this point I
server-side programming it's not my
forte but the very least well I because
I put up a notification for an alpha and
I have like 600 people sign up and then
I realized that that's like way too many
people and so off to figure something
out and I just one of one of the biggest
problems right now is that it's not very
fault tolerant like if if a right at
this moment if a test free throws an
exception it kind of gets kind of wonky
after that so that's one of the things I
want to fix is that if if a client kind
of dies off or something you know that
it's able to you know gracefully recover
and can it continue to run but that
being said so there's a couple use cases
that didn't think of that are now
becoming interesting like for example
for jquery i want to run it against a
very specific number of browsers and to
understand you know it is a passing her
family but there's also the use case of
putting it out to as many different
browsers as possible at as many
different platforms as possible um you
know two seeds just what happens so this
in that case of for example you can send
out a feature detection code so you can
write you to write a specific chunk of
code to detect you know features in
JavaScript pass it off to 50 different
browsers and you can know instantly how
that behaves in all these different
browsers maybe it could be used for
pinging an instance of something or you
know doing a lot of JSON PE requests or
possibly right now it a test worm works
across domains fairly well so that's
definitely an option
I at least what I showed running there
that that was Jake Jake wait a street
running the you know qunit that is not a
requirement it as the stands it can run
on any test me as a simple little API
hook into and at least from there for
the first version I'm going to have it
support the jQuery test suite prototype
dojo mootools and Yui all hugs for all
of those if you get profile information
back or just very simple pass/fail so
that's an interesting problem in himself
it is how do you use this probe for
profiling and it can't be used in the
traditional sense in that that if you
passed off and said here give me the
times for these things on this browser
the problem is that it may run in one
browser on a completely different
platform may rot in some old you know
like 486 I don't know how old r on it
but once the ancient computer and all
the way around a super fast computer and
you know that's not very good you can't
compare those numbers a different
alternative and this is actually thought
of I uh one of the guys in the mood
tools team which was that was pretty
interesting was instead of getting bad
gross numbers what you do is you send a
client a comparison test you say here's
code a and here's code B which one you
know does code be run faster pass or
fail and then that way you could push
you say so this a be testing and then
you could pass the a/b testing out to
you know ten browsers and then you get
past past past fail fail you're like oh
no it we had a speed regression and in
an explorer with that change but it
actually got faster in Firefox Safari
some of you look like a multiple also
like it's did times slower than
iterating through a raid sure yeah so
yeah I mean there's definitely um I
think there's definitely potential there
yeah so what about like not just
profiling the browser white light load
test profiling so if you want to see
how's your HX running when there's a lot
of different browser to apply
possibly I mean the thing is is that at
least in that case you're going to want
to determine you like simultaneous
requests I mean in any way you slice it
you're going to have to have a lot of
pages open or a lot of clients open it
could be possible I mean I would imagine
that that would be something that would
probably not run in the main test form
but probably be more of like if a
company wants to determine that their
website is able to scale then you know
have their developers is open massive
numbers of pages or what have you well
actually this is a case where I think
something like Amazon ec2 oh and
possibly selenium grid would work out
really well is that you know spawn a
whole ton of ec2 instances running
multiple copies of browsers would test
form open and then just have it pound
the server and then get all the results
back again how you saw the same origin
policy the limitations so what I do is
because okay so there's the iframe they
have something in a separate domain and
you want to communicate the results back
so what I what I do is is that I the
code an iframe has one script included
in it and yeah it is it yeah so that's
requirement in order to have it run in
the be capable to run in swarm you have
to have at least have an injection strip
the submission script it creates a dummy
form ejects the data in and then submits
it now the thing is is that when you
submit forms you know that when you
create a fake form and submit it you
can't get the information back from it
but that's okay because what happens is
on the resulting page JavaScript pops up
and communicates it back up through the
frames again back to the top klein and
that works well in all browsers but I
ate because I they have this new the new
cross-site scripting detection and it
sees that it's like oh Christ site
scripting and but the thing is that i
ate has the window post message so you
the new API in html5 actually quite a
few new browser in fact all browsers
have it but they're just implemented at
varying degrees equality index bah rates
is decent but we can do is you from
within an iframe you can communicate to
a parent frame with a string message and
then it can respond back so yeah so it
ends up working out fairly well so
you've got like 30 100 things that just
won't have to dispute s uh it's tested
submitted on our first come first serve
basis and so yeah in the so first come
first serve and um it depends on how
many runs you want and these cases I
only showed the test running once but
like for example let's say you worried
about the quality of the results coming
back instead of running at once maybe
you run it each individual test suite
like five times so that way uh you know
you're sure you could say like okay it
passes in for the browser's fails of one
of the browsers you know what does top
will discard that one failing case
because maybe that's just an outlier you
know so you can start to make
determinations like that so at least for
determining who gets what again the
clients are communicating with the
server so the client will just say is
there anything for me yes no so anything
for me yes now this oversight yo here
you go here yeah it's so again this is
whoever gets there first it connects to
your dialogue example it seems to be a
lot of subjective as to whether or not
this past bales pasties
is anything about putting another
benchmark to the right so one of the
things i think about for that is having
haven't having a so there would be a
general pass/fail state so I mean it'd
be pretty obviously something worked or
just completely did not work but at the
same time having a text input so you say
yes it worked but uh oh yes oh yes I was
able to drag the dialogue but it kind of
jiggle when i first started dragging it
or no it did not work you know no matter
how much i tried to drag it just did not
work yeah so the variance I think that
being able to have a little bit of
verbal indicator or I guess written in
decatur communication would help and
absolutely there would be instructions
as well you know the time users I was
just thinking it might be useful I'm
standard video of a graphic but that's
simply a lot of work set us I ultimately
that would be up to whoever's you know
building it or developing those tests
the more comprehensive the more
explanatory the tests are probably the
better results you get out I mean yeah
when you're dealing with humans things
get are now in perfect yeah so the
question was in case you're gonna hear
is you know there was a big speed
improvements from jQuery 126 to 132 and
there are other limits and so at least
right right now I I haven't seen a limit
yet at least for 133 i'm still doing a
lot of work so that there is that the
profiling work i showed earlier i'm
using that extensively right now to
rewrite almost all the major methods so
add class removed class append remove
CSS attribute like the core methods and
almost all those are getting heavily
we're in for 133 and the performance
improvements are coming out a very huge
so at least for now that's something i'm
focusing on I mean it free 8 release you
kind of have to take it you know part by
part it can't
all everything is just so much potential
for breakage so in this case I'm
targeting like you know attributes dom
traversal dom manipulation and but i
don't think there's a wall yet and
there's still plenty of room for
improvements we can call it boobs are
hollow question but what your calls grew
and actually these tests examination
flavor for me um you look last here what
are the kinds of improvements with it
yep even giving isn't been reorganizing
Oh an algorithmic has doing things so so
look at there's a couple things oh
there's certainly different algorithms
helped a lot you know is structuring
code differently um one of the things
that that we've been improving upon is
that in the past we typically put all of
our browser specific code in line and
when in fact we're now working to
extract that so that you know the the
things that only mattered in an explorer
will only ever be loaded or to a browser
that meets the specific you know failure
state will that code will only be wrong
and executed in that browser so at least
in the code right now there's a lot of
cases where you know there's an if
statement you know if this feature
exists do this else do this when in fact
the the user should never be hitting
those lines code only on load so that's
been one thing that's helped another
thing is that in a lot of ways right now
the the code in jquery is the internals
are obstructed actually quite well and a
lot of the improvements has been going
back through and removing someday
abstractions which has made the which is
certainly decreased code quality in some
areas which is unfortunate but the same
time the
it's been pretty good and in those cases
we tend to weigh the you know the
improvements versus the degradation and
color quality you know if we think
there's a significant drop in
understanding and legibility then we
just won't land it I mean it don't just
have to be that way yeah yes first
strategy game why is it all blogging
that into server just because G for
stretching I mean typically that that's
simply just how it has to work in that
and they all people will try to cheat or
I mean it for you think about you know
the risk game for example if there is no
if all the logic was on the client side
then you could just say all right I'm
going to take my country that now has 50
units and I'm going to tag this one on
the other side of the map you know I
mean there has to be restrictions there
that prevent the user from blatantly
manipulating the game so I mean that's
not to say that all the logic has to be
on the server but the very least most
the important gameplay logic is that is
gonna be on the server here we'll use
closures too high so there was um okay
so there's a feature if you want to call
it that in and firefox where you can
pass in a function to eval and you can
actually get information that's hidden
inside of a closure and so all that
means is that someone using Firebug can
start to tweak things but that being
said all that really matters is sitting
there you know a watching HTTP request
go by and just saying oh no we're gonna
change that variable to this I mean you
don't have to have it doesn't matter how
well you hide it if the user can still
mess with it so yeah I mean it's not
even Firefox no specific at that point
then and that's to say that even if you
move your logic to the server side that
doesn't prevent you from getting
affected there was a game a while back
called a cold war new unroll installed
backwards
and it was sort of like monopoly it was
a ruby on rails game and a used
prototype is like monopoly but the board
never ended it just kept going and so
you would try to get properties and
owned them and then other people land on
and have to pay you a fee but the thing
is that I realized after playing for a
little bit that there was that the more
property you owned it didn't matter how
did the helped it was the more property
you own the more money you would get
since the greater likelihood this some
of the land on your property so I wrote
a bot that go through and keep rolling
the dice in the game again again again
and just buy any property it landed on
so like it's funny because if you look
at the scores for the game had a high
score board and all the scores were you
know those people kind of get money get
money and then you see you know like the
the score from I bought is like cruising
up to the top and then and then of
course all the people figured out and
there's then you see all the boss you
know just kind of getting up to the top
but it was interesting because in that
game they actually ended up making a
normal version of the game and then they
had a separate version that was just for
BOTS there is another game that I showed
here let me see babble I wrote about for
this one as well I mean is this on a
really hard problem you have so many
letters but so many letters you have a
dictionary you just go through you know
solve all the words in it and you insert
them all in but the thing is is that at
least within Babel there is no huge
there isn't like a massive reward for
being the first to solve the puzzle or
something I mean if you if you solve the
puzzles six minutes after midnight when
it comes a new puzzle comes on everyone
knows you're cheating anyway but the
thing is is that in this community of
what happens is that there are people
who've written solvers for these but
what they do is they use this solved
information to go through and help other
players like for example um someone here
says I you know I've hit a wall they
don't know how to continue and then
someone here says oh you're you're
missing F is an FA for so we use this
code to communicate with each other so
this in this case this person no
they're missing a word that begins full
letter F and this person is saying is
that it begins with F a and it's four
letters long and this person has already
solved the game but they're using that
knowledge to help other players in a way
that isn't being a total dick yeah yeah
but I think that's interesting and that
this this is how the community is
structured and it actually works out you
know fairly well people play along
together and it works out well um Sam
Bishop wheeler principal with it has
multiplayer what happens if you either
are trying to distribute the rule sets
across multiple player there's
definitely security oddities that
digging is distribute it has to be at
least six of those feeling at the data
anyone know to kind of updated head wrap
information to get the whole dataset or
even then make the actual value of
anything based also on where other
players are in cuse book people are the
rules as well schools kind of cheese and
usually what where that's possible I
mean it is I mean you certainly get very
complex I think pretty quickly I mean it
we're entering the realm of the sort of
problems you see what games like I was
like counter-strike for example where I
mean what were you end up doing in those
games that you're actually running like
a little simulation on you're on you're
on your own personal machine and so that
you're saying hey let's move ahead and
shoot and it looks like it's working in
a computer and then like that
information gets sent to the server the
server verifies hey can you actually do
what you're doing but at the same ones
doing these simulations and that's why
when there's like lag and stuff you see
people like jumping around and stuff
because their simulations are in sync
with you yeah i don't like it i mean
distributing the ruleset maybe i might
work all right I think we're running out
of time oh sorry I actually you should
be worried about when you're optimizing
to you Larry do you think that libraries
going forward are reaching the point
where they're going to have to split
llaman
functions the shop we found that that
happens already such a small percentage
but I see in the next going here it
feels like absolutely man where you
can't pop much for everything so then
you end up you make up track flexible if
you made it directly simple and you know
where I just wear your thought like
where do you think that's had that's
tricky I mean the problem is is that i
don't i don't think it's possible to
what okay so this is I mean essentially
you're trying to optimize for as many
use cases as possible and I think it's
important to optimize always optimized
for the most common use case both in the
design of your API but within the
performance of the API as well you know
if if you know let's say that the the
common case of setting an attribute is
um you know that should be faster than
some other use case that is not so
common so at the very least I think that
when optimizing you should always go for
the most common case but without
significantly degrading the performance
of the other cases yeah I don't know I
think when the problems that comes up
fairly often is is that you have an API
structure to meet a specific need and
then but something else you know loses
out like for example jquery has CSS
selector support and its generic and
designed to support any selector but at
that cost is some degra gate degradation
and that ego has to do some string
parsing and determine you know what
exactly the user inputted and when we
first implemented that there were some
cases that lost like for example just
getting an element by ID that case
should be fast you know and that was a
case that lost out and so what we did
wind up doing is we ended doing some
very specific code paths in jQuery just
to handle that one case so in that case
we because that was something that
people did so often that
how to make sure that it stayed fast and
at the same time the generic common CSS
selector API you know is still what it
is you know it we didn't affect that in
any way hope that answers yeah City Hall
forever I think we're pretty much out of
time here so feel free to stab me
afterwards and we can chat some more but
yeah so thanks for having me talk
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>