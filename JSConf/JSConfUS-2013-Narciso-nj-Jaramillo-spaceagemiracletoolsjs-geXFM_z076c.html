<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>[JSConfUS 2013] Narciso (nj) Jaramillo: space-age-miracle-tools.js | Coder Coacher - Coaching Coders</title><meta content="[JSConfUS 2013] Narciso (nj) Jaramillo: space-age-miracle-tools.js - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>[JSConfUS 2013] Narciso (nj) Jaramillo: space-age-miracle-tools.js</b></h2><h5 class="post__date">2013-10-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/geXFM_z076c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so this is the talk called space-age
miracle tools such is everybody calls me
NJ because it's easier than trying to
pronounce my actual name so NJ it is and
I'm not website on twitter and i work at
adobe on a project called brackets which
i hope to start brackets is a code
editor for web developers and it's built
almost entirely in HTML CSS and
JavaScript a little native stuff around
it so it can access the local file
system and it's completely open source
MIT license and stuff like that cuz they
may her actually tried brackets out like
oh good so may ever actually tried to
hack on brackets or write an extension
for it alright you don't count Brian I
mean no you count a lot I just mean okay
so well maybe it's a couple people so
you know I called this talk space-age
miracle tools ojs which is kind of a
terrible name because how could you
possibly live up to a name like that but
what I'm going to show is some sort of
early experiments some ideas we have for
future developer tooling and we kind of
want your feedback on you know whether
these things make sense whether there's
something that you think we or other
people should pursue and then a top of
getting feedback on these ideas we also
want to hope hopefully inspire other
people you know you guys to think about
what kinds of developer tools would you
like to see you know for the next 10
years for the challenges that we're
going to be facing in the future or even
are facing now that maybe aren't
adequately addressed by the kinds of
tooling that we have today so there's
gonna be a sequence of demos and I
didn't actually do most of them myself
so I'm going to introduce who actually
worked on them so the first one is
called Theseus and it's done by Tom
Lieber who I think he's just finishing
in PhD at MIT and drove Brandt who works
at Adobe and their research group and
the prom they're trying to solve is that
debugging asynchronous code I mean we're
web developers right we have to deal
with us all the time and it's super fun
right right yeah so basically you know
you see something's wrong in your web
app and then you have to kind of guess
where the problem is by reading all your
code on the client may be on the server
right it could be either place and then
because the problem aight be an
asynchronous code you can't just step
through all your code right you have to
think about every single place or code
might go and then like a break points or
log statements or whatever and just sort
of scattered them all over the place and
then like reload try to figure out
what's going on and then you know if you
haven't fixed it yet then you know you
kind of have to rinse and repeat so it's
kind of a pain
right so idea of theseus is to make it
easier to debug this stuff by basically
capturing information as we go along so
to see this let me go ahead and start a
brackets and if you haven't seen
brackets before you know as you can tell
pretty much looks like a text editor on
the surface right it's just got the
standard stuff you'd expect like code
coloring and it's got a little file tree
and stuff like that i'll show you some
of the more like specific features that
we already have in brackets later on but
right now you know and all this stuff is
built in HTML like I said in JavaScript
but let me go ahead and show you how
this Theseus stuff works so when we
start by starting the server for it so
this is my server app but what I'm going
to do is instead of starting at a node
i'm going to start it and no Theseus
which is going to instrument it in
certain ways that we'll talk about later
okay so this is running my node app now
and then from brackets I'm going to
enable Theseus and I'm going to go to
the source code for that project hoops
and I'm going to go into this live
development mode ok so now I'm running
this application and this is just like a
simple demo app it's a reservation
application right and so the ideas are
supposed to be able to select an
activity you want to do and then select
which date you want to do it on but as
you can see there's no actual dates in
the drop-down right so there's a bug
somewhere so where's the bug well it
could be in this event handler for this
drop-down right it could be that we're
not kicking off the Ajax request
properly it could be that on the server
side it's not accessing the database
properly or it's not returning the
response properly whatever so it could
be in a bunch of different places so
because we were running this all in the
context of Theseus we can actually go
back and look at our source code and now
i'm going to switch to my client side
JavaScript and you can see that as I've
been doing stuff it's actually been
capturing information on which functions
got called right and this is live so if
I go and I pick another activity let's
say you know like running or something
you can see that it updates what got
called so it's kind of useful and I can
also click on these things to get more
information so for example we can see
that our change handler got called to x
which is what we would expect as we pick
two different things from the background
yeah oh I'm sorry it's a better
it better all right okay so you can see
that we've got to change gentlefolk make
an even bigger so we've got change
handler here right and that got called
which is what we would expect and so I
can click on that and I'm sorry I can't
increase the font size of this right now
but basically it's showing the
information about each of those calls
and I can also look at some other stuff
like there's this set up dates function
which got called also twice and then
there's an ajax post and then there was
a callback function that got returned or
that got called when the data was
returned right so you click on all those
things and you can see that we're
actually showing in this log now
basically the causal chains here so the
change handler called set up dates and
then as a result of the post that got
done instead of dates get dates callback
got called and the interesting thing
here I mean a little side note is that
you know this isn't just a call stack
right like this is basically a call
stack but the get dates callback that I
should got called back asynchronously so
if you were to look at this in devtools
you wouldn't see it in the same call
stack because all that other stuff but
we're actually kind of tracking that
stuff and showing you how these
asynchronous things are related to each
other so I can look at this and I can
look at the return values from get dates
call back and you can see that the data
I got back from the server is empty
right so clearly there's a bug on the
server so I'm going to switch to the
node code so this is the JavaScript
that's actually running on the node
server and because we were running that
in this Theseus thing to you can see
that it's actually showing the same
instrumentation information for the
server side and again I can click on
these things to see what happens so I
can click on these calls here and I can
take a look and see oh okay well it
looks like this handle API quest got
called and that called get dates but in
get dates this activity was undefined
and so if i look at the call to that it
looks like i just made like a stupid
typo right so this is obviously a very
simple example and this is kind of early
work but the idea is to make it so that
by sort of watching what your
application is doing we can give you
rich information that you can use for
debugging after the fact as opposed to
you having to sort of proactively figure
out all the places where you have to
essentially manually instrument your
code yourself with log statements and
break points and all that kind of stuff
so this is actually just turn this off
so they've started putting this stuff up
on github already so it's open source so
if you have brackets you can check out
Adobe research / Theseus and you can
just install this as an extension
into brackets to check it out and
definitely give them feedback on you
know is this useful what other kinds of
information do you think could be
collected you know what are different
ways you might want to query that
information ok so that was Theseus the
second thing we're going to show is this
idea called insta bug and this is
actually done by Peter Flynn who you
might have seen his talk at the ABC is
talk on Wednesday on performance let's
good talk you should check it out on the
recording if you didn't see it but
anyway he's gonna talk about something
totally different now which is called
instant bug
almost can never hear me all right cool
all right so how many people have seen
this demo from Brett Victor while back
you have basically a code editor on the
left on the right hand side to have this
visualization of how the values of
variables change over time and as you
edit the code on the left the
visualization on the right hand side is
actually updating continuously as you're
typing so you're getting this sort of
live feedback how many people have seen
that that demo before all right cool
this is a kind of sort of novel thinking
that gets me really excited about the
future of JavaScript tooling and so I've
actually been working on something along
these lines and basically to looking at
some of the ways that you can branch out
from this idea so let me show you a bit
of that just going to take a little
quick switch a root here oh it's your
turn up disease
so I don't know if I can make the font
much bigger than that i haven't still
fit but hopefully it'll be okay so for
those of you haven't seen in demo here's
basically how it works you have some
code and as you make edits in the code
actually see the stuff on the right hand
side here is updating in real time it's
showing me how each value changes as its
assigned as its modified so as I'm
making edits here you can actually see
those values being modified so what's
really cool about this is it's taking
this traditional three-step cycle that
we're used to first you write code then
you test code then you debug the code to
find problems to fix the problems taking
those three steps and it's fusing them
to this one continuous ongoing process
so while you're writing code you're
continuously seeing live feedback as to
the results of executing that code and
when the result isn't what you expected
you already have this rich debug
information on the screen right right
there and I think that's actually a
combination of sort of two interrelated
ideas the first is this this sort of
idea of continuously executing the code
as you're making changes and to be able
to show you that live feedback and then
the second is this really rich
visualization you see on the right hand
side that's broader on the time spectrum
then when you get from a traditional
debugger so traditional debugger right
you're looking to this really narrow
window it's just an instant in time and
that's all you can see you can step
forwards but you're only looking through
a little sliver this is showing you a
more holistic view of the whole history
of the execution of the flow of
execution through the code and I think
that right hand side that visualization
can actually be made semantically more
rich in other ways to let me show you a
couple ideas that we had around that so
one thing you could do for example is
you can grow out blocks of code that
aren't being executed so that your eye
is just naturally drawn toward the
actual code path that the execution took
then if you have something that lets say
a loop being executed we can show you
the number of iterations that it
executed just a really quick way to get
a you know wrap your head around what
the codes been doing and then let's say
if you have a variable that's being used
as an index into an array we can
actually show you the value of that
variable not just as an integer sort of
floating out of context but actually as
an indicator on the array itself showing
you what member of the array that value
is actually pointing to so it's
basically beginning to give you sort of
this rich or semantic view
of what the values in the code mean and
what the execution of the code looks
like over time but skimming back to that
first thought that sort of continues to
re execution of the code one question
about that is whether that's actually
sort of a fatal flaw in this this whole
idea every time you see demos like this
it's always either a toy snippet of code
like this one or it's some kind of run
loop like in an animation or a game that
certain lends itself naturally to being
rerun over and over again because that's
what it's designed for and it's a
continuous we execute makes a lot of
sense there but you can't continuously
execute an entire web app as you're
typing like what does that even mean
doesn't make much sense this whole idea
is really predicated on taking a set of
code and isolating it along with its
inputs and sort of mocking away the rest
of the world to be able to do this
continuously execution to me that sounds
a lot like the process of writing good
unit tests isolating code mocking things
etc so I think it's really interesting
to look at all this from the perspective
of unit testing and tdd and I'll show
you an example of what I mean by that so
here's a no we got the lineup you should
let me make the font a little smaller
again sorry this is the low resolution
is a bit of a bit of an issue here but
no lower resolution I thought that I
oh yeah it keeps there we go the phone's
going to be really small I don't know
why we're getting that problem I think
it's on the other branch maybe but
anyway so oh that's okay hopefully
hopefully I'll kind of talk to the code
so if it's hard to read hopefully it'll
still make sense this code right here is
a function it takes an argument it's a
really crappy implementation of
converting a number to a string and so I
can fill in a hypothetical argument
value here to begin to see you know what
the code is doing but I can also fill in
an expected value and you can see that
the codes doing the wrong thing it's
actually getting stuck in an infinite
loop but let's set that aside for a
second and sort of do a test first so I
can add a few more test cases here 0 is
a good edge case negative numbers
another good edge case and like i said
this codes really crappy it's failing
every test case I can possibly think of
but that's fine let's go back to the
first one we've tried 120 and see if we
can actually get a sense of what's going
on here so we're expecting num to
converge down to zero and instead we can
see really easily hear that it's
actually just getting into smaller and
smaller floating-point numbers so that's
you know one of these sort of
traditional pitfalls in JavaScript an
integer division doesn't doesn't
truncate and we can really easily fix
that with just adding in a math that
floor here oh no it's doing it again let
me take some white space out of the code
sorry there we go so now we can see that
we're running three iterations for a
three digit number that's what we expect
the single digit case is actually
passing already now but if you can see
this it's actually outputting 0 to 1
instead of instead of 1 to 0 so it's
concatenated numbers in the wrong order
we're still getting bad output that's
luckily really easy to fix too so there
we go now we got the two cases passing
fixing the zeros really easy i can just
add in a little extra thing here and you
get the idea and i can make these fixes
sort of feeling confident that I'm not
breaking other stuff because all of
these test cases are being react
security continuously so they did
something stupid here like making it
always return 0 you immediately see the
feedback that some of the other test
cases had basically gone red and one
thing this brings to mind is I think
it's it's really important to sort of
begin seriously thinking about blurring
the line between these sort of one-off
test values that we throw around when
we're initial
writing code and getting it up and
running versus the more formal unit
tests that we keep around in the long
run and one way that we can do that is
to actually you know keep track of the
history of test values that you've been
using like we do here and then actually
generate an initial set of unit tests
for you sort of scaffolding based on the
testing that you've already been doing
so
so these are just a few ideas I think
there's lots more really awesome ideas
in this space and I'm really looking
forward to the day that we can start
using tools like this on on real world
large-scale code bases so thanks and
back to NJ it's totally on the wrong
branch for that sorry about that
yeah All Right see then get this thing
back on their way ok so good ok cool so
so I wanted to talk a little more about
this idea of sort of live JavaScript so
this is actually a live javascript
editing and sort of you know being able
to see results as you edit so how many
people saw peter van disease talk a few
hours ago ok bunch of people did you see
you saw your own tacos and so you know
he did this great job showing an
approach to this you know there's been a
lot of activity in this space and a few
short of light table but those guys are
looking into this I think some of the
other sort of web IDs have been looking
into this as well and it's something
that obviously we've been thinking about
to and I worked on this part and I
didn't think you needed to see my face
behind me on the screen so i didn't
bother to picture myself in a bit so
i've been think about this and sort of
looking into an approach to doing this
that you know sort of interesting but
also a little bit weird and so this is
definitely going to be maybe a little
bit more grotesque than you might want
to see but hopefully won't claw your
eyes out all right so let me give a
little example of what we have in
brackets today and then i'll show how
we're doing how we can do things
differently so right now in brackets
actually a switch different project here
we have a very we have a notion of live
development right so the idea is you can
go into an application here or a website
and i can open it in the browser in this
live development mode and then for CSS
we can do things like you know as you
make edits the font size here right like
as i'm editing the color you can see
that it updates the color in the browser
is on typing you know i can do things
like it a padding or whatever right so
this is sort of a it kind of really
makes this really immediate feedback
loop between what you're doing kind of
like what what Peter was showing and it
turns out this is actually pretty easy
to do for CSS because it's declarative
right and in fact the chrome what we're
doing is we're connecting remotely to
the chrome developer tools over a web
socket and they were just pushing new
CSS at it and it knows how to replace
that stuff on the fly now the thing is
if you think about doing that for
javascript is actually a lot harder and
again if you saw peter van der disease
talk you talk about something changes
there it turns out that chrome does some
of that stuff already so if you push a
whole new script at chrome it'll
actually replace function definitions
at least in some cases but it won't off
so it won't always work and I'll talk
about some of the edge cases as I do
this next demo so let me actually switch
to a different building brackets that
has some different lab development stuff
in it this is my prototype code here and
it is okay so this is a really stupid
app basically you click this button then
every time you click the button it shows
a new number or it increments a number
and it prints out a message right so in
this version of the live development
mode what I've done is I basically taken
the existing JavaScript file and I've
instrumented it in such a way that we
can do various kinds of live code
replacement on it so again somewhat
similar to some of this to Peter had
there so for example I can go here and I
can change this to new message and then
without reloading the application or
whatever just pushing a new function
definition you can see that it's showing
the new message here all right so I
haven't reloaded the app IM say anything
like that so that's pretty that's you
know one thing you can do another thing
you can do is you can actually add new
functions here so let me go ahead and
change this to list i want to do a
little refactoring i do i make it so
that I can you know add five every time
instead of account and I'm going to do
that by defining a new function so that
function is going to take the amount and
it's just going to add that to the count
right okay so now I click on this button
now you can see that it's now
incrementing by five right and again I
didn't reload the app I didn't save or
anything like that so you know one thing
that's interesting about this case that
makes it kind of hard is that you know
this new function i defined and the old
function that it's referring to in the
and the code that it's referring to
before like that stuff was all in this
module closure right so this there's
this closure actor called my lager and
that's what we actually use you know we
put our functions in that to sort of
hide the implementation details and then
we call it from this click handler so I
didn't actually reacts acute this module
right because I didn't want to lose the
existing modules state I didn't want to
reset this count variable right we want
to keep that state we just want to add a
new function into the closure and we
want that function to be able to see the
current state of what was in that outer
closure but if you don't reacts acute
the outer function then how do you stuff
something new into it right because this
is JavaScript and these closures I mean
that's why they're called closures right
they're not they're supposed to be
sealed not supposed to be able to poke
new stuff into an existing closure and
furthermore have the existing stuff in
that closure be able to see new stuff
that you add to it if that old stuff
gets re-execute 'add without we executed
the whole module to begin with right how
does that work sorry was that you're
like a rhetorical question there all
right how does it work all right so let
me go through celebs sorry all right so
let's talk about the first function
replacement case I'm not going to go
into a lot of detail of this because
it's actually quite similar to the
technique I think that that Peter used
in his talk so the basic idea is let's
say I start with this code right this is
my script that I type in to my editor
right and says my fog you know
console.log old message so like I
mentioned before what we do is we before
sending the script to the browser we
actually rewrite it by basically putting
in a chunk of extra code into every
function that's in the original script
file and that code looks like this so
you start with the original code which
is here right and then I basically say
okay I'm going to create this table of
function replacements and so before
every time I enter this function instead
of just executing the code I'd
originally written I'm going to look
into that table and see if there's a new
definition and if there is i'm just
going to eval it otherwise i'm going to
use the original function definition and
then once i have that i can just call
funked out apply this common arguments
in order to make it evaluate the same
way the original function would have
right so it's a pretty straightforward
trick and as again Peter point out has
talked one of the nice things about is
that if you do this eval in the context
of this function you get all the outer
closure state right all that stuff stays
preserved right and then when you want
to send a new function over from the
editor right so the user makes an edit
and the editor you just send it over the
browser and then it steps that back into
this table here okay so the question
though is how do we do this other case
right how do we do this case where
you've got a closure that you don't want
to re-evaluate you don't want to rerun
this closure and you have some stuff in
it that gets you know basically defined
when you first execute it right so i
define a variable i define a function
that logs that variable and then you
know as the user I'm in my code editor
and I go and make some edits and what I
do is I basically introduce this new
function that refers to a variable that
was already in the closure and then also
the existing function here I make a call
that new function right so there's two
things going on here right both the new
function has to be able to see the stuff
that was in the closure to begin with
this
your instance that already exists and
the old function has to be able to call
the new function after its content gets
replaced using the technique we showed a
little while ago right in the previous
slide so long ago all right so how do we
do it well we use the scrote a grotesque
hack which is with and so most you
probably know it with is and you know
mostly that you're not supposed to use
it but basically what it does right if
you're not familiar is it was originally
intend as this convenience feature in
JavaScript where you basically say I
have an object with a bunch of
properties on it and like every time I
refer to one of those properties i want
to have say like some obtained and some
object I HR whatever if you wrap stuff
in a with block that refers to that
object then what it does is basically
takes all the properties that object and
puts it in the local scope so now I can
just say name and age instead of saying
some obtains modulation so you know like
i said it's this weird convenience
feature nobody really uses it it's
actually deprecated new versions of java
script but and it's partly because it's
just weird right that's like it's
injecting all this random stuff at your
local scope least ambiguities and things
like that but this is actually the the
feature that makes it so that we can
actually use it to prototype this kind
of injection of stuff into an existing
closure so how does that work well again
we'll start with the original code right
which was there was this module and it
had this variable and this function in
it and so we're going to add a little
more code to it what we're going to do
is we're gonna start by just creating an
empty object we're going to store it off
in a table so we can refer to it later
and then we're going to say with that
empty object do this stuff we were going
to define the things that we were
originally going to define the module
and then take all of the things that
we're defined in that module and stuff
them into this scope variable right into
the scope object so because of the with
here all those things essentially get
readded into the local scope here but
that's kind of a no operate that doesn't
do anything because they were already in
local scopes who cares but the trick is
now when you want to go to find a new
function and you wanted to see all that
stuff and be seen by all that stuff you
can just wrap it with the same scope
object and then you can copy a pointer
to that new function again into the
scope object right and so now when the
new function executes it sees all of the
local stuff that had previously been
defined in the module because it got
copied over into the scope variable
right and then if you re-enter this
internal function right there's my funk
right this is the same thing that like
that logger function in the original
example right then it can actually see
the new function because it got added to
the same scope so basically what gives
you as a way of exposing and consuming
the lexical scope you know some random
place in your code exposing it as a
dynamic object dynamic scope that you
can then poke out and mess with right
alright so big deal like why why would
you even want to do this right like it
gets weird and confusing and so I think
the reason that I'm interested in it is
because you know if you again if you
went to Peter sake point out that
there's a lot of cases where it just
gets hard to do live JavaScript
development well right like it's one
thing to replace the content of an
existing function that just going to get
executed again you know like Peter was
saying or if you if you're in like an
animate loop or something or you're just
continuously executing it if you just
add a bit of imperative code somewhere
in a scope where you don't want to
re-execute that whole thing again you
know it's not that easy to do and so
there's just a bunch of these edge cases
and things that I think are difficult so
what we really want to do is sort of
prototype this stuff as much as we can
using pure JavaScript and using whatever
hacks we need to but ultimately I think
what we really want to do is lobby the
vm makers you know v8 and JavaScript
core and spider makino them to basically
add more support for this kind of live
development into the vm you know the
same way that the Java VM is added you
know stuff like jaco replacing and
things like that and again you know some
of them are already starting to do this
like there's a little bit of this and v8
already but if we can get them if we can
figure out like what are the right
primitives that we need in the vm to
support the style of live development
then you know we could get that stuff
into the vm and then all of the
schooling you know those brackets or
light table or whatever can take
advantage of it so let's say either okay
that was pretty nerdy hey it's jase
girlfriend so let me skip to one more
thing which is well it's a different
kind of nerdy anyway and I know we're
running low on time so I'll try to get
through this quick so thus last time was
called response and this is not actually
bout JavaScript development this is
about CSS development it was done by
this guy League brim below who works at
Adobe and so what I'm going to do real
quick is again for context i'm going to
show you some features that are already
in brackets and then show you how he's
building on top of that to provide an
experience for a responsive design so if
i go back to my example file here one of
the things that we have when these
features that we have in brackets is
this idea of inline editing so the idea
is that if i am in like an HTML tag for
example and i want to see the CSS
associated with that tag is everything
to like go and dig around my CSS file
for it I can just hit this quick edit
key and what it does is it actually
is open The Associated CSS rule right in
line there so I can just tweak it and
then get out so I can't really get into
this sort of mode if I'm just like in my
same file and just editing editing stuff
from the CSS and then I can pop out and
we use this idea of inline editing all
over the place like we use it for you
know for things like colors so like if I
the color here I can pop them in an
online editor for the color if you're on
a CSS property you can get docs from the
web platform docks project and see it in
line and stuff like that so it's just a
sort of you I idea that we had for
making it just kind of quicker to work
back and forth between different context
so Italy did was he took this idea and
he added to it to enable some responsive
design stuff and then let's talk about
what that means so I'm going to open his
responsive design extension here errors
totally fine and it's not a bug in my in
my demo and so the idea here in the the
concept behind this is so you know when
you're doing responsive designs stuff
you know we've got we're starting to
work on things like tools for designers
to make it easier for them to to do this
stuff we've got this project called
reflow that we've started up for that
but if you're a coder right primarily
what you're doing is you're living in
your code all day but you might want a
little help with sort of visualizing
what the results of your responsive
design stuff is going to be so we built
this extension called response and it's
built as an extension of bracket so it's
you know I'll build again an HTML CSS
JavaScript I basically way does it gives
you this preview of your website here so
it kind of splits open the brackets
window and puts a bunch of stuff in here
and what lets you do essentially as
visually defined media query breakpoints
and then give you a really easy way to
modify them in code so like here for
example when I get to about this this
size maybe I want to actually start
having the text be fluid so I can create
a media query break point and then I can
use this inspect mode to select an item
in the HTML and let's see if this
problem is that going to work as the
font size okay but you can see that it's
selected this associated container div
in my HTML here and we can use that same
quick edit gesture to see the associated
CSS styles but we're in a different mode
now where this is associated with the
current media query so if I now make a
change here to the width it only applies
to that media query so if I make this
back bigger again if I make this bigger
again you can see it's fixed width again
out here and then inside it it's ninety
percent right so it's basically letting
me make overrides in an
media query you know I could do the same
thing here for this this grid you know I
want this stuff to not be so spread out
in smaller and smaller widths and so I
can go here and I can make that fluid
with right and so now that works as I
resize the browser window and then you
know I could go ahead and like make
another media query here for you know
this stuff is starting to overflow so
maybe I want to create a new media query
break point and then edit that to do
display none ok so again you know this
is necessarily what you do it's not
mobile first and it's not best practice
in my row but gives you the idea of what
we're what the response plugin is doing
and what's been doing all along as I've
been making these edits to what looks
like my original CSS files it actually
wasn't editing the original CSS what it
was doing was putting those overrides
into media query break points that were
/ these different break points that I
created visually so this is a kind of
thing where you know we don't want to
build tooling that like takes over your
code and spits out a bunch of stuff that
you know I understand it's really about
kind of giving you a sort of small
amount of tooling that can aid your
existing coding workflow without sort of
taking it over that's the idea with this
all right so i think i have like maybe
three more minutes so we just go i'll
wrap up quickly so i was four different
demos of some pretty different things
got some JavaScript development some CSS
development and you know again you know
the idea here is to see if if any of
these ideas resonate with you guys if
they're things you'd like to see or if
you have other ideas that would be cool
I will make a plug for you know brackets
as a base for this stuff when we started
building brackets as a code editor we
decided to build it in HTML and
JavaScript it was kind of a lark it was
sort of like hey let's see if we can do
this right and we also have this thought
that it's great for a tool to be
implemented in the same language that
its users use right so that if you're a
person who uses it you can also hack on
it and you can build extensions too and
all that kind of stuff but then there is
this more subtle point we realized kind
of later on as we started finding people
building more and more interesting
extensions on top of it that we hadn't
even ever thought of before like that
response extension and sore came out of
the blue one of these days and it's
really that you know by analogy I don't
know how many of you have used Eclipse
so may use Eclipse right so it says Java
IDE and it's built for java developers
have some of that same flavor and they
spent a bunch of time thinking about
extensibility right so I mean it's very
extensible tool but at the end of the
day they were fundamentally hobbled by
the fact that
was a non declarative UI stack right
they had to think of an API that would
explicitly let you do certain things so
if you wanted to add an icon to the
toolbar you want to add a new panel
right they had to think up an API for
that but in the web stack you don't have
to do that it's like that guy you know
the guy here with that response thing
like he just hacked a bunch of stuff
into the DOM and it just worked right we
didn't have to give him permission we
didn't have to figure out what the right
API was going to be before he did it now
that's not saying that you never need
clean api's and you never have to think
about accessibility we thought about it
a lot too but our philosophy is really
you know put the pads where people want
to walk as opposed to like let's try to
figure out every possible thing so they
might want to do it in advance and so we
found that at least we think that makes
brackets a really good sandbox for this
kind of experimentation with developer
tooling so if you have ideas for
developer tooling that you want to try
out you know the context of a code
editor we'd like to invite you to
pulling the sandbox too so we're
github.com / adobe / brackets that's the
main github repo if you just want to
download people to try it out you can
get that at download brackets taio and
these slides are online at this URL here
and i am NJ and not web safe and that's
my talk thank you
oh and i forgot to say if anybody wants
to come up i have some bracket 3d
printed brackets logos for you for
people who want them i think we're kind
of running over so i don't know if we
should take questions or others a break
ok these are there any questions while
I'm here yeah the live development right
now yeah that only works with come
because we're talking to the chrome
debugging tools currently but obviously
you know Mozilla is starting to have
they have the remote debugging protocol
and things like that so we're planning
to hook that up as well uh-huh yep yeah
we haven't we haven't started working on
officially we've got some prototypes I
mean the main thing is where do you want
your code to be stored right it has to
be instant back again so we've got like
a prototype of it running against
dropbox as a back and just sort of as a
proof of concept the intention is
eventually will basically abstract it so
you could have any one of a number of
backends but we haven't done the work to
actually make that official yet so we're
hoping to do that I don't know can we
say sorry by the hoping by the end of
the year huh
yeah no yeah so the question was could
we support source maps for these things
where we're doing all this crazy
instrumentation of JavaScript we
certainly could like I said this is just
kind of a hacked prototype it's not sort
of cleanly packaged up the same way that
Peters stuff was so but yeah that's
definitely what you'd want to do if
you're going to go with this
instrumentation based approach for sure
any questions oh yeah
mm-hmm
yeah now we're definitely up to do that
so for which part were you talking about
we talked about like the live JavaScript
replacement stuff or were you talking
about some of the other stuff yeah i
mean that's that's the other thing I was
right is that basically when you deal
with real-world JavaScript you have all
of these things you have to worry about
right you have to worry about people
putting stuff in modules and
asynchronous loading stuff like that so
like I said that's part of the hard
problems that we have to think this is
just like the first like tiny slices but
we would have to think through to get
this to work in kind of a real world
production environment where you
actually want it to work anything else
all right thanks a lot</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>