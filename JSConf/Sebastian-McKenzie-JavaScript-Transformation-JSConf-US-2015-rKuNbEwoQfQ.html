<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Sebastian McKenzie: JavaScript Transformation | JSConf US 2015 | Coder Coacher - Coaching Coders</title><meta content="Sebastian McKenzie: JavaScript Transformation | JSConf US 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Sebastian McKenzie: JavaScript Transformation | JSConf US 2015</b></h2><h5 class="post__date">2015-06-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rKuNbEwoQfQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi my name is Esther McKenzie I work on
web content optimization and CloudFlare
so I work on making websites faster
monitoring performance that kind of
thing
so what I'm going to be talking to you
about to you today about is JavaScript
transformation so what is JavaScript
transformation well you put JavaScript
in and you get javascript out the
generated output is determined by
contextual information based on what you
put in so it like statically checks and
infer as kind of what the code does and
then transforms it as such into the
output JavaScript so first off let me
explain some history so there was this
thing new thing called es6 now es2015
there was a large gap my knowledge arm
passes compilers and generally the
intricacies of JavaScript so I decided
to make an a s-six transpiler to learn
it called six-to-five unfortunately this
wasn't a very good name people started
to use it and 65 already supported like
bleeding edge as7 stuff so it would have
required a name change to seven to five
and then once es6 became mainstream
would have been had to be changed to 76
but then es6 was renamed T as 2015
so this obviously wouldn't be in very
practical so in order to keep up with
the rapid pace of the web the name was
changed to babble with this name change
on not only came like the sense of
permanence where future versions be
supported but the scope of the project
was kind of expanded to be a more
general JavaScript compiler I'll go into
a bit more detail on what that actually
means
but basically different types of tools
could be built on top of Babel and there
be future-proof so what does that mean
so for example if you build a minnow
fire on top of Babel I mean some cool
new ears feature came out as long as
Babel supported it everything that was
built on it or used it would support it
too so to give some context on why this
is neat I need kind of understand a bit
about how it works so you have some
source code cool
how can I deal with this how would you
throw a regex at it no not really
there are way too many variations of
syntax in order to kind of do anything
good with just regular expressions so
you need to represent this code in a
data structure that you can deal with
called in abstract syntax tree or AST
for sure so this is the AST for the
previous code it's a group of deeply
nested objects that expressively define
each syntactic element so each property
of these nodes contains metadata about
what it represents so this may kind of
seem intimidating but an easy way to
visualize this is via a tree so it is
the T in AST after all so as I said
before each syntactic element represents
a node so now that you've got some
context on what an ast is it's the data
structure that we deal with when we're
dealing with code it's easier to
understand each component of Babel so
this split up into three very distinct
areas so you have the parser that turns
your raw code into an AST or some parses
it to the transformer to manipulate
manipulate then on to the generator to
turn back into code that you can execute
and so this graph is more to scale that
well most of the time in Babel is spent
and where the smarts and car logic
actually is
so the transformer is mostly where the
tricky stuff happens and in order to
understand the core concept of the
transformer is to understand traversal
so traversal is where you have a tree
represented by the red nodes and then
you have a visitor represented by the
blue node and you want to visit all
these nodes so basically it happened
like this so you would visit program the
variable declaration and then you keep
on continuing through the entire tree
I'm going at any points additional nodes
could pop into existence or no to be
deleted and this can be tricky so if
you're replacing a set of valid nodes
with a set of invalid nodes so to make
kind of this a bit easier bubble is
aware of JavaScript semantics so it can
understand what JavaScript means so what
does this kind of mean so here's an
example here you've got an array
destructuring assignment this this
should execute calculate coordinates and
assign the values of x and y to the 0
and 1 index of the result of the
function call so this would look
something like this so yeah this works
it's in a statement position but what if
we use the exact same transformer on an
expression so this should do the same as
before but the resulting value should be
the right hand side so it should be the
result of calculate coordinates so if
you use the exact same transformer on
that code it would output this which is
obviously invalid you're trying to
replace an expression with a list of
statements and what does this even mean
so JavaScript stems and expressions of
different things but in Babel that kind
of equivalent so it can tell kind of
what you're doing and explode that into
this so that's the exact same
transformer is so it's written only from
one context and it's can support many
just based on inferring information
about it and one of the other things
that you made so replacement is one of
the things you find yourself doing to
the tree and the other is removal so
here we have left + right is represented
by a binary expression
and say you won't remove the rat node so
typically you'd get something like this
scissors have left and missing a right
node this is invalid and so so babble
can tell or hey you're there's no right
hand side so it just places with this so
it's kind of powerful so that you just
ride it for one context and the
internals kind of handle it for you so
it reduces a lot of bugs where you know
repeating constantly each specific
scenario that something can appear in
and so there's a lot of applications for
this it's extremely wide from browser
compatibility to module mocking to
profiling so it's more or less the same
thing javascript in and javascript out
so today i'm going to be focusing on
four different areas translation so
es2015 to es 5 application optimization
browsing availability and a mystery use
case which is by and large my favorite
so first and foremost is translation so
there's this new fancy thing called es
2015 it adds a ton of new features from
arrow functions as hell calls
unfortunately browser support is fairly
poor I mean it's entirely new standard
these features are incredibly
complicated to implement in modern
engines and even when modern engine
modern browsers do support the whole
range of features there's always going
to be mosaics of the world more
importantly mobile browsers that rarely
get updated in an accessible and open
web it seems ridiculous how to limit
yourself to the latest greatest browsers
and so one of these new fancy features
is es 2015 error functions so these are
a different way to write functions
I picked this feature specifically
because it's seemingly straightforward
how to transpile this but there are kind
of some hitting gotchas associated with
where it's not perfect so these are the
four kind of main semantics of error
functions it has an implicit return for
expression bodies it inherits the
arguments and this binding so you cannot
new it and it has no prototype so for
this example it turns the multiple disk
into a return at this stage it's just
kind of just syntax handy on
around it so yes we can do implicit
return for expression bodies but what
about arguments in this well so we've
got this it's meant to reference Bob but
if it was just a normal function it
would reference this top friends so in
order to retain the same this binding
you can just simply add the decorator at
a reference of this and then replace the
this inner functions to reference that
temporary variable so we can inherit the
arguments and this bindings but now for
the bad news
what about not being able to new it so
in es2015 this should be illegal arrow
functions aren't completely synonymous
with normal functions I mean if it was
there wouldn't really be much excuse to
have it in the language and since we're
just telling our functions into normal
functions it works so one of the ways we
could do this is by adding a name to the
function so underscore error and then
replacing all new expressions with this
help a method that checks to save the
name of the function is um spa error but
what if you're relying on the name of an
error function so if you don't name
should be foo not an underscore error so
you're trying to implement specific
semantics by introducing bad ones as
well so it's kind of or you could add a
property and just use that and then in
the construct helper check to see if it
has the underscore our property this is
it's kind of crap so in the first
example we're adding the wrong name to
the function and in the second we added
a property even if this was practical it
only really affects code that we've
compiled so all third-party code that
would execute it it would work normally
so it's kind of iffy we can't completely
replicate at least not practically some
of these features and semantics so we
can't not allow people to do it at least
not practically what about no prototype
so as I said before our functions aren't
normal functions they so they have no
prototype so you can't use them
constructors so since we just turn them
into normal functions how could we get
the same behavior so we need some way to
mark it as an arrow function in this
case we add a property and then we
change all references to just dot
prototype to use this helper method that
checks see if its function if it is
returned undefined otherwise just return
the prototype um this is problematic
since Java scripts of dynamic language
so it could be like this it's kind of
difficult to catch so this means that
you have to wrap every single property
access computed property access to
determine whether or not it's ever going
to access prototype so you end up with
something like this
it's going to add a lot of additional
overhead especially in hot code where
performance is extremely critical it's
not really ideal you're really
implementing a lot of native JavaScript
features that are kind of unnecessary so
this is even worse the main wrapping or
code that we think is dynamic with
helpers so at this point were like a
little engine that could you can almost
get there you're so close but there are
some things that you can't really
practically implement using just a s5
especially if you want really good
performance so what is this mean for the
average developer that's currently
transpiring what would the migration
path be like from transpiled es6 to
normal es6 it'll likely be smooth but
you know like if you're relying on some
of these unspecified semantics split
that the transpiler
will kind of destroy then you may you're
likely to run into issues but it's
better than nothing
and so following this kind of want to
emphasize this point where you shouldn't
be using transpilers to learn new
language features you can definitely
like compare the output but if you're
just basing all of your knowledge on new
language features on hey this is
equivalent in es5 so it's exactly the
same then you're likely going to be
misinformed since there's a lot of
hidden semantics that can't properly be
replicated and even like stuff like
referencing a variable can drastically
change the way that the
it is generated and so yeah it's it's
really contextual so you shouldn't
really be relying on transpilers to
learn your language features so what
about something a little more practical
application optimization at face value
this may seem like an eclaim but allow
me to elaborate
so the preface is so I have to talk
about compile time versus run time so
when you're compiling your code it so at
compile time it's only compiling your
code that hasn't even been executed yet
and run time is when your code is
actually running so when it's executing
and you simply know different things at
different times so when you're compiling
the code you can determine that Square
is called with a two literal and then
and then Square is called the M with
just a variable at runtime you can't
determine the square function can't
determine what it's being called with
since it only cares about the actual
value not kind of where it came from or
how it was represented so this is
extremely useful so we can determine
what the exact intent of the code was
this is so what are some examples of
this so a big one is reiax
you may have heard of it it has a neat
feature or well feature JSX which is xml
like syntax you either love it or hate
it
it is however good for one thing which
is writing additional language semantics
now traditionally it's really just being
syntax handy so it's been like a
one-to-one mapping to your function
calls but in Reax 0.14 JSX elements are
treated as constant value types so if it
looks the same then we'll always return
the same value so whenever you call
render it will return the exact same
instance so this is extremely important
for performance since why you're
constantly doing more work than you have
to so this would be turn in something
like this so it'd be hosted to the
highest paper that could and then just
return free would be done in the render
method so each time you called through a
render story it would return the same
element so this works for immutable
elements but this enough to be applied
to readable ones as well so here the
react the JSX element you
as references the fruit and text
variables and so that can be wasted to
the create component function like so um
and so the core concept is just
pre-processing and making the JavaScript
engine do less since doing less is
generally faster and JavaScript engines
have no way to infer this kind of
behavior you have to tell it basically
using this kind of techniques
another example is M Bo so amber uses
HTML bars now you may want to use these
embedded in files in like stuff like
tests it seems silly to have to
constantly compile this every single
time the credits run since this is
static and like it's constant so there's
no reason to really be making the client
to it each and every time so you should
be doing it when the when you're
processing when you're building your
JavaScript and so you can determine that
tagged the the template and then compile
it when you're pre processing it into
something like that where the comment
represents the actual template contents
so the main points that I want to take
away from this you shouldn't be relying
on pre-processing for functionality so
like this type of stuff should purely be
supplementary instead of additive so it
shouldn't be it should it shouldn't
really be changing the way that the code
works it should just making it faster or
removing things that kind of don't
matter since your code may not care
about it and you're the only one who can
make assumptions about your code the
JavaScript engine copy more lenient it
can't not do things if you tell it to do
something it has to do it so you have to
tell it to do less so the next item is
browsing a pad ability it's a basically
it's just trying to patch broken browser
implementations of certain pages so this
isn't relevant really in newer browsers
but there's some things that in older
browsers that are just completely broken
sir Internet Explorer 8 who would have
thought this would've been one of the
browsers that was broken so there's an
issue with named function expressions
here we declare a variable with the
function
Russian note that it is named and then
online to that it's leaking out so it's
kinda been treated as a function
declaration and then on line three it's
trading two different bindings with two
different objects what so it HAP what's
the solution you automate it you fix it
so this is a babel plugin that will
change or name function expressions into
an immediately invoked function that
turns the function into a declaration
then returns that declaration so this
may is somewhat comprehend it actually
is but this is basically what it does it
turns the the function the name function
expression into this emailing invoked
function a return turns into a function
declaration than then returns our
function declaration so that basically
fixes the buggy behavior of insects per
eight so the last mystery application of
javascript transformation is a mirja
fication I have no idea if that's an
actual word but I think it is now
so is 2015 it has Unicode point escapes
so you can do stuff like this where the
variable declared our ID is a Unicode
character so what does this really mean
emojis so about this foreign code I took
this from the jQuery sauce trimming
letters and what can we do with this so
we can convert this to this now here all
the identifiers are escapes but have no
fear they do represent emoji so unescape
s-- it looks like this
beautiful so don't even need comments at
this stage you can just represent the
intent of your variable is using emoji
like so how can you do this well I made
an NPM package you can install it and
use it probably won't run in browsers
since not many support or I'm not sure
if there are any that's what Unicode
point escapes for identifiers yet but
the future so Java Script transformation
JavaScript in JavaScript out hopefully
by now kind of there's a lot of
potential for extremely high quality
tooling that not only evolves quickly
but it's very stable that keeps up with
the rapid pace of the web and as new
features implemented yes sir that's it
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>