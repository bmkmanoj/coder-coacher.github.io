<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JSConf Iceland 2018 Day 1 Katla Track - Live | Coder Coacher - Coaching Coders</title><meta content="JSConf Iceland 2018 Day 1 Katla Track - Live - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JSConf Iceland 2018 Day 1 Katla Track - Live</b></h2><h5 class="post__date">2018-03-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/D-h3bhzauKo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">please standby for realtime 
captions... Test.  
   &amp;gt;&amp;gt; Please let me know if you 
can hear me right now.  
   &amp;gt;&amp;gt; STUDENT:  I can
hear you! 
   &amp;gt;&amp;gt; Okay.  Awesome.  This is 
working right.  That's great.  
And I got you connected to the 
monitor.  I think it's like, ten
minutes...
we're basically just waiting.  
We're running late, so you can 
make a call when you're ready.  
It's supposed to start at 11:10.
captions... 
Please
.  
for
realtime
.  

.  
       .  
.  
           . .  
.  
           .  
.  
   .              1
.  
   .  
   Live Captions by:
   Live Captions by:
@smiley845 with @whitecoatcapxg
    &amp;gt;&amp;gt; Hey!
How's everyone doing? 
[ Applause ]
so, so, so quiet, I feel.  How 
is everyone doing? 
[ Cheers and Applause ]
That's better.  That's how loud 
you should be when someone comes
up here on stage, especially our
next speaker.  His name is 
David.  He comes from Microsoft.
He's very passionate about open 
source.  Loves talking about 
web-based technologies, 
JavaScript, CSS, and he is going
to talk to us about simplifying 
complex UIs.  Who here works on 
apps and thinks that they've 
gone like, you know, bananas, 
and it's way too complex for 
them to
handle? Me included.  It can go 
into unbelievable complex 
things.  I don't know what a 
finite automa statechart is, but
we will find out.  Here is David
to talk to us about complex UIs.
[ Applause ]
   &amp;gt;&amp;gt; DAVID: Thank you.  Is this
on? Can you all
hear me? All right.  There we 
go! All right. 
So, yeah.  My talk is
simplifying, though I would have
liked to see a talk titled 
simplifying complex talk titles 
with fewer words.  I know what 
you might be thinking right now.
The react API, a little scary? 
There's a good book in order to 
understand how to best work with
it, and it's doing
whatever Danny says to do.  The 
second half of this talk is 
exactly what I'm talking about 
today, except in the more 
general sense.  
    I want to talk about it, 
though.  Not in the context of 
React or you or angular or any 
of the last frameworks that came
out last week.  But I want to 
talk about it in a 
framework-less context.  This is
an idea that doesn't just apply 
to any framework or no framework
in general, but really any 
programming language as well.  
We can see how it could help us 
simplify our UIs.  So I'm a
pianist, and I have been playing
for about 20 years.  This is the
approach that I take to software
development.  I made the analogy
that if software is music, then 
developers are composers.  We're
taking that music, and we're 
composing it in a way that is 
applicable to any language or 
any platform.  And we do so in a
variety of ways.  However, 
music's interesting, because 
with music, you have music 
notation, which you just saw 
there.  Let's go back and see 
it.  So this stuff right here.  
This music notation is hundreds 
and hundreds of years old.  
However, the exact same notation
is used today to represent music
from classical, romantic, 
whatever the hell Bjork is.  You
can give a musician who 
understands how to read sheet 
music, and they will be able to 
play it.  And this works for all
instruments, and you know, all 
musicians of all levels.  So I 
was wondering, what is the music
notation of user interfaces? 
What do all user interfaces have
in common, and how can we 
represent that
declaratively? 
    So when we're working with 
software, we usually deal with 
APIs.  Good APIs have three main
qualities.  They're well 
documented.  You can read the 
documentation and understand 
exactly what's happening with 
the API.  They are very 
predictable.  The API is going 
to work the exact same way every
time.  And they're also 
testable.  You can test against 
an API.  They provide mocks for 
you or have a test database or 
something like that.  So user 
interfaces, though? User 
interfaces are really complex.  
I mean, does anyone find 
developing user interfaces easy?
Those of you watching online, no
one raised their hand, which is 
good, because I would have 
called them out if they did.  We
have to deal with something 
called a human API.  That's all 
of you, all of our clients, 
everyone we work with.  Human 
API is undocumented or 
unpredictable, and we're 
untestable.  And we're also 
extremely buggy.  If you don't 
believe me, turn on an American 
news network, and you'll see 
proof of that.  So I work for 
Microsoft.  By the way, I'm not 
relating Microsoft to any of 
this terrible API stuff, I 
promise.  And at Microsoft, we 
have more than 50,000 software 
engineers throughout the world, 
and at least 7 designers, I'm 
sure.  
[ Laughter ]
And we also serve one and a half
billion customers.  I think this
is just for windows.  It might 
be more than that.  When we're 
developing user interfaces for 
1.5 billion people, we have to 
imagine all the different ways a
user could use the user 
interface.  And you know, this 
is different cultures and 
languages.  You wonder why 
diversity is so important in 
tech? We have to reach the 1.5 
billion people.  So we don't 
develop software for just one 
person.  However, when we're 
developing software with just 
the happy path in mind, that's 
essentially what we're doing.  
We're assuming that there's this
ideal user who's using our 
applications in the exact way 
that we want them to.  But this 
never
happens.  
    We're going to take a look 
at the code example, but I don't
want you to read too deeply into
the code.  I just want to see if
you relate to this.  We're going
to create a sample F where we 
query the flickr API and then 
the results.  Similar to what 
Dan was doing with movies in his
last talk.  So it's pretty 
simple right? We do a fetch.  
Then when we get the data, we 
show it.  Are there any bugs 
here? Are we done? Well... 
    Let's say the data takes a 
long time to load.  Okay.  So 
now we have to set this loading 
flag, loading is true.  And once
we finish loading data, then we 
have to set loading to false.  
Are we done? No.  What if we 
have an error.  Well, we have to
hide the loading screen, show 
the error, right? But, are we 
home free yet? No.  Because, we 
also have to make sure that we 
clear the error once we try to 
search again.  As you can see, 
the complexity is getting bigger
and bigger.  Now my onserve to 
vent handler is getting 
extremely huge.  I'm sure many 
of you can relate to this code. 
Many of you will say yeah, some 
of my code looks like that.  
Sure.  What if your boss comes 
to you and says we want the use 
tore be able to cancel the 
search, because, you know, 
sometimes it takes too 
long.  
Sometimes they want to search 
for something else.  That logic 
gets crazier.  I don't know if 
you can read that.  I'll zoom in
for you.  But there's a lot of 
complexity in just one event 
handler.  You might know this as
spaghetti code, where our code 
quickly gets unmanageable.  Some
of you might see your engineers 
and think I don't do spaghetti 
code.  All of my code is modular
and layered and separation of 
concerns.  You might not write 
spaghetti code, but you might 
write lasagne code, which is 
spaghetti code in layers.  This 
is called the bottom-up 
approach.  That approach is 
whenever you have an event like 
onclick or on change, you do all
of the logic in that event.  And
that can refer to so many 
different actions, and some of 
those actions might change the 
states.  But you have to choose 
which actions are executed, 
otherwise you might edit the 
state in a wrong way, and you 
have to ad if statements.  
There's a lot of downsides to 
this.  This bottom-up code is 
difficult to test.  All the 
application logic lives in your 
mind.  So when you're writing 
your tests, you have to output 
it from the developer's mind on 
to the tests.  And it makes it 
really hard to work with other 
developers.  The code is 
difficult to understand.  The 
code that I just showed you for 
showing and hiding the gallery, 
if you were to try to parse that
as a brand-new developer working
on the project, you would find 
it really difficult to do so.  
The code will contain bugs, for 
sure, because there's going to 
be edge cases that you might not
have considered.  It will also 
be difficult to enhance, just 
like we've seen with 
cancellation.  And features, 
such as cancellation, make the 
code work.  They explode the 
potential possible states and 
actions that could happen in 
your application.  
    Here's an intuition for 
moving forward.  We have a 
realization that UI components 
are not independent.  We have 
frameworks that they isolate 
components and say these 
components fit in their nice 
little box, and we can stick 
them in the page
anywhere.  
Everything they see on the 
screen is in the exact same 
context, and we have to 
coordinate from components to 
component.  So another 
realization is that actions, 
which is what happens when you 
do an event, are based both on 
the events executed, and the 
current state of
the context.  
And it's also that this event 
action paradigm is too simple to
represent all the possible 
states our app can be in.  
    So, what's
the solution? 
Standard statecharts.  I know a 
lot of you may have heard these 
before or studied them in 
school.  Even though you might 
know what these are, you 
probably haven't applied them to
user interfaces and actual 
software.  So, looking up 
material for this could be a 
little complicated.  I'm a 
visual person, and I'm going to 
do it in a very
visual way.  
First you have an initial state.
Then you have a finite number of
states, which represents the 
states that the app could be in.
When an app is in one state, it 
can't be in the other state at 
the same time.  You have a 
finite number of events, such as
fetching, resolving, or 
rejecting a promise.  You have a
mapping from state to state 
based on these events.  So for 
example, when you're fetching a 
promise and it resolves, you go 
to the fulfilled state.  And 
same way with reject and 
rejected state.  And you have a 
finite number of final states.  
User interfaces can be
continuous.  We could keep using
them.  It doesn't say we're 
done, so go uninstall Instagram 
because you're not going to need
it.  If you go to this site, 
it's going to say promises are 
just a state machine.  That 
should give you a big clue with 
what we're working with here.  
    So the original app that I 
showed you, the gallery app can 
be modelled as the state machine
right here.  So we start in the 
idle state, and then we go to 
search.  Then we're in the 
searching state.  If we try to 
search again, it loops back.  
It's like hold on.  We're 
already searching.  We can 
either resolve or reject the 
search results.  And from those 
two states, we could
search again.  This is clearly 
seen by the arrows going from 
success or failure back to 
searching again.
So, the machine that -- the 
state machine that I envision 
looks sort of like this.  It's a
JSON object.  I like JSON better
than blackbox functions because 
you can enumerate all the 
possible states and actions and 
be able to transition from one 
to the other with nice, simple 
function right here.  For 
example, if we're in the 
searching state, and I get a 
resolve, then I just look it up 
in this JSON object.  This 
searching,
on resolve, success. 
In type script, it's a record.  
I guess it's the same in C#.  In
PHP, they call for help.  I 
don't know.  So here's an 
example of what I just showed 
you.  If I were to search for 
iceland -- let's search for 
goats first.  Let's say I don't 
want to search for goats.  I'll 
just cancel that.  Let's search 
for Iceland
instead.  When we do the event 
of selecting a photo, we have a 
state transition that goes from 
gallery to photo.  We can exit 
that, search again, cancel, 
search.  Let's cancel that.  
Iceland.  And so you see it goes
from state to state, and no 
matter how many times I try to 
break this app, it's not going 
to deviate from this state 
machine that I have here.  And 
you see there was a few extra 
things such as done searching, 
actions over here.  When I'm 
update the items? We're going to
discuss that in a little further
detail.  And also this is part 
of an article that I wrote which
gives an introduction to finite 
state machines.  
    So I use visual studio 
share.  I work on it and I also 
have to use it.  It's called dog
fooding.  Anyway... and this is 
sort of what it looks like.  And
so, I don't know if we have 
Sarah and Burke in here.  Here's
Burke right now.  You can think 
of it as Google docs for 
collaborative coding.  It's in 
preview in Microsoft.  And I 
have no control over what 
they're typing, and they're 
typing this in realtime.  With 
this live share, we can 
collaboratively code in the 
exact same document at the same 
time.  These are a complex 
series of events that are 
happening at the same time, and 
so we have to manage all of 
these possible events and all 
the possible states that this 
could be in.  I have no idea... 
    Oh God.  Good luck breaking 
the demo.  It probably will, 
though.  Ha ha.  Anyway! I'm 
going to end this before it gets
too crazy... 
One of the big things I have to 
work on in liveshare is this 
whole sign-in flow.  You would 
think that signing in is easy 
and, you know, signing in, 
signing out, all of that.  But 
it's actually not.  Once you 
start drawing it out, it becomes
a lot more complex.  So for 
example, there could be a 
sign-in failure.  You know, 
especially from Iceland.  I'm so
glad that worked in Iceland.  
All of our servers are based in 
the United States.  So when you 
have a sign-in success, then you
go to the signin state.  From 
there you could go do two 
things.  You could either share 
a session or join a session.  So
what I did was a couple months 
back, I refactored this part of 
the app so that it uses an 
explicit state machine just like
this.  We were getting a lot of 
bugs.  We were saying what if 
we're in the middle of sharing 
and the user signs out? What if 
we join the session, and then we
decide to share a session at the
same time? That shouldn't be 
allowed.  We had all of these 
if/else and switch statements, 
so I decided there has to be a 
better way.  I did the simpl 
JSON object approach.  The state
machine that I set up? It was 
very easy to add telemetry to 
it.  I added telemetry, and I 
get this nice visual showing 
exactly the frequency of how 
users go from state to state.  
So you could see obviously, most
of the users go through this 
initializing and then signing in
state, and then you could either
externally sign in, or you could
sign out.  And then you could 
see that users tend to go to 
either joining or sharing, you 
know? At about the same 
frequency.  And yeah.  So it 
clearly shows, too, how many 
users go to the error state and 
how many users go to the success
state for each of these states 
as well.  Now, these are very 
powerful insights.  Because 
while telemetry will only tell 
you an atomic bit of data, here 
is telemetry that tells you the 
entire user flow of what's 
happening.  We could limit this 
to user and be able to see a 
nice path of what the user 
actually did in the app.  So 
it's sort of like, you know, 
like the funnel diagrams, except
even crazier.  
    We could also use state 
machines for integration 
testing.  And so this gets a 
little bit into graph theory, so
bear with me a little bit. 
Here we would be using a 
shortest path algorithm.  You 
could choose your favorite one. 
It sounds like an
Icelandic name.  
Any of these formulas for 
finding the shortest path.  And 
so, for those who don't know, 
the shortest path is just going 
from one state to the other with
the minimal cost.  So you could 
imagine each of these arrows 
have a wait.  And so you just 
want to minimize, you know, how 
long it takes to get from one 
path to the other.  Sort of like
in Google maps, finding the 
shortest ETA from one point to 
the other.  So analytics would 
provide these waits.  And this 
heaped represents all the happy 
paths a user could take.  If we 
want a user to, let's say, share
a session, and get to the shared
state, we would imagine the user
going from signed in to sharing 
to shared.  Just that simple.  
These could be automatically 
generated from the JSON 
structure just like this.  But, 
remember, we're not just dealing
with the happy paths.  So, we 
would do a death first search 
algorithm to find all the other 
paths a user could take.  Some 
of you might be thinking these 
algorithm things, I didn't think
I would need them.  You sort of 
do; they're really 
helpful.  And so, these 
represent all the possible user 
flows.  You can imagine a user 
getting from state A to state C 
might not take the easiest 
route.  They might take a longer
route to get all the way to C.  
And it reveals all the edge 
cases.  
When you model every single 
possible state with every single
possible action, and you get all
of these flows, you're going to 
basically have 100,000% test 
coverage for anything that could
possibly happen in your app.  
And of course these could all be
automatically generated.  I 
caution against this, because 
you would be generating 
integration tests -- it would 
generate a lot of integration 
tests, which isn't necessarily a
bad thing, but when you're doing
continuous integration, you 
don't want your tests to take 
four hours long.  
    It makes software bugs 
visually clear by drawing a map 
and putting them on the diagram.
You can see when I do this 
event, I'm going to the wrong 
state.  Or maybe I have an 
unhandled event, which does 
nothing.  Or maybe I have a 
missing transition.  That's 
shown here, too.  For example, 
Dan was showing the example 
where when you click a movie, it
just waits and waits, and then 
you get the next movie, and 
there's no loading state.  You 
can clearly see that in the 
state transition diagram.  And 
also, my favorite, race 
conditions.  These are just made
completely nil and void with 
state machines, because you 
explicitly say, when I get this 
event, I go to this state.  If I
get another event after that 
that I don't care about, it's 
not going to cause a race 
condition, because I will ignore
that event.  And that's what 
state machines can help with.  
    Now I want to talk about 
Harold statecharts.  This could 
go on for hours and hours, 
because there's so much 
information here.  I'm going to 
give an overview of what these 
are and how these extend state 
machines in order to improve the
way we look at user interfaces. 
Because, user interfaces can get
complex, and finite state 
machines might not solve 
everything.  So with 
statecharts, they are similar to
state machines.  They are an 
extension of it.  Except we can 
have actions with Harel 
statecharts, too.  They actually
do things to the state and the 
app.  We can have guards which 
prevent states from going from 
one to the other if something 
doesn't match the condition.  If
I'm trying to search for 
something, and the user didn't 
give me a search query, then I'm
not going to transition to the 
next state.  That could be 
declaratively modelled as well. 
There's the idea of nested
states.  This is parallel 
states.  It is not concurrent 
states where an app can be in 
two states at the same time.  
It's more a way of simplifying 
the number of states you have so
your state machine doesn't look 
all crazy.  And also, history, 
which is a very common feature 
that many users would want in 
order to go back to their safe 
state.  So I created this 
library called X states which 
models finite state machines and
statecharts in a declarative 
way, so that all you would have 
to do is use this JSON structure
to model your state machine, and
then you would get the next 
state by calling transition on 
the current state and the 
action.  It's functional, and 
it's going to work in any 
framework or no framework at 
all.  It also has the notion of 
actions, so it will return you 
an object telling you, these are
the next actions that you're 
going to take once you 
transition to a state.  It also 
has guards, so you could pass in
some external state, and it will
validate against that external 
state and say, Okay, this 
condition is met.  So you go on 
to the next state.  It also has 
hierarchy so you can represent 
and compose machines easily.  It
has 
orthogonality so you can 
represent parallel states and 
also represent remembered 
states.  If you're doing a 
payment flow and you're asking 
for cash or card, the user can 
switch between them, and the 
user gets to the review page.  
You want to remember if the user
chose cash or card.  So you go 
to method.history, and it would 
remember that.  And this is a 
purely functional, no side 
effect type of thing.  And so 
you can imagine the applications
of where you could apply this.  
One example of where you would 
use orthoganal states is this 
example.  Say you have bold, 
italic, or underline.  A user 
can use all or none of them, and
it's represented by all of these
eight states.  And you can 
imagine if we add more options 
such as align left, align 
center, justify, it's going to 
explode into even more states.  
With orthogonal statecharts, we 
just have this succinct 
representation of these possible
states, so that we know we can 
go from bold on to after, 
italics on to off, and same way 
with underline, and we can 
represent all of those at the 
same time.  And also, hierarchy 
helps to reduce the number of 
arrows that you have in your 
finite state machine.  So for 
example, both the success and 
failure states, we could search 
again and go back to the 
searching state.  We could 
simplify this by just nesting 
them in a single state, the 
search state.  This is fully 
supported by X state, and yeah. 
So, you could imagine how this 
would simplify just really 
complex state machines.  So, I 
released X state about six 
months ago at React rally, and 
since then, there has been a lot
of development and a lot of 
people actually using it to make
projects such as React automa 
and others.  And pretty soon, 
I'm going to be releasing 
another version, minor version. 
Don't worry; nothing crazy, of 
Xstate where we improved the 
user
ergonomics.  It's full SCXML.  
It's not sexy.  Code is not sexy
at all.  A
Reactive interpreter, 
visualization interpreter, and a
lot more examples.  
    In order to show you what 
I'm talking about, here is an 
example of a visualization tool.
That same JSON object that you 
passed into xstate and the same 
one I used for my gallery app, 
this is one example of where you
would
use this.  My initial state is 
start, and I can hover over this
search action, and go to this 
state.  Then I could see the 
possible different actions -- 
sorry, events that I could take 
from this state.  So let's say I
have a search success.  And so, 
I go into the gallery view.  And
then I choose to search again, 
or I could select a
photo.  So, I can visually see 
what's happening in my state 
machine by pasting in that JSON 
object.  That's hard to do with 
just a function, so that's why I
decided to do it in a more 
declarative way.  I'm going to 
be releasing this soon.
I want you all to enjoy the rest
of the conference before I 
release it, so you can have time
to play with it afterwards.  
That's my excuse, at least.  
It's not out yet.  
Now, it would be, you know, sort
of remiss of me to not talk 
about sort of the downsides of 
state machines and statecharts, 
but the truth is that you all 
are already creating finite 
state machines and statecharts 
in your app already, and you 
don't even know it.  However, 
the ones that you're creating 
are implicit.  They're full of 
bugs.  They're incomplete.  And 
that's just the nature of
how we code.  So the advantage 
of finite state machines and 
modeling them in a very explicit
way is that you reduce a lot of 
complexity up front just by 
getting rid of your if/else 
statements and getting rid of 
your switch statements and 
having a direct mapping.  
However, that quickly explodes 
into many, many different 
states.  So statecharts help 
manage that with a little higher
complexity cost up front.  But 
in the long run, you will see it
will be very easy to add 
features, remove features, and 
handle different actions and 
different possible modes of your
application.  
So, of course, there's a lot of 
advantages to using statecharts,
and the ones I am going to quote
are not actually from me.  
They're from NASA.  A few years 
ago, NASA had to send this 
little vehicle right here all 
the way to Mars.  And they did 
so using statecharts.  So the 
advantages that they said was, 
first of all, there's visualized
modeling.  So you could both 
model and examine the model of a
state chart using visual tools. 
You get these precise diagrams 
that tell you exactly what's 
going to happen when certain 
conditions are met, when you're 
in a certain state, and this 
event happens.  When you're 
sending something to Mars, you 
can't exactly just send it there
and hope that it work works, 
right? You have to be absolutely
sure that your billion dollar 
project is going to handle every
single possible state.  And so 
they also use state charts for 
automatic code generation.  I'm 
not a fan, but you could see how
it could be beneficial.  Also, 
comprehensive test coverage.  By
using state charts, they were 
able to generate just all of 
these integration tests where 
they could test each and every 
one, and ensure that every 
single state was being hit, and 
every single possible action or 
event was being handled.  Also, 
you know, being on a big 
project, you have a lot of 
requirement changes.  We want to
add this to the rover.  We want 
to remove this functionality.  
We want to change the way this 
works.  And when you're working 
on a big project, and you have 
these late breaking requirement 
changes, then things can get 
really stressful.  With state 
charts, since you could clearly 
see the full flow of your 
application, you could easily 
add and remove features without 
worrying what's going to break, 
what's going to change, what's 
going to be affected.  So there 
are some disadvantages as well. 
    And the disadvantage is that
my screen just went black.  I 
guess that means there are no 
disadvantages.  Ha ha.  
Anyway... 
Since the rest of my slides are 
forked, I want to show you this 
real quick.  I gave a talk about
one and a half years ago. 
It was at 
JSConf Iceland.  This is where I
saw the primary use case for 
using state machines and 
statecharts.  There was this 
really complex UI design that I 
really wanted to model, and I 
found it pretty difficult 
without using an explicit state 
machine or state chart.  So what
I'm doing here, there's three 
different states.  This one.  
This one.  And there's different
actions as well.  So
the user could pan right, but 
just a little bit.  So I handle 
that as a transition from going 
to state A, back to state A if 
they didn't move far enough.  Of
course, if they move far enough,
it goes to the next state 
successfully.  And also, it 
handles, like, if I'm going up, 
and I decide to go left and 
right, it's not going to do 
anything, because we're already 
going up and down.  So it knows 
when this event happens, don't 
try to go to a different state, 
because we're already 
transitioning to one state.  
    I also wanted to mention two
very good resources. 
The first one is on 
spectrum.oi/statecharts.  This 
is a community where we talk 
about statecharts, their 
possible applications, and how 
they're used everywhere.  
Statecharts are nothing new.  
They're invented by David Harel 
in 1987, which is what? 30 years
ago? This is not cutting-edge 
stuff.  If people are asking why
aren't we using statecharts 
everywhere now? Well, the thing 
is, they are in embedded systems
or systems programming.  People 
do use statecharts in order to 
model their applications.  We 
don't, quite yet, but I think 
it's about time that we catch up
to it.  And so, Eric Mogansen 
made a wonderful resource called
the unfinished world of 
statecharts.  Over here, if you 
want to learn more information, 
there's a well
wealth of
information here.  I really want
to 
encourage you to revisit your 
application and the way you 
think about things, and actually
try to visualize things.  You 
will see that by visualizing 
your application, all of its 
possible states, all the events 
that could happen, that you're 
going to have a clearer 
representation of the possible 
bugs, the possible features that
you might have, the user 
improvements, and everything 
else.  So I want to thank you 
all for having me.  
Unfortunately, I can't show you 
my last slide, because it's not 
working, but thank you.  
[ Applause ]
   &amp;gt;&amp;gt; That was so awesome! I 
have a question for you.  I 
thought it was really 
interesting, and I also want to 
apply this to what I do in 
working with UIs.  Do I have to 
completely refactor my app so I 
can get the advantages of what 
you just talked about with 
finite state machines? 
   &amp;gt;&amp;gt; DAVID: That's a really 
good question.  With Redux, you 
have to pull everything out, but
with statecharts, you don't.  
Statecharts can't model 
absolutely everything, and 
neither can finite state 
machines.  So what you could do 
is you could write a separate 
finite state machine that 
represents your app, use that to
create tests, and once you see 
all the tests are passing, then 
you slowly start moving it in.  
You can use finite state 
machines for things as small as,
should this button be disabled? 
And then you stick it in there, 
have your app grow, and use 
state machines everywhere.  
   &amp;gt;&amp;gt; That's awesome.  Thank you
so much.  That's actually a 
really good transition into the
next talk.  It's going to be 
from Will.  He's coming from 
Colorado.  He's passionate about
open source software as well, 
organizing events and meet-ups. 
Is Will around?
All right! Seems like Will's not
here? 
&amp;gt;&amp;gt; Let's take a bit of a break 
while we wait for the next talk.
Thank you. 
&amp;gt;&amp;gt; Will is here, so, we're
&amp;gt;&amp;gt; Will is here, so, we're going
to get started
really soon.  I'm going to talk 
about Will and Will's talk while
he sets up.  He's a front-end 
engineer, co-organizes the React
Denver meet-up.  He loves 
sharing what he can, organizing 
events, mentoring others.  And 
he says he lives on a healthy 
diet of diet coke and
ice cream.
That sounds healthy.  And he 
will be testing using a tool 
called Cyprus.  And it's for 
end-to-end testing.  Now we 
discussed complex UIs, and now 
it's time to test the complex 
UIs that we just created. 
Live Captions by:
@smiley845 with @whitecoatcapxg 
&amp;gt;&amp;gt; WILL: Thanks! Almost.  One 
second.  Thank you. 
Is it actually presenting okay? 
   &amp;gt;&amp;gt; I think it looks great 
from this  end.  Anyway, give it
up for Will Klein! 
[ Applause ]
   &amp;gt;&amp;gt; WILL: Oh my gosh, I think 
it works! Cool! Okay.  Whoo! 
    So, I've got a talk about 
end-to-end testing, and why the 
game has changed.  I actually 
have a little story to share as 
well that's kind of personal, 
but it means a lot to be
here today.  My name is Will, 
and this is my wife, Diane.  
This is us on Amelia island.  It
was a really great time.  I
appreciated that JSConf welcomed
us and our family.  I appreciate
that that tradition has 
continued here today.  I had a 
question at the time that I was 
trying to figure out the answer 
to.  How do you it's your front 
end? I think we've got answers 
about how to test our unit 
tests, how to test our 
functions, our classes, and our 
UI components in isolation.  I 
think it becomes more difficult 
when we try to integrate all of 
these things and put it all 
together.  A lot can go wrong, 
whether it's our UI or web APIs 
or our back-end or database or 
even our deployments.  When you 
put those things together, 
anything can break down, and we 
can have all the unit tests in 
the world, and they won't help 
us in most cases.  So the type 
of tests to emphasize this are 
called end-to-end tests, from 
one end all the way back.  I had
a lot of great conversations at 
the conference.  Sorry.  Move my
mouse off.  I had a lot of great
conversations, but one stuck 
out.  I
met this person Nicholas Boll, 
and he talked to me for hours.  
His wife was at the conference 
and she was quickly becoming 
friends with my wife while 
hanging out and talking about 
testing.  We talked about the 
tests his team had written. 
They had thousands and thousands
of unit tests.  Lots and lots of
integration tests, and maybe a 
thousand or so end-to-end tests.
They were testing an Enterprise 
app, which is an app that does 
way too many things.  I was so 
impressed with all the things 
they had to say about their 
stack and tools and all the 
effort they put in that I 
applied to work at his company. 
We moved to Colorado and joined 
his team.  He and his wife 
helped us off the moving truck, 
helped us settle in and invited 
us in for the holidays.  Now we 
hang out so much together today.
    So when I joined this team, 
I found they were using a tool 
that I was actually quite 
familiar with,
se  Selenium.  It lets us test 
apps from the point of view of 
the browser.  It's a little old,
but it's done a lot of wonderful
things and let us do things that
we otherwise might not be able 
to do.  It's go this java 
service that just listens for 
commands.  And you write test 
code in any language, actually, 
and more often than not, not 
JavaScript.  And that language 
would usually use a library to 
speak the language of Selenium. 
It sends the command to the 
service, and the service would 
cue the commands and try to send
them to any given browsers, real
browsers.  There was a number of
different abstractions and 
interfaces where things could go
wrong.  It could be that your 
test code has an issue, or 
you're using the API different. 
And all the different APIs work 
with Selenium, and they all work
with JavaScript.  They are all 
different.  They could have 
issues or you could use them 
differently.  They are sending 
command drivers to the browser, 
and the drivers could have bugs.
There are so many ways for this 
to have bugs just with this 
architecture.  
    So the greatest complexity 
of all is our app.  I find that 
as we write modern JavaScript 
apps, we're doing a lot of 
things now in the browser.  
We're making the different API 
calls from the page loads.  
Those come back in different 
timings, different orders 
sometimes.  That can cause just 
different behaviors in our front
end.  When the user interacts 
with our UI, that makes more 
calls.  More things happen.  All
these things happen 
asynchronously.  So we are 
rendering.  It could finish at 
any time, and we don't really 
necessarily know when it is, at 
least from our test code's point
of view.  As humans, it's 
intuitive to us.  But when we 
run our test code, it does 
exactly what we tell it to.  If 
it clicks a button and starts to
rerender, and we try to do the 
next thing, we need to be 
careful about knowing that it 
finished rendering, or we might 
get something unexpected.  
    So, the greater problem of 
all is when we take the Selenium
architecture and combine it with
the complexity of our apps.  
It's really a recipe for frees
frustration.  We run a commit, 
push it to the build, and 
sometimes it would fail, usually
in an end-to-end test.  We would
run that build again, because it
was a test that shouldn't have 
broken anything.  And it would 
pass.  We would see this over 
and over again, where different 
commits randomly fail different 
tests.  We call this flakeyness.
The problem might be something 
with the Selenium architecture. 
Often it was a combination of 
that and the complexity of our 
app working in different 
performance characteristics.  
Particularly when we're on build
environments, they're 
virtualized, things would slow 
down.  Anything could make it 
work a little slower in one part
of the stack at any given time, 
and something would fail.  We 
had a build job that would just 
run all the tests, and it would 
flush out dozens and dozens of 
tests that just failed a lot.  
Even with that, we just kept 
tripping over this issue over 
and over again.  Tests that 
would fail once in a while.  Why
do we keep doing this? Well, 
these tests we found to be 
extremely valuable.  You can 
have all the unit tests in the 
world, but if everything 
integrates and something breaks 
down, you're going to have a 
really bad time.  And worst of 
all, your user is going to have 
a bad time.  At the end of the 
day, everything you do is about 
building a user experience, 
building values so somebody can 
do their job or that part of 
their job, or make that one 
thing easier that gives them joy
and makes them happier or more 
productive.  We invested into 
making this better, the flakey 
finder.  And we tried to make 
our tests better in a lot of 
ways.  One example, we wrote 
some test helpers that would try
a command, and if something 
didn't work right, it would 
retry it a number of times for a
certain time out.  This is 
called an implicit wait, built 
into the API, so you don't have 
to do that manually in the code.
We also found that it helped to 
mock some service once in a 
while, mock services to test 
large data and certain 
scenarios.  Things like that.  
Doing that, we wrote some of our
own service mocking libraries to
make that process easier.  We 
invested as much as we could 
into making the developer 
experience of using and running 
our tests better.  So we keep 
doing it, despite how painful
it was.  
    So, after a while, I joined 
a new time and got Selenium up 
and running there.  That went 
all right.  Ran into some of the
same issues, and just this past 
fall in October, I was consult
consulting on a project.  We had
run into a serious quality 
problem.  We didn't have a 
dedicated QA team.  As much as 
we smoke tested our app on every
single commit, there were always
use cases we missed and we 
didn't know what happened.  We 
decided to write more tests.  I 
pulled the story to write the 
end-to-end test.  I pulled out 
Selenium, and the first thing I 
had to do on my year-old mac 
book was install java.  So the 
next tool I tried was Cyprus.  
And Cyprus was something that I 
had actually held off on using 
for a while.  It had been closed
source up until May of last 
year, and in private beta until 
October.  They had built a 
company around some of the 
premium CI features.  Now that 
it's open-sourced, everything 
that you need is right up there 
on GitHub.  If the team stopped 
doing what they're doing, the 
community could pick it up and 
run with it.  I waited to use 
this until it was open and 
freely available.  Something 
that was MIT licensed and ready 
to go.  
So I actually used it for maybe 
two hours, and I was honestly 
blown away.  I was so shocked by
how different and better my 
developer experience was that I 
wrote a proposal to a conference
after just working on it for a 
couple of hours, and here I am. 
[ Laughter ]
    I have a few downloads that 
I will run through to show you 
how to install it, set it up, 
what some of the tests look 
like.  I don't want to get hung 
up on the syntax or commands.  I
just want to give you an idea of
what it's like.  The first thing
you do is you MPM install it.  
This actually will do a download
from one of their -- from their 
website and pull down the right 
cypress app.  It will pull down 
based on your operating system 
and your CPU architecture. 
Next you open it.  And the first
time you open it, it kind of 
initializes some things and 
makes sure it's verified and 
it's the right thing and all.  
When it runs, there's a pop-up 
to say hey, to help get you 
started, we put some files in 
the file system, and you might 
want to take a look at that.  
The files are basically 
examples.  This is just nice.  
There is an example like 
fixture.  There's example 
plugin.  Custom commands, and an
example spec.  The example spec 
is a kitchen sink of all the 
different commands you might 
want, and gives you a quick 
reference.  You can go to their 
docs, but it's all right there. 
It gives you a little head-start
with what you might want to try 
to do.  
The nice thing is, it's -- 
from there, it starts to get 
very familiar.  If you've ever 
done BDD style tests, the syntax
is going to look very, very 
familiar.  Let me make this a 
little bigger.  Oh yes.  Cool.  
All right.  So this is just part
of a spec file.  And the first 
thing is there's this top-level 
describe.  We're describing our 
app or some view in our app, and
we can have the eaches, and do 
things before every test.  And 
most commonly will load the 
page, load a route on our app.  
We can have nested describes in 
mocha.  And we can have our 
it/shoulds.  It should do a 
thing.  It should focus on the 
to do field.  And from there we 
can start using the cypress API.
We are doing focus, which is 
look at what's focused in the 
window.  And then it says it 
should have the class new to do.
There's something interesting 
about the should, and this 
whole, you'll see some chaining 
here.  There's a reason why hay 
the use that style.  The should 
has a context of I'm try to do a
should on something that was 
focused.  The should will keep 
trying until it's true or until 
there's a time-out.  This is 
nice, because when we first load
our page, the first thing that's
focused might just be the window
or document.  That thing has not
rendered that has that class.  
It's going to keep retrying 
until it passes.  This permeates
all of their APIs, and having 
that context and doing things 
more intelligently by nature.  
I'll show you one other example.
This is an example that is quite
common where you try to get 
something based on selector.  
It's using 
Jquery under the hood.  And then
we just type in a little thing 
we want to do, and another thing
I'll point out is instead of 
having to embrace the key codes,
having to know what key code, 
they just use enter with curly 
braces.  It's nice and 
convenient that
way.  
    From here, I want to show 
you what running the test and 
debugging the test looks like.  
All the other stuff is 
relatively familiar to Selenium.
This is where it starts to take 
off.  So the first thing is you 
can run it headlessly.  By 
default, it runs headless
ly.  It is recording by default.
So you can replay the recording 
and all the tests, if you want. 
Here is where it starts to get 
different.  There's an electron 
app.  The first thing that 
happens when you load the 
electron app, there's a yellow 
warning that says, Hey, can you 
make sure you're running your 
web server.  It will check that 
when this app electron app runs 
to make sure you're running your
web server.  I can't tell you 
how many times I forgot to run 
my local dev server when I'm 
running my test.  It tells you 
right away.  And you can also 
choose which browser, whatever 
version of Chrome or firefox and
Edge and all of that eventually.
I'll get to that.  And then you 
run your spec.  From here we get
into the test
runner.  This is running in a 
browser, a sandbox browser 
environment.  The test runner, 
there's our test on the left, a 
header on the top that has this 
information about what tests 
have passed, which have failed, 
how long it's been running.  We 
can stop and replay it.  There's
a URL preview.  
There's a target icon, that's 
adomadom a dom selector 
playground. 
There's view port information at
the top.  On the right is our 
app.  This might seem like a 
little thing, but just having it
right in the same window is very
convenient.  And there's a very 
good reason why they put this 
all in the same
window.  
    So that thing on the left 
where our commands and tests are
logged, that's called the 
command log.  This thing is 
cool.  When we click on anything
in there, expand one of our 
tests, we see all the commands 
that our test tried to execute. 
    If we click on any of the 
commands, it will jump to that 
part of the test.  It takes DOM 
snapshots throughout the test.  
We can jump around in our test 
sequentially or out of order, 
and replay the state of our dom 
and see what's going on in our 
app without having to -- without
much effort.  And you'll see 
this thing at the bottom of our 
app that says before and after. 
Certain have commands such as 
before and after.  Typing is one
of them.  If you go to type new 
todo, you hit before, you can 
see what's going on, and then 
click the after and see what was
after the typed command.  This 
ability to walk through the dom 
snapshots just by click 
something a night and day 
difference from anything I 
experienced with Selenium.  The 
workflow I was used to is 
setting up a debugger, setting 
up a trigger point and hoping to
stop at the right point and 
running into default time-outs 
and test reloading and all of 
the lockouts that were 
frustrating.  
    If you write really good 
tests about your app like this, 
you can actually sort of 
document how your app works.  
And a new user or new person on 
the team could look at it and 
get a good understanding of all 
the things it does and how it 
behaves and what it looks like. 
All of that.  
    So, let's talk about 
debugging, like really 
debugging.  The first thing is 
when we click on those things in
the test runner, any of those 
things we click, they have some 
context of there's a DOM element
involved or a network request.  
If you click, they get logged in
the console.  Normally I would 
have to set a break point and 
write the logs.  Just with a 
click, we can get that and start
playing with it. 
DOM debugging, you can inspect 
the state of the DOM in any of 
these snapshots.  
It's not necessarily replaying 
all your different Redux states,
for example, your true app 
state.  It's just going based on
the DOM.  I have found in 
reality, with an app using React
and Redux, I was interact and 
things would sort of work.  And 
there are hooks to potentially 
do things like inject Redux 
state and snapshot that stuff.  
I haven't gotten to that yet; 
I'm not sure anybody has.  But 
there are crazy anyonings -- 
things we can do.  
I found it really awesome that I
only needed to run this one 
browser, this one app and this 
one debugger to debug my tests 
and app code.  This replay is 
showing hitting a break point in
my test code here and hitting a 
break point in my app code.  
And being able to jump between 
those two contexts.  I was used 
to having a debugger, hopefully 
in node and another in the dev 
tools for my app, and I would be
bouncing around between the two.
There's this cognitive load that
comes with, which one am I in? 
Where am I? Bouncing back and 
forth and windows switching and 
all of that.  When you start to 
take this very challenging thing
that we do every day and you put
it in a single place and make it
that much easier, it starts to 
make it
fun again.  
    I mentioned we had to write 
our own implicit waits.  There's
a four-second time-out, which is
plenty.  You can override that. 
There's direct access to the 
DOM.  In Selenium, everything 
was being serialized, so you're 
always getting a serialized 
version of the DOM.  You're 
actually dealing with a DOM 
that's in your app from your 
test code, and you just have it.
It's just nice.  And there's 
service mocking libraries built 
in.  They just made it easy to 
define things you want to match 
on like method or parameter and 
have it return fixture data.  
It's just rolled up.  That's the
thing overall.  It rolls up all 
this tooling that we would 
normally be cobbling together 
ourselves, sign on for the 
request stuff, service mocking, 
Jquery, mocha and chai.  It 
takes care of all of that for us
so we don't have to select them 
ourselves, and it becomes one 
cohesive package that is well 
documented on their site.  
    On their blog and docs, they
have tidbits like this.  When 
you start to extend the 
time-out, which is a common 
trap, something didn't work.  It
wasn't ready yet.  So we'll 
extend the time-out.  There's a 
catch to that, especially if you
do it universally.  There are 
things, tidbits that are not 
specific to cypress.  There's a 
book in here about how to write 
good end-to-end tests that could
apply to Selenium or whatever 
other tool you want to use.  I 
like that.  I like that they're 
a little opinionated and they 
share these things right in 
their docs.  It's nice that they
went
that far.  
    There are trade-offs.  I 
have been talking about how 
awesome it is, but I want to 
talk about what it lacks.  It's 
a new tool, new technology, a 
new thing to bring into your 
team.  There's always a cost to 
that.  I take that very 
carefully.  It has a style of 
chaining, and I don't like 
chaining, but there's a reason 
for it.  They like to maintain 
the context of what you're doing
so they can intelligently tell 
what you're doing next.  They're
up front about their trade-offs.
They have a whole doc dedicated 
to this.  They mention permanent
and temporary trade-offs.  
Permanent is that it runs in a 
single browser tab.  If it opens
other tabs, you will not be able
to test those things in cypress.
They didn't try to support every
browser out of the gate.  They 
just chose Chrome-based 
browsers.  They are working on 
Firefox.  They are fixing issues
on that, squashing some bugs, 
and they will have that as soon 
as they can.  And I'm sure that 
Edge and so forth will be next. 
That's something
that is very important.  I would
suggest still having some 
Selenium tests just for those 
situations that cypress cannot 
do.  I find that 99% of the 
value of the tests is easily 
covered by cypress, making sure 
we exercise all the views and 
interactions that we care about,
testing each work flow once.  
The user wants to do A, B, C.  
Test those things.  
Testing the UI components at 
least once is really important. 
    They basically re-invented 
the wheel, and any time you do 
that, you will have your own set
of bugs and challenges.  I think
they tried to not only
    They basically re-invented 
reinvent Selenium but add a 
comprehensive developer 
experience on top of it.  That 
is crazy.  If I would have ever 
met the original author years 
ago, I would tell him good luck.
I don't think it's possible.  
Don't feel bad if you fail.  
Here he is, with what started as
an experiment.  
He got it working, and he's 
built a team around it.  There's
six full-time devs on
it now.  
The open-source community is 
growing and others have made 
contributions.  There's going to
be bugs and issues.  There's 
going to be the trade-offs I 
mentioned.  I'm really glad that
they made it anyway.  
So I would definitely say when 
it comes to end-to-end testing 
and our ability to test the user
experiences, the game has 
changed.  I would encourage 
everyone to not just think about
unit coverages, but user 
experience 
coverage.  If you're new to 
this, do this.  Write a smoke 
test.  Test the main work flow. 
Do the happy path.  Make sure 
that's good.  That is going to 
give you 90% of the value.  
You're going to cover your build
and deployments and that one 
thing that your app is supposed 
to do.  From there you can start
to cover more things.  But that 
is the one thing that you could 
do in maybe a day.  I think I 
had -- I think I had the first 
app tested in an hour or two, 
and I went from
there.  
    I like to say this, don't 
let your users test an app.  If 
you're not automating these 
things, that's what you're 
doing.  You can have a QA team 
or smoke testing this yourself 
in your own browser, but there's
no way you can catch all the 
things that the automated tests 
can catch as quickly as they can
catch.  If you do them manually,
what's your dev cycle? These 
things can run very quickly and 
catch so much 
more.  
    So atlas law.  Any 
application that can do 
JavaScript eventually will, 
right? That's a good thing.  I 
was working in visual studio 
code, and I thought wow.  I 
remember when atom came out.  
Before I was using sublime.  
Everyone loves sublime.  Or at 
least they used to love sublime.
And then atom came out.  And oh,
this is rendering JavaScript in 
editor? This is fast and crazy. 
And visual studio code? I'm 
thinking when I use visual 
studio code in atom, I'm using 
pluginplugins.  There are 
eco-systems of tools, because 
they're written in JavaScript, 
and things we're familiar with. 
With cypress, it's still evolve
evolving.  We're in the early 
stages of seeing that eco-system
expand and grow and become 
something beyond what the 
original authors intended.  
    I really want to thank the 
cypress team.  They did an 
amazing job.  They definitely 
ran into all the problems that I
experienced with Selenium, and 
said they wanted to do better.  
And they have.  They've built 
something that not only is 
written in JavaScript, but tried
to solve the developer 
experience and tried to make it 
smoother and make it encouraging
for us to write the tests that 
are not always easy.  I think 
they've done a terrific job.  If
you -- I think their docs are 
great.  But if you need more 
help than what's in their docs, 
check out their GitHub chat.  I 
promise you they're nice and 
friendly.  
I want to finish my personal 
story.  This is my family and 
Nicholas's family.  We each had 
a daughter two years ago.  
They're born a month apart.  Our
wives are both expecting our 
second this summer.  I really, 
really wanted to bring my family
here, but my wife is five months
pregnant and my daughter is two 
years old and wants to climb 
over everything.  I asked my 
wife's doctor if I should, and 
she yelled at me.  She said that
would be a very bad idea.  I 
miss them very much, but I will 
also say that Nicholas and I, 
you know, still talk for hours, 
and still teaches me new things.
I'm so grateful for having met 
them at JSConf five years ago.  
    Thank you for joining me 
today, for wanting to hear about
how to write tests, how to do 
this better, about what's 
changed.  I hope I have given 
you some ideas about that and 
about what's happened in our 
eco-system, what's happened in 
our tooling.  I love talking 
about this stuff.  Please come 
find me or find me on Twitter
Twitter @willslab.  
   &amp;gt;&amp;gt; Thank you so much.  I find
your story really inspiring.  
It's like a story of mentorship 
turning into friendship and more
mentorship after that.  We can 
all learn something from that.  
Really, talk to the people next 
to you and get to know their 
story and learn from them.  
We're all here to learn from one
another.  So a few 
announcements.  We do have a 
lunch break right now.  We also 
do have the diversity panel 
happening at 12:15.  Grab your 
lunch and join us on the 
diversity panel.  It's going to 
be fun.  Another thing is that 
the SO party passes or tickets 
are apparently still available, 
so you can still buy them.  And 
that's it.  Hope you have a good
lunch. 
Live Captions by:
@smiley845 with @whitecoatcapxg.

&amp;gt;&amp;gt; Hey.  How's lunch? No
&amp;gt;&amp;gt; Hey.  How's lunch? No one's a
fan of lunch? That's like my 
favorite time of day.  The lunch
was great.  I love fish and 
salmon.  Let's get into our next
round of talks.  
[ Applause ]
    People from Iceland are shy 
or don't feel like clapping? I 
don't know how medium works 
anymore.  Our next speaker is 
coming from London.  She is born
and raised in
San Francisco and is a creative 
engineer at Google.  And she 
will talk to us about something 
that is really cool, in my 
opinion.  It's augmented 
reality.  I've never played with
it, but it seems like cool 
technology.  Please give it up 
and help me welcome Raisa up on 
the stage.  
[ Applause ]
   &amp;gt;&amp;gt; RAISA CUEVAS: Hey, 
everybody.  I think my mic is
working.  I should have done 
this earlier. 
All right.  So, first of all, 
let's get this on
the screen.  I'm a little 
embarrassed about my outfit.  
The truth is, I brought a really
nice, stylish shirt to wear 
today, but my hotel room didn't 
have an iron.  I called them at 
7:00 in the morning, and they 
took too long to bring it up.  I
was panicking this morning, and 
called my boyfriend, and I said 
I don't have anything else to 
wear.  Maybe I'll go on stage 
and look like a 
mountineer.  And he said it's 
okay.  It's a developer 
conference.  And I'm like that's
right.  Let me introduce myself.
My name is Raisa, and I'm a 
creative engineer at Google.  We
were looking for ways to use 
augmented reality in one of our 
marketing campaigns.  I took the
liberty to do the research on my
own and see what's possible.  I 
got really excited about the 
many years that it has gone 
back, and wanted to share with 
my team to help them appreciate 
what it is today, and do my 
actual job of reporting back 
what's possible today and
in the future.  
    So what is possible in
the future? I want to make a 
quick disclaimer that all this 
research I did was on my own.  
It's all public knowledge, and 
with that being said, I'm 
speaking on behalf of myself and
not on behalf of my company or 
any of the organizations I'm a 
part of.  
    So let's step back into 
1901.  This is a time before 
airplanes, before traditional 
color photography that we know, 
and nearly a decade before the 
first talking motion picture.  
Yet, before all of these 
technological advances, we had a
visionary author who envisioned 
a world in a book called &quot;the 
Master Key,&quot; and he put on a 
pair of spectacles that would 
overlay a character marker.  He 
is looking around and can judge 
a person on a single look.  
These were really deep sci-fi 
thoughts back in 1901.  I can't 
imagine how he could have come 
up with the idea.  If the name L
Frank Baum rings a bell, he's 
also the author of the wizard of
Oz.  
Fast forward to 1968.  We have 
built a plane and orbited the 
moon.  And we also have the 
first head-mounted display.  
This was developed by Ivan 
Sutherland.  You can see him 
spinning around, and all he can 
see is a simple wire cube.  
After this hard work, you saw a 
visionary cube in space.  And 
this was a really important 
precursor to AR.  As you can 
see, there have been so many 
advancements with head-mounted 
displays these days.  And now 
looking at 2018, we have a 
rocket orbiting into space with 
a car that is out there 
floating.  But we also have all 
of these advancements in 
augmented reality.  Everyone is 
talking about it being the next 
big thing.  Technologists and 
investors alike are speculating 
on when this will blow up.  
    So what's happening? There 
is rich history that dates 
augmented reality back to at 
least 1901.  So, if you look at 
this chart from Google trends, 
in case you haven't used it 
before, the Y  axis is the 
search enjin  -- engine from 0 
to 10 and the X is time.  So I 
did a search for 200 years.  As 
you can see, there's interesting
activity going on here.  
Suddenly in the summer of 2016, 
we see a huge peak, and people 
are curious about the mysterious
AR thing.  This is when Pokemon 
go was released.  People 
wondered, whoa! What is augment
augmented reality, and what else
is possible with this thing? 
This was probably the most 
popular AR application, although
it's not fully AR capable, and 
they're working on that fully AR
Pokemon go soon.  But this 
opened the public's eyes into 
the possibility of AR and showed
the potential for its scale.  
    Later, around the fall of 
2017, we have another peak 
that's starting to rise.  It's 
not as high as Pokemon Go, this 
was from AR core and ARKit that 
were released around the same 
time.  These are developer kits 
that will allow people to build 
experiences such as Pokemon Go 
in a much easier and more 
streamlined way.  
So a quick definition, ARCore is
a platform for building AR apps 
on Android, and ARKit is Apple's
version for building AR on iOs. 
Looking back, this is as far 
back as you can go.  There is 
some activity going on.  People 
are actually interested and 
aware of augmented reality.  
Especially around 2009.  So that
was almost ten years ago.  And 
why does it seem like it's such 
a new thing now? This is when AR
tool kit was released for web.  
It's an open-sourced tool kit.  
If you want to compare it to 
ARCore and ARKit, and allowed 
developers to build AR 
applications.  The output would 
be Flash-based.  
This is one of the reasons it 
didn't take on.  Users have to 
install a plugin, and they have 
to use their web cam in a weird 
way that does not feel natural 
compared to a mobile device, 
where you can take it around 
with you, and it makes more 
sense to point at what you want 
to project your AR object on to.
    So, this really shows its 
state.  This publication about 
it describes what AR tool kit 
is.  It shows AR tool kit in 
action.  It's marker-based, so 
they have this code where it 
will project the object from the
code.  And then in the 
documentation, you can also see 
that it's using windows XP and 
telling you how to use a web cam
on your computer.  
Later in 2009, we have the 
introduction of augmented 
reality into the real world.  
Esquire published this issue, it
was an augmented reality 
special, and on the front cover,
you had this QR code you could 
scan, and something magical 
happens.  Robert Downey Jr. 
Comes out of the screen and 
starts acknowledging you.  As 
you saw in the previous screen, 
there were 12 pages of AR 
content and lots of publications
were talking about it, and it 
was becoming more noticeable to 
consumers.  
    So fast forwarding to today,
we have back in 2012, Google 
hangouts foments
filters, which was long before 
snap
chat.  We have Pokemon Go, and 
Ikea's furniture app from the 
Apple store.  
What's making this possible is 
we have much more powerful 
devices, much more powerful 
browsers that will soon be 
capable of AR.  Hopefully future
support on the web will help to 
bring this technology to the 
masses.  
    So let's go back to basics 
and talk about what defines 
augmented reality
apps.  So ARCore, again, is the 
kit that allows developers to 
use these defining features in 
applications.  And these 
defining features include motion
tracking, which allows the 
device to understand and track 
its position relative to the 
real world.  So a scare crow 
that you can place into the 
world and move around and looks 
stationary just like the people 
next to it.  And environmental 
understanding so the device can 
detect the size and location.  
Previously it was only 
horizontal surfaces, but with 
the new release, you can place 
it on textured surfaces.  There 
was a demo of placing things on 
the snow, like around the tree. 
And then light estimation, which
allows the device to estimate 
the lighting conditions.  This 
helps brings objects to life.  
The Subtleties like shadows and 
brightness can really make an 
object in the real world look
real.  
    So, previously we had a 
platform called tango, which 
allowed augmented reality on 
powerful devices, but we decided
we wanted to bring this to the 
masses.  That's when we focused 
our efforts from late last year 
on ARCore, which will make 
augmented reality possible on 
more Android devices.  So that 
is a huge challenge, but a 
really big opportunity.  The 
fact that there are 2 billion 
plus active devices running on 
Android.  And each of these has 
their own unique hardware 
requirements and specs that we 
have to make sure align and 
provide the same high quality 
experience that we want all 
users to have.  
So currently, with the most 
recent release, it works on 100 
million devices including 13 
unique models.  And we're 
working with partners to make 
sure that more devices can 
support this.  
    Going back to ARKits.  This 
is the software developer kit 
allowing developers to use the 
same essential features in iOS 
11.  It's very similar to the 
three basic AR features that 
ARCore suggests.  Those are 
essential AR features, not like 
AR core.  They can be described 
for any augmented reality app.  
And the device compatibility, 
most recent Apple devices. 
So with iPhone 6S and above, and
some of the newer iPads.  
Let's talk about building for 
web.  All of this allows you to 
build native apps, and this is a
JS conference, so you are 
probably bored thinking about 
building an app.  We want to 
build for web.  So let's see 
what's possible.  ARCore has an 
experiment exploring the 
possibilities of web support, 
and it will lower the barrier to
enter, which people can build 
apps and release them out to the
web.  This is a pre-standards 
experimentation, just trying to 
see what's possible.  It's 
basically a wrapper of chromium 
extending web VR features, so 
it's really
scalable.  So they have this 
cool demo called article, which 
you can download on get  GitHub 
and run it on the server.  It's 
super easy.  
    ARCore is not one single 
entity.  You're building a web 
app with AR capabilities.  
You're running it on the 
experimental browser that is 
supposed to emulate what the web
standards might look like.  
Currently they have experimental
browsers that work on Android
and iOS.  
    And most of the examples on 
the web AR for ARCore demos are 
built with 3JS.  It's a popular 
library used since 2010.  Some 
of Google's projects have
used it, and all of these other 
cool Google and non-gilt 
experiments you see here.  It 
allows you to create 3D shapes, 
animations, complex scenes, and 
gives you tools to make this 
easier.  3D modeling concepts 
are really hard.  
So this is one of the tools that
it provides.  It's an in-browser
shape editor or scene editor.  
It allows you to control all the
different parameters.  And it's 
a really good way to start 
learning 3D modeling, especially
if you haven't been paying 
attention in math class.  You 
have to relearn mapping and 
matrix multiplication, and 
sometimes it's
overwhelming.  With time, you 
can make 3D creations like this.
If you are having trouble, you 
can download some models on poly
and find these different kinds 
of cheese burgers.  Search for 
the term, and you will find 
items tagged with that 
description.  And if you really 
like these cheeseburgers, you 
can put them together, start 
throwing them in the air, and 
that's your AR app.
    So just to highlight what's 
possible with 3JS, this is one 
of the apps that my team has 
built, and it helps people
find the direction prayer for.  
This is basically just usek web 
RTC to use the camera and 
navigation APIs.  And basically 
it's projecting this into space 
rather than as we have learned 
as an essential AR feature.  It 
doesn't allow you to place it on
to a detected surface.  It's a 
kind of faux AR, but it's -- I 
guess you can compare it to 
Pokemon Go, where you're not 
really throwing the Pokeball on 
to the Pokemon.  It's not on the
floor.  Sometimes it's floating 
around.  So that's kind of one 
distinction of what's possible 
with 3JS and how we need to 
bridge the gap.  There is a 
library called 3.AR.JS, which 
detects the device compatibility
and interfaces with a web VR 
extension that is exposed by the
experimental browsers.  That's 
what is allowing you to throw 
things on to surfaces and detect
it with precision.  
    So putting it all together, 
you can create useful apps.  For
example, this living room
modeling.  There's useful things
you can do for consumers, 
especially if it's available for
the web.  People can reach these
experiences from a link, and 
access them if their device is 
compatible.  
    So, again, the web AR and AR
core implementation is an 
experiment to explore what is 
possible and what might be 
potential web standards.  There 
are more possibilities.  Moz://a
has their possibility, and there
are a lot of commonalties in the
pre-standards proposals right 
now.  Things are starting to 
align, and hopefully we have 
standards, too.  I think one of 
the most popular ones might be 
the marker-based ar.js.  If you 
recognize the markers from my 
earlier slides, it's because 
it's based on AR tool kit.  So 
it goes way back.  With all of 
these standards that are not 
fully in place, why should we 
care now? What if it changes and
it stresses you out to learn all
of these new things? With 3D 
modeling, it's a big concept to 
grasp, and if you start learning
it now, there's a lot to catch 
up on.  People have been 3D 
modeling for decades.  If you're
interested, start equipping 
yourself with the basic 
knowledge to get started.  And 
people are already building 
really cool stuff right now.  
    Some sources of inspiration,
there are ARCore-specific
examples.  There's an ARKit 
version at the bottom there.  
One of my favorites is here, 
which just features some of 
Google's -- I am not biased or 
anything -- some of Google's AR 
experiments.  But one of the 
reasons I love it so much is 
half of the experiments were 
created by women.  So that's 
awesome to show that 
representation in the web XR 
community.  And going back to 
Ivan Sutherland, the professor 
who created the first 
head-mounted
display.  With all of these 
advancements, I think we're 
getting close to that.  
Although we might not be close 
to the really complex 
head-mounted displays, I think 
it's exciting that we are 
getting really close to building
web-based AR applications.  
That's what is really going to 
make AR become more widespread. 
So thank you guys for 
listening.
[ Applause ]
&amp;gt;&amp;gt; Thank you so much, Raisa. 
I have a question for you on
AR.
I want to get your viewpoint on 
what you're most excited about 
on the types of experiences that
users will get from web AR? 
   &amp;gt;&amp;gt; RAISA CUEVAS: Yeah, I 
mean, I'm really excited about 
web AR, because it's going to 
open it up to more users.  There
won't be the barrier of entry to
have a specific device.  It has 
to be one of the compatible 
devices.  But they won't have to
download a specific app, and it 
opens up the possibilities.  But
some of the use cases that I'm 
excited about is education.  We 
currently have the Google 
expeditions, which was formerly 
like a VR classroom experiment, 
but they have expanded it to AR,
so kids can use their phones in 
class and see volcanos erupting 
on the floor or see the planets 
in the sky.  It's a good way to 
see that interactively. 
&amp;gt;&amp;gt; I wish I could go 
back-to-school.  
&amp;gt;&amp;gt; RAISA CUEVAS: Definitely. 
   &amp;gt;&amp;gt; Thank you so much.  
[ Applause ]
    Our next talk is another 
creative talk.  It was previewed
earlier in the intros.  It's the
paint splatter technology that's
being used right now, outside.  
So it's by -- I don't know if 
I'm going to say this right.  
HalldÃ³r -- HalldÃ³r and pÃ³rour 
Hans Baldursson.  I think that's
HalldÃ³r -- HalldÃ³r
to talk to us about the colorful
painter technology that's all 
over the concert hall them.  
They're right now.  
Vandalism without consequences. 
And how they turned Harpa into a
giant LED-lit facade, into a 
collaborative art work that can 
be used by everyone.  They make 
up the two-man digital arts 
studio that is Staffly. 
Is that right? Together they 
created a few interactive art 
installations.  They most 
notable work is the one that's 
outside utilizing the LED
facade.  
    While they set up, help me 
welcome them to the stage.  Hall
Hall --
HalldÃ³r and pÃ³rour Hans 
Baldursson [ Applause ]
   &amp;gt;&amp;gt; HALLDï¿R: Hello.  My name 
is HalldÃ³r.  
   &amp;gt;&amp;gt; HANS: Hello.  
   &amp;gt;&amp;gt; HALLDï¿R: I'm going to 
begin by telling you a little 
bit about myself.  I have a 
bachelor's degree in computer 
science, a BS in CS, or a bull 
shit degree in counter.  I also 
do my fair share of websites and
whatnotes.  My second job is as 
a musician.  I compose music, 
and I also am in a band, which 
you should totally check out, if
you haven't already.  And I
collaborate with musicians on a 
new robotic piano project.  Some
of my work is
most notably a generated music 
piece, and it's writteden in 
JavaScript.  It uses the photos 
taken during the moon landings 
back in the '60s and '70s as an 
input to a musical engine, and 
creates sound scoopss -- 
soundscapes.  
There is ambient music generated
in the browser.  And another 
project is the infinite string 
quartet, which is a modular 
string quartet, written by my 
brother, who is also a composer.
And we created an interactive 
version of it that runs in the 
browser.  And you can select 
modules or clips from the string
quartet, and make a 3D space 
around you.  You can play for 
hours, creating creepy string 
quartet music with this.  
    And then the project I'm 
working on here.  Here we are 
contemplating how to make it 
sound more like a flower.  You 
know, artists.  That is being 
released very soon.  
   &amp;gt;&amp;gt; HANS: I work for the local
contracting company.  I'm also 
going to use the opportunity to 
talk about some of my projects, 
since I have this
platform.  
This is a Chrome extension.  
Woo!
It takes all of the works and 
replaces them.  Here we have 
bacon.  And that gets replaced 
with this.  Recently, just 
earlier this month, we did 
another project using the facade
outside.  This was
done, and basically a giant 
heart projected.  The input is 
users' heart rate.  
   &amp;gt;&amp;gt; HALLDï¿R: So let's talk 
about paint splatter.  It's an 
interactive installation where 
you can participate on your 
phone.  And the simplest way to 
describe it is that 
it's a giant digital canvas made
out of the huge LED facade.  And
anyone with access to internet 
or a smart device or a computer 
can interact with the cameras by
splashing virtual paint on it, 
which drips straight down or 
sideways depending on wind 
direction and force.  Take it 
away.  
&amp;gt;&amp;gt; HANS: So, when you're 
creating collective art, it's 
important that the user input is
simple and rewarding.  Most 
people like vandalizing, 
especially without consequences.
So anonymously splashing paint 
on Iceland's most expensive 
painting seemed like a rewarding
and simple way to be an outlet 
for that kind of behavior.  
    For the first few days we 
had thousands of visits from 
people all over the world.  And 
some people standing outside in 
the storm splashing for hours.  
The reason why it became so 
popular is our interactiveness. 
The fact that by touching a 
small area on your phone 
resulted in a giant blob visible
to all participants all over the
world.  It's also visibly 
pleasing.  The blobs have 
different looks.  We could avoid
making this look like a giant, 
shared Microsoft paint document.
We could avoid 
mankind's most drawn art work 
ever, the phallic symbol.  
&amp;gt;&amp;gt; HALLDï¿R: The design process 
was straightforward.  It started
with conceptual sketches on 
paper, like all good ideas 
start.  And the whole concept 
was thoroughly determined before
we started coding anything.  So 
that helped us really keep 
things in scope.  And we did
one thing well.  
    The next step was doing some
web mock-ups just to get a gist 
of how the animation would look 
like.  And I'm going to show you
a code pen I did here.  
&amp;gt;&amp;gt; HANS: This is not the code 
pen. 
&amp;gt;&amp;gt; HALLDï¿R: No, this is my home.
This is where I live.  I used to
keep this
on my screen. 
Here it is.  Here
is the first directive, and how 
with input parameters, how it 
would leak to get a sense of the
rendering and main obstacles.  
This took like 30 minutes to do.
And it was so good to have this 
with the project proposal.  
    Okay.  Back to the 
presentation.  The biggest 
unknown factor in the whole 
project was how to render stuff 
from the
light facade, but it had been 
done before.  So we got access 
to node.js server access code 
written
by Owen Hendley.  
The networking part was also 
pretty straightforward.  We used
socket.io, and you press and 
make a blob, and it sends the 
event to all connected 
participants.  And it also 
contains some rudimentary game 
logic and input sanitizing and 
UX
throttling.  
    So when we set that up, we 
faced some real-world problems. 
The server had to be located in 
the basement with the rest of 
the controllers, that meant we 
had to go up and down and up and
down endlessly in our feedback 
loop.  This is a video of one of
those times.  But it was great 
physical exercise.  
   &amp;gt;&amp;gt; And we also got lost a few
times.  It was like Hogwart's 
school. 
&amp;gt;&amp;gt; I think there are a lot of 
people stuck down there. 
&amp;gt;&amp;gt; Probably is a small 
population there by now.  
&amp;gt;&amp;gt; Yeah.  And this was online, 
we wanted to allow more people 
to participate.  So we decided 
to set up our live stream.  With
our limited budget, we picked up
the phone and duct taped it to 
the ceiling of the hotel lobby 
across from the
location.  But soon, people 
started complaining about the 
tourist bus blocking the view.  
And also the staff at the
hotel, they were not pleased 
about the unidentified phone 
that was possibly broadcasting 
their conversations to the 
internet.  
   &amp;gt;&amp;gt; Yeah.  We also encountered
some problems with deploying the
rendered server at Harpa.  We 
had to connect our computer 
through six unmarked ether net 
cables, and had to be done in 
correct order for it to work.  
It was most definitely not a 
very atomic deployment process. 
Almost like programming punch 
card 
programs. 
   &amp;gt;&amp;gt; So we had to become like a
small tourist station.  
   &amp;gt;&amp;gt; Yeah.  
&amp;gt;&amp;gt; We had to fulfill our duties 
as a live TV station.  
Did you already mention the main
complaint from the
Reddit users?
The tour bus? 
&amp;gt;&amp;gt; Yeah, yeah.  You're not even 
listening to me. 
&amp;gt;&amp;gt; And then we got spammed.  
It was bound
to happen.  
Somebody found a way to 
circumvent our rate limiting.  
Oh no! And why am I telling you 
programmers and JavaScript 
people? And then we got, like, 
properly hacked.  
    Now this is actually a very 
funny story, because somebody 
found a way to override our 
color scheme.  We had like a 
very limited color scheme.  You 
could not draw black, for 
instance.  So you could not 
clear the screen or something 
like that.  But somebody found a
way to override it, and were 
suddenly able to draw arbitrary 
buffers of images.  We knew this
was a possibility from the 
start, but didn't have the 
resources to prevent it, except 
for some basic rate limiting and
exponentially increasing buffer 
periods.  
    But this was a very fun 
challenge, and war was upon us. 
Iceland is very small, and the 
communities here are even 
smaller.  The proof for that is 
that I just got on messenger and
guessed who the hacker was. 
And this was  before the hacker 
started writing his name on the 
facade.  He was my former 
computer game programming 
teacher at university, and he's 
also a programmer at CCP.  And 
the only person in Iceland I 
knew that would be able to do 
such a thing, and invest the 
time to do it properly.  
[ Laughter ]
    So I could immediately 
recognize his way of doing the 
hacking, because it was very 
professionally done.  We 
approached him and after 
negotiations, he surrendered and
told us all about how he did it.
He sent his code and a lot of 
comments on our code, which was 
very fun to read.  So he was 
able to draw arbitrary buffers 
with paint.  This is where he 
was like neatly organizing his 
name in a two-dimensional
array.
He wrote a whole rendering 
service that was running on his 
computer that spun to our server
with paint blob events that 
enabled him to do this.  So he 
was rendering on a rendering 
server, because we all like 
rendering servers, right? 
    But, we made it harder for 
him.  We just increased the rate
limiting of it, and added some 
extra throttling without 
degrading the experience of the 
normal, non-spamming user.  And 
this fight was ongoing 
throughout the duration of the 
display.  He also was able to 
avoid, because the
paint leaks. 
If you draw something, it won't 
stay there forever, because it 
gets -- the paint leaks.  
Somebody else paints over it.  
He added the skewing factor he 
could tune to his tastes to be 
able to create very straight
images.  Then we added random 
noise to it to decrease the
resolution of what this hacker 
was able to draw.  And this is 
still in the code.  You see it 
if you press the -- if you splat
paint, you can see that it -- 
   &amp;gt;&amp;gt; A receptor. 
&amp;gt;&amp;gt; It doesn't come exactly in 
the center of where you
clicked.
And it's totally on concept, 
because splatting paint with 
some paint blob is an unprecise 
art.  It's just part of the
concept.  
   &amp;gt;&amp;gt; If you spend some time in 
Iceland, you quickly learn that 
the weather here is quite 
unpredictable.  When we did this
the first time in 2016, there 
was basically a crazy storm 
throughout the whole time it was
up.  And that was a great way to
show off the feature that we 
were using wind force and wind 
direction to render.  So we just
looked on the bright side.  
There were a
-- were not a lot of people 
outside trying it out, mostly 
inside.  The next time, the 
weather was way better.  
Nice weather and almost no wind
at all.  We were somewhere in 
our calculations, we were 
dividing by zero.  For the first
time this happened, we were 
going to be on live television, 
and this happened like five 
minutes before that happened.  
And as you can see in this 
picture, here's the mayor.  
Loads of wind.  You can see his 
hair.  It's crazy.  In 2017, 
this is a frozen server with no 
wind and we are somewhere in the
back having a panic attack.  We 
somehow got through the 
interview demonstrating how it 
worked without it actually 
working at all.  Nobody seemed 
to notice, which was a pretty
good thing.  
   &amp;gt;&amp;gt; We learned a few lessons 
through the whole process.  
First being that we
should avoid any ribbon cutting 
ceremonies, especially when it's
on live television.  Secondly, 
you should always allow for the 
weather, even when you're 
writing code, even if it has 
nothing to do with weather.  You
should do it, especially here in
Iceland.  
   &amp;gt;&amp;gt; And it's always fun when 
your work is worth hacking.  At 
least when it's not done 
maliciously, and it's 
entertaining.  This piece 
revolves around the concept of 
vandalism, and that everybody 
gets their say.  Everybody can 
participate.  So programmers 
with the programming skills, 
they can, of course, 
participate, but if you intend 
to do so, please behave 
yourselves.  We don't have the 
money to
fight you.  Thank you so much 
for listening.  And the piece is
accessible at
point.jsconf.is.  Or just 
paint.is.  It's been a pleasure 
talking here.  We would like to 
know if any of you had any 
questions? We are happy
to answer.  
    You have a question there? [
Inaudible Question ].
    Yeah?  to answer.  
You have a question there? [
    The insights of how many 
users and how many users at the 
same time have used this? The 
night when it went live on 
reddit, we got like 7,000 hits 
in a certain period of time.  
And that was after we set up the
live streaming cam.  So even if 
you were abroad, you could splat
paint and see a live stream of 
it actually
happening.  That was not -- it 
was a pretty even spike    &amp;gt;&amp;gt; 
And the log file from the server
was around 300mb, if that tells
you anything.  Anymore 
questions? 
   &amp;gt;&amp;gt; Oh yeah.  Uh-huh.  
    [ Inaudible Question ].
   &amp;gt;&amp;gt; Yeah.  We did one, a 
couple of weeks ago, which we 
told you about briefly.  It's --
we connected a heart rate sensor
to heart animation on the front 
of Harpa, so you could go
connect to the sensor that could
connect to your heart rate, and 
it blended nicely on the light 
facade.  
&amp;gt;&amp;gt; And we allowed for zero, but 
no one had zero heart 
rate. 
[ Laughter ]
[ Inaudible Question ]
   &amp;gt;&amp;gt; Sorry? 
&amp;gt;&amp;gt; It was taken down because the
hotel manager thought we were 
spying on some guests in the 
hotel.  And our friend needed 
his phone back as well.  
[ Laughter ]
&amp;gt;&amp;gt; Poor guy. 
   &amp;gt;&amp;gt; We'll take care of it. 
   &amp;gt;&amp;gt; Just ask away, if you have
any questions. 
   &amp;gt;&amp;gt; What is the time-out? Two 
seconds? Four seconds? Eight
seconds? A silly TCP joke.  
Sorry.  Thank you so much for 
listening.  
[ Applause ]
   &amp;gt;&amp;gt; Thank you.  I think their 
talk is a perfect segue into our
next talk.  The next talk talks 
about security and how to, you 
know, protect your web apps.  So
our next talk will be Dominik.  
If you will come on stage so we 
can set up.  Dominik is a 
developer evangelist in Berlin. 
He's passionate about 
JavaScript, hack-a-thons, 
teaching, and also good whiskey.
You'll usually find him speaking
at conferences like this or 
meet-ups or mentoring in 
hack-a-thons.  He's going to be
talking to us about about XSS, 
CSRF, CSP, JWT.  The title of 
the talk says what the fuck.  I 
don't know.  So if he can come 
up on stage to
set up.  There he is.  I think I
see him. 
set
   &amp;gt;&amp;gt; I'm going to spit out some
random Icelandic trivia that 
I've learned from looking up 
random Icelandic facts.  I've 
never been to Iceland, and this 
is my first time, you know, 
here,
obviously.  One of them is 
apparently there's an Icelandic 
naming committee that decides 
whether your child's name or 
even your name is a valid name. 
So I don't think my name is 
valid at all in Iceland.  So I 
think I'm an illyy
-- illegal named person here.  
No one tell the Icelandic naming
commission 
that.  
    So update.  Apparently we're
running pretty early.  So we can
get a 12-minute break and just 
come back here in 12 minutes so 
we can continue
on time.  
Live Captions by:
@smiley845 with @whitecoatcapxg.
&amp;gt;&amp;gt; Okay.  I think we're finally 
ready for the next talk.
The live stream must be really 
confused.  
Dominik is a programming 
evangelist.  You will find him 
normally speaking at conferences
like this, meet-ups, or 
mentoring in hack-a-thons.  He 
will be talking to us about all 
of these abbreviations up here, 
and how to protect yourself and 
your users from the new 
generation of bobby tables.  So 
give it up for Dominik.  
[ Applause ]
&amp;gt;&amp;gt; Welcome everyone.  Is this 
mic on? Can you hear me? Thumbs 
up? Awesome.  I think I have the
most click-baity title.  I will 
not read all of the 
abbreviations, because that 
wastes half of the time.  I 
would like to give you a quick 
introduction to web security.  
And this is not going to be 
making you all web security 
experts.  But one thing I that 
want to make sure is all of the 
topics that I highlight are 
topics that I think every web 
developer should be aware of 
when they build an application. 
    Before we start, I would 
like to quickly introduce 
myself.  I'm a developer 
evangelist for a company called 
twilio.  We do APIs to send and 
receive text messages and other 
things around communications.  I
live in Berlin.  But there's one
more thing you should know about
me.  I can drop this jacket now,
because it's getting really 
warm.  And this is where the 
talk gets awkward.  All right.  
So I'm a member of
a group called woed 
onsie.js.  I think there is a 
unicorn running around.  But, 
you know, like, today, we have 
so many social networks and 
communication channels, but 
there isn't really one for 
onsie-loving developers.  So 
being a developer myself, I did 
what every developer does when 
something doesn't exist.  So I 
built the future great social 
network called onesie life.  I'm
not sure why I don't have high 
traffic yet, but it will come.  
    And like being a developer, 
I made sure this is as secure
as possible.  And doesn't have 
any vulnerabilities, especially 
nothing that can be hacked with 
a banana.  You know I thought of
everything.  It uses HTTPS, and 
I don't have to pay a dime for 
that.  It uses HSPS, which just 
makes sure there's no 
downgrading of the traffic.  
This is typically what blocks 
you from going to Google.com 
when there's a public Wi-Fi with
a captive
model.  I don't allow mixed 
content.  So no HTTP content on 
a website that is certified 
HTTPS.  I sanitize the HTML.  So
I allow people to put a mark 
down, but I will make sure to 
send it before it goes to the 
page.  And there is no room for 
SQL injections, because I'm not 
using a real database.  
So there's no way to have the 
injections.  And I'm not talking
about NoSQL databases, but I'm 
literally using a plain start, 
because I don't believe this 
will scale.  But turns out that 
developing secure web 
applications isn't as secure as 
I thought.  So I contacted my 
buddy, Bob Allison.  And he took
a stab at the application and 
figured out a bunch of security 
vulnerabilities that I would 
like to share with you.  Now 
it's really warm.  So I will 
take this off.  
All right.  So, if we go
to this page.  I will set an 
HTTP cookie to maintain the 
session. 
It's just a way that allows you 
to to maintain session state 
throughout multiple sessions by 
setting a value either by HTTP 
headers or via JavaScript.  If 
we go into the console here, we 
can access that.  I have one 
that is called off token.  This 
is what is called a JWT or JSON 
web token.  We can see that it 
has three different parts, a 
header, a red part, a purple 
part which is like the payload, 
and then it has a signature.  
That's generated by an algorithm
that is specified in the header 
using a secret.  If we look 
here, it says invalid signature,
because I was smart enough not 
to use &quot;secret&quot; as my secret, 
but there is a vulnerability in 
my app around this that
we can exploit.  There are 
different algorithms that you 
can use, and one of them that is
mandatory in the spec is none.  
Disregard the
signature.  If we do this, and 
let's have fun.  We switched the
role to Admin.  And then I copy 
this part.  And this is just 
basic code.  This is just plain 
data.  Don't think this is 
secure or something.  And I will
set this as an off
token.  We can refresh the page,
and we will see that we are now 
in Admin mode.  And that is 
because I'm
taking the JWT as a single 
source of truth.  If I say I'm 
an Admin, I am.  That in 
combination with the algorithm 
that is none, we can kind of 
just switch anything.  And I 
wouldn't have had to log in in 
the first place.  I could have 
generated this with any user 
name and sign in as anyone.  How
can we protect ourselves from 
that? You can set cookies via 
JavaScript or HTTP headers.  And
you can declare cookies as HTTP 
only.  They will still be sent 
by the browser, but you will not
be able to access and manipulate
them.  And an assigned cookie 
means I could not manipulate 
without knowing the token and 
that it's secured.  But there's 
another thing I should have 
done, and that
revolves around jaws.  I'm using
the library on node, but I'm 
using an old version, and that 
one has two flaws that the newer
one fixes. 
On the one hand, the library 
should provide you with a way to
white list algorithms.  In this 
case, I'm in the secure version 
of this, I'm saying that I only 
allow HS256 tokens versus 
nothing else.  And then the 
other thing is in this library, 
for example, if the secret is 
set to something that is not 
null, the library will not 
accept none as an algorithm.  
But that's only in the newer 
libraries.  So the bottom line 
here is stay up to date.  You 
don't want to be the next 
Equifax.  There was an older 
version of an implementation 
that was known to be vulnerable 
and them not getting around to 
updating it.  You don't want to 
be in the news far that.  
    This is a social network, so
we can post stuff.  Let me jump 
back here and post something.  
This is marked, so I can write 
something like hi, JSConf 
Iceland.  And I will post this 
and look at the traffic.  We
will see that -- if I make this 
bigger, there's an HTTP post why
here that sets the token along 
and sends the form data in the 
bottom.  This is nice, because 
it's really easy to implement.  
I'm literally submitting a form 
asynchronously.  But the 
combination of form and cookies 
is also something that can cause
a request forgery attack by 
hackers.  To give you an idea of
how this works and what this is,
this is -- sometimes it's 
written as XXRF or CSRF, but 
typically pronounced &quot;c-surf.&quot; 
If you get back to the page and 
refresh here, you see that the 
attacker was able to post on my 
behalf on the page.  The reason 
why this works is the browser is
super eager to send all of these
cookies along on every request. 
If we look at the code that 
hacked us here, it, on body 
unload, it will submit the form 
that we have here.  In this case
it is visible, but it could have
been hidden.  There is an input 
tag with a message we want to 
send.  It could be hidden.  It 
doesn't have to be visible.  And
then hit submit.  This is the 
danger about this, because the 
browser is super eager to send 
this.  So let's talk about how 
we can
fix this.  Let me find my slides
again.  Apparently it was hacked
twice by this application.  
Let's navigate and talk about 
what happened here.  
When I clicked on the link here,
I'm using a target blank here.  
The attacker's page can access 
my page window by using 
window.opener.application, and 
rewrite that application.  In 
that case, the attacker page was
navigating me to another 
harmless page, but this could 
have just as well been a 
redirection to a phishing page 
that looks like your page.  
Someone could put in a page 
filling that redirects the 
original browser to a phishing 
page.  Luckily, protecting 
yourself from that is pretty 
straightforward.  You want to 
use the rel attribute and set it
to no opener and no defer.  You 
don't want to provide access to 
window.opener, and there is no 
refer because some browsers 
don't support no opener.  Namely
IE and older versions of Edge.  
You want to use the no refer as 
well.  Plus there are some 
JavaScript scripts that allow 
you to circumvent this as well. 
    To get back to the CSRF 
attacks, the approach is 
relatively straight-forward as 
well.  The basic idea is that 
you will generate a new cookie 
called 
_CSRF.  You pass it as a cookie 
and embed it into the page that 
is supposed to have form 
submission and a hidden input 
field.  When you submit the post
request, in this case, you will 
check if the value in the cookie
equals the same value that is 
either passed in the request 
body and the request query 
parameters or in one of 
the headers like the ones in the
example which are the wins that 
the CSRF library checks for.  In
that case, that works.  If it's 
not the case, it's likely 
someone will perform a CSRF 
attack against you.  They are 
not able to read the cookie 
since the browser auto-submits 
this, so they will not be able 
to pass this as a header.  
Let's talk about Sammy.  The 
reason is, to first give you 
background about little bobby 
tables, if you're not familiar 
with that, it comes from this 
comic, which is a joke about 
squill injections who named 
their family like a squill 
injections, and the principle 
being Mac, because they lost the
student records because they 
were not sanitizing the input.  
    Does anyone know what this 
source code is from? I would be 
really impressed if someone 
knows this by heart.  This is 
the myspace or Sammy worm.  Some
of you might be familiar with 
this.  This was an attack from 
2005 on Myspace, which would 
repost this code, add Sammy as 
your friend and post that Sammy 
is awesome.  That's also how 
they caught him.  If the access 
code points at your Myspace 
profile, that's not smart idea. 
The cool thing about this attack
is it shows a couple of things 
that people used to circumvent 
the protection.  One thing they 
said is they don't allow script 
tags, didn't allow JavaScript 
call-in in URLs and stuff, but 
they did allow in-line 
CSS.  And because he wasn't 
allowed to use quotes, he took 
all of his code, wrapped it into
an evaland put it into another 
HTML attribute, and that would 
be
evaluated.  
They have lists of words,
like this.  
    But, what Sammy just did, he
turned this into strings, split 
them by a plus, and recon
catinated them.  And then 
there's the other thing.  You 
say I could block eval, and 
that's fine.  Those are all ways
to evaluate code.  The last one 
is from a project that I'm not 
sure if I can name the name, 
because I'm not sure if it 
violates a code of conduct, but 
talk to Martin, and he can tell 
you the name.  Or I can tell you
the name afterwards.  But the 
bottom line is there are a bunch
of ways to write the same code 
in JavaScript.  You can't 
blacklist certain words, because
that doesn't help you.  
    So blocking XSS is not 
trivial.  And I have a demo for 
that as well.  I told you I'm 
use mark down here, and a 
library called marked.  If 
you're a few versions back, but 
not really old, even though it 
has a function that allows you 
to sanitize stuff.  So we can do
stuff like alert 1, and this 
will not work.  There is a 
security vulnerability in here. 
We can create links, right? I 
can do something like &quot;click 
me.&quot; And in here, if we would 
write JavaScript:alert hello 
JSConf.  This doesn't work 
directly because the sanitizer 
is smarter than that.  Shout out
to Guy from Sneak who actually 
showed this to me.  Let's do 
some fun stuff with 
encoding.  
This here is literally the same 
as a closing parentheses.  And a
colon is
the same as this.  We don't have
the closing pieces anymore, but 
we're getting there.  Now we can
use a quirkiness in the browser,
and actually write this here.  
And what this will do, let's 
first try this.  It works.  And 
the reason why this works is 
that the browser -- so first of 
all, the HTML sanitizer will see
this, and it doesn't see
JavaScript:
JavaScript: But I think you 
meant a semi colon, so I'll be a
good guy and insert this.  So 
this is valid, and it doesn't 
complain about that, and we can 
do anything afterwards.  We've 
seen this work.  The bottom line
here is encoding can be 
dangerous.  Don't trust any code
that your user
can modify.  
Don't trust CSS.  And Greg just 
tweeted about this two days ago.
Really don't trust it.  There's 
a bunch of stuff you can do, and
I highly recommend you check out
the blog post in this tweet.  
    Let's talk about another 
thing, and that's JSON with 
padding.  It's being used less 
these days.  But basically it's 
a way to circumvent samor 
general policy.  The way it 
works is you define a global 
function.  If you just Jquery's 
JSON p method, but it's a call 
function that has to be global, 
and you expect the data to be 
passed into the code.  And you 
inject a script tag with the J 
son P URL.  You define the name
of the function in this case, 
it's called got post.  It will 
take the name and wrap the data 
into a function called with that
name.  If you use that, but you 
write poor JSONP, now this is 
getting fun.  My JSONP end point
does not verify what I pass as a
call-back, and that means that 
we can -- I'm in the wrong 
place.  We can generate 
arbitrary JavaScript here, and 
this gets really fun.  I'm going
to first show it to you and then
explain what's going on.  This 
is a bit of a longer code 
snippet, so I will copy this.  
So I'm going to press this and 
click this button.  And nothing 
happens.  But if I refresh the 
page, we get this.  And I can 
refresh as many times as I want.
It will stay like this.  The 
reason why this is happening, if
we go to application, I 
installed a service worker.  If 
you don't know what service 
workers are, they're an API from
the browser that allows you to 
handle the network proxies so 
that you can -- it's made for 
things like offline available 
apps so you can cache your web
website and your resources and 
handle which ones you want to 
cache and which ones you don't. 
It can do pretty much anything 
because it can intercept the 
network requests.  The browsers 
are smart enough to be sure a 
service worker can only be 
installed from your domain.  But
if your domain has a vulnerable 
JSONP interaction, then you have
a problem like this.  We can see
the call-back parameter here is
really long.  We can see what's 
actually happening.  I'm 
creating a service worker 
script.  And the data, I don't 
care about.  I just commented.  
We just reply with a hack and a 
script tag injected.  This is an
obvious attack, but you could do
it in a less obvious way as 
well.  You could actually fetch 
the page, inject the script tag,
and send that to the user, and 
the user will not recognize 
this.  Especially not a common 
user with the dev tools to check
the service worker
install? Open that, and you will
see how many people actually 
install service workers.  You 
have no idea what these service 
workers do.  It's sort of a 
dangerous attack.  
Let's actually remove this or I 
will forget about it.  
Unregister.  If we reload this 
now, and you don't want to 
explain your customers, go to 
your browser and click on 
application in the dev tools and
click on unregister on this 
thing called service worker.  
    So far we've seen different 
attacks, and we should fix all 
of these and also all the other 
attacks that we have in there.  
There is a new super hero in 
town that allows you to protect 
yourself against some of these, 
and that's called content 
security Policy, or CSP.  All 
that I'm doing is injecting an 
HTTP header.  We can see if I 
click on any of these, and 
refresh, nothing
happens.  23  -- if we open 
this, we will see a bunch of 
errors.  What does that actually
mean? Content security policy is
just an HTTP header that you can
define rules that the browser 
should play by for your 
resources.  These can be things 
like by default.  For scripts 
and styles, I only want the 
things that have the following 
non-s.  This can't be hard coded
by the attacker.  
That means no more in line 
scripts unless they have this 
HTML attribute, no in line 
styles.  And that's why the 
attacks don't work.  And 
blocking objects here, image 
source, I'm only specifying 
self, and the user.  I only 
allow Google fonts.  I block all
mixed content, so no HTTP 
content on my page.  And I 
specify a report URI, and it 
will be pinged with every 
violation.  There are tools you 
can point this against.  You can
point this against any end point
on your server, and this will 
report it.  There's a 
report-only flag, and that 
allows you to say that you want 
to only get the information that
something has been violated, but
you don't block the actual 
content.  This is great for 
transitioning into it, 
especially if you want to test 
this first in a local 
environment or something.  CSP 
should not be your security 
strategy, it should be your 
safety net.  Writing of really 
strong CSP is hard, and there's 
a great paper by Google about 
this, like about the dangers 
about this.  You should still 
care about the attacks.  
    A couple of other things 
that you should look out for.  
You should disallow framing.  
Most websites don't have a 
legitimate reason to be allowing
to be iframed, what an attacker 
can do is place your page with 
an opacity of zero above their 
page and line up buttons so that
they -- user thinks they're 
interacting with their page, but
they're really interacting with 
your page.  And so this is what 
people could use, for example, 
to, like, if you want to like a 
page. 
Facebook blocks iframing.
Don't show versions of front-end
libraries and servers.  There 
are packages that are useful to 
develop things, but if you show 
a version number in your HTML 
page or HTTP headers, this gives
an attacker the right idea of 
what security vulnerabilities to
test out.  And you don't want to
make their job
easier.  And check for types of 
input because there can be NoSQL
injections.  
Don't just assume that it's a 
string.  There are some partial 
libraries that will parse things
like objects as well.  If you do
that, the result is that you 
could, for example, have a NoSQL
injection.  
Other things? Consider security 
audits, especially if your code 
base has never had a security 
audit.  If you don't have an 
internal security expert, 
contract one.  Because there's 
so many things that it's really 
hard to keep up with that this 
is really helpful.  And you 
learn yourself a lot if you look
over their shoulder.  That's how
I learned most of the stuff is 
when I had to go through a 
security audit with a feature.  
    And then stay up to date 
with versions.  You don't want 
to be the next Equifax.  
Similarly, use a tool to detect 
security vulnerabilities in your
dependencies.  You can write the
most secure code, but if your 
dependencies are vulnerable, 
that defeats the
purpose.  So, sneak is one of 
them.  They provide patches if 
they are too late.  So marked
fixed that 
volley ne'er-- 
vulnerability.  But Snyk has a 
patch.  And there are other 
tools that check for this as 
well.  GitHub scans and tells 
you about vulnerabilities as 
well.  
    So to wrap this up, use 
signed only HTTP cookies.  Be 
skeptical of JWPs.  Use no 
opener and no refer on your 
target lines.  You CSRF tokens. 
It's easy to use.  Blocking SSX 
is not trivial.  If you have 
user input or query parameters, 
think of these and know that 
they can cause harm.  Be aware 
of encoding, because there are a
million ways to write the same 
thing.  Be careful of JSONP.  It
should only accept call 
characters.  Use CSP as a safety
net, and most importantly, stay 
up to date.  I put up the slides
here, and I will tweet the link 
in a second, so you can check 
them out again.  Similarly, the 
source code of the website is on
this URL, including different 
files for every one of these 
vulnerabilities that I showed 
you and a couple others in 
there, including resources that 
are interesting about their 
respective topic.  With that, I 
thank you for your attention.  I
will be around for the rest of 
the day wearing likely this 
jacket instead of the onesie.  
Come by, ask me questions, and 
thank you for your attention.  
[ Applause ]
&amp;gt;&amp;gt; Thank you so much.  I have a 
question for you.  So, what do 
you think we as software 
engineers can do to advocate in 
our own companies to actually do
more things for security? 
&amp;gt;&amp;gt; I think sort of highlighting 
past examples.  
There is a
great talk by @jawegg on 
Twitter.  He has a great talk 
online talking about different 
instances where people were 
hacked because of security 
vulnerabilities.  Showing these 
things.  You don't want to be in
this situation, right? Security 
is a preemptive strategy.  You 
should always have security in 
mind, because if you have to 
think about security because of 
an attack, it's too late.  So 
you always should think of this 
ahead of time. 
   &amp;gt;&amp;gt; Thank you so much.  Again,
Dominik.  So we have a break for
30 minutes.  So go get your 
coffee.  I think I need coffee. 
Any body thinks I'm in New York,
still.  Head out, and come back 
in 30 minutes.  
[ Break
] 
Live Captions by:
@smiley845 with @whitecoatcapxg
Live Captions by:
@smiley845 with @whitecoatcapxg
&amp;gt;&amp;gt; Hello.  Okay.  Hello, 
everyone.  Welcome to our 
lightning talk part of the 
event.  So, it's going to be 
seven lightning talks, and we're
going to be starting
with Andy. 
I have a timer on my iPad timing
them.  We're a little strict 
about it.  Here's Andy talking 
to us about TypeScript. 
Awesome.  
[ Applause ]
&amp;gt;&amp;gt; Hi.  I'm Andy.  And I work at
shopify.  Today I'm going to be 
giving you a whirlwind 
introduction to TypeScript.  A 
brief disclaimer, most of the 
stuff I'm going to talk about 
today is TypeScript-specific, 
but TypeScript is not the only 
way to bring types into your 
JavaScript.  There are other 
options.  I first started with 
flow, and we switched to 
TypeScript at work, so that's 
what I do most of the time.  But
they're all great.  
    Okay.  So first, I want to 
give you a little bit of why to 
use types.  This is probably the
most important, and then we'll 
dive into TypeScript syntax to 
hopefully make it less scary to 
get started.  I really want to 
talk about two main reasons that
you would want to use types in 
your project.  The first one is 
if you're working on a large 
application, as that application
grows, it's impossible to keep 
in your own mind everything 
that's happening.  If you're 
working on a small library, like
maybe the overhead of types is 
overkill.  Be  but if you're 
working on a large application, 
it will get to the point that 
you can't keep track of all of 
the changes that are happening 
to functions or other interfaces
in your application, but the 
compiler can keep track of that.
It's like having a super-powered
buddy on your team who will keep
track of everything that's 
happening.  
The second thing is that it's 
really hard to keep 
documentation up to date, 
whether it be comments in your 
code, or whether it be a read me
or whatever else.  The nice 
thing about types is they make 
your code a little more 
self-documenting.  Since the 
compiler is going to be 
enforcing those types, it's a 
lot harder to get them out of 
date.  It's definitely possible 
and easy to do things that still
make it hard to understand, but 
it's a little bit of a help to 
make your code easier to jump 
into.  
All right.  So, basic types.
We're going to start going 
pretty fast through syntax here 
to give an overview.  So here is
like sort of a hello_world of 
primitive types in TypeScript.  
It looks like normal JavaScript,
but you have a colon and the 
name of a type, which is how 
you're going to annotate your 
variables.  That actually isn't 
necessary a lot of the time.  I 
more often than not don't have 
to add explicit annotations to 
my code, because TypeScript is 
very good at inferring what I 
mean.  
    You can also see here, this 
is where the benefit starts 
coming in.  This screen shot is 
from visual studio code, but 
it's a reflex of the error that 
the compiler is putting out.  
You can see it has a red 
squiggly, because the it doesn't
have the call.  
Arrays.  You have an annotation.
You put square brackets after it
to say that it's an array.  I 
have this array of foods, and if
I initialize it to these 
strings, it's happy.  If I push 
in a new string, it's still 
happy.  But if I were to try to 
initialize it, or push in a 
bollion, it would complain and I
would have to fix that.  So your
functions, you will be inporting
them all over your application. 
Those were contrived examples, 
because you can look at your 
variables three or four lines 
above.  But a function, this is 
where you're going to be able to
catch things across your 
application as you import 
things.  You can see here that I
typed my parameter with that 
same annotation.  There's 
another annotation after the 
arguments list, which is the 
return type.  And then we just 
write normal JavaScript on the 
inside.  If I pass race car, it 
will be happy, but bullion, it 
will complain.  It is smart at 
figuring out what return types 
are, so you can omit the return 
type if you don't want to do so 
much typing.  
All right. 
Unions.  This is something that 
I use all the time.  It's like 
an or.  I want to say that a 
vegetable can be a broccoli or a
carrot.  Fruit can be any of 
these fruits.  And I use unions 
with types.  I can say an 
ingredient for this restaurant 
is going to be a vegetable or a 
truth,
fruit.  
If I try to make this sludge 
drink out of bread and bacon, it
will not be happy because it's 
neither a vegetable or a fruit. 
Interfaces.  This is how you 
type objects.  This looks a lot 
like plain object notation.  You
have a colon, and instead of the
value, you put your type name.  
You also can use all of these 
other features inside of your 
interfaces.  So here we have a 
union between a bunch of 
animals.  You can have your 
favorite.  You can make it 
optional by allowing nulls, and 
TypeScript will help you check 
null before you access the 
values or anything like that.  
    All right.  So most of my 
day I spend writing React, and 
that is where TypeScript really 
shines for me.  I like it when 
I'm writing plain TypeScript, 
but for React components, I 
think it's the bees' knees.  If 
you use the prop types package, 
this probably looks familiar toe
you.  In prop types, you have to
declare your types.  You get 
more help from the compiler.  
You don't have to include the 
prop types package.  All of this
gets stripped out at compile 
time, and you ship a smaller 
bundle, a little bit.  So just 
to walk through this, we have 
our props.  We're going to have 
one prop called size that 
accepts small, medium, or large.
And then we just pass it into 
our component as usual.  And you
can see here that inside my 
component, I have very little 
TypeScript-specific syntax.  It 
really looks pretty much like 
normal JavaScript.  And this is 
what it looks like to use that. 
I import my icon component, and 
if I don't give props, 
TypeScript will complain because
I told it to expect props.  Here
if I give it size, it can 
suggest to me what the props 
should be.  This is nice when 
you're using a design system, 
because you can know exactly 
what the values are supposed to 
be.  This is the VS code 
interface, and when you run the 
compiler, it gives this exact 
suggestion where it will list 
what it's expecting.  If I give 
it something that it's 
expecting, it will be happy and 
I can compile my code.  I hope 
that has made TypeScript a 
little less mysterious.  Thank 
you very much.  
[ Applause ]
   &amp;gt;&amp;gt; Hello? Hey.  Andy was 
right on the dot on that timer. 
Our next speaker is 
[ Applause ]
   &amp;gt;&amp;gt;Burke, and he's going to be
talking about, it's titled &quot;the 
best UX is no UI at all.&quot;
   &amp;gt;&amp;gt; Has it started yet? What 
do I do? Just go
to the right? 
Again? Wrong slides.  Wrong 
slides.  Different slides.  
These are good slides, though. 
[ Laughter ]
    Should I tell a joke while 
we wait? I don't know any jokes!
Help me out.  
Let's see.  A good book is like 
a puppy.  Easy to pick up; hard 
to put down.  See, I told you I 
didn't know any good jokes.  You
forced me into it! I didn't want
to do it! 
Please hurry.  Okay.  
    All right! Did we start? 
Thank you! That's it.  I'm done.
Can I go? Did I already start? 
Tell me when to start? Now? 
Okay.  Hi.  My name is Burke, 
and I love user interface.  I 
have always loved user 
interface.  I remember staring 
at the glory that was compact 
tab works while I played this 
game called the incredible 
machine and listened to the 
tears for fears greatest hit 
album.  I was listening to mad 
world way before Donny darko and
that creepy rabbit movie.  
That's an old and obscure 
reference.  It's not you.  It's 
me as Costanza would say.  
That's another old and on secure
reference.  I got my first 
computer when I was in boot 
camp.  They pay you but you 
can't spend it because you're 
doing push-ups.  I got my first 
computer -- oh, you can see the 
slides right here -- which was 
an HP pavilion.  It came with 
windows 98.  My sounds aren't 
working.  There we go.  I loved 
windows 98.  I spent so much 
time changing the different 
themes, looking at the icons and
the text.  Each theme was better
than the previous theme.  It was
incredible.  It was so good! And
if only I had known then, if 
only I had known what was 
coming, if only I had known 
about windows XP... okay.  
    This was -- do you believe 
in love at first sight? Does it 
exist? No, of course it doesn't.
Don't be ridiculous.  It's a 
complex human emotion.  Let me 
tell you what does exist.  
Infactuation.  I was infact
-- 
I was infactuated with XP.  I 
was not socially popular, so I 
had time to sit around and stare
at operating systems.  When you 
can do that, you want to make it
look like OS10.  So this
goes out to you.  As much as I 
love UI, I'm not a designer.  As
much as I want to be a designer,
I am not.  What I can do is 
assemble building blocks.  If 
you give me sliders and 
drop-downs and modal windows, 
then I can build you a UI.  I 
used to work for a company 
called Kendall UI, and I have 
been fortunate to be part of 
great products.  But you 
wouldn't hire me to build a 
website for you.  Unless you're 
my mom.  If you did, you would 
get sub par results.  What I 
realized through all of my time 
working with UI, is that the 
best user experience is no UI at
all.  So let me talk about that 
for a second.  UI is a middle 
man.  It's a conversation.  It's
pre-canned.  It has boundaries. 
We try to code for the simplest 
possible scenario to get a user 
through the process, or all the 
processes in the world! Right? 
And so we could improve upon 
this UX probably a little bit.  
There's been great feats of UXG.
If a baby can pick up an iPad 
without training, that's kind of
an amazing thing.  The reason we
have UI and wonderful buttons 
and sliders is historically, we 
haven't been able to talk to 
computers -- until now.  Natural
language processing is the field
of computing that deals with not
just speech recognition but 
extracting a user's intent from 
what they just said.  We have 
Alexa, Cortona, Google home, 
okay Google or Google assistant 
or whatever you call that thing.
A lot of people have these.  I 
will give you three examples of 
how no UI is better than a UI.  
I can say hey siri, remind me to
e-mail my mom.  That experience 
is way better than this.  No 
matter how beautiful the 
reminders app is, it will never 
be easier than saying just do 
it.  Here is an example of me 
turning lights on and off.  
Here's the app that you do it 
with.  Here's me turning lights 
on and off with the app.  Very 
nice.  Here's me
doing it... 
Alexa, turn off the lights in 
the master bedroom    &amp;gt;&amp;gt; Now 
watch this. 
&amp;gt;&amp;gt; Okay.  
   &amp;gt;&amp;gt; Alexa, can you turn on the
bedroom -- turn on the master 
bedroom lights.  
&amp;gt;&amp;gt; Okay.  
   &amp;gt;&amp;gt; That is natural language 
processing.  It completely 
botched that command seven 
different ways and it was able 
to do it.  If you have a nest 
thermostat, you can lay in bed 
and control your temp with your 
voice.  Now that I said that, 
its sounds pathetic.  Never 
mind.  I don't ever do it.  
    The last I would give you is
a service called digit.  It 
saves for you and it will give 
you savings updates.  I blurred 
this out so you don't get too 
depressed by my lowball lance. 
 -- low balance.  It was 
resilient at understanding my 
commands.  I didn't have to know
what to say, I just said it.  So
the question now is, is UI as we
know it dead? The answer is no. 
No! Absolutely not.  There are 
accessibility concerns.  You 
wouldn't want to take photos 
with your voice or scroll 
through pictures with your 
voice.  That's not a good user 
experience.  But it does give us
a chance to rethink some of the 
ways that we build UIs that 
maybe we don't need to build a 
UI, and instead what we need to 
build is something that's more 
conversational in nature that 
uses natural language 
processing.  That's now 
available to all of us.  And if 
I'm going to end a little early.
You can check out
the project here.  As long as 
you know how to make an AJAX 
call, you can add natural 
language processing to your 
applications and build a BOT or 
a conversational UI.  
Thank you so 
much.  
[ Applause ]
&amp;gt;&amp;gt; Thank you.  I just want to 
acknowledge my co-Emcee.  We use
they/them pronouns.  I don't 
really know the name yet.  We're
going to be friends in a
minute.
Their name is
Beyla.  Our next talk is Istvan 
and his talk, 
2,506 bytes ought to be enough 
for anyone.  Thank you so much. 
My Iceland.  dear co-presenter 
is going to
&amp;gt;&amp;gt; be here today, Beyla.  You 
can see them 
holding yeast yesterday's beer. 
We will be talking about 2,560 
bytes is probably enough for 
anyone.  If you don't get this, 
you are probably not very old. 
I am from Hungary, or at least 
from I rent an apartment there. 
I'm a speaker.  I worked with 
the dev team doing the same 
thing, and I'm doing a bunch of 
JavaScript,
microcontroler stuff, and
the T
Tessel project brought me into 
programming to begin with.  I 
started playing around with it, 
and I did my first presentation 
in Budapest on JavaScript and 
microcontrolers and convincing 
people that running JavaScript 
on a microcontroler might be a 
good idea, or at least not a 
terrible idea.  Why would that 
be? I'm not sure this talk is 
going to sell it to you.  But 
one of the creators, John McKay,
has given a talk last year 
talking about the whole journey 
of the Tessel team.  It's 
fascinating how they use 
JavaScript on a microcontroler. 
There are devices like you see 
on the screen.  This is the 
thing that you see is a USB 
connector.  And you can program 
this with JavaScript.  It had a 
very strange JavaScript
compiler.  Somebody didn't think
it was okay, so they set out to 
bring JavaScript properly on to 
microcontrolers.  It has 
improved a lot.  Espruino is a 
capable chip by now.  It powers 
a lot of devices.  You can power
BBC microbits on it.  It is 
interesting stuff happening, and
I forgot to set this up, so let 
me just set some -- hopefully --
yep. 
Not yet.  Technical 
difficulties, I guess.  Let me 
see if I can get this
to work.  
There you go.  Now we're 
talking.  All righty.  Let's 
talk about a bunch more 
interesting stuff like
JavaScript.  Babel announced 
they were running JavaScript on 
their watches, and they didn't 
stop until they could get
JavaScript running and 
efficient.  230 lines of code 
versus 39 lines of JavaScript 
over the UI of a smart watch.  
And when they went defunct last 
year, they got bought out by fit
bit, and my watch is running 
JavaScript on the UI.  You can 
create apps for your watch on 
JavaScript.  But we need to get 
smaller.  These are pretty 
capable chips.  How about 
putting JavaScript on a 
microcontroler like this? Have 
you ever played with this 
before? This is an 8 bit 
processor.  It literally has 
2,56 o
bytes of memory.  It holds 30K 
of flash.  And you can do stuff 
like put space invaders on it.  
How? There are bunches of way.  
Usually you use some C
+ + to code it.  It's a good 
thing, and you just mentioned 
flow.  It uses flow to infer 
your types and stuff.  I don't 
have time to explain it.  But 
come up to me and try it 
yourself.  Because that's all 
the games you will be make 
willing be just JavaScript, you 
can just put them on to the web 
and play them.  And after you 
played them, you can compile 
them and put them on to devices
like this one.  This is a 
JavaScript game running on a 
microcontroler, with hardware 
that has 8 bit 16 megaHertz 
processor.  Or you can use this 
one.  It's a tiny arcade box 
that you can play with.  Why is 
that interesting? Because this 
is just JavaScript as you are 
writing.  And you can check 
that, because I have some links 
up.  If you go to this with your
computer or laptop, actually, 
you can play the exact same game
that gets compiled down to the 
microcontroler.  And we have 
space invaders if you're into 
that kind of stuff.  And we have
a workshop.  So if you're 
Icelandic or going to be driving
around the island in the next 
week, drop by the university 
next Saturday, and we're going 
to do a whole workshop with the 
creators of these devices were 
kind enough to provide us with a
bunch of devices.  So you can 
play JavaScript games and put 
them on to a microcontroler
and play around.  If you want to
talk to me about this stuff, hit
me up on Twitter or follow me.  
All of this is open source.  
Most is built on node.js and 
compiler.  You can contribute if
you want to.  All the slides are
online.  That's an Icelandic 
domain, right? Thank you very 
much.  There's a reading list, 
if you want to know more about 
the talks.  
[ Applause ]
   &amp;gt;&amp;gt; Thank you.  Our next talk 
is from Martin, and he's going 
to be talking about accessible 
customizable selects, and it's 
probably harder than you 
thought.  
&amp;gt;&amp;gt; Hi.  Okay.  This is
working? Great.  Welcome to my 
presentation about accessible
customizable select.  My name is
Martin, and I work as a 
front-end developer for a 
company.  Let me address the 
elephant in the room.  Why 
another JavaScript? Isn't it the
first rule that we should always
use the native whenever 
possible? True.  However, the 
native thought is hard to style 
using CSS.  This forces us to 
create our own custom 
implementations, and we need to 
reimplement the accessibility 
into it as well.  And I'm not 
talking about high enough 
contrast and large enough fonts.
What I mean
is supporting assistive 
technologies, such as the screen
readers used by the visually 
impaired.  And there must be 
plenty of existing solutions out
there? Well, I have looked
into them.  I have reviewed 
existing solutions provided by
various companies and various 
techniques.  
Unfortunately, there were 
issues.  For example, the 
implementation provided by 
Google as part of the polymer 
project is not compatible with 
JAWS and square key when using 
voiceover screen readers.  How 
can we use such a solution? We 
cannot.  On the other hand, 
there's implementation by Jquery
UI, which is buggy and remains 
completely silent when used with
voiceover.  So how can we use 
such a solution? We
cannot.  We were looking for a 
solution that could be 
integrated into any project 
regardless of its front end 
technology.  But of course, 
accessibility was the top line 
priority.  What do I mean? We 
were looking for a solution that
works regardless of the 
operating system the user may be
using.  With slight reservation 
when it comes to Linux, 
assistive technologies is not as
great as it's going to be.  
Next, we must support all of the
commonly used browsers, 
including internet explorer 11. 
If the technologies used by the 
solution would be available for 
up to I8.  Support for all major
screen readers used around the 
world is a must.  And of course,
we cannot forget about the 
myriad of keyboard shortcuts.  
Don't worry.  We don't have to 
consider all of these 
combinations and all of these 
technologies equally, since 
there are combinations that are 
recommended by the providers and
vendors of these assistive 
technologies.  It doesn't mean 
we can ignore the rest.  We just
need to make sure that these 
work really well.  On the other 
hand, there are combinations 
that are just not compatible at 
all. 
For example, the JAWS screen 
reader is incompatible with the 
Edge browser.  I'm told this is 
being fixed.  
All of this has taken us on 
several months of a journey in 
which we were testing and 
prototyping, and we made quite a
couple of findings.  
Accessibility supporting 
browsers could be improved.  And
support for aria, which is used 
to make our websites more 
accessible is implemented by 
assistive technologies, not 
browsers, inconsistently.  This 
makes situations where you are 
prototyping and testing a 
solution.  It seems to work fine
with one assistive technology.  
And things completely break 
apart.  After a moment, you will
begin to feel like Alice in 
wonderland.  Things just don't 
make any sense.  
    This is me right here.  
Anyway.  There are some positive
sides about this.  For example, 
once you put accessibility into 
the mix, the Android and iOS 
platform are pretty much the 
same.  Throughout all of this, I
have been reminded of a quote by
Steve Jobs.  Yes, he's more 
handsome than me.  Great things 
are never done by one person in 
business.  They are done by a 
team of people.  Similarly, to 
achieve great accessibility, we 
cannot rely on just a single 
technique.  We will need to find
a combination of techniques that
will work well together.  Well, 
have we found such a solution?
    I'm happy to tell you that, 
indeed, we have.  We were able 
to design a solution that adapts
and works very well with all the
compatible combinations of these
major technologyes.  The project
itself is MIT-licensed, open 
source, available at GitHub, 
where you will find more 
detailed project information, 
current documentation, and how 
you may integrate this into any 
of your projects regardless of 
the technology you may be using.
Thank you, and I wish you a nice
day here in 
Iceland.  
[ Applause ]
&amp;gt;&amp;gt; That's our first half of the 
lightning talks.  We will have a
break for ten minutes, and come 
back for more later.  
Thank you.  Iceland.  
[ Applause ]
&amp;gt;&amp;gt; That's our first half of the 
lightning talks.  We
[ Applause ]
 [ 
Break ] 
 Live Captions by:
@smiley845 with @whitecoatcapxg 
&amp;gt;&amp;gt; Hey, everyone.  Welcome back.
We're going to be talking about 
hacking the future with Laurens.
   &amp;gt;&amp;gt; Hi.  I'm at the university
of applied sciences at 
Amsterdam, but that's not what 
I'm here to talk to you about 
today.  I'm a volunteer at a 
refugee code school called hack 
Your Future.  While I can tell 
you what that is, but it's been 
done better in this
video.  I'll show you a short 
clip.  
[ Video ]
. 
    [ Music ]. 
&amp;gt;&amp;gt; Hack your future is an 
initiative. 
&amp;gt;&amp;gt; It's an organization.  that 
is especially for refugees. 
&amp;gt;&amp;gt; That come to the Netherlands.
I think it's mostly Syria, but 
other places as well. 
   &amp;gt;&amp;gt; People who have left their
countries involuntarily to pick 
up a new skill, hopefully.  
&amp;gt;&amp;gt; So hack your future teaches 
them computer programming, web 
development. 
   &amp;gt;&amp;gt; CSS and HTML.  And you 
learn basics and JavaScript, of 
course. 
&amp;gt;&amp;gt; And help them to find
jobs.  
   &amp;gt;&amp;gt; These are people who had 
some unfortunate circumstances, 
perhaps, and are trying to do 
something good for themselves 
and for the world. 
&amp;gt;&amp;gt; I'm proud of myself that I 
could learn it.  
&amp;gt;&amp;gt; So this actually tells you 
about what hack your future is. 
But not so much about why hack 
your future is.  So hack your 
future was founded by a couple 
of people who thought, well, 
there's a growing group of 
refugees coming to our country. 
And they actually have a lot of 
trouble entering the job market 
because they won't have the 
right backgrounds.  They'll have
language barriers.  Maybe 
there's discrimination issues 
going on.  How can we prevent 
these people from becoming 
marginalized in our society.  So
they funded hack your future, 
because they decided what's the 
best way to empower people and 
the best way to get them jobs: 
One of the best ways is to teach
them web development skills.  
There's a lot of demand for web 
development skills.  It allows 
you to go into various different
paths, as you all know.  We 
thought, well, how can we do 
that? We came up with an idea of
setting up a volunteer program 
where volunteers teach refugees 
every Sunday for about four 
hours.  We have interactive 
sessions with them.  And then 
they spend about 20 hours 
working on home work 
assignments.  And they hand in 
their homework on GitHub.  And 
we interact with them throughout
with week on Slack.  So they 
have support for the whole week.
We teach them basic skills.  
First we start off with HTMLHTML
CSS, because they have virtually
no technical skills coming in, 
and that's an easy way to enter 
the field.  Then we spend nine 
weeks on the basics of 
programming through JavaScript, 
which I had a lot of pleasure in
teaching them.  
They're super-motivated, so it 
goes faster than with my 
students at the university.  And
after -- at the end of those six
months, they work on a project 
and they actually develop 
something themselves.  They 
often choose to develop 
something that will benefit 
other refugees, which is really 
awesome.  And alongside that 
program, we also teach seminars 
on how to conduct yourself in 
job interviews.  How to make a 
good LinkedIn profile, you know?
Basic skills that you might also
want, and things that are quite 
different in the Netherlands as 
opposed to, for instance, Syria.
So yeah, that's the way that we 
set it up.  So what have we 
achieved? We have about 55 
students that have found jobs at
companies such as KPMG, 
booking.com, and KLM.  I guess 
that's the main thing that we've
achieved.  But we also have an 
active network of students, men 
20Rs,  -- mentors and alumni.  
They're all in the Slack group, 
and they help each other out 
with anything from finding good 
companies to apply it, to how to
cycle through the snow in the 
Netherlands when winter comes.  
And we've also achieved 100% up 
time for the past two years, and
who can really say that about 
any program they're running.  We
also have new chapters in 
Copenhagenen, London, and more. 
People have started copying our 
project.  Hopefully it leads to 
a better future.  
    So I also have a quote.  
It's not by Steve Jobs.  It's by
one of our students, Jack.  He 
says that his main take-aways 
from the program were to -- how 
to think like a programmer, how 
to work in a team, and most 
importantly, that people can 
still treat him for the person 
that he is and not the way that 
he might be seen.  Which I think
is a very important thing for 
these students coming to us, 
because as soon as they enter 
our doors, they stop being a 
refugee and they start being a 
student.  We just treat them 
like that, and we don't really 
talk about their backgrounds at 
all.  We treat them as students 
and we say this is your 
homework.  You have to deliver 
on it.  We will be supportive 
and try to help you with any 
issue, but you have to deliver. 
    So, actually, the point of 
this talk is not to tell you how
awesome it is that I work at 
this program, that I volunteer, 
or how good this program is.  I 
actually want all of you to 
start copying this idea, and to 
set up a hack your future of 
your own.  I think it's one of 
the best ways to empower people.
So how can you do that? You'll 
need a couple of ingredients.  
First off, a convenient 
location.  It's important that 
people can actually reach your 
location.  And a lot of these 
people will be in camps, and 
they might not have a lot of 
money or means of 
transportation.  So that's 
important that you find a good 
location.  Secondly, you'll need
some laptops.  They don't need 
to be start of the art.  It's 
better if developers don't have 
state of the art laptops so they
learn to develop for old people.
You'll need a program director, 
or better yet, a team of people 
prepared to think about the hard
challenges that you might face 
to get everybody together.  We 
can help you a bit with that.  
You'll need mentors, and it 
seems like it might be difficult
to find people to volunteer, 
especially on a Sunday.  But 
we've found that there's an 
abundance of mentors.  People 
are happy to help.  There are 
people from universities.  
There's people from companies.  
There's people from any place 
you can think of.  A lot of 
people with diverse backgrounds 
like to help out as well.  So we
have a very diverse group of 
mentors helping out.  And 
students, of course.  This is 
the most important part.  It 
might not be as easy as finding 
the mentors, because you need to
find people that have basic 
English skills, first.  That's 
our minimum requirement.  But we
also want them to be very 
motivated.  So we actually have 
them do a little test before 
they're allowed to join our 
program.  And it's about 
learning a skill on your own.  
So they have to prove that they 
can do that within a certain 
amount of time.  And it's a task
that really anybody can 
complete, as long as they're 
motivated.  
    I guess a lot of people will
ask, how do you get financial 
support? You don't need that 
much money.  It's nice if some 
companies help out and donate 
old laptops.  It's nice in the 
municipality helps out with the 
rent a bit or gets you a 
location.  But ultimately, this 
is definitely something that you
can overcome.  You would be 
surprised at how many people 
want to help if you have a good 
idea.  
    Of course you also need a 
curriculum.  This is something 
that can be very difficult to 
set up, but we've already done 
it for you.  So I'll show you a 
link on our curriculum.  It's 
just something on GitHub.  It's 
just a list of topics that we 
think is good to talk about.  
But of course you can set up 
your own way of doing it.  So, 
how would you do this? Just
like JSConf, you can say I like 
this idea and I want to do it in
my city.  So you fork the 
project, and if you want to know
how to get started, you
go to start code school, and 
there will be lots of tips and 
documents and a set-up for a 
code of conduct.  
There will be an article about 
how to deal with students who 
have some trouble with staying 
in the country.  There will be 
some tips on how to conduct 
yourself as a teacher.  So, we 
strive to share all of the 
knowledge that we already have 
here.  And we also have links to
all of the resources that we 
use.  
    If you need some more help, 
you can talk to me on Slack.  I 
think there should be a space 
between Laurens and Aarnoudse, 
which is a very dutch name.  I 
will be around for these two 
days, and I like to work 
together with you and to create 
a better future.  Thank 
you.  
[ Applause ]
&amp;gt;&amp;gt; Thank you so much for that 
talk.  I hope someone -- I don't
know, maybe me can bring that to
New York.  That would be 
awesome.  Anyway, our next talk 
is from Kristjan.  He's going to
be talking about something cool 
that GitHub
could do.  
   &amp;gt;&amp;gt; Hello.  Oh my God, I can't
see my speaker notes.  That's 
fine.  Hey.  I work at GitHub, 
but this talk isn't about me as 
an engineer at GitHub.  It's 
more of a
user.  Before I started at 
GitHub, I would have these ideas
like, I wish GitHub could do 
this one thing.  And I would 
write Chrome extensions to do 
these things.  But there's some 
things -- there they are! 
There's some stuff that I 
couldn't do as Chrome 
extensions.  For those things, 
I've recently discovered this 
library.  This is not the right 
clicker.  There you go.  It's 
called pro BOT, and it's a 
library for GitHub to write 
these GitHub applications.  And 
pro BOT does this by leveraging 
web hooks and the GitHub API to 
give you the power to extend 
guilt hub in a
-- GitHub in a simple way.  If 
something happens to GitHub, 
proBOT gets a ping, and it will 
analyze what to do in the 
situation, and maybe fire off 
events of its own.  I have a 
little trivial example.  If we 
want to respond to every issue 
opened in our repository, and 
let's just say hello.  A 
welcoming message.  
We're going to build it right 
now.  We have this module, and 
it takes in probot as an 
argument or parameter.  We can 
attach event listeners on the 
robot.  There's a list on the 
GitHub documentation page for 
what you can listen to.  You're 
listening to if there's any 
events opened.  We get this 
context with it.  With the 
context, we can create a 
comment.  This is kind of 
confusing, and I didn't 
understand this at first.  But 
it just gives you an object back
that operates in the context of 
this issue.  And we just give it
the body for the issue.  And 
then just using GitHub API, it's
easy.  Create this comment.  We 
can run this.  And every time 
someone opens up an issue where 
this probot is installed, it 
will respond, thanks for
the issue.  There's a bunch of 
these BOTs out there.  Sometimes
they will close down the issues 
when nobody has commented the 
issue.   for some days, and I 
have a problem that I really 
want it to solve with probot.  
And it is related to ES lent. 
I don't know if everybody here 
uses it, but I almost always use
it.  It will run in a build.  
And if someone broke an ES lent 
rule, it will give you like a 
red status.  There's just one 
problem with this: People can 
just disable the rules right 
there in the code.  So this is a
project that I have where 
somebody disabled the rules and 
did whatever they wanted.  I 
understand that people need to 
get stuff done.  They're like, I
don't know how to do this.  I 
know how to use JQuery show.  I 
don't know how to show and hide 
things.  I maybe would want it 
to focus that you shouldn't do 
this.  Or, like, ping me and I 
can explain how to do it 
correctly.  So, like, this 
previous one, it just goes 
through and everything is green,
people
are great.  I, like I said, I 
would like for these to be 
flagged.  So I wrote this 
probot.  I gave it a logo.  It's
an ESLint logo with the eyes 
emojiemoji.  When a pull request
comes in, it checks the diff, 
and if disable is in there, it 
will comment on there.  There's 
a great thing.  If you install 
probots into your repositories, 
you can give conflicts.  My 
probot, you can change this 
message.  If you wanted to give 
him like a little image, you can
do that.  You can @ the team 
that should review this.  
Like @the JS team.  And if 
they're like legitimate 
ESLint disables.  This talk went
really fast.  You can find 
probot on my GitHub, which is up
there.  
Thank you.  
[ Applause ]
   &amp;gt;&amp;gt; That's actually all of our
lightning talks for today.  So 
I'm here to say that y'all can 
leave early.  But I'm also here 
to promote the party happening, 
and I
[ Applause ]
&amp;gt;&amp;gt; That's actually all of our 
lightning talks for today.  So 
hope I can pronounce this right.
At 
Egisgarour.  I tried.
It's in your leaflet. 
And also, until around 6:30, 
there's going to be a bus coming
in from here, and also the hotel
to the party.
And dinner is also provided.  So
don't, you know, have dinner 
before the party, unless you 
want to have a second dinner, 
which I won't judge.  And Harpa 
opens tomorrow at 9:00.  I hope 
you enjoyed the rest of your 
day.  That's it.  </div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>