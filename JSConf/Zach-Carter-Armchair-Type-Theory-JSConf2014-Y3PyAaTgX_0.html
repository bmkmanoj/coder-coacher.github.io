<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Zach Carter: Armchair Type Theory [JSConf2014] | Coder Coacher - Coaching Coders</title><meta content="Zach Carter: Armchair Type Theory [JSConf2014] - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Zach Carter: Armchair Type Theory [JSConf2014]</b></h2><h5 class="post__date">2014-07-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Y3PyAaTgX_0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so sluggish titled armchair type theory
who could spot the type error in this
opening slide now you'll notice there's
a couch there when it's supposed to be
an armchair so yeah my name is zak Z on
Twitter I'm actually from Florida so
yeah right there so you want to know
anything about the state feel free to
check out this website Google and I can
help you out with that but so this is
jas cough and javascript doesn't have
types but let me motivate you a little
bit this was a bad year for software
engineering there was the go-to fail
then there's also something called
heartbleed with a really nice logo and
it's I think it's becoming clear that
we're good at building features but
maybe not so good at exercising all of
the unhappy pass so we're really good at
building features building or exercising
the happy paths and usually what's out
of sight is out of mind and we don't
notice when we're exposing all these
these opportunities for failure so
been that we're horrible at exercising
these unhappy these unhappy paths code
reviewers QA the open source community
even missed these these bugs that were
in the software we have to rely more on
computers or computer friends who are
relentlessly unforgiving and which is a
good quality to have when you're
reviewing software so this talk is
titled armchair type theory so of course
we're going to be talking about type
theory you can kind of see in the
background there that's Bertrand Russell
he invented type theory to basically
solve a bug in formal logic so in
programming languages we use type theory
to develop type systems and you can if
you're not familiar with type systems
you can basically think of it as like
j/s hint on steroids so it'll it'll
actually it's actually part of part of
the language usually languages I have
type systems they embedded in the
language but it's also static analysis
to it so and nothing short of running
the actual program will guarantee is
correct but type systems provide a way
to narrow the scope of what's a valid
program sort of the same way that your
parser will narrow the scope based on
the grammar of the language the system
will narrow it further using extra
information context about what the link
what the program means and this is
something you only do with a type system
but of course there'll be trade-offs so
if you're trying to do something
dangerous or anything with safeties
built-in is going to make it harder for
you to do like certain things that's
part of the trade-offs you have to make
and I'll talk about that more when we
get into things that are relevant to
JavaScript like pure script and
typescript because of course JavaScript
itself doesn't have static types
it does have these cool number types
like Brian mentioned but nothing
resembling static typing unless you
count as an j s which is sort of like a
clever reuse of operators to act as like
a static typing hint for language for
edges that understand it at least but
it's not really relevant to javascript
in general so we have these new
languages that have been developed that
compile to JavaScript and these ones
especially target JavaScript as their
back-end so typescript of course has
been around for a while I'm sure your
most of you are familiar with it then
there's also something called cure
script which is newer and it resembles
Haskell and also elm is a really cool
language that it's also similar to
Haskell in certain ways but it's
targeting frp so functional reactive
programming i highly recommend it if
you're trying to get into functional
reactive programming and you also want
an additional challenge because who
doesn't want that of learning a purely
functional language so but we're going
to focus on typescript of care script
and i'll i'm not going to get into
actual type theory sorry for you those
of you who came to this 930 talk ajs
comp to actually learn about this stuff
but we can sort of format using this
metaphor instead basically what the type
system is doing for most most type
systems that we use and popular
programming languages to have them they
basically look at the value the shape of
the value at different parts of the
program where it's passing through like
functions function application operators
whenever you're passing that value
around to these applications of a
function or operator it'll check the
value and make sure it performs as the
shape so these blocks are representing
the values of them the holes and this
block here are the API boundaries where
that values being passed around
and here's an example of typescript
where you'll see this is like a function
but it also has typing annotations for
the first name and last name expecting
on the B string then also little return
a string and you can imagine this as one
way to imagine this is if there were
assertions like generated or inserted
into your program to make sure that it
was always the correct value the shape
the shape of the value is correct but
the advantage of this as opposed to like
unit testing or using assertions is that
you're guaranteed tab based on the types
of your Garrity to have a hundred
percent code coverage if you're if
you're using like something like Haskell
or pure script it's guaranteed to be a
hundred percent coverage because the
entire the program has to be typed but
it it's also done statically so you
don't have to actually run make sure you
have a hundred percent code coverage and
you actually run the program so you'll
be able to catch errors faster as you
notice types another way to look at it
is the compiler is sort of running a
simpler Dumber version of your program
at compile time the type checker is
reading the ast taking the types and
sort of running a computations on the
types themselves to make sure that that
passes then once you do that it's like
you have a formula you have like a proof
of your program so programs we want
programs i can prove themselves sorry
for this next we've got programs i can
prove themselves sort of like daniel the
karate kid proved himself and you'll
want to be able to sweep the leg sort of
say on certain classes of bugs and
depending on the type system you'll be
able to eliminate those bugs from your
programs basically so sorry no more no
more of these craddock you references
i'm sorry but yeah so they're of course
they're going to be trade-offs
especially the different types is you
might notice that c-sharp java and
haskell have like completely
different-looking type field the field
of the type system is different and
that's also the case of typescript in
pure script it's basically like a Java C
sharp past versus Haskell classic 00 p
which is purely functional but what's
interesting about typescript is of
course it's a superset of javascript so
you can take a standard JavaScript
program and sort of incrementally add
types to it if you want so you can take
a standard function and then add types
to it and this is you know you can do
this for parts of your program at a time
and of course it has the basic the basic
things you would expect from a type
system that is like C sharp or Java but
I wanted to highlight a special a
special part of the type system and
that's the any type which it does
exactly what you expect it basically
lets you substitute any value for that
variable that's annotated with any type
then you might wonder why you know your
your honor you can you just use an
untyped language but you're having like
an untyped untie javascript that you add
types javascript to it and then you
interact with an untyped subset of the
javascript and it's sort of like that i
don't know if you've seen this before
the the island in the philippines it's
called Luzon Island and then there's a
if you zoom in on the southern end of it
there's a lake and then if you zoom in
on the lake you'll see that there's
another island and then on the island
there's another there's another lake so
you know you have this sort of untyped
environment where you add types to it
but then you can also interact with
other untyped may be foreign libraries
that you need to interact with but and
also if anyone's keeping score dynamic
typing
a subset of static typing so static
typing is actually more general than
dynamic typing you basically punch a
hole in the type system and add untyped
like this any type to it and so so
dynamic typing is basically having one
type and then static other static typing
is when you add additional types besides
the any type so you might be wondering
again like why why he's a typed language
when you can there's so much more
flexibility with the n-type language and
really the type systems are adding all
of these extra features so that you can
have these expressive programs you can
approach the expressiveness of a num
typed language but still have the
guarantees that those classes of bugs
are absent which is of course the main
reason why we want to have these the
time systems in the first place and pure
scripts I'm going to talk about next has
a completely different approach than
typescript so typescript was trying to
trying to achieve the improbable task of
adding a sane type system on top of
JavaScript and keeping the same
JavaScript semantics so Pierre script
took completely opposite approach like
scribe scrap JavaScript add as it is and
add a language that resembles Haskell so
it's purely functional you'll see the
syntax looks basically like castle and
if you've never seen it before it looks
like completely foreign you might not
know how it works but that might be a
good thing because it'll it'll serve set
you off guard keep like putting on your
toes because the actual the language
itself function is a lot differently
than a standard JavaScript or object
oriented programming so you could say
it's sort of like JavaScript of
functional parts it takes the functional
parts of JavaScript but also wraps it a
really nice type system to give you
those assurances that you need and one
property of the type systems that I want
to highlight the difference between
typescript and
your script is something called
soundness and soundness basically means
that every program that you can express
in the in the language and the type
system if it passes the type checker
then it'll be a valid program you know
it'll be valid at runtime and a lot of
research goes into assuring that this
this hold so whenever there's like a new
new new type new type system developed
that has different guarantees that will
provide they go through great lengths to
ensure that it's still sound because
sound this means that at runtime those
guarantees that it's supposed to make
will hold but for typescript is a
different story someone actually a guy
named a toy bow pulled out a theorem
prover and went through typescripts
language spect and showed that a part
part of the rules were unsound so there
were expressions you can express in
typescript that will pass the type
checker but if you run them at runtime
you'll get like a type error because
it's it's not actually about a valley
expression and they have actually
notices in their their documentation on
you know why they have certain unsound
expressions in their language and so the
bug was a this issue was event of course
it was smart they won't fix and this is
my favorite won't fix gif I encourage
you to post it on github issues whenever
you have a wall fixtures let's just
watch it a few more time
so good so yeah so they basically said
in order to keep the Thai system more
lightweight they didn't want to add
these these rules I would guarantee
soundness but perhaps make it less
intuitive for people trying to build
JavaScript programs because we're used
to a certain way that the language works
being able to pass certain values to
functions and adding soundness might
make that less intuitive for the most
JavaScript programmers so it was a
trade-off that they had to make so like
the hardcore type theorists might get
angry but in the end it might be a net
gain for the rest of the users but this
is not so easy of a trade-off for
languages where memory safety is a
concern so in JavaScript you don't have
that control to say like dig into memory
and alter things but for languages like
C and C++ an unsound type system would
lead to you know things like heart bleed
for example and with great control comes
great responsibility and this is of
course where I would mention a language
like rest which Niko here gave excellent
presentation and then the videos
available online where he goes through
the ways that rest will guarantee memory
safety and it's not only the shape of
the values in rust case because there's
like concurrent processes happening in
different ways to dig into the memory so
the type system will actually give you
types that you can annotate variables
with that will track like ownership and
and different things that will help you
protect against like a mutation of
shared data so with something like rust
you
the you wouldn't be vulnerable to these
classes of memory memory vulnerabilities
where you can basically violate memory
safety so type type safety is important
aspect and soundness is also an
important aspect when you want to
guaranteed memory safety and a part of
how r us does that is like I said it
makes everything explicit so explicit
annotations on variables when you do
when you need when they need mutation
and a lot of that you can do in C and
C++ and there is some slow down when you
basically do things the right way but
the the benefit of making things
explicit is you'll save the headaches
later on it you'll eliminate these
classes of bugs so being explicit really
is worth the trade-off i would say
because you you're going to get that
performance penalty if you if you use
language like c and c++ and you do it
the right way anyway so something like
rest at least has a coherent sound type
system that would guarantee that those
memory safety bugs won't creep up
because C and C++ have tools to prevent
that but they're sort of added on later
and it's not a coherent sound type
system so i would say being explicit is
the the key here for for a rest and in
general my tips would be thus to use the
computers for what they do best like
we're not perhaps we're not best suited
for digging into these really like the
unhappy past sort of grow exponentially
because there's so many unknowns that we
don't see and it's hard for us to see
them so they can if we have like a
system that is enforced by the computer
like a strong type system that we know
it's sound it won't allow us to sort of
create these these errors that were sort
of incapable of perceiving ourselves
then
we should do that we should use
computers as much as possible for those
tasks because otherwise you know what
we've seen what happens and also more
explicitness now though it might be more
complexity upfront for you if you if
you're more explicit and you'll you'll
save your sanity later on so when
unexpected things happen</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>