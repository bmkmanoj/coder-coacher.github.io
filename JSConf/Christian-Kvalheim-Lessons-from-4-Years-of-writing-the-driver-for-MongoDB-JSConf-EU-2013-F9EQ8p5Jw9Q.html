<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Christian Kvalheim: Lessons from 4 Years of writing the driver for MongoDB -- JSConf EU 2013 | Coder Coacher - Coaching Coders</title><meta content="Christian Kvalheim: Lessons from 4 Years of writing the driver for MongoDB -- JSConf EU 2013 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Christian Kvalheim: Lessons from 4 Years of writing the driver for MongoDB -- JSConf EU 2013</b></h2><h5 class="post__date">2013-10-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/F9EQ8p5Jw9Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Oh
you
so I question first like how many people
are actually maintain an open source
project how many people I wanted to rage
quit their opens our sale me too it
seems to be the kind of like general
term when it comes to you get to this
point where you kind of just really
don't want to deal with your project
anymore and then something happens like
for me they started paying me for do it
and now I have to do it it's the way I
get food on the table so how did I get
into it was really fast how did I get
into know Jess so I was actually become
here in Berlin in like two thousand and
was he like 2009 or something oh yeah
something like no 2007 actually and we
were talking about the I think v8 have
just been announced and it was like all
over the internet and stuff and I was
talking with a friend I was like so how
long do you think it's gonna take before
somebody writes JavaScript framework
right for the server and I was like I
don't know but it's gonna be cool right
and I did the little thing put up a
Google Alert and like I think it was
like a little bit layer like a nearly
two years later Selena my google alert
went often said like a no GS is out and
I was like oh look it's JavaScript on
server but it's not exactly what I
expected for coming from Ruby I was like
a string penis huh alright so that was
like the big big shock and I we got
intrigued right and I decided to like
start playing around with it and wrote
my own little applications and I came to
the timer I basically had to need the
story some data somewhere and at that
point there was only Ryan's PG
javascript script that was like a simple
postgres driver Washington really fast
wasn't really any particularly you know
full form platform at that point and I
was kind of looking around in a friend
of mine Ruby I had been using MongoDB
down in Atlanta for our project and said
like what don't you use this is like
Jason right as I said okay let's mean
you start write my own drivers and so
you basically have to do everything
yourself at this point because I don't
know how many people were in a node
community at that time a couple of
hundred maybe so after a couple of
months the first commit was out and like
january seven
and pen and since then it's just been
crazy all right and specifically last
year the last 12 months like the growth
in usage for for no jest projects in
general or MPI modules has just exploded
right mongodb is kind of like as
exception like I mean you've gone from
like about 20,000 mpm installs to about
like two hundred thousand a month or so
glad I think socket i/o I think red is
probably the biggest one I think he's
got about 400,000 installs a month but
it's just gone gangbusters that and I
kind of expect this trend to keep going
in the next couple of years so how was
the first driver when it came out it was
told piece of ok so it had things
like a hash now ordered hash class that
had written because I you know I was
relying I didn't want to rely on the
behavior of v8 and ordering keys and it
was completely horrible structure mess
like it was just me learning to write
JavaScript basically and there wasn't
really any testing frameworks lat points
so I had to kind of hack up J spec to
make it work so I could have some
testing framework everything was like
node was like liquid water right
everything was constantly changing like
from one point released you the other
like philosophies would change all right
so I don't know how many people here a
lot of promises but that was initially
in node and then they took it out I
don't remember exactly why the reason
was but it was taken out and yeah there
was no NPM power points all right so
everything you did you basically had to
kind of download Jas and put it in the
right that I directories yourself
ossified so there's no real way of
distributing the driver either people
who started basically clone your git
repository and used driver so I can't
challenge is you kind of run into when
you're driving writing something like a
driver and JavaScript now in 64 support
I was just in a JavaScript crypto talk
here and he said that he mentioned that
there's likely there's a
three crypto library or crypto API may
be coming that might have in 64 s that
would be a revelation for for me by the
problem and this is something you're
going to run into eventually as the
JavaScript developer is that the numbers
aren't really numbers they're actually
floats like they're double floats which
means that anything over fifty three
bits cannot be represented as a whole
integer in fact when you reach that
number it just keeps being the same
number over and over and over again
right so to represent 64-bit ends which
we need for to support all of the
MongoDB kind of types you have to use
the google long closure library and that
works pretty well it's a bit slow
because you have to do all this 64-bit
ARM ethic over to 32-bit values but it
works but I was a pain so then we
started kind of adding features because
I was sort of evolving the driver as
MongoDB itself was adding features so we
had that great at fest which is like
storing files in the database there they
came up with like clustering which
called replicas along with me and then
later sharding and so I had to add
support for that and then adding streams
support for cursor and great FS when
that became kind of like the big meme in
a no Jess and he kind of became more
standard and healing was complicated
issues like high availability done
laughter wall royal you know like you
get into this one I want to like
optimize stuff and the C++ API is had
finally kind of like solidified enough
for you to go and write a C++ extension
and there was actually enough tutorial
so people actually had tried at that
point so i decided to profile
application and then look at like where
the hot spot in the code was and at that
point the whole parser was JavaScript
and it was actually the bottleneck was
the parser right so I wrote a horrible
C++ parser because I'm not C++ person
thankfully there was a guy in lucas art
may they rest in peace that cleaned up
the cold later and now i think it's a
fairly solid parser
a couple of things that I did wrong was
that for example the initial version
implemented these types that are among
the D being like a binary class or a
long type of this kind of stuff we
implemented in C++ and I was just hard
as hell to maintain right it's like
every time somebody changed me sent me a
bug fix for something like I had to go
back in C++ and fix that code as well
and in the end it didn't mean anything
there was no performance benefit or any
at all because in the end it wasn't
expensive to actually instantiate just
JavaScript classes inside of v8 C++ code
in just use those so now the parser C++
parts you just deal for the actual
parsing we're still just using the
JavaScript objects for the types which
means I don't have to maintain as much
code then like as no jess was liquid
suddenly they introduce buffers right
and buffers was like a massive
improvement right also because the
Google VI team-wise laughs in these guys
actually went the other way to make it
be fast for no Jess so one of the things
you cannot have to do with buffers like
for example is to be aware that like
allocating buffers can be expensive and
so when you're doing something like a
bison serialization you have to allocate
some sort of binary buffer of some
particular size the way MongoDB
documents are nested documents you
cannot have to walk the tree to
determine the size of the final buffer
and it's actually faster to iterate
through the entire tree allocate once a
big piece of slab of memory sterilized
into that memory and then write it out
than to try to basically you know plug a
bunch of smaller buffers together
because the cost of allocating all those
small things is quite expensive actually
in fact like one other experience I'm
considering is just to allocate the
maximum size of bytes and I can do and
just use that buffer again and again all
the time and just never actually
allocate any memory other than once so
I'm see I think that might be able to
break get to see the JavaScript version
up to C++ speed so one of the things you
have to know
far forces that they're up to have a
secret optimization in the eighth so if
you ever do like profiling in alg su
you're going to see these things called
slow buff and fast buff show up and fast
but basically lets you map directly into
memory so if you do something like entry
if the buffer is called a element zero
and accepted to a byte value it actually
will go straight into memory instead of
going through the entire stack of v8 so
that's also based on what type arrays do
so temporaries are equivalent in this
respect to like better performance wise
that's it I don't know if eventually
buffers might even go away or be
implemented just on top of existing type
arrays but that's something to ask for
no just people the other thing you have
to deal with is like pool handling so
when you're a database you've got lots
of connections you have to check in
stuff check it out you can't really do
that in a ficient way and no just
because blocking isn't really an option
right so spice must flow and also in in
MongoDB you basically have the situation
called a right concern so traditionally
MongoDB basically wrote a message like
an insert to the straight to the socket
out to the database and to actually get
the result of that insert you have to
write a second message called
getlasterror right after right so the
gate last error and the thing has to
happen one after the other because the
socket is bound to specific threat so if
you put something else in between and
then we do get last year you're
basically going to get the result from
the operation that happened but not the
one that you want it so the thing to do
that is at least knowledge as was the
pipeline is right so you write the up
and then get less area into one single
binary buffer and flush it out the
socket then we get problems like how to
deal with reconnect right so you have a
cluster the servers one of the servers
disappear now you have need to reconnect
but MongoDB is blocking like Sen typical
traditional synchronous languages like
Python you might just wait for the
cervical to come back and unlike block
all operations until you're basically
ready too bright to the server so not
just basically what it does is that in a
cluster when the second
goes on in such buffering up the
operations and until there is like
basically an available server and then
it flushes those operations out to that
server so in the best case what you're
going to see is just the increase in
latency on your operations but you're
not going to loose any operations the
problem is obviously if your service is
out long enough you're gonna get you're
going to run out buffer or memory space
basically so there's still this kind of
like balance between one and the other
here that haven't quite figured out the
other thing that people were one it was
the ability to kind of like just
serialize an object but not necessarily
just let the sterilizer decide which
feels were to be sterilized time so
there was a need to weigh this was
actually people came to me and and
committed part of this code the idea was
just to add something like a to be some
things so like if you actually have an
object in yada to be some function in a
function whatever you return is what
gets sterilized so it makes it a little
bit easier to kind of make your own kind
of like semi odm style thing where you
can kind of keep feels transitive in the
in the document and not necessarily have
to write them to disk and this was like
a very simple thing but that it actually
got a lot of like used for all of people
so we were talking about the fact that
we have these clusters on replica sets
they come and go like a server so you
have these secondaries in MongoDB which
are basically slaves in the in the
terminology of thermal databases and you
have these problems where you basically
have to query once in a while the state
of replica set to figure out if some new
node came into production right because
the among going to be you can kind of
say I'm going to put up a new database
and i'm going to add that to this
cluster and the driver needs to be able
to pick that up and basically include
that as possible way a server to read
from and in the application itself you
can basically say let me read from a
slave all might reach you go to slave
and not to the actual master
so this is where the main problem home
with no Jess right for this particular
use case a single for it just sucks
right like you can use that time of the
set interval but it's not really that
good it's like a Yankee way of doing it
because there's no hard this really
really soft kind of like it's very very
very soft guarantees on such time as a
set interval on it running unless
specifically a specific time so if you
just hammering your no jest application
with JavaScript you might set thy mother
said to one second might take longer
than one second and there's lots of
subtle state changes that can happen in
between and I don't think we're ever
going to get web workers you know Jess I
hope so but I'm holding my breath and
there's not really an option or using
processes because I can imagine a driver
that starts spinning of processes
without your knowledge that's probably
not going to be a popular driver and the
other thing that I ran into was one no
just want multi-platform right hello
Windows users anybody hears the windows
user wow there's actually a couple of
months that's amazing so no just goes
windows all right what about that damn
C++ right anybody here oh there u
Windows users enjoy C++ extensions no so
so what what you do in this case like
you install is install a driver not give
will throw an error it will still
install but it will throw an error so
you get this confusion going right so
you build dll's in case I built dls
automatically for windows 32 and windows
64 and just wrap your package them with
with the actual driver so that like if
you're on Windows you will go and look
insider' dll low that and you'll use the
C++ parser but there's all these lanky
things I've probably improved a little
bit but for example until recently you
could only build no extensions using
visual studio 2010 plus the windows 7
64-bit SDK
just finding that out is like question
itself and you know no gift will
basically give an error that the package
didn't build leading to my you know
typical github issues where I cannot
install the module because I'm getting
an error right even if the module
installed so usually the problem is
between you know the screen and I seats
but sometimes they have a valid point so
one of my biggest pet peeves I guess is
that I would love to see be able to tell
no chip don't build for windows right
and and then I just have it installed
properly and it ignores basically the
build process and then you have the
random people who are still using
Windows XP like who the hell uses mean
at 6p seriously it's like it but it
seems to be like I don't know it's like
there's like a random among the people
who are using it so after exterior
painting the windows which is an ongoing
hell bicycling so it's never finish it
finished or something new every couple
of weeks usually when Microsoft
publishes a no just a player you know
article in there msdn magazine there's a
new flood of people to use no Jess at
least like I had the possibility of
working a little bit of higher things
right so one of the things that I really
enjoy it was like getting the arm bill
to work properly right so you can run it
on Raspberry Pi and that was really good
fun and I learned a lot about like how
memory alignment is different between
arm and x86 so considering all that you
know like what kind of regrets do I have
one when having dealt with this project
over four years all right so I think
most when things i really regret is
doing this I don't know if I this can be
considered an anti-pattern but it's
definitely not good if you're dealing
with something like the driver I should
have done this right and the lessons
from that is really if it's possible to
access an intern the internal state of
something people are going to access the
inter
whole state of something and it's just
like getting tickets where people are
like oh my application doesn't work
because i'm using this internal field to
find some state of the driver and that
field is no longer there it's not kind
of fun right so like the lesson at least
from the perspective of this is like if
i guess it's a global lesson when it
comes the AP is which is like only
exposed state and functions that you
explicitly want the user to use now this
was more the fact that i was like
completely new to java script and that
was what i started with so I'm kind of
trapped between this situation that I
actually have to do backwards
compatibility drivers are supposed to be
one of the most boring things you use it
should just work right so changing code
that breaks to other people's
applications is a no-no re things that I
really did bad was like I actually
exposed the collection class and I
expose the cursor class leading people
to do create instances of these and they
were never supposed to be used to
recreated instances because they are
actually just kind of internal classes
and i'm still paying for this with
github issues so if there's essence here
is like just be very careful about what
you expose and then slowly increase the
exposure if you need overtime testing as
well is something that's incredibly
painful when you're doing something like
a driver so in the start I was using
simple integration tests you know take a
document put it in the base read it back
and test right and i was using j spec
and then i moved to like the NJ units
clone and units and I'll after a while
this reality kind of hit me the thing is
like my testing is not a linear thing
it's a grid so I have to test against
notes you're 80 10 whatever the next
version is and there's like several
different versions the Mongo each of
them having slightly different features
or slightly changes in behavior and
making this all work and has unified
integration framework is just horrible
right so what I did was like at the end
throw out and units because you didn't
work anymore and then slowly working on
like a new test framework just
specifically for integration testing so
the main core of the idea is to split
the configuration of what you're testing
away from what actually is the test and
also be able to specify tags for the
test so that you're able to say this tag
needs to have the server you know
support at least version 22 for example
and only run it on 122 is pressing so
that you can split up your tests and run
them in the grip right so you want to
run against multiple things you need to
be able to write a test with the least
possible amount of pain but still be
able to give the runner some sort of
metadata that lets it basically run it
against the right version and and the
other thing was like some things are
really painful like sample I replica
said like when you bring down a server
it takes a while for it to stabilize and
bring it back up so running a lot of
tests was incredibly slow all right so
paralyzing the test was also important
not paralyzing as in running a multiple
servers out there just being able to run
them in parallel using multiple
processes on on the machine for example
so that's also an ongoing thing but we
all know for example I want them as
painful things over a long period
project is that your test code grows
uncontrollably because you never prune
your tests ever how many here actually
going back when we factor the tests and
really move tests in the last couple
years a couple people right but you all
know the problem right it's like after a
while you don't know which tests overlap
in functionality anymore and as if
you're looking you're only one person
working on the project I can't imagine
if you're a team so one of the things
I'm also want to work on for this
particular thing is what I call reverse
code coverage so instead of asking the
question like given an X amount of tests
what code is covered by it I want to ask
the difference question a reverse
question I want to ask given a function
which tests cover this function and then
be able to delete functions so this is
like basically i think i'd probably have
about thirty forty percent crap
tests so if I could just delete that I
would be golden hopefully somebody else
be able to use it after that the other
thing when you're driving something like
an open source project that everybody
uses is like documentation and we all
know we love to do documentation because
that's not painful at all to do right so
what people ask for when you're using a
driver examples just tons and tons of
examples give me an example how to do X
right and i realized that i already had
those in code right because i had the
integration tests so i decided to build
some tools there's a bunch of spaghetti
JSI need to refactor and using the
Python Sphinx library and what I
basically did is very simple so I added
like the meta data types myself using
the I think it's like Jays doc parser
and I basically have a concert of
something called class like underscore
class where it says this belongs to this
particular class and this particular
function and then what what it does is
that it goes down through this file
finds the duck duck line which is just a
line that gets added specifically for
for the documentation and then basically
just rips that particular piece out of
it and generates documentation with with
using the merging in the integration
testing the documentation it's still a
bit like like you know fairly verbose up
there so there's still things i need to
fix but the idea was basically simple if
i had a new test and i want to make it
example in a documentation i could just
tag it and then at least I would have a
guarantee that when you copy and paste
that code from documentation it would
run right so you could I wouldn't have
to like maintain things to places and
then it's like the open source thing
right which is his own chapter backwards
compatibility right as i said earlier
drivers need to be boring and changes
bad and drivers because it's not like
you're some people are using the drivers
but directly but most people are using
it through Mongoose plus something else
or whatever and so when you change
something at a fundamental part at the
bottom of the pyramid the whole change
ripples up to the chain and you create a
lot of havoc and yeah some of the api's
are currently there suck and I know it
but I can't change them like that easily
because there's a lot of cold out there
relying on and it's getting worse for
every day right and then there's changes
in like just what's hot in the moments
there's you know CoffeeScript one we can
remember getting pull request why don't
you rewrite your driver in CoffeeScript
it's like whatever and now it's
lifescript like really live script like
we're back to naming it what javascript
was actually called it better look like
JavaScript then liked it's like the
managing part of the projects right one
of the things is just to challenge
people to help like I really appreciate
the appreciated the blog post that Felix
guys nerve brought about like just
giving projects to people if you're
leaving them and I've had some success
with that because i had a get javascript
library it's not great but it works more
or less and i just didn't have time to
work on that so I managed to this you
just give pawned off to somebody else
and I worked great but people in general
are lazy right so they want to do the
least possible thing so one of the
things you have to do when you maintain
a project in somebody sends your bug or
something is challenge people to help
right try to be specific about what you
need and they're like be sure that you
give credits for pull requests all right
like make sure that you are nice back
and then just ignore flames to create a
system they don't matter they go away
after a while and there's like just
ignore bad faith issues where people are
just ranting they just put a issue there
because they're mad or and i found the
like the general it's like wait 24 hours
to respond to an issue and see if they
fix it and fix themselves before you
start like commenting on it because if
just basically a lot of things will just
go away because people didn't really try
it before they merge the issue
and then your call is always going to
suck so you basically just have to roll
with it I how many here actually like
gone look at the con side all the hell
wrote this just to realize that they get
play mostly themselves alright so once
you get that then you understand live
code and what is actual good code is
completely objective and it's also give
and it's also completely dependent on
where you are in your learning process
right so just be kind to people that's
like the general rule and usually
they're kind back right and if they're
inflamed you don't respond just don't
it's not worth it and I think like as
one thing I learned a mango is like
being good at not responding to flames
like so we simply not wrapping up it's
like if you're going to have some
takeaways from this talk it's like
there's no static environment like we
think that no jess is fairly stable now
but it's going to change again and it's
going to have like your this little
knock-on effects right so they're just
live with the fact that everything is
dynamic testing drivers is extremely
hard and then not like criticism
personally challenge people to help you
most people are actually nice and
actually are willing to help and just
credit everybody who helps you in fact
being nice people pays back in
conclusion it's been like three and a
half years since I released the code and
it's been great it's been really busy
and up and downs and now I will do it
for a full time job so I can't complain
I made tells mistakes under way and I'm
sure to make lots in the future but I
would do it all I can that's it
you
Thank You Christian uh opening up the
floor for questions it's like a
reoccurring theme should just start on
this side um I don't know if this is
reasonable or possible but I was
thinking about the buffering operations
when a connection goes down yeah there
could be a configuration to say prefer
memory or prefer disk and then buffer
just stream it to disk and when the
connection comes back stream that Dre
straight to the socket that's a
possibility haven't thought about that I
definitely something else interesting
but the main problem and all those
options like you have make it very
explicit so there's no unintended
consequences you know yeah yeah any more
questions no I like I like how you
started that off with I don't know if
this is reasonable reasonable or
possible you know that something
interesting is at least coming like so
many good ideas start that way you know
I thought that was great all right let's
give a round of applause for Christian
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>