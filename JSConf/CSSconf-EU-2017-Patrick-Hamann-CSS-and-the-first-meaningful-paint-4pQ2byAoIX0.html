<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CSSconf EU 2017 | Patrick Hamann: CSS and the first meaningful paint | Coder Coacher - Coaching Coders</title><meta content="CSSconf EU 2017 | Patrick Hamann: CSS and the first meaningful paint - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CSSconf EU 2017 | Patrick Hamann: CSS and the first meaningful paint</b></h2><h5 class="post__date">2017-05-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4pQ2byAoIX0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello so thank you very much for having
me it's a pleasure to be back here in
Berlin as Tim just said this is actually
my second time on this stage and it's a
conference that as everyone's already
mentioned this morning has a community
that is dear to my heart and so it's
actually an honor to be able to be back
here speaking against it Thank You
Chrissy calling you Kevin and the rest
of the team and this awesome work that
they've done and especially for it even
allowing me to bring my child here I've
got a one-year-old baby here with me
Freddie come and say hello to him
afterwards I'm trying to get them on the
CSS party pack later on to do some
obnoxious CSS animations as well so
we'll be kind of live coding over there
with Freddie if you want to join in so
my name is Pat you come in you can catch
me on Twitter there and I work at fastly
we're an edge cloud provider that
specializes in real-time content
delivery and my role there is a web
performance engineer where I spend a lot
of time thinking about how we can
improve the speed of one our network but
most importantly delivering content for
our customers and their users as fast as
possible and so some of which of that
I'm going to talk about today and show
you some of the research that I've been
doing so why am I here and you're
probably wondering what the title CSS
and the first meaningful paint even
means and so hopefully all will come
true shortly so I want to ask you a
question of how do you measure the
performance of your website what does
being fast even mean is it how long it
takes to get to a load event is it how
many bytes you send down the wire or how
many requests but I would say I would
argue that it shouldn't be any of these
things ultimately we are building web
sites for our users or our customers
users and it should be about how they
perceive the speed of your website
should we even have a golden performance
metric does it even exist I would
that shouldn't and for years we've been
optimizing our pages to be built for
these metrics that don't directly
correlate to how our websites are built
but not the user experience and how
users are perceiving these things so
time to first byte or document complete
load event how many requests I sent none
of these correlates to a good user
experience and that as I can't stress
enough at the end of the day we are
building our websites for real users and
they are coming here to do something and
so fortunately we're seeing rise of a
whole new collection of metrics focused
around user experience such as the speed
index and the first meaningful paint
which we're going to talk about today
and time to interactivity and we're also
seeing writer
being thinking about custom metrics
specific to our needs maybe for a search
results on a search pages how long it
took the user to be able to find what
they were looking for or a news
organization is how long it took the
user to find an article and read it we
should be thinking more about metrics
specific to our users needs and not
focusing on how we delivered that and
built our technology and so we're going
to focus a bit on time to first
meaningful paint today so what does that
even mean if it simply the first
meaningful paint is the time when it
pages primary content appeared on the
screen ie
put simply the time when the thing that
the user actually came to that website
appeared on the screen more detailed
it's the first paint after which the
biggest above the fold so we only care
about the viewport if you can imagine on
a mobile screen that's only what
appeared in the first viewport has
happened and so layout is when the
browser converts all of your elements
and your CSS queries into an X and y
coordinate are you where that element is
going to be painted on the screen and
its width and its height so we have the
browser has to perform layout of all of
the elements in that above the world
view and paint them to the screen and
most importantly TTS MP also takes into
consideration when custom web fonts have
loaded because I've heard that we all
like to add custom web fonts to our
websites these days much to my
discomfort and disagreement but
maybe this is better represented rigidly
how does what does TT SMP actually mean
so T definite be exactly a very new
metric we've only started using it since
last year some folks at Google wrote an
amazing white paper I'll release the
slides later where they detailed how we
can go about ascertaining the time to
first meaningful paint and unfortunately
it's not exposed via JavaScript API yet
though we are talking about it and you
have to be able to use for instance
clones internal tracing to be able to do
this but on the top here we have a graph
that represents how many layout objects
are actually painted to the screen so
that's time on the x-axis and the amount
of objects on the y-axis and how that
correlates to the user experience below
and as you can see here Google do
something very clever that they flush
the head of their document way before
they even send the search queries back
to the database and so it paints very
quickly on a 3G and emerging marketing
network you've got a paint at 1.5
seconds but actually the meaningful
paints the thing that the user actually
came here for is at 1.9 and we can see
how that directly correlates to the
amount of objects that painted the
screen and hopefully you've now got a
much better indication of this ISM a
metric that's much more useful than
start render or your time to person time
to first byte because we've given the
user what they came here for and this is
the type of metric that we should be
focusing on and talking about and
building and trying to optimize for and
maybe this is a better representative
like this so this is the SD comm
homepage and who here thinks the time to
first meaningful paint is three point
five four five four point five five so
yeah the TTS MP here is actually five
seconds on a 3G connection so you're
probably wondering how you can measure
your TT FMP yourselves fortunately
Google have open sourced and built you
can contribute to this lighthouse which
is they actually built this tool is
there an auditing tool to audit how your
new progressive shiny web app was
performing against some of the best
practices but it turns out that some of
the audits in it are actually very good
just for any web site you don't have to
use service workers or progressive web
apps to use lighthouse to audit your
tool and using a lot of hosts you can
install it via
a browser plug-in or CLI and have it
part of your build process you can
expose the TT FNP of your own websites I
urge you to go home in and check this
out and try it out on your own so let's
dive straight in of how we can optimize
our own websites for that TT FMP metric
and how this relates and it's extremely
tightly coupled to CSS and obviously
this is CSS comps but it's unsurprising
hopefully to most of you that CSS is so
critical to how we deliver a good user
experience to our users and so we're
going to look at past present and future
best practices for how we deliver CSS
and the assets that are related to it in
the browser
and hopefully you'll be able to apply
some of these methodologies at home now
to do this it's very easy to create a
test case study using a to do MVC app
sorry
addy if you're in the room but it's much
better I find to show we'll use real
websites to optimize for because
ultimately we are again all building
real websites and not just to do MVC app
they're delivered in two files and we
decide to throw a metric crap kind of
JavaScript down the pipe at the same
time and this is using real-world
conditions is when we can really see how
the optimizations have effects so
therefore for the purpose of the talk
and the research I'm going to use the FT
com home page and we're going to apply
some optimizations together to it to see
how we can improve the times first
meaningful paint so just a disclaimer
here I used to work for the Financial
Times so I chose it that because I know
how the page is built and they've given
me permission to do this and in fact I
think some of these developers are still
who still wet they're in the rim and but
you know it is actually a very good fast
website but it we can probably improve
it and that's what going to try and do
and so for each optimization we're going
to be testing on a real device and I
can't stress this enough and to do this
we're going to use web page test if you
haven't used web page test before I urge
you to go and do it is the number one
tool box in my arsenal of tools because
it allows me one to test on real devices
there is a real moto G sitting at the
end of this form and allows me to shape
to a real network condition that
again we are building websites for real
users okay it contrary to popular belief
the shiny iPhone that you have in your
pocket is not a real-world device and
actually the average device globally is
a low to mid n speck Android that has a
very terrible CPU performance and very
low memory so webpagetest allows us to
actually test on these physical devices
for each test we're going to run nine
tests and choose the median result of
them and we're going to use three
Network conditions which I'll chat about
later my friend Ben is actually going to
be talking about this kind of data of
real-world devices and what is the real
network at J's comp this weekend so I
urge you to go and look at his talk so
we need to ask ourselves these questions
first of to be working out what our
average user profile is where are your
users based what is their device
landscape in what context are they using
your website and I would be very
surprised if you can one of you can tell
me that you have a single context for
your users because that that just
doesn't exist the same person might be
accessing your website on a flaky mobile
connection in the morning and then goes
at lunch time to use that same website
on their fast a iMac with their fast
cable connection there is not this
single context what is their network
profile and what did specifically did
they come here for and that's what you
should be optimizing for so for the
purpose of the test we're going to be
trying to deliver a first meaningful
paint in three seconds on a emerging
market network which has a 400
millisecond round-trip time so that's
the time a textual request to go from
the client to the server and back again
400 milliseconds just on an emerging
marketing connection and we're going to
try and optimize for a thousand
milliseconds on cable but I can't stress
this enough that you shouldn't be taking
my base lines as well at home on what
you should be using you should be
thinking about what your user profile is
and setting budgets for those and so
that we can measure the impact of our
tests and optimizations we can set a
baseline and so this hopefully will look
very familiar to all of you this is a
hex ml document that
right near the top we have a link
element referencing our compiled main
CSS file I don't care how that was
compiled or if it was offered in DES
or whatever as long as you're delivering
your CSS like this this is probably how
we have been delivering CSS since the
birth of cascading style sheets is
probably how most of you in the room are
still delivering your CSS so if we were
to run that in web page test this is the
waterfall result we've got so hands up
if you use have seen Network waterfalls
before use them on daily basis awesome
so it doesn't matter if you haven't so
say the wire the x axis here is time and
the y axis axis is the network request
that the browser is making and the
priority and the order in which that
happened web page test fortunately gives
us mine types here so we've got pixels
blue CSS is green images of purple
javascript is orange and fonts are red
and for each one of these segments
there's two shades of color that when
that we have resent the request and then
the waiting period and then the download
process and how long it took so here we
can see that we requested our HTML file
it found the link element because it
paused the document incrementally that's
great thing about HTML spec is it can be
pausing clementa ly it found the link
element quite soon during their download
of the HTML and triggered request and
then the green line here is our start
render so that's not our x first
meaningful paint but that's when we
started painting on a free G
emerging-market so that gives us a
baseline around 8,000 milliseconds
TTFN p on 3g in emerging market and
around 2000 fur cable - way out of our
budget so now we've set a baseline so
the first experiment we want to do is we
want to inline our critical CSS and
hopefully many of you heard this
technique this is what I you came to
this very stage to talk about in 2014
and in since then it's become quite a
common practice and so let's have a
quick recap of that the first thing we
need to do is we have to look at our
critical rendering path of our page this
is the single path that a browser must
do to be all the steps it has to do
before it can paint to a screen so first
we have to
I'm make the get HTTP request of our
index file we get the response to that
we can start building the document
object model this is the Dom that we
will interact with in JavaScript which
is a tree like structure representing
the parent-child relationship so I have
a body tag inside that has a div which
has a key which has a span and we pass
we can construct the Dom as we parse the
HTML incrementally so we don't need to
wait for all of the bytes of our HTML
file to be downloaded before we can
construct the Dom which is an often
overlooked but amazing feature of the
HTML specification we find the link
elements we then have to go and stop
constructing our Dom because CSS is
known as a render blocking resource and
we have to go and perform the networking
for that get that and then we can
construct our CSS object model which is
exactly the same as the Dom and but note
the idle time here we've wasted a lot of
time on our network connection waiting
for that CSS file and also note the fact
that imagine if I was on a train I was
looking at Twitter I clicked on the link
to the FT I downloaded the HTML and then
I go into a tunnel and so I have no
network and now I don't have enough
network to perform that CSS but actually
I've got all of the content I could just
paint to the screen so what we've
actually done here is we've created a
single point of failure by delivering
our CSS as a separate object whereas we
do have all of the information so that
the theory here is what if we were to
inline the critical CSS just required to
render that first viewport the one that
we care about for our first meaningful
paint into the head of our document then
declare the rest of it as I synchronous
telling rather I don't care about this
for the first paint and so now we have
all of the information we need probably
within the first round trip of a network
connection so then we can construct the
render tree and render to the page so
going back to our experiment this is now
what it looks like we now have a Spile
element in the head of our document this
moves against everything we've been
taught about separation of concerns of
styles in our scholar sheets behavior in
our java scripts and then we're using a
new friend the link preload
element which we can talk about later
and here I'm using the filament groups
load CSS function to do this I think
this is for me that the best way about
doing this at the moment and it's got a
little polyfill for browsers that don't
support this so what if we were to run
this in web page there so let's recap
this as our baseline remember we're the
start render line is there and now with
in line look we've instantly got
painting as soon as we've started to
parse the HTML document we no longer
have to wait for our CSS because we've
declared that as asynchronous and so you
can imagine this is going to have a very
dramatic effect on our times first
meaningful paint metric and so here you
can see we now have a 63% improvement on
our baseline we've got 1300 millisecond
times first meaningful paint on cable
and 3200 so we basically have dit which
is extremely impressive just using one
technique but this comes with some pros
and cons we now no longer have that
single point of failure we've eliminated
all of the blocking resources but the
eagle-eyed in the room would notice that
probably because we've declared our
other CSS as asynchronous that still has
to be loaded and we still have to apply
it to to be able to paint to the dom so
it causes a reflow and that's why it's
really really important that you
separate your truly critical everything
in that first viewport from the non
because if you were to have stuff that
within the top of the viewport inside
your known asynchronous stuff you're
going to cause reflow and actually have
a jarring user experience the most
important point to note here though is
we've made it not too cacheable by
aligning our CSS into the document every
time we change that CSS we're
essentially invalidating the cache for
all of our HTML files so if you can
imagine something like the FT com
that's a very large cache that we're
going to be in validating every time we
change some CSS and we don't benefit
from the browser caching that object and
then we're actually going to be sending
more bytes down the wire every time
which is completely unnecessary
it's also very hard to maintain a very
hard to automate inline CSS and I've
worked on some very large scale websites
and it's become a pain that we there's
no optimal
way of doing this so we've been able to
get our CSS down as soon as possible but
how can we then prioritize the delivery
of the other sub resources that our CSS
requires to achieve that time - first
meaningful paint I use the critical
resources for our page so I want to ask
you a question of can you think about
what are the critical resources that you
have on the website that you were
building yesterday or today even for
your customer or your company can you
think about those right now top of your
head the resources that if the networks
failed I only need these one two or
three resources to be able to deliver a
good user experience the rest of them
that adds code for the JavaScript that
can all be left behind have a think
about that so let's identify the
resources together for the ft.com page
is it a logo is it the custom web fonts
and we know that TTS MP has to use the
custom web fonts and actually we're
delivering the news the user needs to be
able to read it or is it the hero image
to give some context and a very sorry
here for the Theresa May photo bomb I'm
actually really annoyed with myself but
I've included her in this ditch doesn't
deserve it
so what how can we go about automating
the process of choosing these critical
resources fortunately again lighthouse
has got our back and they do this with
an audit that they call the critical
request change so here running ft.com
for lighthouse
we've identified a critical question of
five resources so you can do this even
though I just asked you to do that in
your head work out what your critical
resources are you can automate this
process and if I was to you were to take
away one thing from this talk today
please let it be this that you need to
be able to be optimizing this critical
request path eliminate every asset that
is in it that is not critical to the
core user experience of your website and
then optimize the remaining ones make
them as small as possible and prioritize
the delivery of those assets over the
network and that is how you will achieve
a very fast time to first meaningful
paint with your CSS so if we remember
the methodology for
meaning the times first meaningful paint
we also block on our metric waiting for
web fonts because they are delivering
the user experience after all and so
look how low down in our waterfall our
web font delivery is much much lower
than the CSS it's around the 20th
request now why is this if there's such
an important critical resource why is
the breyer browser prioritizing that
network request so low compared to some
of our imagery answer to do this we need
to take a look back at how browsers know
about painting again
first the browser discovers the H then
makes a network request for the HTML
document it begins pausing that document
it finds there discovers the CSS maybe
some JavaScript if you haven't declared
it as asynchronous then we have to CSS
can't unlike HTML can't be paused
incrementally ie we have to wait for all
of the bytes of CSS to come in before we
can construct the CSS object model and
there's a very good reason for this
because of the nature of the Cascade in
cascading style sheets that you might
have a style declaration down the bottom
of your file that is overwritten
something at the top and if we were to
part it incrementally and pink
incorrectly you might probably have some
stuff moving around so it's a very good
reason that CSS can't be parsley
incrementally you have to wait we can
get the CSS object model and these two
trees are joined together to form the
render tree and so it's exactly like the
Dom but it only contains the elements
that are going to be displayed on the
screen because you might have other
elements in your Dom that you've done
display:none on you've hidden them so
why does the browser need to try and
compute the layouts objects for those
when it's not going to paint them so the
render tree is actually what is used to
rasterize the page and send it and it's
only at this point why have I even gone
them on this own digression to tell you
this because it's only at this point
that the font files are found and the
networking for them is sense and that's
because you may have a whole block a
whole paragraph of text that have a font
that you've declared but you've
displayed none on that why should we go
and perform the networking for that
variant files by their pure nature
very expensive they sometimes megabytes
in size why should the browser perform
the networking for them if we're not
going to display them and so it's this
reason that the browser doesn't perform
networking for front until the render
tree is constructed but you'll notice
here though we've wasted an extremely
large amount of time waiting for that
period so what if we were able to hint
to the browser these are my critical
resources you're not going to find them
for ages because they are hidden sub
resource with inside the render tree but
I know as the author they are extremely
important so if you imagine the five
resources that lighthouse identified for
ft.com they're the things that we should
be hinting to the browser and so
fortunately the web performance working
group have defined a new API called
preload which allows us as the authors
of the page to indicate to the browser
the critical or safe hidden resources so
it can then prioritize a networking for
them so to put simply it provides a
derrick declarative fetch primitive that
initiates an early fetch this is the
most important bit separating fetch from
resource execution so I can now say go
and download this javascript file but
don't execute it because that would
probably be bad but perform the
networking for it because it's extremely
important delivery of my good user
experience so this is what it looks like
we now have three new primitives in HTML
at the top via the link element with a
rel preload attribute I think this is
extremely powerful we can do it
dynamically with JavaScript so you can
imagine if a user is hovering over a
button to open up a carousel with images
at that point as they hover you can
inject link preload elements to preload
all of the images so when they do click
on it you're going to have a
lightning-fast experience and finally my
favorite which is the preload link
header that often forgotten HTTP header
we can declare link elements essentially
but as headers so here with a HTTP
header on the response of our HTML file
we're telling the browser that go and
preload this CSS file is extremely
important and so going back to our
experiment on ftom we identified those
five resources so we're now going to set
the link preload header on the response
of the HTML and hit note here there's
two interesting points to note here that
fonts have to be declared as cross
origin even if they're on the same
origin or hosts because some genius
person many years ago deemed that all
fonts should be treated as crossed
origin for security purposes and the
important thing is the no push attribute
here I just want you to remember that
for later on so okay so we've applied
these linked headers what impact does
this have on our times first meaningful
paint so this is our waterfall before we
apply them remember the how the fonts
are so lowdown because they're not
discovered until the render tree
construction and by applying the link
headers we've been able to tell the
browser these are my critical resources
and we've instantly shifted them up so
hopefully you're now beginning to
understand what impact is going to have
on our time too first meaningful paint
that's given us a 64 percent improvement
on our baseline now we've hit our budget
for cable over thousand milliseconds and
we're very very close now on 3G on an
emerging market connection so again this
comes of some pros and cons it gives us
a way of indicating the hidden resources
we can now dictate the priority by order
sorry that's a very important thing to
note is that the order of these headers
also dictates their priority in which
the browser will perform the networking
for them so does their relation of style
and font and the con here though is very
easy to create contention on the network
with great power comes great
responsibility if you were just to set a
preload header for every single asset on
your page you're actually not allowing
the browser to do what it's very good at
doing using its preload scanner or
speculative posture to go and find and
prioritize assets so only use this
technique for your critical resources
that you've identified so we could just
stop there right we've improved our TTS
MP by 64 percent but surely we can do
more and this is where HTTP 2 new
feature could serve a push come
to play but it is now over 20 years it's
the first time in over 20 years that we
have a new version of the underlying
transfer protocol of the internet called
HSB 2 and I could literally do a whole
talk just on H 2 and push in itself and
but I don't have the time to the up for
one but I urge you to go and check it
out and the question on rely class who
is using HP 2 in production ok so it's
about 30% of the room from looks things
which is bit lower than I was hoping but
that's still very good so to understand
well that was a bit weird I've broken an
animation so and to understand what push
does let's look at again how your
average web page is constructed first we
make the get request to the index file
the server responds with the response
for that index file we pause the
document we find the link element we go
and make the request for the CSS file
and the server response of that but what
if we the server knows as the authors of
the website we know that the next item
or sorry resource that the client is
going to request is that CSS file
because we know it has the highest
priorities so what as an author we could
dictate to the client I am going to push
you these with the CSS file you don't
need to request it and this is where the
push promise frame comes in so it's a
data payload on a HTTP 2 connection that
the server says I am going to send you
the bytes for the CSS file you don't
need to request this then we can push
the index file and push the CSS down so
we're eliminating the round-trip
completely to request that CSS file so
now we can do this with h2
programmatically using our friend the
link preload header here this is the
semantics that we've decided upon as an
industry so now if going back to our SD
comm example we can remove our inline
CSS now and we can declare it just as a
normal style sheet that declared the
secondary the non-critical CSS is
asynchronous using preload and then tell
our hb2 server you have to have a h2
server enabled for this behavior to work
that I want you to push the critical CSS
and how we're doing that it's just we've
removed that no
push directive that I told you to
remember about earlier on so hex to
server will see this response it would
say right that author wants me to push
all of these resources and it will push
the critical CSS bytes down so let's
take a closer look at what's actually
happening on the network before we apply
this optimization and note that we have
idle time before we get our HTML bytes
that's when the browser has made the
request but we're waiting for the server
to respond of it at the beginning then
we have a very fast start render because
we've in lined our critical CSS then the
browser has some think time again it
then requests the main CSS file and
there's our x first meaningful paint now
then what you're going to think is going
to happen here but you may be a little
bit surprised as the impact of pushing
our critical CSS says removing it from
inline and pushing it we've actually had
a negative impact on the x first
meaningful paint and why is this we're
not using the idle time at the beginning
of the connection and to understand why
this is we have to have a bit of better
understanding what's actually happening
on the HTTP 2 server here HT servers use
a prioritization tree to determine which
the order of which the packets is going
to send down the connection and even
though we told our Haiti to server to
push the CSS via our link header because
we actually did it on the response of
the HTML document the server had all of
the HTML and HTML has a much higher
priority than CSS does so of course it's
going to flush all of the HTML bytes
down the connection before it did our
critical CSS even though actually what
we wanted it to do is flush the CSS in
our idle time whilst we were waiting for
our HTML connection and I must stress
here that this behavior is slightly
different depending on your HDTV server
implementation but all of the major h2
service at the moment prioritize and
quite rightly prioritized HTML over CSS
on the connection and so this is the
impact it has on our waterfall now it's
really interesting thing here to note is
the critical CSS doesn't have a light
green segment beforehand because it
didn't need to send the request and
therefore was there was no waiting for
it so this is the benefit that we get
from push is that we're reducing the
idler time from the request to the
response but it's we're not getting our
CSS delivered at the point that we want
it to in the light blue area of our HTML
and it's also important to note if you
weren't in lining your CSS and many of
you probably aren't this is still quite
a very good technique because you are
saving that that request time so we've
had a negative impact on our time to
first meaningful paint here only 43
percent improvement on our baseline
we've gone back to 5,000 milliseconds so
the question I'm asking is should we be
using server push at all actually we're
having a negative impact and most
importantly is using the link header
with a rel preload actually much too
late in the connection state for us to
indicate the CSS that we want you to
push and so how can we actually achieve
that holy grail of pushing our critical
CSS only in the server idle time and
this is what firstly at fastly sorry
we're calling async push so let's look
at that network utilization again from
my experiment and note at the beginning
we have that idle time waiting for the
server to respond it's probably
performing the templating going and
requesting your user data from your
database is that this server think time
that we want to be using to be pushing
our static assets and so a much more
common architecture that probably many
in the you in the room are using is that
you have your application server is
actually separate from your HTTP server
think you probably use nginx or Apache
you might use a CDN for instance and so
this is the request flow that the index
file goes through and then we get
response and what if that server was
able during an application think time
was able to push the critical resource
at that time this is the think time that
we want to be using so here's an example
of doing that using an Express style
request handler using HC and knows HTTP
- implementation the important point to
note here is not the implementation of
but what we're doing at the beginning of
the request the first thing we're doing
is flushing our critical CSS via push
down the network connection
then we go and do our templating and
fetching from our rendering and then we
respond with our link headers and this
is how we can utilize that idle
connection time and so what happens to
our connection state here now is we've
we've reached the holy grail we've been
able to push our critical CSS in the
light blue area whilst the server is
still thinking we've given the browser
everything it needs way before it even
gets any HTML to style and paint your
entire document so now we have a 65%
improvement on our baseline we've
reached that holy grail so this comes of
some pros and some cons obviously that
we're using that idle time but it's very
easy to create contention with push and
there's limited availability of this
because you have to have access to the
network connection within your server to
be able to do this and hopefully many of
the room thinking but what about the
repeat view every one of our tests has
been the first view the uncashed the
browser doesn't have anything cached and
that's what we should be optimizing for
for our time first meaningful paint but
with push if I was the user was then to
visit the next page on my website and I
was going to push those bytes we've
actually the browser's probably got that
asset cached already but we've got no
way of indicating to the server that we
have that CSS so please don't push it to
me and I did want to show you how to do
this using new technology such as
serviceworkers and the purple pattern
but unfortunately I've ran out of time
today but the good news is adios money
is from Google is going to be talking
exactly about these types of patterns
and how you can optimize for time to add
interactivity on your repeats view at
jazzpunk for this weekend so let's look
at the final results and I think it's
better to show you to them as how the
user is perceiving this now with our
async push example down the bottom all
the way up to the baseline we've been
able to improve the delivery on a 3G
emerging-market connection by over 3,000
milliseconds which is staggering
improvement for our performance
okay so finally I just wanted to leave
you with some glimpse of what the future
is happening we've now got strong
toolbox of AP is preload HTTP push and
inlining but there's still some issues
of each of those that I outlined the
biggest weakness of server push as we
mentioned is that by indicating that
push via link preload header is that
that initiation of the push is much too
late in the network connection and we
end up in just in the network and this
is where my colleague Kazuo firstly we
now have a working draft in the ITF of
the 103 early hint status code the 100
range a lot of people didn't even know
existed it's the information status code
range and we can now have this pattern
where the client requested something
from the server and whilst the server is
generating the response it can flush an
early hint response containing link
headers to all of your critical sub
resources and then the browser can go
and prioritize the networking for them
and finally the cache digest
specification remember I mentioned that
the repeat view of push we have no way
of indicating to the browser what we
have in a cache for our CSS for that
domain and so now on a h2 connection the
client is going to be able to send via
cache digest frame or a header all of
the files that it has for that host name
and then the server can decide ok I'm
not going to send you that CSS file
because I know you already have it in
its cache and I think this in itself is
going to be one of the most powerful
performance optimizations in the future
of the next five years as it gets
implemented in browsers so that's been a
whirlwind tour I've gone five minutes
over my slots
I'm very sorry my lovely CSS conference
organizers so I just wanted to leave you
for the last points and takeaways and
that is that hopefully you found that
resource loading in the browser is hard
it's much harder than you probably
thought it was bandwidth is often
underutilized but we have technologies
now emerging to enable us to give that
utilization to the browser identify your
critical resources and your request
chains use preload to indicate those
critical resources to the browser
especially your fonts if you're using
custom web fonts and push your critical
CSS but only in first view and please
try and only used within that idle
connection time but most importantly
always be testing it's the most
important thing to leave you with thank
you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>