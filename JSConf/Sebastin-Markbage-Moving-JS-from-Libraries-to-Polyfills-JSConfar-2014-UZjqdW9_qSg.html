<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Sebastián Markbage: Moving JS from Libraries to Polyfills | JSConf.ar 2014 | Coder Coacher - Coaching Coders</title><meta content="Sebastián Markbage: Moving JS from Libraries to Polyfills | JSConf.ar 2014 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Sebastián Markbage: Moving JS from Libraries to Polyfills | JSConf.ar 2014</b></h2><h5 class="post__date">2015-05-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UZjqdW9_qSg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you I'm sure it's fine
I like to start off with a question is
does anyone have a favorite utility
library like low dash or jQuery or
something like that we use this lodash
underscore knockout that's cool is it
great that we have this community that
we can use all these different features
and different libraries we want to and
nobody can tell us that we can't do it
and there's like no single company that
controls our community except do we
really need this many ways to iterate
over an ordinary do you even know all
the ways to filter in the array and
underscore is it the same exact version
in lodash or is it I think it's slightly
different depending on which version
you're using do you even know all the
JavaScript standard library functions
what about the ones in he is six I don't
think Brendan even knows all that wants
to make six pretty sure let alone all
the libraries on top of it it's not that
a library is too big it's pretty cool
every library is pretty cool it is it
has a nice feature size extensions the
problem is that we have a lot of them
and each one has a lot of different
functions and a total amount of AP is
that you have to learn to be productive
in this industry is huge it's way too
much to learn so what happens when you
get a new team member coming out to your
team how many special utility calls to
be able to find in your code base and
how much ramp up time didn't need to
figure out what's actually going on
there so why do we actually use
javascript to begin with it's not the
best language in the world there's
regardless of what style you prefer
there's at least one language that's
better that can compile to JavaScript
except javascript is everywhere this is
why we're using it it's at least
something that a lot of people could
agree on
an art industry needs a baseline to
build on top so javascript is one of
those bass lines so we can build on top
of and using a standard comes with a lot
of benefits the right information is
accessible tooling people to hire and so
on so by introducing divergence in the
library community we're actually
undermining what makes JavaScript great
we're already created in environments
where you can't hire a JavaScript
generalist anymore you have to hire a
JavaScript specialist and a specific
library at Facebook we have a very
simple story we use JavaScript standard
library there's one way to do things and
it's the standard way they don't have an
underscore we don't have utility
libraries and avoids a very simple
problem bike shedding it's the biggest
waste of time of all we still have to do
that but we keep that to the standards
mailing lists and most of it is
arbitrary anyways it doesn't really
matter that much so why is the industry
still using so many JavaScript libraries
well this standard library is pretty
small and it doesn't have all the
features that you may want but many
times the answer is just write a little
bit more boilerplate code it takes you a
few seconds longer you don't take on a
dependency the person coming to fix your
code later after your left or if they're
busy in a meeting they don't have to
learn some obscure functions or twenty
other versions of the same functions
that someone else bought was slightly
better than this one one of the best
lessons that I've learned that Facebook
is that no abstraction can actually be
better than a prong extraction and
especially since abstractions build on
top of each other they're difficult to
unwind so proving that a general
abstraction is worthwhile can actually
be quite difficult and teaching it to in
our entire industry is even more
difficult it takes time and this is
where the reason why standards are slow
you may want JavaScript to copy feature
from
language but once you look at a lot of
different languages is not really clear
which one is the best one now you have
to figure out which one is the best one
because picking the wrong one is highly
risky because our entire industry will
have to figure that out but there are
some features to a language that are
really powerful and we really need them
and we really need them as soon as
possible the problem is that even after
there's agreement on the value of this
specific feature there's still a long
process before it's actually implemented
in browsers so this is proposal their
standardization initial implementation
mainstream browser support and then the
long tail of browsers right and once the
browser implements it it's too late to
take it back so engines actually
optimize for correctness and
compatibility before speed performance
or early implementations that's why the
employability looks like this because
for browsers is way too risky to
implement something way too early but
that's not really what adoption curve
looks like because third party libraries
don't have this restriction they get
adopted before the standards in the
provoke post the industry has already
learned them by the time there is a
standard and at the end of the curve we
have support for new language features
but by the time the new language feature
occurs and it's available there's
already ten libraries that have the same
feature and now you have to learn to
those ten libraries plus another
language feature this is the point when
people are starting to have a strong
reaction against standards because they
already have the feature they already
have the possibility to do this and I
don't want to learn at one more thing at
Facebook it looks something like this we
use small experimental libraries we roll
it up slowly unless you really need it
you're not going to use it too much and
when there's a standard proposal we
quickly roll off our
experimental libraries and use polyfills
instead even before the standard is
filing so most developers won't actually
see these ten different things of doing
things they will jump straight on to the
standards version and I'd like to see
this happening more in our industry as a
whole so why aren't you all using just
poly feels so it's not that easy
actually there's a few problems with it
the primary problem of adopting too
early is that the standards actually
change a lot during the process and poly
fills was differed slightly in various
ways libraries have these problems as
well within consistencies between
versions so often you'll never never
actually noticed this but it does become
a problem when you have a third party
code that depend on the changing
standard and the various versions of
polyfills and one of the reasons this is
a problem is because most built-ins are
only global object or in the prototype
you can only have really realistically
you can only really have one version at
a time and different libraries may
depend on different edge cases that
can't be used together so if they go
unfixed for a long time which they
actually do unfortunately a lot of
polyfills more and more code starts
relying on a particular version of a
polyfill so it's very important for its
Paula feels to stay up to date but also
the code that uses them to stay up to
date but you can package multiple
versions the Varden scores with your
apps it's not ideal but you can it's
much more difficult with a polyfill
another issue which is similar to the
one which brought up earlier is that
some people like to discourage polyfills
because they might actually break the
spec and i'll explain what happened with
string contains so this was another era
long before es5 in the new wave of
standards it was before Guillermo had
facial hair
where are you so gear when I was working
on a framework called mootools at the
time so muches was extending the
building prototypes with some extra
helper functions and we did it this way
we checked if there was at existing
function and if there wasn't we
introduced our own one so what happens
when the browser's try to implement this
feature the new version comes in and it
replaces the Muto's version which means
that the website that relies on the
Muto's behavior breaks so luckily we're
learned our lesson with mootools 1.3 so
instead of overriding them conditionally
we unconditionally override any built-in
version except the built-in version has
a new mobility flag set to false which
means that you can't loop over the
property to find it so what happens with
a second statement it no longer copies
the object if the browser ever
implements this feature so this is
actually the reason why the browsers
refuse to implement this so they're both
fixed in newer versions of mootools but
mucosal is a popular library back then
and a lot of websites have deployed this
version so we I guess we could just
break them except nobody is working on
them anymore there's no consultants
working on these websites so if a
browser introduces this feature it will
break the website and people will start
using another browser so whoever browser
is the first one it's going to lose out
and this is the classic browser game
theory problem no browser wants to be
the first one because they will lose
customers so this is why a bad polyfill
could potentially risk breaking the web
and actually breaking the future
standards that are trying to polyfill
however this is not just a problem with
coded mutates the prototype I've found
this this we can react we actually check
that the string object doesn't have a
key property so if a browser ever
implements the key property on the
string they might break old versions of
react and I picked two examples from
libraries that I've been involved with
but I'm not the only one doing this only
one screwing up this is pretty easy
mistakes to make but as you can see it's
not just if you try to change prototypes
it happens in libraries all the time and
we just renamed pertains to includes
it's not a big deal our suspects will
have to find a way to work around this
it's not a reason to not to you to avoid
using polyfills there's a common
misunderstanding that native functions
are always faster than the polyfills or
library features that's not true so
naive polyfills tend to use the native
implementation if it's available but
then you can end up with the same
problem that Muto's did right if the
spec actually changes then people using
your polyfill might actually break this
back and additionally early
implementations are often really very
slow they're not optimized for speed yet
they're optimized for correctness
because it's high risk for a browser to
introducing a feature so you have to
make it correct so the solution is to
simply just always override the native
implementation until way into the long
tail of browser support
so for new syntax is general solution is
to compile your modern code down to an
older version you're not modifying the
runtime so you don't really suffer from
the same versioning problem and you can
ship different versions of pre compiled
code however transpiring tools I mean
they're great they're they're efficient
than the this setup is fairly easy
however people have a very strong
reaction to that extra compilation step
people don't like compilation for
production it doesn't really matter that
much to be honest like you have a mini
fire in packager anyway so plugging in a
compiler in your pipeline isn't that big
of deal if it's fast enough and the
Facebook we're working very hard on
making these tools fast enough however
looking at the long tail of the jse
ecosystem support for new language
features is actually pretty bad but this
is strictly a tooling problem that we
can solve if you use the well supported
and frequently updated parser than
linters will work with that and what
happens is that these tools tend to die
off when they don't support the new
features they get replaced by other ones
anyway and compilation isn't really an
inherence problem to to this transpire
situation browsers could have
first-class support for trailers or you
can make it browser extension to do it
or you can make a operating system
extension that makes it easy to just
open any file and have a chance pilot
completion happens anyway in the browser
it it happens within the runtime on the
fly so why shouldn't be able to do that
on the fly with a client side to a
spider as well one problem with the
currents which is that there's way too
many options out there having too many
options can actually be a bad thing
getting the polo fields right it's very
difficult and various polyfills depend
on each other's and when they overlap
they might not be compatible with it
other in slightly different ways so I
would recommend using like a full
end-to-end solution and it's not having
too many choices not actually a good
thing in this regard because people
avoid using polyfills because is so
difficult to set up so you actually want
something that is easy and we're just
works out of the box policy tools as a
service is one of these new easy
phenomenons it only really works on
runtime follicles it's pretty easy good
to get started there's still kind of a
lot of configuration options but there's
also a single point of failure which
means that if the CDN updates or goes
down in the future in the long term then
you might break the website and that's
that may seem like a bad thing and for
your clients this probably is but for
the rest of us is actually a good thing
because you can't accidentally break the
future of the web it's the right spirit
that like I've enumerated a lot of
problems here and there all solvable we
just need to start building a cohesive
story around public wheels and buy into
it from the end-to-end stack some people
think the polyfills is a temporary hack
that we don't really have to focus on
it's something that we use now to to get
rid of older browsers eventually but we
won't as long as the web is evolving
it's not an ad hoc hack it needs to be a
natural part of all of our tools chain
and if your tool chain doesn't support
the bleeding edge polyfills entrance
filers it might actually be left behind
so all the major UI frameworks have
announced intentions to design their new
versions or new features with es7 in
mind naughty s6 s7 and this is because
all the new frameworks buy into this
story of having polyfills and and
adopting new standards very early
another faint is showing up there's all
these new type systems making the right
into JavaScript they all have special
annotations and if you want to use the
type annotations you still need some
kind of compile step to strip them out
because they will realistically not be
standardized anytime soon it will take a
long time to standardize these type
systems because this the tc39 doesn't
want to standardize an incomplete type
system they want a complete solution
standardized which means that these
limitations will live on for a long time
without supporting the browser's ideally
we don't want to end up in this
situation where every framework has its
own language and depends on a certain
segment of transpires and polyfills it's
natural that every framework cares
little bit more about certain features
than other features so they will try to
jump on a particular transpiler
particular polyfill but this is a
configuration problem that doesn't
affect most developers then in their
day-to-day life but it's everyone's
responsibility to sort of cooperate and
try to move towards a unified JavaScript
so we avoid the situation with the
virgin libraries but using just
JavaScript doesn't matter necessarily
mean that you have to use all of it so
JavaScript already has a very large
surface area and if we want to add more
features to it we need to remove
something so that we can learn any
features and the new people coming into
our industry doesn't have to learn all
the legacy that comes with along with it
so linters strictmode vm optimizations
they all discourage certain behavior
certain JavaScript features they can
never be removed and unsupported but
they can be removed from our industry's
mental surface area in the sense that
you don't really have to know them to be
productive in our industry so don't use
the crazy parts of JavaScript just
because we can and hopefully we can get
to a adoption rate that looks something
like this thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>