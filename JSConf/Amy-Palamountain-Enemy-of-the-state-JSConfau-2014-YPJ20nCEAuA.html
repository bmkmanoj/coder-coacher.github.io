<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Amy Palamountain: Enemy of the state | JSConf.au 2014 | Coder Coacher - Coaching Coders</title><meta content="Amy Palamountain: Enemy of the state | JSConf.au 2014 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Amy Palamountain: Enemy of the state | JSConf.au 2014</b></h2><h5 class="post__date">2015-01-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YPJ20nCEAuA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so now that we're all friends and see me
little round of my machine I'm just
going to cut right to the chase and kind
of be a bit straight up I think building
and front-end JavaScript applications is
pretty damn hard and I think there are a
bunch of factors that contribute to this
and one of those factors is that they're
just giant balls or state which is what
Pete was talking about so I thought
would be kind of interesting to take a
bit of a step back and and maybe play
the devil's advocate and take a critical
look at some of the patterns that we see
being applied on front-end JavaScript
code bases and see if they give us ways
of handling state and events in a
scalable and maintainable fashion and
then maybe we'll take a look at some of
the tactics that we can use to help us
better embrace state and events without
sacrificing clarity in our architecture
so I'll just introduce myself that's not
me I'm Amy I've come from New Zealand if
you're ever in Wellington and you want
to hang out just give me a shout on
twitter i'm a meep and it's jared see
that i work at github I'm if you want
some stickers my buddy Marcus's down
front he's got a whole pile of them
direct all of your attention that way um
I've also got a tiny confession I don't
write any JavaScript yet github I build
the github windows clients I'm a windows
developer I'm actually pretty new to
github and before that I was writing a
whole ton of JavaScript building epson
and backbone so in terms of architecture
front end-front end apps to have
actually quite a bit in common with
desktop applications and the thing that
ties them together is that they have
heaps and heaps of state so front-end
javascript ads contain lots of different
kinds of state they've got the state of
the court entities are models they've
got that state that needs to be kept in
sync with the server we've got the state
of the address bar we've got the state
of all the different views that are
presenting various bits of information
on the screen at any given point in time
and then we've got the overall state of
our application memory management all of
those kinds of things so on its own
state isn't very interesting what makes
an application interesting is the
interaction with that stage so we're
able to interact with the state and
force new transitions new states on the
system in some
we have something that's way more
compelling so traditionally state
transitions are going to occur by our
events so for example you've got some
data on the screen at xbox somebody into
some information they click Save the
model gets updated and we transition
into a new state it might be an invalid
state so the thing about these
heavy-duty thick client JavaScript apps
is that basically this brought these
blobs of code that kind of just sit
there and wait for interesting things to
happen and we have a bunch of ways that
we can make interesting things happens
we've got Dom events which I like click
drag k out there's a whole pile of them
and we've got model events so that might
be when we transition into that invalid
state our model might raise a signal to
say hey I'm actually in a valid state
and people who are interested in that
and we subscribe to those events we've
also got router events so these are kept
off when the address bar changes and we
need to do interesting things to the
overall view state of our application so
we've got lots of steak and we've got
lots of means and they all need to be
managed and if we don't manage them in a
way that kind of accurately separates
all of the concerns out and state and
events they're going to get really tough
to manage so I've got a really contrived
example here of estate and events being
managed in a pretty sub optimal way so
we've got a view it's a part of you
there's a there's a there's just one
lone party animal at the party party dog
and we're going to have an invitation
list as well so here we can input a new
enemy Warner right to the invite to the
party and we've got a button with an
onclick handler shout out awesome so
don't please don't do this and so when
somebody clicks that button to invite
the animal we're going to use jQuery to
reach into the dome to grab the state of
the textbox we're going to pull that bit
of information out we're going to invite
it and more to the party we're going to
build up a new view we're going to reach
back into the Brahman and put that in
there we're doing a whole pile of like
just it's spaghetti code basically so if
you're going to extrapolate that kind of
code to its natural conclusion it's it's
easy to see that we've got a state and
state changes state and state
transitions being intertwined and we're
very quickly going to end up with an
unmaintained codebase so the more state
you have the harder it is to manipulate
state and then
the trickier it all becomes to manage
and so this is where people are going
hey we've got design patterns and that's
awesome we totally do they've come to
save our souls so the thing that I think
find really interesting about design
patterns is I contrast what's going on
in like the physical world of
engineering to what's going on in the
software and world of engineering like
physical engineers are going to build
buildings like this and they have a
specific way that they need to construct
the building so that it doesn't kind of
collapse and kill everybody inside and
they're going to need to do that
regardless of the outcome of the
building whether it's going to be a meat
market or whatever but in software we we
kind of had these these loser ideas that
we can apply in very different contexts
so I mean I guess was me not bound by
the laws of physics to a point so it's
interesting because it means that we can
take patterns that have been applied and
very very different contexts and start
applying them to help us solve
interesting problems and new contexts
and it means those ideas kind of evolve
a little bit like memes on the internet
right like mean actually means anything
that's spread or inherited in an on
genetic fashion which basically means
memes or ideas so their ideas it stuck
because they're funny or because
everyone thinks that they contain an
interesting solution to a tricky problem
and I think that in v-star the MV star
family of patents is an example of this
so originally presentation patterns that
fall under this category they actually
originated from building desktop clients
and then over time web and web server
programming became really popular and
these presentation patterns were applied
in that context so we end up with web
server frameworks like rails which
implementations of MVC and then we've
got these kick-ass front-end JavaScript
frameworks which are also claiming to be
implementations of an MVC pattern and I
really don't want to turn this into a
conversation about like who's doing in
bc by the book because that's not
particularly interesting but what is
interesting is to take a look at how
each of those flavors are being applied
in the different contexts and how they
affect how we manage state and how we
manage state transitions so I'm going to
take a quick look at how we manage state
and the web server environment so
hopefully some of this is going
mostly a reminder so we've got models
they are the guts of our application
it's where all the interesting domain
logic is going to occur we've got views
and though the presentation of that of
those models and typically this is going
to be like a JSON document or an HTML
document so the interesting thing about
views in this context is that they are a
snapshot of the models current state and
then we have controllers which are
responsible for sending commands down to
the model maybe they will transition the
model into a new state mr. step back
maybe just query it and then they're
going to return a snapshot of that
current state a representation of that
current state and then we have routers
so they are responsible for doing some
pattern matching of an incoming web
request routing that off to a designated
designated controller and then to an
action which is the action selection is
normally done with a combination of the
URL that's come in and the HTTP verb
that's being used so how does this
relate to how state as miniature on the
web server environment or hopefully
you're going what are you talking about
we don't have state on the web server
environment we want to be stateless
because we want to be able to scalar
applications so how are we achieving the
stainless pneus while we persisting our
models to a data store of some kind and
so in this environment where state is
persisted to a data store and we're able
to address that state via HTTP like we
can say HTTP get me all the animals at
the party and then if we find out one of
the animals is causing a bit of a
commotion and we want to kick them out
we can just execute an HTTP HTTP delete
against that same resource so what we've
essentially done here is we've simulated
a state transition across the HTTP
boundary across the client-server
boundary and what that means is all
states and all state transitions are
necessarily addressable via HTTP so
quick example we've got a couple of
routes here that we're defining against
the same party resource get post and
delete the get example is going to take
the incoming perimeter it's going to go
to the data store and find the
particular animal and return a snapshot
of that current state we're going to add
an animal to the party we're going to
grab that and come with parameter again
we're going to modify the state persist
it down to the data store and then rich
a new snapshot of the pub the parties
are state with an extra attendee and the
same goes for the delete when we want to
kick somebody out we're going to modify
the state of the party persist that back
to the data store and then return a new
snapshot so routers are matching a web
request pattern it's handing it off to a
controller and invoking an action who's
going to do a model look out in an
update and return a snapshot of the new
view so because of that client-server
boundary all of the states and all of
our interesting events are addressable
via HTTP and the way that we use rounds
means that our architecture is very
linear so requests come in something may
or may not happen to change the model
state and a snapshot has returned so
we've gone down the stack and up the
stack again so the key difference for
the way that we implement MVC on the
server and the way that we're going to
implement NBC on the client is that the
implementation on the client has a lot
of state we don't need to try super hard
to be stateless anymore in fact we want
to embrace stage so we're keeping a
bunch of things in memory here to form a
cohesive application and it all comes
together to form a very rich and non
linear state-space we've got our models
they usually coupled with a snapshot
that's coming back from a server that
JSON document that might come back and
then we add an extra layer of complexity
on top of that we've got validation
security we are playing new behaviors
through other functions we've got to
decide when we keep that state and sync
with the server so we're keeping that in
mind at all times the number of possible
states that we've just put on top of
that snapshot has just has blown out
proportionally on the screen at any one
time we've got many different views that
are each presenting different model
states and together those views to find
the overall view state so what many
items can we see in the sidebar like are
we able to eat it the that the Palean
kick somebody out are we able to invite
a new animal to the party and are we
even able to see what's going on the
shenanigans going on inside this party
so this is adding again to the
complexity that we have in the state
space
and with overall we've got the overall
application state as well so this is
things like which models which modules
and controllers are currently active and
which ones are no longer active and
should be cleaned up in order to free up
that memory that we hogging and of
course that state our state boundary
that we had on the server that client
super boundary is no longer relevant
suddenly we don't have to emulate state
transitions across a boundary state and
the transitions occur within the same
execution context which is awesome
because it means we have a much much
richer set of concepts if we can
architect a replication around so as the
state space grows and we're moving
around the state space in a very
nonlinear fashion things get complicated
really really quickly it has a
dimensionality to the problem which
makes managing all of this really really
tricky so we need to have a plan we need
to apply some memes some ideas some
patterns to help us out here and not end
up in a spaghetti code soup so we
originally brought over these
presentation patterns onto the client to
help us deal with complexity the
complexity that we saw on the client
we've got models we've got our views in
our controllers these concepts that we
were saw on the server I mean whatever
you want to call that controller part
I'm I have weird feelings about that
name and then we've got routes okay and
we add those to the equations so that we
can so that we can address parts of our
state space so I look at this and I
think this is a little weird like why do
we have right routes here like on the
server the the purpose that they served
was that we needed to be able to address
all the transitions and all the states
and here we don't really need to do that
and then I remember okay it's actually
not weird at all because we still need
to be able to address parts of that
state space we absolutely need to be
able to take the URL in the address bar
and give that to your friend and have
them see exactly the same state on the
the web page so address ability and the
support of routes are still a really key
part of our of our design
so let's take a little look at the
typical way that we might structure some
of our client side code to account for
the need to be able to address all parts
of the state space so I'm going to give
this example in backbone so we've got an
animal and a collection of partying
animals we've got a party view which has
a template and a render function and
what it's going to do is it's going to
take the template it's going to take the
model and it's going to mash them
together expect something out onto the
view and then we've got our router and
we're defining a couple of routes here
we can start the party and and turn the
music on and let them go and we can also
uninvite any misbehavior people so we're
going to revoke party rights what we're
doing here is we're taking an incoming
parameter from the URL we're grabbing
that collection we are finding the
animal in the collection we're
destroying the model and we're reaching
back into the into the Dom to remove the
view and in the starting the party case
it's very similar we're creating we're
creating of you doing a fish and a
render so what's going on here we're
breaking encapsulation to push
everything up into the Russian portion
of our code so we've got this view
controller thing that's responsible for
doing some initial rendering and then
when it's got a reference to our model
and then the round kicks off and the
first thing that it does it does an
active look up for the model so we've
got these stateful concepts where our
view already has a reference to the
model but we're going to grab the
collection and do look up anywhere okay
that's fine and then we're going to
perform an extra the hints that model
and we're going to transition it into a
new state and then the next thing we
need to do is deal with some view
concerns by ie we need to remove that
few from from the screen so again we're
breaking encapsulation here the view
controller thing already has a reference
to the Dom element why are we creating
the spaghetti code in the router why
wouldn't we just let the view be in
charge over time that's going to become
very difficult to maintain over time so
on the client side we're often working
with these heavily stateful frameworks
and all the objects that we need in
order to perform a state transition that
already instantiated and already held in
memory we don't need to structure
application in the same way as we were
on the server because on the client we
can fully embrace stayed we don't need
to manipulate our models like they arose
in a database a models can be rich
interactive real objects so we took
these ideas these flavors of MVC that we
saw on the server and we try to apply
that very linear approach to the client
and we started to break encapsulation
pretty quickly an order 200 application
around the design and and the need to
support routes we started to treat state
and events and the very things that give
us that rich interactivity on the client
side we started to treat that like a
second-class citizen at the side of the
talk I showed you that or fall jQuery
madness we were doing weird things like
triggering events from the DOM and then
I reaching into the Dom to grab the
state and then persisting that state
back into the diamond it was all kind of
crazy we were executing that state
transition to update the DOM and show
the new state and that code doesn't
scale very well beyond a very simple use
case and the reason is because it breaks
encapsulation and I kind of feel like
we're back at this again we're using
routes heavily because they're
convenient but in doing this we're
sacrificing clarity in our architecture
so to build accessible single page
JavaScript apps we still need to use
rounds and it's critical that we're able
to address portions of the state space
but in my mind routes are a feature
they're not the cornerstone of our
architecture the cornerstone of our
design and architecture should really be
concerned with state and events so I
routes the problem here I don't I don't
think right so the problem here I think
the thing that's causing us pain is only
using routes as the part of the
architecture breaking that encapsulation
of the views and the models in order to
get it done as quickly as possible it's
not giving us a way to scale a design so
separating concerns as we've seen is
super important we've implemented that
NBC design pattern on the client and the
first place to get rid of all that
tangled mess but somewhere in the course
of that doing that with two closely
emulated the designs that we see
on the server the things that work
really well for stateless with
applications and as the complexity grows
in our various state full application we
start to see the cracks and that
approach so thankfully I think we can
find a happy medium where we can embrace
the need for routes on the client
without relying on them to drive state
and state changes within our application
we can use events in a composable
architecture to help us separate out our
concerns so let's first take a look at
the bloated router code example that I
gave hopefully it's starting to start to
be apparent that addressing a state
transition like a delete is probably not
the best thing to do in this case so
we've still got our models we've got our
animal model and our party animal
collection we've got a party animal view
which as before has a template but now
it has an event hash which is cool
because it means that this view is now
listening for click events on a link and
it's going to write that down to a
delete function that delete function is
able to say hey I'm just going to delete
the model that I have a reference to and
then I'm going to close myself which is
so much more simpler than looking up a
model and look reaching into the DOM and
removing this debt from from the Dom
it's kind of the concerns are way more
way more encapsulated in this case so as
I say we don't need to do that
unnecessary look up anymore we're also
using declarative events so we combine
the delete link to the delete the delete
function on the view and it allows us to
call destroy on the model directly which
is a huge one and for bonus points we
live interview take care of itself so
that's fine but I said earlier that
routing is still a key part of the
client-side code and we need to support
this feature of addressability and some
of the state space our application is
going to suck if we don't do this we
need to be able to give those URLs to
our friends so that they can arrive at
the same state that we did so how can we
better embrace the need for an event
rich envy whatever you want to call it
pattern and the need for routes in a
clear architecture so I just want to
show you a couple of ideas
it means and you guys can apply them in
whichever way you choose as appropriate
so we're going to take those models
those rich objects those views which are
responsible for rendering templates and
then the views mediating any interaction
between the template and sorry the DOM
and translating that back down to the
model and we've got a controller object
which is responsible for keeping track
of those models and views and we're
going to take all of those and we're
going to put them into a single
component logical component and module
so module was responsible for
coordinating all of the state and events
that we have at a very micro level so
we're not talking a one-to-one
relationship here we're talking about
many views mini models all aggregated
within a module because they are related
to each other on some level of
functionality so it's a discrete area of
a discrete functional unit I guess you
could say so those modules are free to
present views and raise events within
themselves and keep track of their own
internal state so just to briefly note
that while these models are kind of
motor sonic not models modules are free
to present their views I don't think
they should be directly free to start
placing themselves on the Dom because
then your coupling those modules to the
state of the Dom at any given time so
rather what should happen is we should
delegate that responsibility to another
component or some another component
responsible for making a choice of how
our overall view state is going to be
composed and so this is going to be the
job of some kind of layout manager thing
naming things as hard it's
responsibility is going to be to compose
the UI so the layout manager is going to
define a top-level view a shell and it's
going to have areas that the modules are
able to render within so like a sidebar
for two main content region and when a
new module is activated the layout
manager is going to be responsible for
swapping out existing views with the new
views that this module is presenting so
internally the module can figure out
which control are in which view and all
of that kind of stuff needs to be
presented but the layout manager is
responsible for that composite
so it's going to look a little bit like
this we've got a bunch of modules
presenting Mike reviews and a layout
composer working out how they all work
together responsible for composing that
you I so this placement is going to
occur when our new module is activated
how does that work so the thing I think
should be responsible for this is
forgiving the modules to the layout
manager as some kind of dispatcher
object it's going to listen for
interesting events which indicate that a
new module needs to be involved and when
it when it asks when when it receives
these interesting events it's going to
load the target module it's going to
instantiate it and it's going to give it
to the layout manager who will then in
turn compose the application shell so
one of the interesting events that this
dispatcher object thing might listen to
our our routes so a routing event might
fire and the router is going to
facilitate the mapping between a URL and
a module or even a collection of modules
it's responsible for observing on and
acting on URL changes but it doesn't
actually do anything with it other than
say hey the routes changed and these are
the modules that I know you need to
invoke now it's going to delegate over
to the dispatcher and the really cool
thing about this as it means that other
events have the opportunity to be raised
and signal to the dispatcher that new
module should be loaded we're not
hinging our design around route changes
or out changes kind of sit on the side
as a feature
and then the last thing that we have is
the bootstrap over application so this
is the entry point and the extra point
of our application and it's responsible
for composing the the top level
architecture that we've kind of got
going on here and it also acts as an
extension point for your life cycle so
we've split up some of those concerns
that we had around state and events and
all the many views that we were
displaying at any given point in time
and the state of the address bar we've
come up with a much more composable
design where we're using events to
transition into new states and a
nonlinear fashion so I've actually gone
really quick so if it was too long and
you didn't read it because reasons I'll
sum it up for you so the management of
our state's basically it's really hard
when we don't separate our concerns when
when the complexity starts to blow out
on the client we should be using routes
were dressed state but never state
transitions and we should be taking
ideas from one context from it from
another and applying them and taking
inspiration server that's great that's
how new ideas form but if we're not
careful and we treat this like a
rulebook we start to apply patterns that
work well for a linear for a linear
architecture in an estate space where
it's nonlinear and the cracks start to
show so we need to mold these ideas to
support the new requirements the
requirement to be stifled so we need to
embrace events within the same xicon
execution context and we don't want to
make everything into our router we need
to make sure that we're architecting our
client side code lists like it's a web
server because let's face it it's not a
web server and that's way to see</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>