<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Jake Archibald: The ServiceWorker is coming, look busy | JSConf EU 2014 | Coder Coacher - Coaching Coders</title><meta content="Jake Archibald: The ServiceWorker is coming, look busy | JSConf EU 2014 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Jake Archibald: The ServiceWorker is coming, look busy | JSConf EU 2014</b></h2><h5 class="post__date">2014-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/SmZ9XcTpMS4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Hey
hello we've come a long way haven't we
in the in the past 20 years since the
90s I mean back then you would have some
friends over it'd be going great but
then two of your friends would start
having a disagreement involving that the
release date of ghostbusters but then it
starts to get heated
none of them are backing down the mood
of the dinner party is at stake but it's
okay for you hold aloft the answer for
you at the proud owner of Microsoft
Cinemania giving you instant access to
the history of cinema well it's not
really instant though is it because
first you must go to the room with the
computer in and turn it on and then your
clone call the fans start worrying you
get that friendly static crackle as the
CRT monitor words into action Windows
3.1 slowly boots up and then you get
your desktop eventually and it does this
and that really sets expectations we are
dealing with an operating system that
thinks booting successfully is a fanfare
worthy moment
and by the power of multimedia cd-rom
you reveal authority that Ghostbusters
came out in 1984 and you did that in
under 10 minutes the dinner party is
saved the web really changed everything
with the web you get the information
instantly no installation necessary
native apps such as Cinemania and
Encarta they looked out of date almost
instantly having separate apps for these
things that just became weird the stuff
on the intent was better it was built
with this new interconnected modern
world in mind the browser runtime
started to replace more native apps
email clients office tooling video
players code editors native apps became
the exception if you look at the top 10
selling laptops on Amazon they include
Chromebooks you know that's that's how
secondary native apps are although
that's not true
on mobile they're native apps still rule
because they build to the strengths of
the platform and a lot of the web
predates that some of the web is hostile
to mobile this is a creative agency that
I won't name and this is what you get if
you visit their site on a phone it says
choosing your creative agency isn't like
buying a pair of shoes so why don't you
make yourself comfy and visit our site
on a real screen but they're kind of
rights
choosing a creative agency is not like
buying a pair of shoes because I have
never had a shoe tell me to off and
come back when I have real feet if you
go to their desktop site it's a lot
better you can see the stuff they've
done and the things they're expert in
which includes responsive sites of
course
the more worried in case sites that are
simply hostile to just the mobile web
not the whole mobile platform this is a
horrible situation the user has gone to
these sites in a browser potentially
following a deep link and rather than
sending them the thing they want we send
them to another place where they can
download a thing and install that thing
which they can run which may contain the
thing they originally wanted somewhere
in the interface I don't think anyone's
saying that's a good user experience but
it's one that many developers think is
is worth it to get users off the web and
into a native app why is that well think
about the native apps you use the ones
you rely on that is where the web is
failing
what caused that failure what features
do they have that you use that make them
impossible to replicate on the web for
me I use these apps often or I rely on
them in some way and they can't be done
on the web because of push notifications
this is vital for the apps in yellow
they tell me someone sent me something
or something happened in the background
when the app isn't open I rarely use
TripIt I rarely open it I forget I have
it but then it will send me a
notification saying a flight is delayed
or canceled and that's that's really
valuable background sync send and
receive stuff when the app isn't open
from downloading podcasts to sending an
email later that failed to send at the
time which takes us to offline I depend
on this for more apps than I realized
from playing music checking where my
hotel is looking up a meeting location I
don't want to depend on connectivity for
these things and of course we need
better performance and better
integration into the operating system
you know battery stats payment and an
account integration everything that
makes it first-class on the platform the
web can't do these and that's a bug but
what gives me hope is that these are
bugs that are getting fixed like not
just being fought about code is landing
to fix these things and these are the
ones I want to talk about today because
these requires something new background
sync that happens in the background push
notifications are received and dealt
with in the background or flying that
doesn't run in the background but it
requires another context to run before
pages and that thing is is the
serviceworker and this is the spec that
bit got a round of applause at Google
i/o that's
don't patronize me I could have dressed
it up a bit of course I really like what
graphics cards do in this respect
because you know graphics cards are just
circuit boards but they they need to
sort dress themselves up to try and make
them look like the the must-have for
people even though they really don't do
anything on their own the boxes they
come in are amazing this kind of sub
deviant arts crafts you get the usual
sort of sexist nonsense that you get
with gaming but yours get things like
the the hideous offspring of Shrek and
Yoda I love the hair and also a teenage
mutant ninja dog so in that vein I
present to you the serviceworker
that's mumm-ra the ever-living using his
evil powers to control browser features
I we need a logo really badly stopped me
before I design again this is a feature
being worked on between Google Mozilla
Samsung and other third parties it's
like a shared worker in that it's shared
between many pages and has no Dom access
but unlike a shared worker it can exist
without a reference to it and it shut
down when it when it isn't in use but
this is the background JavaScript
context we need it's in browsers today
if you want to use there you'll need
Chrome Canary or Firefox nightly in
Chrome Canary you'll need to go to about
flags and enable experimental web
platform features and give the browser a
restart if Chrome isn't your thing
then you can use Firefox nightly just
you need to go to about config and in
there enable dom service workers don't
enabled and give the browser a restart
I'm gonna stick with canary for the
demos Google paid for my flight in hotel
here so it'd be rude not to but also the
debugging tools are are further ahead
but I'm told Firefox is catching up
there soon if you want to know what
supported all of the sub features is
serviceworker ready it breaks it down
and tells you which browser support what
so first let's take a look at offline
because it's the foundation for the
others offline suffers from the same
misconceptions as progressive
enhancement I think they people say my
app doesn't need to work offline because
my users have permanent internet
connectivity but it's not just about
zero connectivity it's about treating
the network as an enhancement one that
might not be there when the user clicks
a link to your sites they enter a URL
this starts a navigation a document is
created but we have to go off to the
network to get the data for that that
can take a long time it will come back
eventually
we can't render at this point we need to
send off the request for the sub
resources the CSS the JavaScript the
images as these come back we can start
to render but those sub resources
trigger other sub resources strings like
xhr fonts images used in the CSS when
they come back we get towards our final
render as a practical example of this
I'm going to take a train to thrill
which is a little demo site it's a
responsive site it displays the latest
train photos from Flickr don't ask me
why trains I was on a train when I
started building it I had a moment of
zero inspiration but let's load it on a
phone with an edge
in action so that's 250 kilobits 15 year
old me would have killed you for a 256
kilobits it's not the best today but it
is far from the worst so free to one go
we get to first render that wasn't
JavaScript dependent we get content
after about 5 seconds as from Flickr no
images yet though those images are about
200k each that's what Flickr gave me if
I wanted enough pixels to cover a device
of this density a 1080p screen we get
the first image through after 30 seconds
over images start loading and eventually
after what seems like years we we get
the the full render now that video
wasn't real time I had to cut it down it
took so long those are the correct
figures of course we could compress
those images a little bit better we
could do things to ensure that the top
images load first I just took what
Flickr gave me but we are still beating
native at this point the equivalent for
native is the trip to the App Store the
download the install it's a slow and
comparatively poor user experience but
native kicks our ass on the second visit
because it used that initial download to
to install and cache loads of stuff we
have the browser cache yes but the whole
internet is fighting for that and if we
change one line in our CSS or JavaScript
we have to change the file name we break
the cache and you know we'd like to
deploy often so we're breaking that
cache often but this page registers for
a serviceworker allowing us to do
something about that that second load
registration is simple it's just a minor
JavaScript like this give it a location
of your script you can also scope it to
an area of your origin and that's useful
if you have like a single origin with
many apps on it like your Google does
with calendar and things like that
the default scope is the whole origin
which we'll use here it returns a
promise so you get to find out if it
worked or not you can only register for
a serviceworker on pages served over
https the serviceworker is so powerful
that we you'll be disaster if that falls
into the hands of a man-in-the-middle
github pages server over https so
they're a good place to put demo stuff
and localhost is exempt for development
as for work ojs we're just gonna put a
console log in there we're also going to
listen for the install event this fights
when the browser sees this
was working for the first time so let's
see that in action first I'm going to go
to serviceworker internals which is
where our debugging stuff is is living
at the moment house you can see there's
nothing there and then I'm going to open
the training site err a dead version of
it and open dev tools and as you can see
in the bottom corner there our service
worker is successfully registered if we
go over into a serviceworker internals
there it is there's our console logs but
even better we can launch a dev tools
window where we can see the same console
logs but we can also set breakpoints and
run stuff on the console etc if we
fast-forward time a bit the
serviceworker terminates that's not a
bug it's just not needed at the moment
so it closes to conserve memory and
congratulations at that point you are
now wielding the power of the
serviceworker but what did that actually
goes nothing but wait oh my god it's
actually a good thing that it does
nothing the unapologetically made it
good compare it to app cache if you give
an HTML page a manifest and that
manifest only contains the words cache
manifest which is required to make it
valid yeah sure I'd expect my page to go
from this to this said no one ever in
the world so we didn't wanna do that
serviceworker doesn't do anything unless
you tell it to do something app cache
broke a lot of eggs and it failed to
make an omelet but it's made of the
right ingredients it's got routing
fetching caching updating and version
control but because it's app cache you
know in order to get to them you must
first reverse the piles of implicit
behavior which are of course guarded by
the army of robot wasps
if you've used that cache before you'll
know what I mean so we got rid of all of
that we separated them out so they could
be used however you want without getting
stung this is the extensible web
don't let the platform give you a fish
ask for the fishing rod and how to use
it but take the fish as well right we
need both high and low level API on the
platform
first up routing putting you in control
of requests the serviceworker is
event-driven we've already seen install
but there's also fetch this fires for
any navigation to your scope but also
for any sub resource from that page in
serviceworker internals are going to
start
the service worker and we'll inspect it
then I'm going to navigate to our to our
train site and you can see as soon as we
navigate we hit this break point in the
fetch event and that's for our route
page if we move on from there we'll get
one for the the CSS we skip from there
we'll get the logo the JavaScript no we
rendered before JavaScript because we
care about performance and then we get
one for the API call to flickr even
though this request is to win over
origin we will get an event for it and
then we get all the image requests
coming in but hey the cool bit is this
is this is an event and like other
events such as click touch start and key
down you can prevent the default and do
something else you can respond with
something else responses can be created
manually that's why I'm doing here just
a new response give it some text and if
we do that the page goes from this to
this but the interesting thing here is
we delivered that without going to the
network at all making it the first
offline demo of the talk only almost
halfway through but we can do better
than that when the browser discovers the
serviceworker for the first time we'll
send it off to the network you'll get it
to make a load of requests and when
they're done we'll get a lot of
responses and that might be fast it
might be slow the network is
unpredictable we don't care we're not
disrupting the user they already have
the page open if our response has come
back we'll put them in the cache this
pre-caching method is like the is what a
native equivalent would do with it's an
initial install package but we get to do
it in the background without disrupting
the user for our train site this is
things like the the root page template
CSS JavaScript and design images all the
static stuff and then in future when we
get a request to one of those things
we'll just get it from the cache send it
back to the page do you uncertainty of
the network is no longer our problem and
this is really simple thanks to the
caching API which gives you full
programmatic control of the cache in
terms of our train site in the ax Stoll
event from earlier we get this event
wait until and we can pass a promise
into there that extends the installation
process on you used to indicate success
and failure as well so here we're gonna
create a cache give it a name that gives
us a cache object
and then we're gonna add stuff to it all
of our static assets this is an atomic
operation if any of these fail the whole
operation fails and the service worker
won't control pages so if it stall
succeeds we know we have these things in
the cache there are dependencies the
cache itself isn't in canary yet but
there is a as a polyfill backed by IDP
the proper implementation will land in a
in a few weeks so how do we use these
cached items well over in the fetch
event event dot respond with caches
match and passing the request and this
will go to the cache and it'll find a
response that matches that request
matching is done by method URL and very
headers similar to the browser cache if
there's no match you'll get no back the
promises let us recover from that so if
we get no back we can send off something
else what should we do instead we could
send another thing from the cache a
fallback entry but what if we want to
try the network to do this we need to be
able to make a request using javascript
in 1999 Microsoft engineers were
designing a new exciting API but what
should they call it it contains some
abbreviations some initialisms they
couldn't decide if they should be all
caps like in an HTML or just the first
letter like get element by ID so they
did both an XML HTTP request was born
other than that the name is perfect XML
because it only deals with XML except it
doesn't HTTP because it's restricted to
http except it isn't and requests
because you get a request object back
except you don't we try to modernize it
a bit so it makes more sense but it's
still pretty bad let's you some Jason is
verbose and weird we've been patching
this API up for 15 years I do not want
to be using this API when it is old
enough to drink thankfully the fetch
spec by an event Kathryn of Mozilla it
gives us lower level control of a
request and responses we've already seen
some of it the request objects in the
response object lower-level API is are
usually more difficult to use than than
higher level ones but xhr is so bad that
is not true here the equivalent to this
in fetch fetch URL gives you a promise
posit how you want gives you a promise
done this is a forward-thinking API to
es6 arrow functions make it neater es7
async functions can make it a one-liner
if
if you want so to answer the question
how do we send this request to the
network fetch so where does it's get as
what improvements does this give us well
3 2 1 go
we render almost instantly we get
content after a couple of seconds we're
still going to the network for that
content but our JavaScript arrived so
much quicker it was able to start that
request so much sooner still a sad story
with the images though let's fix that
when there's a request for a Flickr
image it'll go to the serviceworker like
everything does if we have it in the
cache will return it from the cache
otherwise off we go to the network but
when we get a response back we'll send
it to two places we'll send it to the
cache and the page so it's there for
next time we're doing this for Flickr
images but this pattern is also good for
things like avatars things you want to
cache as you go along to do this work
we're going to special case URLs that
end in static flickr comm that's where
the images come from in that case we'll
take the request try an get it from the
cache and return it if we find something
otherwise fetch it from the network add
it to our cache send it back to the
browser we need to be careful with this
pattern because we're adding to the
cache for every image request we'll need
to kind of garden it at some point we'll
pick that up later but for now how does
that improve things 3 2 1 go we render
quickly content comes through pretty
quickly but this time we have images all
of the images that we've seen already
but not this one at the top that's new
that comes through in 11 seconds and
that's pretty good but we're still
dependent on the network for that
initial API call that tells us which
images to display let's fix that so this
one's a little bit different the page
does a fetch for the API which goes by
the serviceworker as everything does but
the same time it also goes straight to
the cash because pages can access the
cache too and if it finds a response it
will it'll take it and it will render
with it and then I'll that will trigger
all the requests for the old images that
we've seen already which are also in the
cache meanwhile the serviceworker goes
off to the network after Flickr servers
gets data back and we do what we did
with the images we send it both to the
cache and the page this is also a good
point for us to clean up the
with this pattern the page makes two
requests and it renders content twice
once from the cache and never from the
network that means we get to render
quickly with all content but provide
up-to-date content when we find it the
best native Maps do this very few but
the best ones do so here's where we're
at now we're special casing static
Flickr we also want a special case API
dot flicker calm in that case we'll do
this I'm not going to go through this
line by line this is fetching data
caching it returning to the browser this
sort of gnarly bit in the middle is
where I'm pausing the data from Flickr
looking at the image URLs in there and
removing ones from the cache that we
don't need anymore this is a little bit
gnarly even with promises es7 async
functions make it a lot neater but
that's the serviceworker side but it's
pattern requires the page to make two
requests so over in the page side we set
up two requests one to the cache and one
to the network if the network response
comes in after the cache will update we
show an error if both the network and
the cache fail to provide data if the
cache succeeds but the network fails we
fail silently that's a good offline case
that was probably too much code to show
on slides I think even even at J's comp
but my point is we're expressing
relatively complex custom async
behaviors in relatively small amounts of
code even using the low-level primitives
and the effect of that let's remind
ourselves where we started first visit
takes quite a long time to get the first
render just over a second then content
comes in after over five seconds and
then we're waiting forever for the
images with serviceworker and the code
we've written to manage the network in
the caching free to one go and we have
what looks like a complete view rendered
really quickly new data comes in after a
couple of seconds doesn't disrupt the
user if they scroll up they see it and
we get the new image we shaved a second
off first render over 36 seconds for
what looks like a complete view with
serviceworker you can get content on the
screen in a fraction of a second whether
you have a fast connection a slow
connection or no connection it doesn't
matter this is what catches us up with
the startup performance of native and it
gives us the foundation for these other
features such as push
some background sync first up push
something I depend on for many apps
before we look at the code going to give
a live demo ago which is we'll see how
this goes
Remy could you help me with this so I
need the projector working I don't know
Thank You Remy you were going to send a
chat in there but not until we have
something on the screen
how's it going by the way yeah it's
pretty good
enjoying the morning so far was
breakfast good yes I didn't have
breakfast I was afraid I might throw it
up oh here we go okay so this is a
simple chat app this is running in a an
internal build of chromium but based on
actual spec work so if you could just
type in any message in there oh that's
nice thank you whoever tweeted that
that's good oh that's lovely
no one tweet anything rude right now so
did you send the message there yeah
that's good how's the Wi-Fi holding up I
guess it's let's refresh that go again
oh that's a disaster isn't it okay I'm
gonna refresh this one as well go again
if not we'll just abandon it it's live
demos right yes it's great cuz it's not
gonna display so well I'm getting tweets
which is a good sign how this worked
like five minutes ago no we might just
have to abandon it I'm gonna drop on to
roaming and see if that helps restart
chrome oh that's a good idea that not
only fixes everything we're using
Firefox here to send the messages so I
could always blame them go on give it
one more go if not well if not we'll
just abandon it yes
oh thank you Remmy your sir okay oh no
stay that's but we've seen that happen
before right this is nothing new but
what I'm going to do now is I'm going to
close chrome completely and now there's
not yet now there's nothing that
browsers not open at all I have no
recent apps on so Remi would you care to
send another message now what we're
getting here this is a push notification
using open web features this you know in
a completely native notification the
browser was closed but it started up the
serviceworker in the background and we
got a notification because it's all
using native notifications it is also
appeared on my watch as well just using
the open web
Remy sharps birthday as well
can we can we switch back over to the
laptop is that that possible how do we
wear the connectors flat
after you mix brilliant
so I am hideously running over now
the way we coded that and this is just a
standard in from your page you register
for push messaging we'll give you the
details like the the ID and the endpoint
where to send messages but when that
actually when that's called you'll get
an event in a serviceworker
you get to do what you want at this
point you look at the data update cache
as your notification and when
notifications clicked once again you get
to do what you want in our case to do
you could navigate to a page or refocus
an existing tab background sync is very
similar I won't go through it but you
you don't need a server operation for
that you're just saying sometime later
can you fire an event in the
serviceworker for me to do something I
was unable to do earlier or update on an
interval these things require user
permission of course they'll be told
about this I have ten minutes oh I tell
you about how to code push and sync then
okay how did that demo work Jake well
I'll tell you
from the page you call navigated or
serviceworker dot ready and that gives
you the registration details of the
serviceworker where you can look at this
the state of the installation process on
that registration we call reg or pushed
up register that gives you the details
and you post those to your server you'll
kind of associate that with the the
current user because that will give you
the the endpoint information where
you're going to send a data for chrome
that's going to be GCM Google Cloud
messaging but every browser is allowed
to use their own you'll need to have an
account set up with the different push
messaging providers but the the data
that you'll send to these things will be
exactly the same you'll just have to
know which way you're sending it which
will just be a URL when the user
receives a push message on a device it
spins up the service worker in the
background you get a push event and you
doesn't have a look what kind of data is
it I'm gonna react to that in our case
I'm going to do event dot wait until I'm
going to update the Train caches this is
a pet hate of mine oh afterwards were
just going to show a notification
something this is thing that native even
the really best native apps they get
this wrong that quite often I'll get a
tweet and I'll I won't notice it when I
when it just arrives but on the
underground I'll see the notification
and I'll click it and I get nothing
because they haven't cashed that data
offline we can do the right thing here
update the caches before we show the
notification you get an event when the
user clicks the notification and you do
what you want usually navigate into the
page
we also give you a way to enumerate
serviceworker clients which are the
pages that are within your scope so you
can look at them see if they're focused
see if they're hidden so you can you can
know or hang on there's already a window
that has focus so I don't need to to
show a notification or I don't need to
navigate anywhere it's you know I can
determine that stuff ahead of time what
about background sync this lets you wake
up the serviceworker at some vague point
in the future to do whatever you want so
this is a bit similar to push it's
actually quite a lot simpler so if you
try and send an email but the user has
no connection or the servers down so it
fails you can save it somewhere probably
ID be your the cache API and then you
register for a sync event you just give
it an ID and that will trigger a
permission dialog that returns a promise
and then sometime later when the user
has good connectivity you'll get a sync
event
get to do what you want which would be
you know if the IDS empty inbox will get
the outbox and try and send all of those
emails I think that wait until in this
pattern it works similar to the install
event if you pass a rejected promise it
will go oh well that didn't work
it will reschedule all the sync event so
in that case if we fail to send one of
these emails
it'll be rescheduled so later so this is
registering for a single sync event like
do this when the user has a connection
but you can ask for ones on an interval
as well so we would use that for like
updating train data in the background
the interval you specify it is a minimum
when things happen will be determined
heuristic by the browser it'll take
things into how often does the user use
the app do they if you've registered for
a sync once a day and we know that the
user looks at your app like about nine
o'clock in the morning we can schedule
the sync Ferb for 10:00 to 9:00 you know
get your clever stuff there and coalesce
it with other sync events to preserve
battery life
we've serviceworker we gain a lot of the
features that make native superior but
we retain the bits that keep the web
superior the instant on no install
required it's an open platform chrome is
going to start shipping this stuff this
year it's already in Canary it'll go to
stable this year or early next year
Firefox are actively developing it
Microsoft are investigating it we
haven't heard anything from Apple but
that's not unusual at this stage but
it's designed to be an enhancement I
mean no browser is going to have it
there on the first visit to your site so
you have to prepare for that and as long
as you use basic object detection you
can give this benefit to the browsers
that support it which is a lot of users
in Chrome's case serviceworker doesn't
make stuff work offline it doesn't turn
push messages into cache updates and
notifications it gives you nothing for
free but it treats you like an adult it
gives you the moving parts and says do
what you want use it to make things
faster make things work offline create
new features transcode a video format
using streams turn into something the
browser supports build the client-side
wiki we've seen that already do what you
want do it in a way that's unique to
your app the way that gives the best
user experience I am heavily biased but
I think this changes the scope of what
the web is capable
of more than any feature since xhr let's
build some cool stuff of it thank you
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>