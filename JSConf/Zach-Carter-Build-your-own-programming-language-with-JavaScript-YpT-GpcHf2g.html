<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Zach Carter: Build your own programming language with JavaScript | Coder Coacher - Coaching Coders</title><meta content="Zach Carter: Build your own programming language with JavaScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Zach Carter: Build your own programming language with JavaScript</b></h2><h5 class="post__date">2013-01-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YpT-GpcHf2g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so my talk is about building your own
programming language and using
javascript traditionally most language
building tools are saying C or C++ or
some other type of language that's more
you know in the operating system you
know one of those kind of languages
JavaScript is usually been used in the
browser but now we have environments
like common Jas node you can do these
kind of things just on your command line
without using a browser and the basic
idea I want to get across before we dive
into it is you know every program we
write is basically an interpreter we we
get data as input we execute based on
the rules of the program but some inter
are some programs take other programs as
input and so the other program is
transfer transformative data and the
program our compiler or our interpreter
executes rules based on how we want
those Chuck that structure to be
interpreted so program equals death and
basically compiler is you know just a
translator so you take one language you
figure out what the meanings are of the
symbols the words in the language and
you output another language so you know
Google Translate is a compiler of you
know say English to Spanish or something
like that so same basic idea
and this is a just a basic ordering of
how things go first you have your parser
which handles the syntax of the language
it figures out what the characters mean
what the words are and like what
sentences are valid in the language and
if you do a syntax error that's like you
know a malformed sentence in your
language semantic analysis we won't do
much of that we'll just that stuff like
if you want to do type checking make
sure things are you know correct but
we'll just basically just print out what
we get in in a dull language and that's
at the bottom code generation and your
interpreter and of course all this is
gonna be done in JavaScript so it's
easier for all of us to hack on and
maybe you come up with some new ideas
since JavaScript programmers are come in
lots of different varieties so the first
thing we need to handle the syntax is a
we're gonna use a parser generator you
could of course you don't do some ad hoc
form of you know reading each character
and a string input or something in you
know do your a roll your own way to
interpret or parse the language but
we're gonna use a partial generator
which sort of makes things easier and
these are a few available ones in
JavaScript Oh Maddy Jas Jason and PEG
Jas and Jay SCC and those two are kind
of newer I like those ones a lot but
Jason is the one I wrote so we're gonna
be using that one today and Jeremy who
did a talk on CoffeeScript earlier today
he used Jason for that language to do
the parsing phase with it and he said
it's it's a lot faster right now then
the other ones which ok you know I'll
take that so first we need a grammar a
grammar describes you know what valid
character what valid tokens are and the
structure so I don't know if you guys
have ever checked out a language
specification before if you've you know
this is snippet from the ACMA script
specification the fifth edition so it
just came out and this is the JSON since
JSON was added to the language they have
a grammar describing JSON right there
and our parser generator takes in a
description basically just like that and
oh so I got to kind of move the window
from this view to where did it go
and window kind of ran away
hmm
well if I can't find this window soon
well let me
actually there's a mouse
I'll just open up a new window
and or is it yeah this is when I figure
out the command line and this started
out mostly like all live demos do so
well I can show you the command line
version I wasn't to show you the website
but that's alright let me just bring
over a show and
that's not the right one so the grammar
file is as a extension of Jason which is
the grammar format and it's has ever
anyone ever heard of bison okay yeah so
we have some language people in here
it's basically the syntax of the actual
grammar form is almost basically the
same as bison syntax so it makes it easy
to port grammars that are already
written for bison which is are a lot
because you know bison and yak have been
around you know how are you however many
years so and what I've defined here is
basically a simple language it only has
variables that you can assign a value to
and then B plus expression so you can
add add variables together and assign it
to another variable
so very simple syntax in the first line
is basically saying ignore whitespace
zoom in a little bit
yeah it's hard on this screen
all right yes that's better
so the first line basically says ignore
white space so we don't care how much
white space is between two tokens and
language so you can have a variable
equals and like a long line of white
space you know a number or something
like that actually let me show you this
is an example of
yeah I'm not sure
all right so an example of the language
so our language is actually just going
to look like this x equals five or it's
not ugly using the equal sign that's
kind of boring we'll use X is five let's
say Y is 6 and Z is y all right so
that's gonna be the syntax for you know
the basics of our language then I don't
have a sort of a method to a built-in
method to show the value of that and all
right so keep that in mind
all right so back to the grammar all
right so that's how you you can make
sense of what these mean a little better
now the right there you're saying is and
you're returning what is the token so
you're basically saying match these this
is a regular expression on this side
match the exact characters is and then
return a token which is the is token and
for show it's the same thing you're
matching that those are like key words
so you're match that key word you return
show the show token and you can see a
number is just a regular expression
returning the number token and this this
is also if you're familiar of bison
you're probably familiar with Flex which
this syntax tries to mimic the Flex
syntax so it's easier to port existing
grammars and then so and the rest of
them you can kind of see and there's a
special one for the end of the file
right and then and so this is an unlike
bison flex we actually have the the
lexical scanner stuff inside of the
bison file so it's easier to just
combine it and not have two files
basically I did that so you can do it on
the website without having like two
boxes you can just have it all in one
text field and compile it and it's a
website as JSON org and I mean that the
way to try it is actually on the website
so you can experiment with it and
there's examples that load up on the try
page but moving down past the the taupe
the tokenizer
so we have the tokens they're sort of
like words we have a sort of a higher
conceptual level now not just characters
we have tokens so we move down to the
actual defining what are valid
combinations of those words so
a program you see the first one so a
program is a statement list and followed
by an end-of-file so a statement list
you jump down to that one a statement
list can be a statement followed by a
period and a statement list the
statement list rule is also cursive
that's how you get sort of like a list
it recursively calls itself so you can
get a series of those statements and the
statement rule is either an identifier
followed by is and an expression and the
you'll see those mustache lines between
the actual rule definitions and those
are the actions that are sort of
building up the AST because we want to
get transform the DES characters and the
tokens into something a data structure
we can work with the compiler and or the
interpreter so you'll see those action
lines are just building up sort of an
array that has you know what the the
token type is and somewhat extra
metadata about it and we'll get into
that little bit later but so a statement
can be an identifier with the is token
and an expression so that's the
assignment and then show which is our
special built-in function to show the
value with an expression and then of
course an expression can be an
identifier a number or an expression
plus another expression so that's also
kind of recursive that you can define an
expression to be defined within itself
so these will get expanded into either a
number or an identify
and that is the whole grammar right
there and talking about the actions a
little bit more the thought the double
dollar sign is actually sort of like a
return value so what are you going to
return from that that action and
whenever it it and whenever the parser
matches say an identifier it's going to
run that action and return it and then
say this expression X plus expression
these expressions are going to be
whatever is returned by they identifier
so this action for the expression plus
expression is is going to be combined
combining the result of one of these
actions and so there so it's it's
building up so the AST that way yeah not
exactly the regular expressions but
whatever position the the token is and
this the rule there whatever positioned
offset of the position of that token is
what that dollar assigned number is
going to reference to so yep and then
you'll notice that that the top
actually has a return statement and
that's returning the value of whatever
the program is at that point and so all
of these it it's a bottom-up parsing
algorithm so all the nodes sort of start
at the bottom and then it works away all
the way up to the program at the top and
then it returns that but you could have
a return statement like anywhere in the
rules that would it could exit out of
the parser early so and inside of these
actions is well it's all just JavaScript
code so
those actions are just a regular
JavaScript code you can put whatever you
want in there right okay so at that
point we have a grammar we can work with
and I'm going to show you a little bit
of the the code generation phase so once
you have your program parsed and you
have a ast so we just have like a array
with sub arrays nested arrays inside of
them
that's our ast representation you could
also do create an object instead of just
an array you can you would you probably
want to create an object in CoffeeScript
does that because I'll show you how it
looks here yeah so we see our program
again and actually this first line is
you'll notice that it's come and Jas
requires statement so I'm using actually
normal on the command line to run the
parser so that's just requiring the
parser Oh actually yeah the way to I
should so the way to generate the actual
parser script so you have your grammar
defined in that grammar JSON file and if
you want to actually create the script
of the parser because this is a partial
generator so it generates the parser
you'll use narwall grammar to jason and
that's what actually creates an a
JavaScript parser that you can include
it doesn't have any dependencies you
just include that javascript file and
send it your input it outputs the ast so
oh and I think I have it
well I already have a generated one
already so we'll just ignore that and
get into the the cogeneration file so
we've created our parser module and
anyway so we require our parser at the
top and again the fine is our simple
program X is 5 y is 6 Z is X plus y and
then it shows E and then this is just
some you know our ast is what we
returned from our parse function so the
person we generate has a parse function
that you send in the input so a string
program it returns the ast which is in
our case is a arrays nested arrays and
then we have a code generation function
that we send the AST to and at the end
we'll print the source of but this code
generation function is just you know a
big switch statement and that's why this
probably will scale very well if you
want to do something like CoffeeScript
you create actual objects for each one
of these nodes and have it have its own
cogeneration function that you can just
call on on the object so that more
object-oriented approach but for this
this is what simple I did this last
night or something so so it's basically
just a big switch statement and so you
send it the ast in the top the top array
and the ast is going to be that program
note so it's the first part of the ACE
of the array is going to be program it's
gonna call a helper function code
generate on a list which is here in this
case just a reduce a array reduce so it
it starts out with a blank string and
keeps a pending on the next value in the
so yeah it basically just Co generates
each each of item in the list and then
returns that and that's that's that's
going to be the last one that actually
runs so basically it's recursive you
know all the
children of the node get code generated
and then that gets included in that
nodes full text representation so you
can see a number is just gonna return
the value of the number and an identity
just gonna return the string that was
the name the identifier is name add
expression code generates the the first
operand and then the second operand and
the is statement the assignment is just
setting a name equal to so this is
generating JavaScript code I should say
so even though it's a is statement our
assignment was is used is when we're
generating it we're using the JavaScript
syntax so it's equal sign here and then
at the end you can see the semicolon and
then the show statement is a print so a
show is just we're just gonna print out
what that value is if you're doing in
the browser you do alert or some a
council that log and then if somehow
some unknown node gets in there you can
through Ryton so that's the whole
program and if we run it
all right so we ran the the program and
you can see the JavaScript oh if you
guys can see it back there the
JavaScript program is what gets printed
out so we that's those are the strings
that we were building up in the Coach n
function so it translated it from our
our syntax that we made up we first
defined in our our grammar format and
then you know went through and actually
code generated this code here all right
demo code generation and instead of just
compiling doing this translation you can
also do meta circular evaluator which is
basically an interpreter that instead of
just translating this ast into text code
it does so a read eval print loop kind
of thing and if you want to if you want
to know about all that stuff yeah you
know it's a good a good book especially
if you're interested in programming
languages so and I actually I'm working
on something called Jay sonic it
basically looks kind of like Lisp but
instead of s expressions it's JSON so
and it pretty much looks just like the
the arrays we were building up arrays
with notes and that's what Lisp
basically looks like this looks like an
AST so you know it's sort of the same
idea with JSON ik but it it's not really
practical to write in because it's so
verbose you know you don't really want
to you wouldn't really want it writing
in it for real but it's great for
experiment experimenting with language
ideas because if you have your own
interpreter you can do whatever you want
if you want to create a closure and then
have a way to inspect the context of the
closure while you're inside executing
code you can do that if you wanted to
you basically any kind of introspection
technique you can do or anything you
want it at all
so interpreters are fun so
and that is the end of the top I just
like that picture so and there's a bunch
of links this gets posted somewhere and
I don't have that Jay sonic on github
yet but I'll probably put that up there
and up and then yeah in the demo or that
I did here</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>