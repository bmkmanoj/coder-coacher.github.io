<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Jack Moffitt: The Real Time Web with XMPP | Coder Coacher - Coaching Coders</title><meta content="Jack Moffitt: The Real Time Web with XMPP - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Jack Moffitt: The Real Time Web with XMPP</b></h2><h5 class="post__date">2013-01-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WktC6vc4WQs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">some real-time web is something that
I've been working on for I don't know
four or five years now this idea that
the browser could be a two-way
communications channel with very low
latency so I'm going to show you guys
some explain how we do this stuff with
XMPP and in this JavaScript library I'm
going to show you guys some code and
some demos and stuff like that so so
XMPP is the protocol that we sort of
used to make this magic happen it's one
of a couple of choices that you guys
have it happens to be my favorite it
stands for the extensible messaging and
presence protocol it was initially
started in I think 99 by Jeremy Miller
and some friends to sort of take on the
closed into the messaging systems of AOL
and Yahoo and those guys how many people
in this room know about XMPP or have
used it so quite a few
so everybody who has a gmail account and
didn't raise your hand you know and love
XMPP already so it's originally for
originally intended to be instant
messaging replacement protocol it can be
used for pretty much anything with it
can be extended and people have done
extensions for publish/subscribe
semantics for ad-hoc commands XML RPC
pretty much anything you can think of
someone's written a spec for how to do
it over XMPP these days it's used for a
lot more than just instant messaging and
in fact most of the applications that I
write with XMPP have nothing to do with
instant messaging so why do we want XMPP
well there's we probably everybody in
this room does most stuff with HTTP and
HTTPS are great you can do a lot of
stuff with them REST API s are great you
can do a lot of the functions that you
want to do the problem is is that HTTP
polling really sucks if you want to get
the latest Twitter updates you have to
ask Twitter hey is there anything new
and then you have to ask them hey is
there anything new and like 95% of the
time there's nothing
- but if you want to get low latency and
actually have a conversation you have to
do all this polling anyway there's no
really escaping it
and so real-time applications are
different they require you to have this
low latency which in the HTTP world
means you're pulling the crap out of
something an XMPP is sort of a good
solution to this it's it's a where HTTP
is stateless X and P P is stateful has a
long live TCP connection under it and so
you're probably all asking because of
that how do you do this from the web
browser so before I get to that I want
to for those of you who probably never
seen the actual protocol before I just
wanted to go through a couple of the
protocol points so there's an XMPP
Network the network is federated in an
open way it's very similar to email you
have a client it talks to a server the
protocol that they use is called the
client to server protocol it's very
creatively named and of course you can
have lots of clients talking to the same
server you can have two servers talking
to each other these speak a slightly
different protocol called the server to
server protocol and of course all lots
of servers can talk to lots of servers
and each of these servers can have
thousands and millions of clients
hanging off of it and it works like
email so if I'm on on this server here
and I send something to server B it's
going to forward the message to server B
which will forward it on to the user
there
unlike email there's only one hop here
so I go directly to the pure server I
don't go through any intermediate nodes
and there's no forgery possible meaning
that if this so I can the server can
forge local users but nothing can forge
an arbitrary user on the network so if
it came from a server you know that it
came from the server you don't have to
worry about some of that SMTP spam
vector stuff so to get all this data
shuttled around we have an addressing
scheme it looks a lot like emails
addressing scheme this is a domain this
is probably this is the simplest XMPP
address you can have this is an address
of a server in most cases you can have
user add a domain that looks
like an email address we call this a jid
for jabber ID this is called a barrage
it because it's just the user in the
domain this is called a full jid we have
a user a domain and a resource and we
need this because you might have
multiple connections to an XMPP server
and there disambiguated by this resource
bit so for instance my connection where
i'm at home might be called home and i
might have one for work gmail likes to
give really random strings is these
resource identifiers it really doesn't
matter what they are as long as you know
they're unique so the protocol it's
based on XML it uses something that most
other XML based things doesn't which it
uses XML streams essentially this means
you have two XML documents that are
built continuously on the fly one in
each direction over these so for
instance when you make the connection
you open up the root element you send
these messages across as first level
children and when the connection is
terminated you send the the root close
so at the end of an XMPP connection
you'll have two completely valid XML
documents but during the XMPP connection
you work with XML stanzas which of these
first level children so there's three
main types of these these first level
children
the first one is a message and we have
presents and we have this weird IQ one
and IQ one stands for information query
this is pretty much exactly equivalent
to an HTTP GET request or an HTTP POST
request it's the only one that's
required to have a response so message
stances these are like the basic
building blocks when you send messages
back and forth they could be chat
messages they could be arbitrary bits of
data that you're sending around this is
pretty much what a normal chat message
would look like you have a from in this
case the from is always going to be a
full jid unless it comes from a server
or something you have a - that's where
you're sending it to you can send it to
a barrage it you can send it to a domain
all kinds of stuff and it has a type
most of the time this is going to be
chat for private messages it might be
group chat for group chat messages
there's also some other
types like headline and things that are
used for various weird purposes and then
we have the body which just has the text
of the message you're sending um and of
course if you're sending a message
that's not chat you might not have a
body you might have something else here
presence is how you know somebody is
online or a way or busy and that kind of
thing in XMPP we use it it's sort of a
mini publish/subscribe system here's
somebody setting their presence to away
we have you know type equals away
there's also if you have no type than
its type util it's basically available
presence there's also do not disturb and
some other ones and then the show is is
a it's not arbitrary text here there's
only a few possible parameters and
that's just to give the client
developers something I hint at how to
show this presence and then the status
is just freeform text you can put this
is like Facebook status messages or
Twitter updates that kind of thing and
one last thing on presence is that you
have to subscribe to people's presence
so for instance if I want to add
somebody to my so we can't say buddy
list because AOL has trademarked that
name so we call them rosters if I want
to add somebody to my roster I send them
a present subscription request and they
can approve it or deny it and then I can
see their presence and these presents
are two-way just like Twitter follows
which means I can subscribe to you but
you don't have to be subscribed to me or
we can be mutually subscribed to each
other so so I queue messages are look
just like this there's a there's a two
just like everything else has we have a
type equals get there's also a type
equal set get is sort of like a HTTP GET
request and set would be more like a
post so this is generally used when
you're accessing some information as
opposed to you know changing some data
all of every IQ has to have this ID
attribute they have to be unique for the
stream and this is because when you get
a response to the IQ it has to have the
same ID attribute on the response and
then a lot of the different protocols
and XMPP use this query child
this namespace here I've shortened them
so these aren't the real quite the real
namespaces tells you which sort of
extension protocol is in use here this
one for instance is service discovery
here's the response to that same IQ that
would be sent from the server you can
see that we have the same ID there this
is type equals result because it's a
response we could also have a type
equals error if something went wrong and
we have the same idea as I said and then
this is this is all of the answer stuff
so we did a service discovery queries
and this is the service discovery result
it's telling us about the identity of
this thing is an e jeopardy server and
it has these features and usually there
will be a giant list of these it for a
XMPP server various different objects on
the XMPP Network will respond to service
discovery queries with with different
things so now we get to this point where
we want to integrate XMPP with the web
which is kind of a challenge because as
we all know the web is stateless and
it's only one way well I mean we can
only ask in one direction we can't ask
them the other direction so there's a
lot of sites that have started using X
and PP on the web these are a couple of
them these sites are chess Park is a
site that I built the other three are
not all of these sites use the library
that I'm about to show you
dropo uses XMPP every collaboration zone
and drop yo is a multi-user chatroom so
when so when you you know drag a file
into the browser to share with your
friends it actually sends a message to
the group chat room and everyone in the
collaboration in the collaboration space
will get a message XMPP message saying
there's a file dragged there and that
kind of thing presently and Yammer both
use it for real-time updates on the site
to keep the the homepage is dynamic and
XMPP on the web is sort of made possible
through Bosh which is bi-directional
streams over synchronous HTTP you know
this is a really fancy name for long
polling so I don't know how many of you
guys know what long polling is
so a couple of you so this is what long
polling and normal polling look like in
the normal polling situation the top
line here with this red stuff the very
top of that is the client side so the
client makes a request since data to the
server hey is there anything new the
server responds immediately there's
nothing and then we wait for a while
maybe it's a minute then we send another
request hey is there anything new and
you can see this keeps happening over
and over and over long polling turns
this exactly around so now we send a
request to the server hey is there
anything new and now the server is smart
it says well there's nothing new but
there might be soon so I'm just going to
hang on to the result as long as I can
and that way if something new comes in
I'll just fire it back with the new data
if nothing new comes in after some time
like maybe a minute or so I'll just fire
it back empty and at that point the
client will re request and it'll sit
there so in long polling you have these
long periods where the request is on the
server end waiting for a response and
this allows you to do two-way
communication pretty efficiently about
as efficiently as you can do anything
over HTTP like this and it's the clients
responsibility so for instance if you
send a request and you wait for a while
and now you need to send data to the
server when you send the new request the
server will release the old one because
you only have two requests available in
most browsers so we have to you know
keep jumping back and forth between them
so boss uses this this this bottom
version of it - to enable it to have
two-way low latency communication and
now we get to Stroeve so so before is
there a question okay
before we get to what comments oh yeah
it's like comet yeah sorry um comet and
Bosh are are similar technologies and
people have written long Polar's that
don't do comment or Bosh they'd use
custom protocols cut the CouchDB team is
working on such a thing for instance so
here's some examples of things this is a
group chat application that my team
wrote that uses this i hope i'm still
logged in but you know you can see I can
type stuff and it appears instantly we
can log in and do all that kind of stuff
this is my presence up here these are
the other people in the room so they can
talk back so you can see the latency is
pretty low because I'm actually waiting
for the server to reset to send me the
message that I just typed to show it on
the screen this is another application
we wrote chess park where you can play
chess games the most popular speed of
game on this service is all the moves in
one minute per side so we had to get it
extremely low latency for this to work
at all and maybe I'll give it a second
to see if it loads up really fast so you
can sort of see the how dynamic the
initial interface is so this actually
just this is a full XMPP client we have
a the roster over here on the left the
private chats and group chats will load
here on the right this middle list is
games that people are actively looking
for and it will be changing the whole
time we're looking at this page like
there's two just disappeared because
they started we can watch games and all
kinds of stuff like that so this site is
incredibly dynamic and it's using the
api's that is using our XMPP right in
the JavaScript so we're building XMPP
protocol messages we're sending them
it has latency characteristics similar
to a desktop client and its end as far
as the developers are concerned they're
not that they don't ever see the you
know the long polling bits of it it
looks like a real stateful XMPP
connection to them
and so I'll get into the strophe so
strophe is the library I wrote the
JavaScript library I wrote them to make
XMPP in the web browsers possible it is
mostly for writing XMPP clients you you
can't really write a server with Bosh
and in the browser's well I don't know
why you would want to but even if you
wanted to it's not really possible with
the protocol it's it's in pure
JavaScript although I'll probably
integrate your project over there
fliends so there might be in the visible
flash thing so we can do cross domain
stuff really easily and we made it to
power real-time web applications where
there's you know lots of collaboration
and dynamicism it's fully documented the
whole library has documents even for
internal structures so if you're not
sure how something works you can just
look it up and it's highly optimized and
what I mean by this is not necessarily
that this is the fastest xhr
implementation on earth I mean that
there's a lot of edge cases in xhr when
you're doing lots and XML HTTP requests
when you're doing lots of these requests
I mean the the xhr object only
understands HTTP error codes for
instance so it knows if you get a 404 it
knows if you get a 500 error if your
proxy server drops the request and never
returns any data it doesn't know what to
do about that if the server never
returns anything it doesn't know what to
do about that
so strophe is highly optimized in the
sense that it will detect if we were
supposed to get data back and didn't
because if you if you don't time out and
do fancy stuff like that you're you're
low latency dreams will be smashed to
bits because you'll be waiting like nine
minutes for the proxy server to timeout
on the request response and the whole
time the user can't do anything so
there's a like most of the grueling
parts of strophe are all error handling
of xhr stuff and it's been well tested
we've used it on chess Park for about
three and a half years now
it works on the Wii it works on the
iPhone I mean it literally works pretty
much anywhere there's a couple people
now on doing Adobe AIR apps that that
use the same that you strop we built it
for chess park but it's an open source
project
we use it to power stanczyk which is now
collective which is a real-time search
engine that I work on and speak which is
the group application I showed you guys
and and a bunch of different companies
use it neuro so st uses it to put in
chat where the subtitles go and TV shows
so you can chat with all other people
you know who have Neuros OSD boxes which
is probably not very many so let's let's
like actually build something or or at
least see how something is built with
this library so first we have to manage
the connection because each XMPP think
has a connection and we have to do a
connection so we just do VAR connection
equals new stroke connection and this
URL is going to be the URL of the Boche
connection manager and normally this is
you know just someone will tell you what
this URL is or you'll set up a Bosch
connection manager and you'll give it
the URL for that once you have this
connection object you can call the
connect function and pass it the
username and password and there's also a
callback and the callback will get
called whenever the connection state
changes if you pass in a username like
user at domain then the server will give
you a resource we saw those earlier so
every every connection has one of these
you can pass in a resource and it'll use
that one or you can do what's called
sass all anonymous authentication which
means you sort of login as a guest you
have no authentication credentials
you don't need a username and password
you just login with the server or the
server and the resource and you'll get
an account and you can interact with the
server we use this for for applications
which don't that we don't have user
credentials for or for instance on speak
if you first come to the site we log you
in anonymously and let you use the
service without having you sign up and
then later if you sign up we you can
upgrade your your connection to an
authenticated one the connection
callback just reports the status so
whenever Stroeve it will attempt to
connect it will attempt to authenticate
it'll and it'll have connection errors
and each time one of these states
happens you'll get the callback will get
notified that it happened it's all the
normal stuff that you would expect the
main one that you want to work with is
you you're sitting around waiting for
the connected state and then you can
actually do some stuff
and this is how you would do that so
this is the callback handler for that I
would pass to connect and this one's
really simple it just waits until I get
the status connected and then it does
some stuff and I don't have the stuff
that it does in here right now but
usually you would set an initial
presence to the server so you would tell
a server server like hey I'm actually
here and you would do queries for your
roster and stuff like that if you were
writing an IM type client and then we
need to be able to send data once we're
connected and now we can just call
connection send and we have to send it
XML and the reason we send it these are
actually Dom objects and the reason we
do that is if we send invalid XML for
instance if we craft it by hand and
forget to escape something then X and PP
will just drop the connection so we
don't allow the user to do that we make
them give us nice XML and that way we
don't have anything to worry about and
I'll talk about some about building that
later and then disconnecting is really
easy we just call disconnect so that's
pretty much all of it except for
handling events so XMPP is all about
being event-driven
just like most UI code and we have
interaction events we have stamp timed
events and we have stanza events now
interaction events are sort of like when
a user clicks on a button then you need
to do something to it so for instance if
we have a send button the interaction
event gets called and and you know this
is just I'm using jQuery here as an
example but this is possible in any of
the libraries pretty much you build a
message stanza send a message for it for
instance if you have stanza events that
means that you set up a hand you you
call this function add handler and you
tell what kind of stanzas you're looking
for so here we're looking for a message
stanza of type chat and when that when
we whenever the connection sees one of
those it's going to call on message
which is a just a callback function and
this is what that callback function
might look like it gets passed in the
message Dom element and we can and we
can do whatever we want with that
message like for instance extracting out
the message body and displaying it on
screen and then we return true which
means that this handler will
keep getting called back if we return
false here then the handler will sort of
disappear
so if you were doing a one-off handler
or something that needed chaining you
might return a different value there and
then IQ stans's which we talked about
which have to have results Oh another
good example of when you would have a
stands a handler if you're answering it
is if someone sends you an IQ stanza
you're required to return a result and
the way you would do that is you would
just listen for IQ stanzas so for
instance here is type equals get and the
the sort of the extension protocol thing
they're using is jabber IQ version which
is actually the thing that you use to
say like what version of the client
software are you running so someone
might send you this just to see what
kind of features you support and then
the other side is you might you'll send
an IQ and you're going to expect a
response that you have to watch for and
so here we we're still watching for IQ
messages we don't care about what the
type is because remember this might be
result it might be error and we're going
to handle both of them here and we know
that we want to handle this disco one
because we normally what will happen is
you'll you'll create a unique ID you'll
send out an IQ stanza and then you'll
use that unique ID here and the handler
to handle the message and then timed
handlers are just this is just a silly
wrapper around set timeout so that
everything is consistent and you guys
can use that one or you can use jquery's
or whatever at the time that I
originally wrote stuff there wasn't a
jQuery so that's why some of this stuff
ended up in here and in building stanzas
is sort of the last bit so I made this
thing called strophe builder because
working with the Dom API is sort of
gnarly and this is inspired by jQuery it
always returns a surf builder or almost
always so you can do this chaining like
people are familiar with with jQuery and
this is what it looks like at the basic
level so you have a stanza and you call
stroke builder you say message you pass
it some attributes and that'll build you
a message and all the methods are
chainable like I said so for instance
you can add a child
to the Dom with the name and attributes
just like we did there we can add a text
node very easily we can add pre-made
children so for instance if you have an
element already that you receive then
you're just you know plucking out some
bit of it and putting it back in you can
use C node and you can modify the
attributes this is really useful if you
have something that builds basic
attribute you know stanzas and you just
have to put a new two attribute on it or
something like that and we have a thing
that traverses up the tree so when you
add a child the next child will be a
child of that child so it sort of goes
downwards so you need a function to sort
of go back up the stack so you can make
siblings and here's some examples of how
it works this is building a message very
similar to the long that we saw earlier
so we create a message we send it to
somebody it's type equals chat we create
a child of type body and within that
child we create a text node of hello
world here's a slightly more complicated
one
this one is the same as the one we just
saw except that I go back up the stack
and I make an HTML child which uses the
XHTML I am specification which is a way
to send HTML messages over in your XMPP
messages and then I make a body tag and
Pia and have hi and then there's a bunch
of convenience functions for stroke
builders because typing new stroke
builder is pretty long thing to type so
we have dollar sign press dollar sign
message dollar sign IQ these will make
the three basic XMPP stanzas along with
their attributes without having to do
any extra work so this is the shortest
stroke builder thing that you can do
dollar sign pres parens and that's the
shortest valid XMPP message you can also
send here's the same message that we
originally saw like the hello world one
with the body and XMPP rocks but with
this convenience function and now we get
to the unchangeable methods and there's
just a couple of these we have two
string which serializes the Dom element
to a string so you can see what it looks
like or printed out somewhere
we have dot tree which will return it's
sort of like jquery's get it just
returns us the actual top-level Dom tree
and those that's it for the untrainable
ones so let's look at an actual
application that uses this stuff and
first I'm just going to show you the
application so what this application
does is I'm going to type a server
address in here it's going to connect to
the XMPP server it's going to ask it
what stuff it supports and then it's
going to print it all out to us and
we'll get to see what that looks like so
I have an XMPP server running on
localhost hit connect and here it is
here's the answer so it's pretty simple
this is just a list of features that it
supports it's got a lot of pubsub stuff
on it and stuff it's an easy birdie
server and then this log tab shows us
the actual bosh protocol that got sent
so for instance this one right here is
the Boche is the initial Bosch thing
that sets up the connection and then
there's a bunch of stuff for
authentication that's not really that
interesting and then down here you can
see the IQ stands that we created right
there a get request to localhost with
the Disco info and then this next one is
the server's response and as soon as we
get the server's response we
disconnected and you can see it
disconnected and then the code for this
is really simple as well
so this is the the code for this
function so this is all using jQuery so
in the in the ready function I use
jQuery UI to setup the tabs and then I
hook up the connect button the connect
function is is right here can everybody
read this is it big enough okay so we
prevent the default events we create a
new strove connection with this raw
input and raw output or logging
functions so that's what generated that
XML strophe will call this whenever it
sends or receives anything over the wire
so you can use it for protocol debugging
we grab the server out of the forum
field and then we call here's the
connection connect function since we're
just making an anonymous connection we
don't need a password so that's why
that's null and it uses on connect event
for the callback on connect event is
right here and here it's very simple we
only handle two states connected and
disconnected and all and and
disconnected all we do is print out some
stuff and connected we add a handler for
this IQ result that we're looking for
and you can see here that I don't
actually say IQ anywhere because we know
it's going to come back with the ID so
all we really need to check for is the
ID and here you can see I'm looking for
the result so the error case is totally
not being handled you might have a
second handler for the error case to the
logic simpler or you might do them both
in the same handler I find it's usually
better to get as specific as possible
with the handlers and then I build the
IQ stanza and then I send it out and so
once the result comes back if an error
comes back nothing will happen if a
result comes back this on result
callback will get called which is right
here which is the longest function in
here and this basically just writes a
bunch of stuff to a special div here
where I'm using jQuery to parse out I'm
getting a Dom object back from the
handler of the IQ and jQuery makes it
really easy to chop this thing up and
rip stuff out of it so I grab all the
identity nodes which are one of the
things that returns in service discovery
I build this little table which has a
bunch of that stuff here I find all the
feature elements in that return that
result and I build a little list of
feature elements and
I call connection disconnect and we
disconnect which which we all saw does
anybody have any questions on that
yeah when you when you see their IQ
response this this function gets called
and and and it's really easy I mean all
I do is use jQuery to pick stuff out of
the Dom element that gets returned and
then I write a bunch of HTML there um
obviously if you are having like the the
chest park stuff has a lot of different
handlers for different cases so we have
handlers for women or private messages
receive from one a group chat messages
received for when game moves are sent
from when you send game moves and all
kinds of stuff like that so the and so
the handlers you'll have a bunch of them
and some of them will only use ones like
for instance this this IQ handler right
here we only use it once so here it
returns null which is a sort of
equivalent to false and this handler
will go away afterwards because we're
never going to get another IQ result
that matches this because it's going to
the new IQs have to have unique IDs so
they'll never be another one
so plugins one of the things about XMPP
it's very extensible you can write new
bits of stanzas and just stick them in
there so for instance at chess Park when
we want to chess moves in there we just
made a special namespace for for our
chess stanzas and then we put them in
messages there's a lot of extensions
defined already just to just to show you
guys the number here which hopefully
won't scare you you know that there's a
there's a couple hundred of these
extensions and for all kinds of things
some of these are used a lot like for
instance multi-user chat is one that's
use a lot service discovery is used a
lot and there's some that are almost
never used like soap over XMPP only a
few crazy people are using that but this
list keeps going so so for instance I
mean there's stuff in here like jingle
is is for multimedia conferencing with
sip one of the nice things about XMPP if
you have some crazy use case you don't
actually have to design all the protocol
you might have to write the code that
supports this protocol but you don't
have to think of all the edge cases that
can happen because there's a giant group
of people that sort of works these out
for you so in order to support all that
stuff like strophe is very simple you've
seen that it only has like half a dozen
functions and yet there's this whole
page full of extensions that that people
do so I wanted to have a way for people
to do plugins and the plugins would be
things like it would handle the soap
over XMPP stuff and it would just give
you a simple function to call to do that
like soaps and or with publish/subscribe
you would want to just do subscribe you
don't actually want to have to build the
IQ message that gets sent to the server
that does the subscription and handle
the error cases and so the plug-in
infrastructure just has two functions
you can add namespaces these are these
are as I said these are the things that
sort of define the extensions so each
extension has to have be name spaced
this is for instance the xtml XHTML IM
namespace and that's actually the full
namespace there so your plug-in can add
new namespaces that you can use so you
don't have to keep writing on and it has
ADD connection plug-in and you have the
name of the plug-in and you just
pass in an object and what will happen
is your connection object will get a new
attribute which is would be my plugin in
this case which will get initialized
whenever your connection is initialized
and so you can have all of your fancy
functions like subscribe and stuff in
this object and I wrote a little
identical who here is familiar with
identica so identica has an XMPP bot
that will send you micro blogging
messages just like Twitter used to have
and got rid of so I wrote a little
plug-in to show you guys that did
essentially is an identical client very
simple one and here I have two I'm going
to use my gmail credentials to login to
Gmail because that's where all my
identical messages go and you have to
forgive me because I'm typing my long
password with one hand here so we
connect and it'll take a second because
the wireless is a little slow here and
then it'll say it'll switch to waiting
for messages and then there's a handler
here and whenever an identical message
comes in it will add it to this list
here okay so we can look at the log file
and see what it's doing so we can see
that it's still going through the
connection stuff they are finally
connected and here's a bunch of stuff
that happens when you log in this is all
of the people in my roster sending me
their capabilities so that I can see if
they have music information they want to
share with me and stuff and so now it's
waiting for messages so now if I go to
identica and I type something
even this is slow
so in any case it will appear in there
you'll have to trust me I guess because
the Wi-Fi is not not behaving we can
also send messages from here like those
interaction events I talked about before
and we hit Send it'll actually build the
stanza and send it and of course it
since identicos apparently being really
slow right now it'll take a while to
show up and I can show you the code for
this oh there it is so it shows up there
and this is actually using XHTML I M so
this is actually a clickable link that
will go to my profile page and the code
for this is just barely more complicated
than the code I just showed you so we
have almost the same on the connect
function so when we call connect we set
up the connection in the same way except
now we have a full username and password
we call on connect event is the callback
when we connect we send initial presence
and then when we write that waiting for
messages thing and we have there's a
missing handler here that I accidentally
deleted so we there's a in this on
connect the first thing we would have to
do is set up the handler that handles
messages coming in and for some reason I
deleted that right before I walked up
here which is crazy but and then here's
the stuff that happens when when the
handler would have gotten called wait a
minute okay somehow I munched two
different files oh here it is down here
so here's the send so you can see us
building the message and we call
connection send and send it out I'm not
sure what happened to the to the handler
but essentially whenever the body comes
in all I did was find the div with
jQuery and and and extract the HTML I am
body and just throw it back in there
yep
so the authentication so you can do sass
little anonymous you can do digest md5
you can do text plane all those some
server supports ass'll external so you
can do things like Kerberos
authentication Google uses it for token
authentication with with their own
instant messaging stuff so pretty much
all the SAS whole stuff you can do there
now what's coming in the future I want
to do XPath matching with strophe
because the add handler thing has like
four or five parameters and they're
really restrictive and I want to just be
able to write XPath queries to be very
precise with what kind of stanzas I want
and this is what it'll look like when it
gets done so this would be the message
handler for you if you calm and type
equals chat so that's that's much better
because not only do you get to write
this very specific query but it's also
sort of error checking it as well right
so you can write a really specific query
and then random messages won't match
whereas with the handler code we have
now you have to sort of get all messages
from from of a particular type this is
actually taking me longer than I wanted
because none of the normal Dom XPath
stuff works on partial Dom elements that
don't already exist in a tree and then
there's the multi session problem that
some people are having in that uh if
you're if you're running an XMPP
connection in one tab and you open a new
tab now you have to XMPP connection and
you have to sort of keep them in sync so
we're working on extending bosh with the
thing for that so that all of the tabs
sort of have the same state without
doing any horrible hacks and the code is
available at code dot stands EECOM slash
Stroeve um the second link is my blog I
write about this stuff a lot there's
more tutorials there on various XMPP
topics and and things like that and my
email address if you need to get ahold
of me as jacket collector are there any
questions all this is true for the boss
you're
to Duke's level differences between
which you just covered it in comedy so
comment is only publish/subscribe
semantics so that they're very similar
in that they both allow you to a low
latency communication comment defines
the semantics of the communication as
subscribing to some path and then you
get events for that path that's possible
an XMPP through pub/sub and also
presence works like that but you can
also do many many other things in
extensions over X and P P so for
instance we can do io data we can do
file transfers we can do lots of the
stuff that's already baked into X and P
P because people have worked on these
extensions where as well comment you
would have to sort of make a new
protocol over the publish/subscribe
semantics to accomplish the same thing
so if you're if you're looking for
something really really simple and you
all you need is pub/sub then comment
works great I found that what happens is
people start with something really
really simple and then all of a sudden
they want file transfers and now they're
designing protocols and so it's easier
to start with this because you already
have all the protocols design because
that's the hard work implementing a
protocol is not too bad yeah so for
instance the Major League Baseball chat
which has millions of concurrent users
is backed by a Jeopardy XMPP server so
it scales pretty well yes it and and
just the other scaling of topic as
google talk has millions of concurrent
users as well and that's XMPP so so
Bosh's is essentially it's kind of like
a web proxy server except a web request
comes in it makes a TCP connection to an
XMPP server a two-way one and holds it
open and then does the long polling
translation between stanzas so for
instance like you can you can see what
this looks like in the log here so the
Boche wraps it in this body tag so
here's this body there's an empty body
tag but somebody find one so here's a
body tag with stuff in it right and this
body tag is just a simple wrapper so the
so the Boche server will get will get
this XML element it will strip off the
body out it takes the body tag checks to
make sure
that some of the security stuff matches
so you can't spoof the connections and
stuff and then the stuff that's inside
the body tag it forwards over the TCP
connection to the XMPP server and then
when stuff comes back it just sends it
to you when it has waiting requests to
fulfill so it's just you can do any of
those things so because of the same
domain policy you usually have to
reverse proxy a Bosch connection manager
under the URL where you're serving index
dot HTML or wherever your app lives and
with something like flensed you can do
cross domain by using the same XML HTTP
request API but using Flash's cross
domain stuff and there are so far for
our applications we run our own Bosch
servers we proxy them under the an
engine X and which serves static content
and we do that that way the comment
requires the same thing you have a comet
comet D running that is equivalent to
sort of the Boche connection manager it
translates your incoming stuff into more
stateful stuff on the server side yes
that's a great question
so locally you don't have to have an
XMPP server locally because because the
connection manager if you run one that's
not built into an XMPP server can
connect to any XMPP server you saw me I
just connected to Gmail for instance so
I have a connection manager running on
this local machine and what I do for
local development is I wrote a simple
utility that will serve the current
directory over HTTP but also keep
reverse proxy configurations and I have
a little text file in there that has a
little configuration for where the
reverse proxies are which reverse proxy
is the bossy so I just type tape in a
directory and it sets up a local HTTP
server just that I short-lived that
serves the directory handles the Boche
stuff and that's how I do local
development and we deploy it there's
usually an engine ax thing reverse
proxying the Boche server and serving
static files or in the case of chess
park there's a django app just wash
server
on the Bosch server I use and the guy on
my team wrote is called Punjab and you
can find it it yeah yeah so code dot
Sanjay Khan flash strophe is the is this
library but slash Punjab is our Bosch
server and the speak site which I showed
you guys is also open source and that's
available at the same site huh you
should've bought this game had a grenade
and have synchronous that mean that the
behavior is called is literally no no
that it's still an asynchronous Ajax
call I'm sure they put synchronous in
there because it made the acronym nice
sounding and but but it is synchronous
in a way that your the long polling is
synchronous right you're leaving a
connection out there on the server and
you're waiting for a response to come
back but but that that's wrapped up for
you in Stroeve so strophe presents you a
completely asynchronous API you define
event handlers stanzas come in and match
and then they trigger events yes Pierre
Bossier shows yes most of the jabber
servers include their own Bosh servers
the difference is there's a good side
and a bad side to that the good sizes is
you have no serialization overhead the
xml comes in it gets serialized for the
server and it goes all through the
server and it only gets to realize when
it comes back out to you with a normal
box server you serialize it to the boss
Bosh connection it realizes it to the
TCP connection to go to the server and
so there's an extra serialization step
what you lose is you can't connect to
arbitrary X and P P servers so if I used
I can switch it to the into my eg
Birdy's Bosh server here by just
switching the URL but what but I'll only
be able to connect locally to that eg
Bertie server I won't be able to make a
connection to Gmail for instance and it
depends on the application which of
these is right for you if you if you
want to support the federated network of
XMPP users so for instance on the speak
site this is a requirement because we
want people to be able to log in with
their Gmail credentials and access their
own Google Talk stuff we don't need want
you to have to have a speak comm account
but for other services I drop a oh and
Yammer and stuff they use anonymous
connections and they just and they do
the authentication at a lower layer
or a higher layer I guess yes
last question back in the picture
everything silk is asynchronous
are you getting partial responses back
from the screen what is every stanza it
someone for us you can send multiple
stanzas but you'll never get a partial
stanza the Bosch connection manager will
only ever send you a complete stanza and
and you can only send complete stanzas
but you can send as many as you want
there's also some neat functions inside
Stroeve if you know you're going to be
sending just a bunch of data from say a
bunch of different pieces of code for
instance that connections start up which
is pretty common you can tell it to
pause it will queue up all of that stuff
and then when you hit start it will send
it all in one request so you can sort of
bootstrap the initialization stuff yes
so you could the thing that XML really
buys you here is that there's no way to
extend a JSON array so say you have say
that this was all Jason and I had a
message stanza and the two is a string
the in XML I can extend attributes by
name spacing them and I can extend any
any tag by putting a child in it and
name spacing that but you can only do
that in parts of JSON so you would have
to have sort of a complicated extensible
JSON format that you would use so you
would lose some of the simplicity I
think of JSON if you went that way
because it's really nice to be able to
send those messages that are bodies
that's standardized write the body tag
is not namespaced but when I send a
chess move for instance it'll be you
know move and they'll have xmlns just
Park / move or something like that and
then I can put whatever I want in there
and the nice thing is the server's if
they don't understand what the data is
they just won't look at it and they'll
pass it all the way to the clients so
with so with JSON you would have to sort
of I'm not sure how you would extend
JSON in the same way unless you decided
to use all objects and no little
any other questions okay thank you very
much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>