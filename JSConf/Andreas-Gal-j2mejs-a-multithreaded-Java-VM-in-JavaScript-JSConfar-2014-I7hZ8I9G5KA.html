<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Andreas Gal: j2me.js - a multi-threaded Java VM in JavaScript | JSConf.ar 2014 | Coder Coacher - Coaching Coders</title><meta content="Andreas Gal: j2me.js - a multi-threaded Java VM in JavaScript | JSConf.ar 2014 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Andreas Gal: j2me.js - a multi-threaded Java VM in JavaScript | JSConf.ar 2014</b></h2><h5 class="post__date">2015-05-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/I7hZ8I9G5KA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay since we were so nice to wait for
me I will actually do tell you how I met
Brandon it was about seven and a half
years ago or so and I wasn't like in
academia as you heard of a PhD in
computer science and my entire career
was really going towards being a
professor so I've worked all my life
being a professor I'm in two different
schools I got every degree available in
my field and I was trying to write
compilers and back then in the beginning
I was writing Java compilers and then
add the idea to write a JavaScript
compiler and the entire academic field
that I've worked for thought that it's a
really dumb idea I submitted paper after
paper showing how we can make JavaScript
go really fast and everyone told me that
I'm solving the wrong problem that
problem was already solved someone
invented java and typed languages all
you had to do is use Java instead of
JavaScript and then you wouldn't need
compilers for JavaScript so I couldn't
convince anyone in my own field in
academia to do javascript compilation i
ran into brandon this was all the time
when chrome was about to come out and we
knew that performance would kind of heat
up in the web and brandon hired me to
missoula to write a compiler for
javascript and we together released one
the the first commercially available
JavaScript compiler a couple days before
actually chrome came out so that's how
my Brendan and it was meant to be a very
short stay I was originally planned to
come up for three months the estimated
you can write a compiler for javascript
in three months and somehow ended up
never leaving all right but now let's
talk about Java and JavaScript some more
my talk today is going to explore why we
are doing Java and JavaScript but also I
one will be a little bit technical and
show you a little bit of the details of
Java and show you how you can implement
Java in JavaScript and some in some
interesting things emerge if you do that
first of all let me explain why we would
do this why would anyone in the year
2014 try to write a Java VM for
JavaScript Java v almost successfully
removed from the web stack today it's
very very rare that you're running
across Java applets
mostly banks I think that use it still
for security and login mechanisms their
reasons to you this year you might know
that we started bringing smartphones to
market about a year ago firefox OS and
firefox OS is targeting parts of the
world that have a lot of people who
currently have a feature phone and
they're looking to get their first
smartphone so device we are seeing here
it's actually a device we launched about
two months ago in India the price with
this device is around 30 US dollars so
it's about the cost of like a lunch in
San Francisco you can get a smartphone
and this thing is completed powered by
html5 so everything you can see in this
phone everything that runs on the phone
all the apps the UI itself everything is
written by html5 in html5 one problem we
run into is that it's over the top
messaging apps like Watsa are very
popular around the world and it differs
a little bit where what is popular but
you can see that the parts of the world
very particularly focusing on is Firefox
OS such as here in Latin but also I Asia
in those parts of the world there's
specific messaging apps that are really
popular and it's very hard to convince a
maker of this messaging app to make an
appt for html5 in some of these cases
because there's not a lot of devices out
there where today you can only bring
html5 content to so an Android you can
run an html5 app but you can also run an
Android app so these guys have all
written android apps for us there's no
Android in our stack there's no iOS
there's only the web and html5 so we
needed somehow away to get these apps to
run in our platform in some cases we
were able to convince them that html5 is
the future and they should write an
html5 app for the platform line for
example did that but a couple other guys
didn't do that and if you look at this
graph this data is about a year old but
it shows that in some parts of the world
some of these messaging apps are very
very popular and if you don't have them
on your phone nobody's going to buy it
look down here for example in many parts
of Latin if you don't have what's up
it's really difficult to explain to
someone why they would want to buy your
so we needed a way to have what's up on
this device even if what's up was not
willing to make an appt an html5 just
yet because when we started last year we
had we started with 0 users so there's
basic two things you can do one you can
go ahead and try to just write your own
wats up implementation or line
implementation we did that and some of
those who can get in the marketplace but
people often ask specifically for what's
up so to go in a store and want to buy a
phone this what's up or is lying or his
y ver and in these cases people in the
store would say well it doesn't have
what's up but the moment you start a
sentence with it doesn't have what's up
the person basically media doesn't want
to phone anymore so to solve this
problem somehow we have to get what's up
onto our phone without relying on them
making a wats up version until the
enough users that people right naturally
software for html5 as well that's kind
of the whole idea what Mozilla is all
about right we want to try to make html5
as successful mobile as it's today on a
desktop it gets even a little bit worse
because the main competition for Firefox
OS phones are these things future phones
so for the price range of the very
entry-level Firefox OS devices that's
kind of the competition you can get some
like Nokia feature phone with a dart pad
in the small screen these things
actually many of these messaging apps
are available so this makes the
situation for us a little bit more
tricky because on the thing we compete
with which is so much worse and hardware
and it doesn't have proper web
experience doesn't have a touch screen
but it has whatsapp so people go in a
store and I'm on a thing with what's up
and then they get this here and not the
smartphone at the same time though this
is actually also a nice solution because
as I said these things run these
messaging apps so the idea we were
looking at how can we take these
messaging apps that are designed for
these feature phones and run them on
Firefox OS these things of course run
Java all right in case you didn't know
that if you ever have to install Java
and I hope nobody here is that
unfortunate when you install that it
tells you that this Oh
three billion devices or three billion
phones running java I'm not sure it's
still true today but it's probably
roughly the right ballpark there's
literally billions of phones out there
anything that's not a smartphone today
tends to run Java inside of it and it
runs a very specific version of Java
that's called j2me and I will kind of
explain where that fits in many of you
have probably never seen this that's not
a problem it's just this is all stuff
this is like I pulled this we can see
how bad the phones are this is like a 14
year old picture so this is what some
thought the world would look like in the
future like 14 years ago so basically
idea was that everything is Java all the
way from Java cards this is this is sim
cards new phone for example another on
the way right side here and then there's
this lightweight versions of Java this
is a micro edition or limited device
edition of Java and then here's the
grown-up job on desktop a nun service of
course today this totally looks
different right so the only place where
Java really survived is in sim cards
that's still javo today and then on a
very far end here in enterprise and
servers there's still some Java in the
middle of it is small is dead the
particular piece we care about is this
one here the limited configuration of
Java that runs on these feature phones
the vm that that was built for that is
called kvm or the killer x 3m that meant
to express that these things are
designed to run this relatively little
memory that you have available in his
future phones so there's a couple
different ways how we can go and
implement a Java VM in our phone to
explain that of this architecture
diagram here or Firefox OS I have no
idea what the Japanese characters mean
in case you wonder I just found this and
its really cool graphics I also don't
have no idea what the ice cone means but
it was really kind of funny and I like
the picture so I decided to use this it
does show the necessary things I have to
show so just ignore the Japanese
characters and ignore the ice cream cone
for a moment so we have it at the bottom
we have gonk which is our version of
Linux and a couple other low-level
things that are really boring and on top
of that is gecko gecko is mozillas
rendering engine that's the thing that
displays the web and then on top of
gecko des Gaia Gaia is this html5
experience that we talked about so all
the things that you see in Firefox OS
are all implemented in html5 and that's
what we call Gaia so the simplest way to
implement this would be of course to
take a Java VM symbolized here to the
inventor of Java and you could just kind
of like stick that on top of gong next
to gecko and basically just kind of veg
it into our phone home and then we could
run messaging things on top of that of
course this is bad at least for two
reasons first of all Java has a really
bad track record with security um
they're still finding really fundamental
bugs in Java and they often really bad
because they affect all browsers at the
same time so if you do this if you take
a Java VM and kind of like stick it into
our system since the Java VM would be
sitting directly on top of Linux and the
OS core we would basically create a
second surface for vulnerabilities there
could be like additional bugs in the
Java VM and they would create additional
room for the phone to be broken into so
that's a really bad idea to kind of put
it in addition to the rendering engine
you basically have twice as much
opportunity for something to go wrong
and in the second reason of course is
that it would be really bad karma to put
another Java VM into the vet stack right
so we got to the point where you don't
want a neat job on a desktop and this
feature phones over the next couple
years going out of fashion java will
also go out of fashion with it so at
this point putting a Java VM into a
web-based and standards-based an
html5-based phone it seems like a really
bad idea so we decided not to go that
route so of course what that leaves us
is this then is to take our little
diagram here with a Japanese characters
in the ice cream cone and simply take a
Java VM and put it on top of the entire
system so we simply avoid a nap in html5
that implement the Java VM and that app
knows how to download the messaging app
itself and I can run this whole thing on
an existing phone the really nice part
of this is that at the time that we
started this which was about four or
five months ago we already had a large
number of phones out in the field that
all don't have the original version of
some of these messaging apps if we do it
this way since we're not using any
privileged html5 capabilities you're not
kind of trying to bypass the platform in
any way we can actually make an appt an
html5 web app like this and just put it
in a marketplace where people can
download it and it can use this let me
sort having to buy a new phone so this
is very nice because we address the
existing on set of phones as well all
right the the downside of it of course
is now we have to write a Java VM in
JavaScript that's very exciting as I
said my background is in writing
compilers that's what i did in academia
before brennan kind of freed me from
academia let's put this way and my
entire background net revolves in Java
compilers before i started to JavaScript
compiler so this is one of the reasons
that i found this project particular
interesting because i have done both
extensively i have written several java
VMs and i have written several
implementations of java spoken powders I
never really try to write a Java VM on
top of JavaScript so that seemed very
appealing to me so for the next couple
of slides I will dive a little bit into
technical details and explain to you at
the high level of how Java works and
show you some of the problems that i ran
into trying to build a Java VM that's
really ready to run production level
code on a device like this don't worry
too much if you don't see on understand
some of the details for example there
will be no quiz after my talk on the
details of this slide this is merely
meant to kind of highlight some of the
concepts need to understand so we can
understand the next slide so in this
slide here really the only thing you
should memorize is that Java is built
from class files every Java program that
you get consists of a large number of
class files and each class file
represents one class and these things
are stored in a binary format it's
basically an array of bytes that
contains information about the class
itself it contains the fields and the
methods of a class
the actual code which is sort of the
bytecode the bytecode you can think of
as a sequence of bytes that explains
what instruction the vm should take and
the vm goes step-by-step through these
by code instructions so really all you
have to do to run a Java program is you
have to find a way how you can parse
these class files and then you write an
interpreter for this language this java
bytecode language and then you run that
interpreter over the code that you find
in these classes and once you have one
class let's your starting class it will
call methods it can call methods in the
same class or it can call to other
classes whenever it calls another class
you have to go and find the class file
for the other class so that's that's the
other than in time magic behind Java now
as I said javac on Java programs consist
of a large number of this class files a
popular messaging app like what's up or
viber is often hundreds of different
classes in addition to that you also
have library classes which are often
thousands of classes it would be of
course kind of awkward to have to carry
around a thousand files if you're
installing a drama program so what they
came up this is jar files a jar file is
a java java like name for a zip file so
it turns out jar fights really are like
zip files they are exactly structured
the same in there basically just a zip
archive miss all the Java class files
inside of that and if you want to
distribute a Java app all you do is you
give someone a jar file and then the vm
can go and read all that stuff out of
the jar file the first problem we run
into is that as i explained what you
want to do is we want to write an app
that knows how to run a Java program and
it will get that actual Java program
from whoever is distributing the Java
program not from us so the first step we
have to make sure of is that this Java
VM that we are writing can read this
original jar files so we need to be able
to parse zip files fortunately that's
something I had to do before so we did
PDF ojs a couple years ago to display
PDF documents as html5 and there
Oh as well the first problem we have to
solve is that PDF documents are
basically zip files as well so you can
if you can see a mean here like
everything out there is a fob basically
and we had actually implemented for PDF
ojs a zip file reader lets up on github
and I'd lying around there for like the
last two years and we didn't touch it
since then so I took zip file dodge is
my word al-ilah parser for class file so
kind of see how this goes and should
work great right we have again parse
class files now we can read the files
and it totally didn't work at all that
was somewhat unexpected so I spent a
good afternoon trying to find out why
the class files I was getting out of the
jar files did not make any sense and it
turns out that if you read the
specification of zip files which I did
it's a very painful process I hope you
never have to do that it's really it
sucks the specification says that any
zeros at the end of a stream you don't
have to store so if you're storing a
compressed file and the last couple
things in the file are zeros you can
leave out those zeros the program that
parses the zip file is supposed to know
that there's something missing just add
an 0 and I somewhat didn't read this
right the first time we wrote this
implementation so what the code
originally did is if you're running out
of bytes in your typed array and you get
an undefined back you raise an exception
so this is the error of your running
into and the fix of course is very easy
you simply read data from a byte array
and then we just or a 0 in there this is
a trick we will use a little bit later
on a slide as well what this basically
does it it it forces that to be an
integer number and undefined is the
equivalent of the integer number 0 so
whenever we read past the end of this
byte stream then we will start reading
back zeros which is exactly what the
specification calls for the neat part is
that we ship this bug in PDF no Jas for
years so people have looked at like
billions
PDF documents and nobody notices that
this was wrong this must be because the
implementation of jar files and of PDF
readers is separate so the PDF readers
seemed or generators don't seem to
generate this kind of optimization with
zero at the end so since then we
actually fix that in in Firefox as well
all right next step so I had now a way
to read your files after some pain and I
had a way to parse class files the next
step of course is VM we have to go and
get something it will interpret that
byte code and run the actual Java
program for us the most natural way of
doing that these days would be of course
to take and scripting and scripting is
this C++ or C C++ compiler that takes
existing C++ code and it emits through
llvm and a couple other steps JavaScript
from that all the last year actually we
also did an extension of that called
SMGs which I think Brendan will show in
his talk in a little bit that makes it
possible to make this really efficient
so if you do this path if you go from C
C++ down to JavaScript you can get
really really close to native
performance so is this work this would
be great because all i have to do is
take kvm which is written in c and i
could compile that and i would have a vm
in my browser or am I rendering engine
in theory that's really great and you
should always reuse code if you can
however in this case I couldn't find a
license for kvm and I'm serious there's
no license they put on coat there
they're saying that there's no license
and didn't have a license for it so i
started calling up some old friends from
sun and there's really no license out
there so for some reason is out there
there's no license right now to use it
and i couldn't find anyone left at
Oracle who knows how they could slap and
open-source license on to it so I ended
up basically not be able to use kvm
because it's not allowed you can only
use it for research purposes you cannot
use it for any other purpose so this was
very sad because there's essentially no
other open source project that
implements this specific flavor of the
vm there's a couple open-source VMs that
implement a more heavyweight complete
java VMS but nothing implements this
limited configuration at kvm needs
so one of the reasons I'm here today
with you is because son didn't put a
license on kvm 14 years ago I all right
um so divided a vm i went to github and
try to find who else try to do this and
it turns out a whole bunch of people
have tried to write Java VM sin
JavaScript and everyone tends to do that
for about two months before they give up
so I looked at all the different
implementations that were completely
incomplete and the one I like the best
is called no JVM I liked it because the
code structure was gonna be very nice
and neat or maybe just because his style
match my random style very well but
anyway this was the one that I started
with I'd had our classified parser and a
bunch of different other pieces that I
was able to be used so if this actually
was able to get the first hello world
program to work I very quickly realized
that the way that they implemented
natives is a really bad idea so what is
the native and drama as you probably
know Java is a type-safe language so
there's a lot of things you cannot do in
Java you cannot poke around this memory
addresses you cannot directly call a
system call that would invoke some
service from the operating system to do
these things Java has to somehow paul
into c code and this C code is what Java
called native code it's basically in the
vm a way to recognize that you're
calling a special magic method this a
specific name and that name is mapped to
running a c function instead of trying
to run actual javascript by core program
the way that the author of this vm
implemented all the java libraries is
that he basically made every single java
library method a native method so you
would go ahead and JavaScript implement
every single thing did you need in Java
in JavaScript that again is a bad idea
for a couple different reasons first of
all there's a lot of stuff the Java
library that you need for this phones
that you're not very large is about one
megabyte as a compressed jar file if you
I'm
Press that and because classify it's
actually very compact there's actually a
ton of code it's a couple of thousand
classes and those classes have a lot of
different implementation details my life
is too short to like write all of that
again in JavaScript 14 years later and
again I was it kind of felt bad karma to
redo all this work that was done 14
years ago so of course a much better
idea would be even though they cannot
use the same vm that um son did 14 years
ago we could at least use the same
libraries maybe and this is very good
lucky and I'll come back to in a second
the second piece that the second reason
it's a really bad idea to try to write a
Java library in javascript is that even
though the name is very similar and i'm
sure brandon has a couple more jobs on
this one to the name is very similar but
semantically this languages are very
very different so in Java for example if
you invoke a method and give it an
object that is null something very
specific happens in Java and you're
supposed to raise a Java exception so
what the vm has to do basically it's not
just throw an underlying javascript
exception but the vm has to throw a java
exception has to take a different path
running bytecode and it has to give the
program a chance to react properly to
that null exception and because Java is
so old and has gone through so many
rewrites and so many as much cool that's
written for it java applications tend to
often really rely on these very subtle
little details so when you're starting
what's up for example it does rely on
the proper handling of a null objective
reference if you start v-chat like this
it relies on an integer division by zero
being thrown as an exception and being
reported so it would be very difficult
to rewrite all this JavaScript code or
the Java code in JavaScript and make
sure that every single step you maintain
precisely the semantics of Java it would
be of course much better if you can
simply take the library code as Java and
then they simply run that in a vm then
you don't have to write the code
and we have guaranteed to write
semantics so as I said we got lucky here
because son open sourced the library
parts of Java just not the kvm itself so
we could simply download from Sons site
the entire source code of the library
that you need for these phones to work
that saved a ton of effort right there
that's great all right let's talk a bit
about the vm so now we have busy all the
basic pieces we have we can redraw files
you can look at class files we have the
library stuff as bytecode not only in a
vm that can actually run this code the
vm itself is really straightforward as i
said earlier java bytecode this is busy
a sequence of bytes these instructions
in their encoded there's a little bit
less than 255 instructions they're
numbered and there's a definition that
says if you see zero in your byte stream
that's a no op don't do anything let's
go to the next instruction if you see
one its and it pushes on now constant
onto the Java stack and so on so the
most trivial way of implementing this is
simply you go ahead and you've read a
little interpreter it grabs the current
frame and it pulls out the stack and
then it does operations on it you know
infinitely spinning wildly it's
interesting to look at two parts of this
loop or this instruction execution the
1i dough is showed briefly a couple
slides earlier in Java you have strict
typing so in Java actually have
different by code instructions for
adding two integers or adding two long
integers integers are defined as 32-bit
integers and lungs are defined 64-bit
integers so for integer addition what
you have to make sure is that when you
add two numbers they're always
guaranteed come out as an integer again
now we could make sure that the number
that goes in into stack pop on those two
there are always integers however if you
add two integers in JavaScript and its
larger than a 32-bit integer what you
get is a
right this is overflow to the doubles so
JavaScript doesn't have this weird case
of Java where if you go over the
definition range of an integer you can
you kind of come back out on the other
side of the world or like if you add one
to the largest 32-bit integer then you
get a negative number so that's really
nice for javascript but in case of a
Java VM we have to actually emulate the
way java reacts here otherwise if some
program relies on this it wouldn't work
anymore use the same trick here if you
or a number of a 0 you force it to be
converted to an integer number and that
way we can implement the integer
semantics of JavaScript the second one
is a long addition down there and that's
actually bit harder because javascript
cannot directly calculate 64-bit numbers
you have only doubles and a part of the
doubles is reserved for essentially
telling the system where the period goes
so as a result of that we are using
geelong ojs which is the 64-bit math
library that ships with a closure
compiler so all longs that are generated
on the stack evasive wrapped into those
objects that allow you to do 64-bit
computation fortunately on these feature
phones 64-bit math is very rare so it's
important to support it but it's not
really a performance problem a more
interesting instructions get filled and
for those of you who don't like reading
code I promise there's only two or three
slides left before we go back to memes
and things to laugh about I wanted to
show a couple of more examples of stuff
that's was really interesting to
implement and as I said I've written
several Java the ends at this point and
implementing some of the more complex
features of Java this time around in
JavaScript turned out to be very very
different from any other implementation
that I've done a good example for this
get feel what get filled does it gets
the value of a field of a Java object
basically what it does is it resolves
the field into a slot into the object
and then tries to read from that slot
and the object the Java specification
defines certain air
conditions that can happen one example
is if you give get filled and null
object then it is supposed to throw an
exception so as the interpreters running
if object happens to be null then this
race exceptional yield is going to be
invoked so let's look at that for a
second because that's so interesting the
way we did that so what raise exception
and yield does is essentially it raises
an exception another show in a second
what it does and after that it does a
yield by throwing and Java Script
exception so again we are trying to
throw a Java exception by doing some
code and then throwing a JavaScript
exception if you can still follow me at
this point your you re brave the reason
we are doing this is that Java is fully
synchronous language this is very
different from JavaScript we're really
one of the prime directives of
javascript is try to run as little code
as possible in your event loop and don't
hog the event loop run small snippets of
code in a lot of system to run events as
well the way we implement this this
discrepancy is that we have an outer
loop that you can see here in context
prototype execute and it's basically a
loop where if the code that you run in
vm execute throws this specific
exception of vm pause or vm yield where
this code does ability jumps up and goes
back to the event handler returns to the
event loop and then next time we come
around we've a run code again so this is
essentially how we implement the ability
to take a job of thread and at any time
we can d schedule it so the system can
do something else and of course this is
also how to implement multitasking Java
a multi-threaded system all you have to
do is basically several of these things
post it and then you essentially have
several threats that are running at the
same time all right
I promise that you will look at raise
exception and don't very most of this is
not interesting the only piece of really
interesting is the very bottom of this
if you look at the integer array the you
and eight array that we are generating
there what you're actually seeing there
is that your hand assembling some byte
code inside that method so when we are
trying to raise an exception it actually
turns out we cannot directly raise the
exception instead they're generating a
fake java method that we put onto our
java stack that we implementing in
javascript the reason you have to do
that is that there are several steps
necessary to throw an exception and each
of these steps can fail individually the
only way I can handle that for example
the only way I can properly handle
throwing an exception while throwing an
exception is if I have a second method
in between there so what for example can
happen is let's say you're trying to
throw a specific exception with a name
acts and that name doesn't exist then in
that case the vm would throw an
exception telling you that a class could
not be found and when you're throwing
that exception you might want out of
memory which case the vm is going to
throw a lot of memory exception so you
have to have this cascading the assault
in essence this thing this is synthetic
methods that we are throwing in between
the stack this is very neat because on
the simple structure of JavaScript
allows us to do is very efficiently
because we're using this UN day to race
to actually store the stack frames I
mentioned a couple minutes ago the
concept of natives natives are in Java a
way to call to the operating system or
the underlying code in JavaScript of
course there's no notion of that we
simply call the Dom or or into functions
that implement it in a JavaScript
library so freely for this VM native
methods are essentially implementations
of code in JavaScript in throw cc or C++
of course it is a very simple Vater
implementers what we essentially do is
when you're calling a method you supply
the name in the bytecode and we have a
little override list where we look into
do we have a native
his name and if the is so they execute
that JavaScript code instead of trying
to call a java method in interpreter you
can see a couple of moment a shins here
we essentially just calls on native
JavaScript written code that implements
those Java functions all right almost
done one thing we did not expect is that
just how slow this would be so and if
you get under this this point we're
about 100 times slower than the
application running on the future phone
and that was really unexpected because
most of time if you look at Java it
really runs a lot of the complex
operations in native code the reason for
this is that back when was Java was
first written there were no comparison
for java it's a lot of the lot of the
drama programs could not do a lot of
heavy computation in Java itself so the
Java language started to provide a lot
of native see implementations of very
complex functionality to compensate for
the fact that Java was so slow so we
really expected that even if you have a
slow vm for java you should be a little
closer to usable than 100 x away it
turns out that the main reason for this
being this slow is that there's some
very frequently called things in any
programming language let's say comparing
two strings this is called in java
equals in java all these things are
implemented in Java itself so if you're
comparing two strings you have to call
this function here and don't worry I
will not try to read through this what
this does all you have to remember is
that there's like 80 bytes or so of
instructions in here and I highlighted
is read a loop that's inside of this so
what this code does it has a whole bunch
of checking with its video string and
then it goes to that loop and it for
every single character it individually
compares whether it matches the other
string or not and then returns true or
false and of course each of these steps
in this program or Java VM written
JavaScript has to interpret so comparing
two strings in this Java
em with this role is horribly slow we
did a low profile using using the dev
tools and you could you need to see that
most of the time was spent in five or
six functions like this so a very easy
way to fix that of course is to use the
same mechanism we just solve as native
methods a native method again is
something that we implemented JavaScript
instead of in Java so they can simply
take shortcuts so I have a little native
method that overrides the pure Java
implementation and it goes ahead and
simply check that it's a string and if
so it has a string compare at a
JavaScript level that's of course
massively faster because the JavaScript
vm in the browser knows how is that very
efficiently you don't have to be like
circle that interpreter loop all the
time so after the dis work of course we
expected things to get a lot better and
it did get a lot better it got like ten
times faster or so but it was still kind
of painfully slow to use and the reason
for that probably is that actually Java
has advanced fight a bit since it's
early days and today most of time when
you run Java programs you actually also
compile them over to an x86 or arm
machine code so even on this simple
feature phones this lecture compiler
built in that takes the bytecode and
then instead of just running an
interpreter it generates machine code
from the by code and then runs that
machine code and since we still had an
interpreter we were slower than the
teacher phone systems to the point where
the app was not really usable so the the
next step of course is how to compile
Java in JavaScript and this seemed like
a really daunting task for anyone was
written compilers so for those of you at
the the the curse or privilege whichever
way you want to see it to have written a
compiler generating code in a compiler
it's like the most painful part of
compilers because machine code is so
hard to read and very hard to target and
it's also the most exciting thing to
debug like this does you have not debug
in your life until you have trying to
debug some machine code that goes wrong
on you you try to understand what the
hell happens there in some like binary
machine code you're looking at
so they go to this point just seemed
pretty scary quite honestly because
every time I had done it before it was a
really daunting task to deal with
fortunately this is JavaScript right and
it is it is not machine language it's
not x86 and it's not armed and it's a
lot easier to do this in JavaScript and
this was almost unexpected for us if you
look at the compiler that is in j2me
DOJ's that is probably the smallest java
compiler i've ever seen if you think
about it for a moment what it does it
takes a Java code and of course emits
javascript code from it it all the
sudden of course makes a lot of sense
that it's a very small compiler because
what you're doing is almost like an
inversion javascript is actually a much
more semantically rich language than
Java and there's much more powerful
primitives what we're doing is you're
busy taking Java and we are lowering it
to this much higher representation this
is very easy because many things where
you have to painfully assemble in on
machine code instructions for Java are
very very trivial to do in javascript we
also harnessed a couple of other tricks
to make this process particularly easy
when you're trying to compile Java over
to JavaScript we try to use edge as much
of the JavaScript semantics itself so
for example Java objects are represented
through one JavaScript object they're
not trying to implement our own garbage
collector we are not trying to implement
many other pieces of the Java VM but
traditionally you have to implement in
some native language so by making our
Java implementation match very very
closely what the JavaScript language
does the actual compilation approach
itself becomes really trivial so this
what compilation looks like and this
will look eerie familiar to you if you
remember the execute loop it essentially
does the same thing that the execute
function did there's a compile function
you go over the bike code in sequence
and for every byte code operation you
simply omit some code and code in this
case is simply a string if we define up
there and we concatenate into that
string operations in JavaScript that
basically emulate the stack nature of
Java
execute operations that Java is
executing this turned out to be really a
very easy way to compile code this part
was really easy but was a lot less easy
is actually trying to run that code we
are running the stuff in an environment
where content security policies are
enforced and if you don't know what it
is I recommend you go and read right
after this talk because it's very
important that you know what it is photo
so you don't know yet CSP survey how you
can restrict web applications from doing
dangerous things NFL is one of those
things that pretty dangerous because if
you have stuff coming in from the user
and it somehow gets into Avelle that's
usually where things go wrong and some
someone is going to take over your code
and inject some code so we are in an
environment where we can actually not
use a vowel so we can compile it a Java
program just find a JavaScript but then
we cannot actually a valid because the
eval function itself is disallowed I
unfortunately don't have time to go all
the evil details but it takes to bypass
that but essentially what we are doing
is we are firing up a new iframe and you
load the code in that you I frame and
that iframe kind of post messages us
back and forth um as we execute code and
it actually even works so um this was in
surprising to me one of the other
authors Nick on this project came up
with this idea and it's pretty insane if
you really would like to see some fun
code or recommend you take a look at
that all right now we had a demo part of
this it seems that the convention is
when missoula comes to demo or at least
when a muscle as CTO comes to demo
something at a jsf conference you have
to show some sort of live demo and
Brandon already set the precedent that
it usually is a game that you're playing
there is no quake for j2me as far as i
know so i picked the second closest
thing I could find and this is a live
demo so if it doesn't work I'm very
sorry let's see where my bookmarks there
we go so this is the asteroids java game
that is common on these on these phones
and great there's a loose
is screwing here I cannot get to my
storage button see that's great slive
debugging here all right now it works
all right so I can go to menu here so
this is all the java stuff it's running
this is the interpreter loop running
here running this asteroid game this is
a jar file is that you an open source
j2me game you can find on the web GPL
it's really great if you have to get
back a vm if you have a program you have
the source code for find try to debug
with something that you only have to buy
quote for its really painful so here
this is this a touch events from the
browser that are sent over to the Java
VM and I can go ahead here and start
this everything you see here like this
this very ugly yellow you I this is all
rendered in Java unlike 14 year old Java
code that runs on these phones and I can
start this and then I'm live demo I can
I move my ship so this is unfortunate um
let's see if you if you can do this
we'll start this again no I cannot all
right I cannot tell you why I cannot
move my ship right now it worked in a
room there you can believe me or not but
in theory I would we give you like live
demo right now next time I'm definitely
record this not show this life alright
let's go back to our slides all right
before I don't have time first of all
thank you very much for listening to me
going on about Java and JavaScript and
VMS Whitney JavaScript I would like to
acknowledge a couple people that have
worked on this project as many of the
other projects that are started in the
past it's usually me who gets to do the
first fun couple of weeks and a bunch of
people have to come in who have to like
do months of hard work to actually make
it work so there's a whole bunch of
people for missoula and also outside
contributors to help the j2me get it to
the point where it can run java
applications and i recommend you look up
their names since you're interested in
the code for this it's all up on github
and check it out and run some j2me stuff
in your browser thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>