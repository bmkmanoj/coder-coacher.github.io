<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>[CSSconf.eu 2013] Peter Gasston - Future CSS in Web Components | Coder Coacher - Coaching Coders</title><meta content="[CSSconf.eu 2013] Peter Gasston - Future CSS in Web Components - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>[CSSconf.eu 2013] Peter Gasston - Future CSS in Web Components</b></h2><h5 class="post__date">2013-09-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/U45e-zq4bTs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Wow danke Schon gut morgen ich heisse a
pizza egg warning London which means
igloo click here's a sign ich kann ich
sprechen Deutsch and that's it that's
all I'm going to say my job is now my
title is creative technologist but it's
kind of mixed with creative technologist
and front-end lead basically it means I
get to evaluate cool new technologies
web technologies and then tell our
clients what we can and can't do we try
and come up with creative ways for them
to do new stuff and so I have to keep an
eye on what's coming and what other
things that's coming that most excites
me is what I'm here to talk about today
which is web components before I get
into it properly just a couple little
points point number one what you see
here is subject to change but when I say
that I mean just the property names and
some of the values things like that
they're subject to change the concept of
web components is not going away this is
not some floated mooted technology that
may or may not happen this will happen
but possibly not exactly in the format
i'm going to show you the second point
is there will be code there will be lots
of code i've tried to keep it to a
minimum but i can't kind of avoid
telling you about new code stuff without
showing you too much code and it's
ironic that i've been asked to speak
here at CSS comp because CSS is going to
make up about twenty-five percent of
what i'm going to talk about i have to
get through the HTML and javascript
stuff to get to the good CSS stuff at
the end so all the explanation of web
components is just to get me to where I
want to be to talk about CSS so I've
said I'm here to talk about web
components but that's not exactly the
truth what I'm actually here to talk to
you about
is the secret of ultimate power they
didn't know that when you bought your
tickets I want to give you a very quick
demo this is the only time I'm going to
break out the browser window so if you
excuse me for this so what we've got
here is a video element and a video
element you can see the mark up for it
hope that's large enough for everybody
to see it's just a video element with
nothing inside it completely empty but
that video element has a play button and
it has a Sikh bar it has a timer and it
has a volume control it has so where is
all that stuff it's not here in the
markup so we have to rely on the browser
to render that stuff for us but why
should that be the case why can't we
make our where we can make our own with
JavaScript but why can't we why do we
have to use JavaScript to to build this
stuff from scratch why can't we make our
own stuff and there's actually a little
bit of a secret in here I've said it's
empty but if i can find my cursor and i
can enable this option here and now go
back into my markup as you really are
doing this over my shoulder what's this
inside there's a document fragment way
that there's a div and there's lots more
deals and there's tons of divs and
there's input types this video element
is full of markup but none of it's
exposed to you the browser makers of the
browser vendors are holding back this
stuff from you
back to my slides if I can
it's gone back to the ranch late okay so
this thing is actually full of markup
which makes me think what the frig is
going on incorrect slide all of this
stuff the video element the date picker
the progress bar all of this stuff
contains this markup which is not
available to you as developers the
browser makers have created it with HTML
CSS and JavaScript and just not exposed
it to you this is the core of the
concept that's known as the shadow Dom
you've probably heard of the shadow Dom
that's essentially what it is its secret
mark up inside elements it's rendered
but it's invisible in the Dom it's kind
of like when you're on the when you're
on the metro and you're reading a copy
of Faust by Goethe but inside you've
actually got a copy of shades of grey
get high must belong and I don't even
want to know what that means so the
shadow DOM is shades of grey there's
your little tweetable thing for today i
want to show you quickly how you can
make your own shadow Dom the first step
is to create a shadow root and one thing
if you will just want to bluff your way
through talking about the shadow Dom
just put the word shadow and put in
front of a bunch of stuff you can talk
about shadow root shadow Dom shadow host
Shadowcat shadow wars shadow anything
just start talking about shadow stuff
and people go he no shadow Dom the
shadow root is the new route inside the
element and it's very very easy to
create you select an element and you say
create a shadow root that's it what
that's done is that's created that new
roots inside the element and then you
can put some content inside there and
append it to your target element you've
created a shadow Dom inside that element
that's how simple it is the mark-up say
you have this markup so you've got a
deal with an idea foo and inside that is
an h1
and then you apply the rule I've just
done which has created a new shadow root
with an h2 inside it the end result kind
of looks like this the h1 is no longer
visible it's been made invisible and the
shadow route takes preference the shadow
DOM is what shows up just to break that
out a little bit that's the shadow host
which I mentioned before which is the
element we've selected and then the old
original dumb markup was the h1 that's
the real Dom as i call it and then we
created a new element inside that with
H&amp;amp;H to which is the shadow Dom ultimate
power creating elements inside elements
which aren't available to anybody else
you control how the page displays
ultimate power you've taken over the
browser vendors role shadow DOM is one
attempt at solving a problem and there
are other complementary technologies
that sends it so in the main problem
which use HTML and CSS as well and the
problem is this see we've created a nice
widget on our website which does I don't
know something whatever it does doesn't
matter but we've created this widget
we're going to use it extensively across
our whole site and we've created some
CSS which is going to style it blue and
then we go with this widget works so
well on this side I'm going to move it
over to one of my other sites special
effects the problem is on our other site
we have an existing selector with higher
specificity which uses another color
it's overwritten this thing and this is
what prevents us from having like
genuine code reusability today there are
lots of ways we tried to stop this we've
come up with object-oriented CSS be emu
no dr why all this stuff which try to
work around this problem but the problem
is still there this is still a risk of
code reusability the solution lies in
what's called encapsulation and if you
used lots of other object oriented
languages you'll understand
encapsulation already encapsulation
basically means the thing has all it
needs everything it needs is contained
within itself but it also means nothing
gets in and nothing gets out so this
encapsulation would allow us to pick up
a bunch of code and put it on another
website and not have to worry about
inheritance or conflicts anything like
that this is the problem that web
components are solving we actually do
have encapsulation in HTML already it
looks like that you could if you wanted
to put all your stuff inside a separate
document and include it over I frames
and you have some encapsulation the
problems with iframe well they're too
many to list but I'll try a few extra
network requests multiple rendering
contexts and possible cross-origin
resource sharing conflicts which make
basically iframes just not a great
solution so the better encapsulation is
web components shadow DOM is part of web
components but what are the whole thing
one definition would probably be there a
set or a suite of emerging complimentary
standards aimed at making reusable
widgets I would probably best define
them as the biggest change to web
development since xmlhttprequest they're
genuinely going to be that
transformative so the three core
components of the web components
components of web components parts alone
the three bits a web components are
shadow Dom templates and custom elements
shadow Dom we've already covered so I
will move on to talk about templates
hands up if you've used mustache
handlebars some kind of right most of
you see you're aware with how we do
templating at the moment is probably
done something like this we include a
script and you put stuff in it and you
can you can include variables and hold
and all that kind of stuff that's a very
very simple way of doing it so this is a
really common pattern to do this now
which is why we have these JavaScript
libraries but what web standards bodies
are doing now is trying not to create
brand-new stuff and give it to you
they're trying to look at the stuff you
do and make that native so this is one
of the first patterns that is going to
go native so we've got this new template
element and the template element just
does this you define it and then it has
markup inside it so what's the advantage
of doing that instead of using
javascript the mark-up inside this is
inert when the browser loads over the
page with the template element inside it
it does nothing with the dark up that's
inside the template tag the template
element so if I had this I had an
external script being called and an
image being called when I use the
template element none of that stuff gets
loaded the mark-up is completely inert
it does nothing all it's there for is
for you to pick up and use elsewhere if
I go back to my original example I
showed a second ago I've got just an h2
elements of super simple barely worth
making a template for a little bit this
isn't this might be a little bit complex
for you but try to try and stay with me
so what's inside this what's inside the
template element is known as content
everyone's there with me on that ok so
what's in here is known as the content
and we can get this content using the
new content object API so we're going to
clone that element in there we're going
to get the content and make a copy of it
and then we can say choose another
element that's on the page and just
append up our content inside it so given
markup like this we could then clone
what was in our template just append it
inside like that really simple that's
what template it does you're all used to
it everybody knows it
the advantage is at this point the
markup becomes active so if you had
image get images if you had external
resources scripts and everything when
they get inserted into the Dom then they
load then they become active then you
can select them so templates his desk
doing exactly what we've already done
they've just standardized it and use the
power of the browser to make it a little
better this is what browsers do best is
being able to standardize the stuff that
you built on top of them and make them
kind of native give them call
functionality that they couldn't do
otherwise but if you've got templates in
your page as I showed there if they're
in your marker obviously they can only
apply to the same page there's got a
kind of a one-to-one relationship unless
you're using Ajax X so much
xmlhttprequest whatever but by generally
just like that they can only be applied
to the same page so what we want to be
able to do is make those templates more
useful we want to be able to share them
across multiple documents which is where
the import relation type comes in so
just by doing this you can love the link
in your head you can say it's an import
and you just include an HTML fragment
this will be done natively in the
browser so you'll be able to take all
those templates you've already made and
you'll be able to share them across
multiple files from a one-to-one
relationship you suddenly go like that
this is the reusability that we've been
talking about this provides that
reusability or makes it much much easier
that's what this stuff's intended to do
it's not intend to do something brand
new intended to make stuff easier for
you and native so we've talked about
shadow Dom we talked about templates
it's time to come on to custom elements
so you've created stuff with a template
you might have appended a shadow Dom
into it you've made code that's
encapsulated and reusable but it still
relies on you kind of marking up your
content with class names or something
like that which just seems a bit of a
legacy kind of pattern say we created a
special kind of new bar called of wonder
bar
we would still have to use our class
names and everything to apply those
styles but wouldn't it be better again
if we could do that natively if we could
go for real a hundred percent
reusability just like we've seen shadow
Dom gives us access to the elements
inside other elements why can't we have
access to the elements themselves if
we're doing a constant repetitive markup
pattern why shouldn't we be able to make
an element that does that for us and now
we can you just register the element in
the Dom just say okay we register this
element and we going to call it wonder
hyphen bar it has to be something hyphen
something because all HTML elements are
a single word so this by using by
hyphenating it just prevents conflicts
with existing and future HTML elements
so we register that and now we have an
element called the underbar which we can
just place into our document gets
rendered at Dom time when when the DOM
is rendered it behaves just like every
other element on the page and inside
that wunderbar we have our shadow Dom we
have our templates so what we've got
here is fully encapsulated and reusable
elements with shadow Dom with templates
with custom elements we can put stuff
inside our elements and we can just take
that element put it anywhere in our
documents and it work and behave the
same every single place basically what
this does as I've waited before is it
kind of brings semantics back to mark up
rather than your page being covered in
dibs or whatever or extended buttons you
can create your own elements register
them and they will work and they will
provide the exact same functionality
everywhere these oh this is what web
components does encapsulation
reusability dead dead simple what I've
shown you is like the tip of the iceberg
they do loads more you can have per
element api's you can define your own is
exceptionally powerful but the basic set
up to get it up and running the cork
concepts are simple and I think at the
moment the big problem with web
components is just it's probably just
lacking a bit of documentation is
probably lacking a bit of detail it's
hard to get your head around at first
but it's really really super simple so
now that I've talked about what web
components are using HTML and JavaScript
I can get to the CSS at last it is CSS
calf to rule one brand new concept that
web components bring and I say brand-new
is brand-new to CSS it's not brand new
to wearable computing languages it's
brand new to CSS is the concept of scope
now we're going to have to start
thinking about scope in our documents
which if you use JavaScript really
perfectly aware of but just to give you
a quick example if I were to use an
inline style element like this they save
the booing and hissing until afterwards
if I were to use an inline style element
like this CSS is all has the same scope
currently some no matter where I place
that style in my document it's going to
render every single p across my whole
document there's no scope it doesn't get
contained just to where I put it in the
document the scope is totally global but
we want to be able to pick up elements
and drop them in other places and we
want to have that encapsulation we want
them to be contained we want them to be
encapsulated if we're putting CSS inside
our documents inside our widgets and
dropping them into websites that global
scope is going to leak Styles back out
into the document it's going to have the
opposite problem of what we want so the
first attempt at working around this is
very very simple you just add the scoped
attribute to your style when that's
their CSS has scope it scoped to the
parent of wherever you've placed that
style now that p will only apply here
you don't actually need to do this if
you're using shadow Dom if I do this if
I'm setting up a new shadow root and I
apply some CSS in there I don't need to
scope that because shadow Dom has its
own scope the shadow scope I told you
about the shadow X pattern right
everything shadow something shadow scope
and that's provided by something called
the shadow boundary the shadow boundary
is not as I first suspected the name of
the evil empire in Babylon 5 big love
for Babylon 5 that was good at was big
here in Germany right shadow boundary
basically works like this say we have a
little reusable widget and we applies in
CSS and CSS is just applied directly to
the widget right that's
non-controversial everybody knows that
when we create a shadow Dom it puts a
shadow boundary around that Dom content
and the CSS is turned away the way we
can change that we can either say
actually I want this widget to inherit
all of the styles from my page that's
intentional so we can just when we set
it up we can just say apply author
Styles is true and that will just let
the CSS pass through the shadow boundary
by explicit permission but there are
times when we don't want the whole of
the CSS the stylesheet to be applied to
our widget we just maybe want some bits
of it we want to expose the widget to
the CSS we have to create kind of an API
for it a lot very low-level API kind of
thing so we can just allow little bits
of CSF to apply to where we want them
this is done through pseudo elements now
you probably use cedar elements before
it very very likely you have it before
after or you can get even more complex
ones like I showed very briefly earlier
an example of a progress bar or CSS / an
html5 progress bar and if you view the
shadow Dom for progress bar
that's the main element and then inside
that you get a div which is has this
pseudo element WebKit progress bar and
then inside that as a WebKit progress
about you so if i want to restyle the
progress bar WebKit has exposed certain
parts of it to me so i could change the
color of that progress bar from green to
blue I can do whatever I want with it
because they've actually exposed that to
me and there's a lot of these if you if
you search online you'll find a whole
list of these WebKit only pseudo
elements and Firefox only pseudo
elements and with the shadow Dom with us
being able to create our own reusable
widgets we want to be able to do the
same as well these are being called
parts or the part attribute and so when
you set up your shadow Dom you've
created a shadow root and then you just
add an attribute to whatever content you
put inside you just say the part is and
you give it a name ache in my case and
then you put that content inside your
target so when it's rendered you'll get
this you get your div and then you get
your document fragment which means
inside here is the shadow DOM and we say
that's how it's Rena suisse a part
equals Apes which means that's exposed
to the CSS so by use of this pseudo
element function we can now apply styles
directly to the attributes we want to do
before so we created our own kind of
little CSS API for this thing we've
exposed certain parts of it to styling
so I'm going to go back to scope for a
second with CSS bringing scope that
allows us to do something that was
previously not really permitted in CSS
they're called custom properties but
really they're variables but they're not
full variables they have limits this is
how they're defined first of all I give
it some scope I say this one applies to
the whole body of the document and I'm
defining a custom a custom element a
custom
property called VAR hyphen highlight
that's the format you have to use always
VAR hyphen something and then I give
that a value and then in my code i use
the VAR function with the name that was
after that so it's very very simple
variable like syntax it's not the full
variable syntax people of our so why not
just use the string you know everywhere
else uses the string and that's because
these aren't fully variables yet there
that's why they're being they're not
being called variables they're being
called custom properties because you
can't do anything with for example the
selector you can't do anything with the
property you can only change values so
that's why they're not being called
variables so much as custom properties
so this scope I talked about so I
defined previously I've got my thing set
on the body and I'm going to do it but
then I can also just change it to say
well in sight only inside the few
element then change what this custom
property does again these are very
simple just like if you use SAS or less
you can send values or arguments into
these you can create quite complex
things but I'm showing you the the
absolute basics so this is the reason
why we have these now and I know I've
seen arguments again saying well we can
do variables in SAS let's just have that
you can that's true the one thing that
browsers implementation brings to the
party is scope you can't do this scope
when using SAS or less so the brows are
the one when they looked at it and they
said well actually as we're creating
scope now is a good time for us to have
custom properties we couldn't do that
before there was no reason for us to do
it and as everybody was totally correct
you could do it in SAS unless there was
no use for it but CSS have found this
opportunity which is to provide scope
which is why they're being done it
natively again you don't have to provide
this if you want creating a shadow Dom
actually sorry I beg your pardon shadow
Dom this is the one exception where it
will inherit the CSS whether you
permit it or not that scope applies to
everything in the document so if you
creating something in the shadow Dom you
can still use your custom properties
there that's perfectly valid okay so
I've just got a little time left I'm
going to talk about briefly the future
or the possible future this is stuff
that's been mooted floated may not
happen not a hundred percent because
there are issues around it but it's so
exciting and potentially terrifying in
what it allows us to do that I really
wanted to talk about it these are called
decorators there's a new decorator
element proposed it's not implemented
anyway its proposed so it's a decorator
element and you give it an ID or some
kind of unique identifier and then you
put a template inside it and you can put
whatever you like in that template the
other new thing we've got here is this
content element and that's blank in here
totally blanks it says content so we've
got this markup here which is from a
conference I did previously and
neglected to update so we've got this
markup here and we want to what we can
now do with it using decorators is using
this new property take the template
which we defined on the previous page
take that template and apply it to this
element and the content of this element
the h1 will now go where the content tag
was before so this markup will become
using CSS this markup we're actually
applying mark up with CSS which as I
said is actually really really clever
because you can use media queries to
actually fundamentally change the page
but also really terrifying that could
backfire badly which is why it's not
been implemented yet but it's been
floated and I think it's a clever clever
idea but there are lots of issues around
it so that may not happen so you're
probably asking you guys is great
Wednesday stuff coming the thing is this
stuff is already here in bits and pieces
and quite often prepped off most of it
is in chrome or canary these guys are
really pushing this stuff hard it was
their idea originally especially Chrome
Canary already has shadow Dom already
has scope Styles already has some of
custom elements I think it's got the
template element is also in there so
there's all there even some of it you
have to enable through the flags but
it's kind of mostly there and because of
that or probe which is based on blink is
also going to have this stuff Safari is
following along slowly this stuff was
all implemented in WebKit when there was
a when before chrome switch to blink so
some of its still in WebKit but they're
planning to take some bits out there not
too keen on the shadow Dom right now but
it is actually still there if you
download safari 6.1 or seven it has that
flag to hide or enable the shadow Dom so
it's implemented but they're removing
the API so you can't do anything with it
and Firefox or Firefox nightly also
implements quite a lot of this stuff
they have custom element registration
they have template element they have
scoped styles that's all in Firefox
again some of it has to be enabled but
this is not something originally when it
was mooted it was like oh chroma just
you know Google or just creating this
stuff which no one's going to use it's
not the case this is a cross-browser
like everybody's behind this this is the
future of web development whether you
like it or not it definitely is coming
there's place to learn about this stuff
go to the polymer project and again this
stuff is unique because the polymer
project is kind of a polyfill for all of
this stuff but it's also how this stuff
is getting created
all of the feedback they're not the
browser's are not implementing much of
this stuff natively it's all being done
at kind of a low-level API levels
they're Korea they're building this
polymer library to not only polyfill the
stuff but also to reflect the latest
standard and take in developer feedback
so the more you use this the more
developed the standard guess this is
being driven by the community so it's a
really really interesting opportunity to
get involved go to html5 rocks com
they've got a bunch of stuff on web
components some really good tutorials a
guy called Eric Begelman at Google who's
driving this stuff great explaining all
of these things follow him on Google+ he
writes about a lot there Mozilla have
created this pattern library called
brick which is a series of custom
elements that you can just take a knew
straight away as I said Mozilla are
fully behind this and there's a website
called custom elements do which is a
community-based repository of custom
elements that so you can just take the
library take the element drop it in your
pager this stuff just works in
conclusion what's that doing there in
conclusion web components provide
reusability and encapsulation and scope
is coming to CSS Thank You shun
thanks
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>