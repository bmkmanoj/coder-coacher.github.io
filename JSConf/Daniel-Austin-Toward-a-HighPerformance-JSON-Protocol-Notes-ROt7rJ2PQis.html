<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Daniel Austin: Toward a High-Performance JSON Protocol: Notes | Coder Coacher - Coaching Coders</title><meta content="Daniel Austin: Toward a High-Performance JSON Protocol: Notes - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Daniel Austin: Toward a High-Performance JSON Protocol: Notes</b></h2><h5 class="post__date">2013-01-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ROt7rJ2PQis" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">right thank you good afternoon as Chris
said my name is Daniel Austin I'm senior
principal architect for Yahoo's
exceptional performance group the I want
to warn you i'm not going to stand up
here and edit any javascript in VI and
and there's no hovers or anything like
that what i want to do is talk to you
about what we're doing to use javascript
and json to make the web faster and if
there's any theme to this talk it's
making the web faster by making it
smarter so that's where we're headed
just but for our agenda today we're
going to talk about a new protocol
called scratch it's not related to the
MIT product that we saw earlier at all
that was sort of a anti serendipitous
moment for me even though I did go to
the Institute protocol design is our
next agenda item will talk about results
in current state and where do we go from
here fairly standard agenda a few words
about my group at Yahoo and what we do a
lot of what we do is building tools I
think everyone here knows about why slow
anybody not know about why slow I didn't
think so okay everybody knows why slows
written in JavaScript lot of what we do
is optimizing these are experience every
time you go to yahoo page we're out
there trying to make it faster every day
and to touch on today's topic we do a
lot of research forward thinking
advanced technology what are we going to
do to make the web faster and smarter
today and that's where we're headed
today so our goals I want to explain the
design for the scratch protocol why we
went where we win why we are excited
about JSON why we think that it's
something that we wanted to come and
talk to you about because one of our
goals is to leverage the collective
intelligence of this group on making
scratch better we want to describe our
experiments request some feedback ideas
improvements criticism constructive
criticism very welcome so the first
question I always get when I give this
talk right after why am I going to burn
the internet down and start over
is why did I call it scratch and we
started out to design this protocol
performance first in mind and it went
through several area several iterations
initially we ended up rewriting
something that looked a lot like TCP I
think everybody that goes through this
exercise ends up doing something very
similar we had congestion control we
didn't quite it reinvents slow start I
won't plead guilty to something that bad
but we went through this process of
redesigning TCP and that really was not
the right solution and and so he's
toured up we started all over again and
and we didn't like that version either
we had a bunch of homegrown UDP
libraries that didn't really work for us
so we burned it down again and started
over and and we tore it up and we
started all over again and we did that
several times that's why we call it
scratch because we started from scratch
several different times so just the
elevator pitch you're in an elevator
with an executive you've got 30 seconds
to describe it I can't do it in 30
seconds I'm sorry but maybe 90 seconds
scratch is new dual band data protocol
for the web it's designed to work
together with HTTP over TCP when we all
know we'll call that the control channel
alpha channel not related to your 8-bit
intensity map we'll also talk about
scratch UDP which is the data channel
for our protocol will call that the
Delta Channel if you look at my
well-designed engineering diagram
produced over here you can kind of see
that we have a erstwhile user going to a
set of machines somewhere presumably
data center obtaining some control
information and then going out making
requests against what are apparently
some data nodes using the scratch UDP
data protocol in order to access that
data this is one of the primary
architectures and the intention for our
architecture it looks a little weird
until you think about oh wait those are
CDN notes so the way we load pages today
we go and we download the base HTML we
parse through that gap
up all the links do some other things
then we go out to the CDN and we gather
multiple data objects obviously you're
small noncommercial website doesn't do
something like this but all of the major
sites do this scratch was designed to
make that scenario a lot easier this is
not the only scenario it's just one of
them all of our large commercial
providers really want to use cdns it
helps performance we're trying to make
that work in a completely different way
so this is basically the elevator pitch
for scratch there's absolutely no detail
here beyond the small engineering
diagram we're going to get into that so
motivation why do we want to do this
first thing as we look at it the web and
what we do on it today and we know that
TCP is not terribly efficient for what
we're trying to do small objects are not
terribly efficient via TCP you can kind
of see here we have some graphs showing
number of objects and their sizes Yahoo
Amazon you can see that these
distributions are heavily weighted
toward very small objects this is not a
mystery most things on the web are not
very large another issue we have is the
parallel ISM across the browsers is not
useful we all know that the browser
tries to gather all the data from the
CDN in some parallel way make it as fast
as possible if anybody's seen a
waterfall diagram we know how this works
but we know it isn't very uniform I
think ie9 opens what's the browser
connection constant friday night i think
it's six connections per unique hostname
and in firefox it's in firefox for its
15 individual connections on to a unique
hostname that's a little crazy and it
doesn't work Firefox is not twice as
fast as I eat one of the other problems
we have with TCP there's no context the
server doesn't remember you every time
you make a request you have to tell it
yes I take text HTML oh and I take gifts
to lot of redundancy in that information
will talk about state and why we need to
manage that and the fact that we do
manage state today even though we
pretend we don't or we often claim we
don't tcp treads two tries to trade
reliability for performance
in allotted cases that's a really good
trade-off it's not necessarily the
trade-off we want to make on the web if
we're going to make the web faster we've
got to make it smarter being forcing
everything to make a trade off between
reliability and performance in favor of
reliability is not a performance
optimization not designed for small
incremental changes bandwidth
efficiencies are typically very small so
typical beta for a website less than
twenty five percent I went measured the
yahoo homepage bandwidth efficiency for
the Yahoo home page eleven percent never
been able to get it past eleven percent
that's terrible we've got to be able to
do better than that one of the
motivations for scratch TCP does not
work for the way we want to use the web
today or in the future so some of our
goals around this and obviously work in
progress right we want to increase that
bandwidth efficiency could we get fifty
percent I bet I could I bet if I
eliminated the redundant headers I bet
if I manage the connection stayed a
little more intelligently I bet if I use
JavaScript to send objects down to the
browser without a lot of intervening
hassle hey maybe I could get fifty
percent improvement what do you think
once again the theme of the talks faster
equals smarter we need semantic
awareness we need manage contexts for
the web identity state first class
objects in the system we do this today
we manage state we have persistent
connections so that HTTP 1.1 thing we
manage state there's those cookies oh
don't get me started on cookies just do
not get me started first class objects
in the system for state identity for
encryption for several other aspects of
things that are bolted on after the fact
should be first class objects in the web
should not be treated as second-class
citizens scratch tries to remedy some of
those problems we wanted it to be robust
we don't need all of TCP and I don't
need 30 years of development on TCP we
want to target slow networks global
networks not everybody's network works
as well as Comcast want mobile and
tablet devices low
and with Internet of Things chatter
we'll talk a little bit about the
Internet of Things the role JavaScript
can play there those are really the
goals that we set for ourselves want to
talk a little bit about the design
decisions that we made so when we went
to look at all the work that's been done
in this space we found a lot of it we
are not the first people to think of
this idea all of these people are fellow
travelers in the goal of making the web
faster and smarter in different
directions some of them are protocols
are different layers of the stack others
are data exchange formats others have
various aspects PD is something from
google trying to multiplex HTML streams
rack Nets often used by mobile games
multiplayer games w3c just released exi
this is sort of a compact binary version
of the XML infoset sort of takes away a
lot of the ideas that we had for using
JSON to begin with they're too late to
the game for this but it's on here
another thing that we that did not make
this slide at something called tella
hash I don't know if anybody's heard of
this but I just found it last week it
didn't make my slide but I suggest that
you go and check it out because I just
think tella hash is doing something
extremely cool regardless of what you
think all of these folks are heading in
the same direction we tried to first Rob
these guys of every single good idea
they had to their names and and we say
thank you to everybody who worked on
those because we unashamedly stole your
ideas and and we also I don't want to to
give anybody the idea that the
relationship shown here are really
intended to illustrate the exact
relationships between scratch and all
these others I just want to give you an
idea the multitude of the different
groups working in this space and the
different approaches that they're taking
as far as i know we are the only group
that's taking the approach based on
semantic awareness all the other folks
are doing what we call faster trash
which just means we're trying to shove
the same headers the same web garbage
down on the user make it faster we call
this faster trash we don't think it's
satisfactory why UDP I had one person I
think said they didn't know what you
need
he is another protocol not similar to
TCP but has its own things about it that
make it worthwhile it's widely is for
all kinds of different things if you've
logged into your VPN lately you were
using UDP for that why did we choose it
need for speed for various reasons UDP
is just simply faster this is not
something that's unknown we need
flexible multi-point architectures the
little stick figure diagram I showed you
earlier with its three point
architectures very difficult in your
connection based TC tcp system doesn't
make a lot of sense because the
individual connections have no awareness
of each other small messages transient
data we didn't need consistent ordering
I mean seriously does it really matter
whether that beacon gets on your page
before they add wouldn't you rather have
the add first you don't care neither did
we we tried a different strategy instead
of trying to do a TCP does and make sure
that every packet arrives in time in
order we just said hey you didn't a kiss
fine we're just going to resend it's
cheap to resend resend don't transmit
there's already a significant amount of
prior art and we wanted it to be very
very simple which is not something you
can say about TCP so enough on that how
did we get there like I said originally
we started out we wrote our own UDP
libraries man this was really really a
bad idea because we learned a lot about
network programming but what we really
learned is that other people had been
there before us and they had already
done so much work and put in so much
effort that we were never going to catch
up no matter what we did and that we
were going to have to embrace and extend
use other people's stuff because on our
time schedules with our group we were
simply not going to reinvent everything
all by ourselves we ended up using
something called the UDT library
originally developed at urbana-champaign
won several sukham supercomputer
challenge awards for high performance
data transport it does a lot of cool
things connection semantics there's
hooks in there to rebuild TCP if you're
really dying to do that we avoided that
like the plague third generation code
works really well the API is similar to
the traditional bsd sockets any
and that sort of programming is not
going to feel terribly uncomfortable one
problem we had with it is that it's
almost too powerful too many features we
had to strip a lot of stuff out there
was data serialization already built
into it there was a number of things
that we did not need we just stripped
all that stuff out and in this pattern
of finding something that worked to do
what we wanted on the net stripping
everything out and then using the result
is pretty typical for scratch and and
you'll see that as we go through here
json Doug Crockford here I guess not so
i can probably get away with this slide
I was kind of hoping he was going to be
downstairs when I put the slide on
scratch uses JSON is its data layer
format why well Jeremy Johnson got up
here yesterday he said you know what the
reason we do this is because it's
JavaScript and Java Script is cool I
think that's pretty fair description
actually it's easy to encode and decode
available for all our platforms
gentleman before me Tom Fuchs was just
talking about iOS and how it deals with
the various JSON aspects very important
json is true to our ethical standard for
the web that everything should be
understandable by a human being and that
you don't require a machine to interpret
anything for you on the web this is a
serious ideal it's compact and
lightweight we love JSON how did we live
all those years without it I'm not
entirely sure but now that it's here
we're not going to would miss the chance
it just makes everything else a whole
lot easier I don't think this is an
audience that I need to belabor the fine
points of JSON about other audiences
they're like what's Jay saw and tell us
about it you guys are already sold I'm
standing up here preaching to the choir
and I'm actually enjoying it so we went
to do JSON and we went and did exactly
what we've done before we stole somebody
else's library stripped out the good
parts and left the rest in this case we
used an Apache project called Avro i'm
not sure if anybody's heard of it was
designed to do RPC data transport for
nodes on the grid Doug cutting if
anybody recognizes that name from the
hadoop world was one of the primary
committers for Avro that in itself
probably means it's pretty good code but
it
has some really interesting features
well managed current code base for an
Apache project I think everybody knows
that's pretty important a lot of
abandoned Apache projects out there avro
makes JSON a lot more robust by
extending the type system enforcing the
types with a well-defined grammar has
self contained schemas as metadata and
that's one of the cooler features I'm
going to save that feature to the end to
explain it in a little more detail
because we have something that almost
resembles an actual bit of code over
here oh my god another thing that Avro
has is it's got hooks in for encryption
sasal lexical sorting oh my god we can
sort things on the web and JSON this is
absolutely required there's nothing you
can do without sorting has to be there
one of the best features was really the
ability to do the lexical sorting
against the Avro framework well there's
not a whole lot of cons it does exactly
what it's intended to do you know it was
very RPC centric it's not bad but it's
not what we wanted we stripped a lot of
that stuff out we did not use it to
compile code we did not use IDL to
define our data types although we might
at some point what we really wanted was
very robust JSON that could be generated
at scale and and that was really the the
key feature and a ver a framework
provided that for us just to hit on the
point about the self-contained schemas
as metadata this is a key idea in Avro
and and really a very key idea for
programming I think in order to consume
JSON produced in this way you don't need
anything on the client you don't need
fancy tools interpreters anything like
this because appended to the header of
your JSON Datagram so to speak you have
added the schema for the data that
you're sending it can be read on site
it's self-contained encapsulated with
its own metadata and you can see this
ridiculously bad little code segment
over here where I'm starting to model a
cookie and you can see that I've got
name and value like I said don't get me
started on cookies but but I wanted to
kind of give you a sense of how this
works to attach the schema for the data
at the began
of each Datagram because I think that
that is an extremely cool feature it
relieves us of having to do a lot of
client work where we would have to build
some sort of interpreter there'd have to
be some exchange of metadata you have to
understand what it is you're trying to
read JSON or otherwise and and we found
that this approach worked really well
for us you know I don't know if anybody
from this team is here but if so we
thank you we're looking out for your
stuff that's basically the part that I
wanted to talk about with respect to the
protocol design just quick time check
and make sure I know where I am and I
don't because my clock stopped but
that's okay let's talk about the results
let's talk about the current state the
just going back through the protocol
stack here really quickly for review UDP
odd the transport layer we're using this
UDP library for session management does
some concatenation connection semantics
stuff like that not as important as the
stuff above it and that's generally true
of any network stack in true OSI form
i'm using the OSI terminology wrongly
JSON is not a presentation framework
right nobody looks at it ray it is
actually a data exchange format but it
fits nicely here into the OSI stack
labeling it that way with the caveat
that we as we know it's not really a
presentation format but data exchange
still it fits into the stack nicely and
if we just sort of warped the OSI
terminology a little bit we can probably
get away with it I think everybody knows
what I'm trying to get at scratch Delta
is at the application level that's where
we want to talk about that's what's
really important about what's happening
here so special plea from the developer
of scratch I know that all the node
developers are in this room or at least
maybe not some of them might be
downstairs but guys I need your help on
this because there's nothing that's more
suited for using node then scratch great
scratch is about sending JavaScript
objects in
coated in JSON what do I need for that
other than node bruh no brainer this was
made for node node was invented for this
you guys didn't know that when you
invented node but now you know why can't
we use the existing node situation well
UDP support is still somewhat basic I
know that Paul kerna had written a a
little UDP transport module for for node
he presented that at node camp and his
very minimalist there's a there's a pcap
library Isaac schluter pointed this out
to me I was actually able to use his
little node package manager worked
really well and installed the pcap a
library and knowed it works I was able
to see packets coming across it doesn't
work very well I need your help node
guys really I do we expect that this
rather this situation is temporary hint
hint okay so enough for the special
pleading from the developer here the
let's talk about some test results so so
this isn't all blowin smoke right we've
actually gone and written some code and
made things work so let me tell you
about our test setup we wrote a little a
little app I'm sure that you can guess
we called it scratch pad there's a lot
of scratch puns I'm not going to
apologize for them first pass results
let me explain to you our test setup we
set up instances on AWS and five global
locations everybody knows you know
there's one in the east and the West in
the US Europe couple in Asia we set up a
circularbuffer test we created link
objects encapsulate a hypertext link the
part of HTML that actually is really
interesting and important or the links
so we created a thousand of those as
JSON scratch Delta objects and we patted
them out to the the same segment size as
we use for TCP because we wanted to do a
comparison tcpd UDP and see exactly what
was going to happen so we padded things
appropriately and and you can kind of
see some of the results here I don't
know if my pointers actually visible but
in the table here you can kind of see
that if we went to update a single link
globally so remember we've got a
thousand of these they're out there in a
buffer and we want to update a single
one globally all across the world how
long is that going to take us three
hundred and thirty eight milliseconds if
we use scratch 20 240 milliseconds if we
use HTTP / UDP that's huge when we went
to update all the links all 1000 of them
globally imagine how this is going to
work first you have to sort them first
have to find them then you've got to
modify the link to the new value we went
through that took us 12 hundred
milliseconds and actually that's right
we couldn't get the HTTP TCP data on
this one because it timed out every
single time the next test that we did oh
and the other thing I wanted to mention
here is that we were really concerned
about packet loss I don't know if any of
the the Google guys are here but one of
the things that they've found out with
their speedy protocol is it's very
subject to pack it was very sensitive to
packet loss we're obviously sensitive to
packet loss to we were really concerned
we did not see major differences in
packet loss now these numbers by the way
are for the only for the scratch demo we
did not get packet loss numbers for the
HTTP transport so the the point 11
number there is really only for the
scratch data but you can see the the
packet loss data is very low compared to
what we had expected to see so that's
you know that's it's an interesting test
we did a circularbuffer and we updated
some objects in memory you know it's
it's it's it's interesting in and the
results are okay more interesting still
not real still not you in front of a
real user but more interesting is that
we tested a real text buffer we took the
Yahoo home page and we send it around
into our circular buffer and we looked
at how fast we could send that around
and we looked at how fast we could do it
if we compressed it and we haven't
talked about compression but we will
compression is a first class object in
scratch everything is compressed accept
the things that are already compressed
so for sending the base file metro yahoo
homepage by gosh 217 seconds to get that
puppy around the world now speed of
light times around the world are not
that much less than that right same
order of magnitude the HTTP TCP method
three times as long I'm not sure I don't
think anybody's really going to be
surprised about that sorry I keep got to
stay in the light here I don't think
anybody's really surprised that it takes
three times as long with HTTP to do this
it is after all stateful or stateless
and and we know that because of the size
of this object is going to be several
packets in length 35 k is multiple
packets you can see in the graph here
you know and this is just visually
showing what's in the table here but in
the graph you can kind of see what the
result is 3x for scratch over HTTP tcp
know when I was practicing my talk today
I kinda I wondered whether I wanted to
make that previous statement because I
don't want you guys going until the New
York Times hey Yahoo's going to make the
web three times as fast it's not going
to happen a experimental lab tests in in
in a closed environment there's no real
relationship to what actually happens in
front of users especially on the
Internet we all know that so I don't
want everybody to leave here saying
Yahoo's going to make the the net three
times faster with scratch we do think
that these results have some promise and
that they're showing us something very
very interesting about our ability to
use UDP to be TCPS performance so this
is basically our first set of test
results this was actually pretty much
complete by mid-february at that point I
got called off to do some other things
and and this is really most of the test
results I have because I was going to
show a demo really I was and and the
demo has been scratched I ran out of
time and sleep I apologize so so no demo
this time but I did talk to Chris before
I came up here to talk and I made him a
deal i said i'm gonna get up here and
i'm gonna give the coolest talk but you
got to invite me back next year
so that I can show the results of all
the work that we've done because I
really don't have that much this time
we're talking about the design we're
still in the design state like I said
I'm not editing code and VI for the
presentation and I do apologize for not
having the demo one of the questions it
often comes to us when we do this is you
know as scratch TCP or scratch Network
friendly in TCP we have this idea about
TCP friendliness you shouldn't flood the
network you shouldn't congest the
network in favor of your traffic over
somebody else's traffic you shouldn't
send syn floods to the server obvious
things like this you need to be a good
citizen on the internet there's no such
concept really for UDP nobody has ever
defined I think UDP friendliness but we
want to make sure that scratch really is
Network friendly and there is some
interaction between TCP and UDP I don't
want to get into it because it gets into
network hairiness they'd sort of off
topic but there is some some interaction
this question comes up Daniel if you go
and fled the internet with UDP packets
from scratch what about those folks that
are still using TCP or need some other
protocol are you flooding them are you
blocking them are you congesting them
making their life more miserable in
order to make your life better we don't
want to do that our answer to the
question of whether scratches Network
friendly is yes and here's why we send
fewer packets more updates remember we
only send the headers once rights and we
only change send an update once up
something actually changes and it's
worth actually making an update we do
throttling or we can at least based on
the MTU and the rtt I think the the
initial when I wrote the initial UDP
library I've actually based some
throttling on the old jacobsen algorithm
right with this 778 coefficients and so
forth because the metadata and scratch
is a first class object it improves the
way that we interact with the network
because it plays a significant role in
the data that you receive or don't
receive we don't send you data that your
device cannot handle we don't send you
data that's already been
sent to your device we don't intend to
send you any superfluous data at all
because we know you we're managing your
connection we're managing your state
there's not a lot of repeated redundancy
that we need to go through metadata is a
first class object improves the web
performance for everybody we'll defined
endpoints and connection establishment
this helps a lot with it would Network
friendliness as well one of the things
about UDP packets is you can't really
tell what the heck is up with them I
mean unlike TCP they really have a port
in an IP number and maybe that's it if
we define additional semantics around
the connections we can make things much
more stable we can make it better for
everybody on the Internet we handle
smaller MTU size it's one of our goals
here was to be able to serve the web
globally anybody who's tried to serve
web pages into Indonesia into Singapore
and Australia knows that there's just
serious difficulties with the
infrastructure with sending packets
under the ocean or down through the
satellite over the cable one of the
effects of that is often that the
packets get shrunk down to the smallest
common denominator that can make it from
A to B and and of course this makes
everything a bit slower because things
have to be disassembled and then
reassembled at the end one of the goals
we had for scratch was to minimize that
make sure that we were able to handle
gracefully this global traffic the
nearest node potential to reduce the
payloads is a huge win what if what if
we manage the internet more like a p2p
network and and you know maybe the yahoo
logos and brendan's cash and you know I
don't have to go back to the yahoo
server for that I could just go into
someone else's cash and grab that logo I
mean the TTL on it hasn't expired why
not certain amount of nearest node
potential involved in scratch helps us
reduce the overall overhead make things
a lot more network friendly just a
little bit of talk about where we go
from here obviously we're in the design
stage for scratch first thing we want to
do is we want to get you guys to tell us
not that we're crazy
we already knew that right don't tell us
we're crazy tell us how you can help us
improve it tell us what we're doing
wrong what we've missed undoubtedly
missed a number of things here some of
the must-haves going forward that we
really need that are not there yet
better semantics currently we really
only have three of these schemas for 144
HTTP headers obviously the cookie object
descends from that one for the URIs this
is the one we use for the the link def
test with the circular buffers another
thing that we really need resource
encapsulation obviously a big part of
the web are these big blind binary blobs
we've got to find a better way to
encapsulate those so that we only send
those the minimum number of times across
the minimum distance once again if we
can dynamically update the IP of the
nearest copy if we can dynamically
update the time to live for that object
we can manage the users cash in a much
smarter much more dynamic way that
doesn't involve sending the whole earth
over the internet every day encryption
is another thing obviously that we want
to get at sasol ssl/tls all these
acronyms almost impossible to make any
of this stuff work over a proxy / UDP we
have simply not solve this problem yet
don't know that we will we may have to
find a different way to handle security
but we want security to be a first-class
object in our system as distinct from
privacy which is also a first-class
object in our system compression so so
compression is definitely one of the
things that we want for scratch it needs
to be there if you look at the data for
uncompressed versus compressed data it's
pretty obvious things have to be
compressed well you know gzip is
everybody's favorite devices supported
everywhere one thing we found though is
that in a lot of cases mobile devices
not the really fancy high powered ones
that we all know and love in this room
but a lot of the others have some
difficulties they struggle with gzip
gzip is a computationally intensive
algorithm
and sometimes the the decompression of
the data as it arrives on the device can
actually take longer than if you send it
uncompressed we've seen cases where this
has happened so we've looked at some
alternatives for compression one of the
ones we looked at in particular was
called bite pair compression I don't
know if anybody's actually heard of it
originally sort of showed up I think on
the modern radar screen through a dr.
Dobbs article in 1992 I'm not sure how
modern that is I might be dating myself
anybody here born in 1992 maybe anyway
bite pair compression came out man it
was completely lost one of the guys at
Stack Overflow much much more modern
than that actually went rewrote the code
in the modern world and it actually
works we've been experimenting with the
byte pair compression it takes a lot
longer to compress a file using bite
pair compression the decompression phase
is much faster much less computationally
intensive if you think about the the
nature of compression you're going to
compress something only once uncompress
it many times if you want to have the
computational intensity or the
computational cycles distributed equity
equitably much better with the byte pair
exchanged then perhaps with some other
compression mechanisms we haven't made a
design decision about compression for
scratch yet we may end up with bite pair
compression we may end up sticking with
gzip I mean it does work it's not you
know not the end of the world if we go
that way the mobile devices will catch
up there swiftly doing that obviously
when another one of the must-haves i
know i said there wouldn't be any more
special pleading earlier but here's one
last little bit of special pleading node
guys please back to the theme of the
talk smarter and faster the same things
we went and found out in doing this that
the whole notion of shoving data down to
the user did not work with the current
environment or the current web
technologies as they are too many
redundant headers too many redundant
style ships
stylesheets too many scripts being sent
over the wire I know anybody that's ever
used Yui Yui has every feature possible
but it's often a very heavy weight
package it's a good example of what we
want to do in terms of reducing the
volume of bytes sent over the wire the
theme of the talk in order to make the
web go faster we've got to make it
smarter we can't just do the faster
trash type model where we're taking the
same document the same HTML same headers
cookies all that nonsense and shoving it
down to the user this is what we like I
said what we call faster trash not the
way we're intending to go with scratch
scratch wants to be smart just a few
science fiction ideas what could we do
with scratch provided of course that my
team actually gets it to work and that
we solve some of these issues and and
the technology is working what are some
of the cooler things that we could do
with it so so we can improve hypertext I
don't know if anybody has really thought
about it but hypertext has not changed
since tim wrote the HTML spec back in
the day it doesn't really resemble a lot
of the work that douglas engelbart did
in inventing hypertext back in the 60s
if you go read the vision for hypertext
then and you compare it to the pathetic
little single-ended links we have now
you'll be disappointed the web as far as
hypertext goes very disappointing could
we fix that maybe we could just scratch
to do something like that we can make
links sofa where self-healing anybody
think 404s or a little past their
sell-by so always seemed a little crazy
to me that things break like that the
yes I was on the excellent group back in
the day we want to make links multi-home
there's no reason that the link can only
point to a single point there's no
reason for that doesn't make a lot of
sense want to make it context-aware the
link might point to different places
depending on who you in particular are
if we know something about you and you
know we know that for instance your
JavaScript programmer and you write in
you know
so you're going to search for something
along the lines of programming we might
send you to JavaScript resources or
provide multiple links to JavaScript
resources and order in a way that makes
sense based on what we know about you we
could make hypertext a heck of a lot
better Pierre caching the browser's
cache is sort of a disaster it's a bit
of a nightmare we stick stuff in there
god knows what really happens to it
we've added all these clue ght p headers
to try and get this max age and friends
you know it works and it works fairly
well I don't want to criticize it too
much but still it's kludgy it's a bolt
on that we added afterwards maybe we
could think about managing the cash in a
stateful way all of Yahoo at least all
the standard assets that go on most
people's pages about forty megabytes we
could probably just pre load this stuff
in your browser and you would like
surfing Yahoo a heck of a lot better if
we could manage that using scratch and
do these little micro updates may be in
a p2p fashion maybe just directly from
the control channel doesn't really
matter maybe we could make things a lot
better that way another idea that one of
the developers came up with is and this
guy's really big on this idea is the
Internet of Things this is the the idea
where you're walking past the pizza shop
and they blast a pizza coupon on to your
mobile device and you go into their shop
and spend some money I know that this
use case has been batted around for
years I think there's some places where
they sort of kind of maybe have it
working with some are fed and somewhat
not one of my developers popped up he
says hey what if all those little
objects were just emitting little bits
of JSON that described what they were
and what they were up to then you could
sort of have this background UDP sizzle
of things as you're walking along and
your device could just read that data
and know what to do with it in some
rational way because hey we sent the
schema along the beginning of the header
there's a number of different crazy
things that we could do these are some
science fiction level ideas I admit that
large part of what our research team
does is trying to think about how
make it better in the future not just
obsessing about the micro seconds in the
milliseconds today performance it's
really really really important and to
make the web faster we've got to make
its murder so that's really all I have
to say thank you for listening I hope
that this made some sort of sense to you
and I'll be happy to take some questions
just before I do my email address is
here on the slides also my my Twitter
tag and and I'd like to have somebody
see if they could red laser that QR code
on my slides I was just curious as to
whether you could actually red laser a
QR code from somebody's slides don't
worry doesn't go to any porn site or
anything just goes to my twitter feed
but I'm just curious can you actually
cure red laser a QR code from a slide on
the screen at a conference somebody try
it let me know all right with that thing
said let me take some questions here's a
gentleman in the back I can't really
make you out there sir but I'll be happy
to answer your question if i can
actually there's not this is the world
premiere for scratch but there will be
stuff out by monday the we wanted to to
come up here and talk to you about this
first and and we kind of wanted to to
make this the world premiere for this
idea not a whole lot out there you're
the first folks to see it you get the
first chance to criticize on it there
will be some code and some other stuff
on github by Monday we're questions sir
I was just wondering since SPD's already
starting being deployed sort of by Fiat
I'm have you measured it head-to-head
against speedy for the same content we
have not gone directly head-to-head
against speedy I think speedy is at a
more advanced state of development they
have a lot more people working on it and
so we have not done that but we're
really anxious to do it we really like
what the Google guys are doing with
speedy I guess you're probably one of
them no oh but the we like what they're
doing the multiplexing thing is really
interesting it's still faster trash
if before but sorry if performance is
such a concern my are using JSON instead
of be Jason there was some talk about
that we could use bj song we could've
used exi which is also binary asn.1
there's some other things we wanted to
be true to the web ideal everything is
human readable you don't need a machine
to understand what's going on on the
internet and also it's just a lot easier
to deal with I know people don't get up
here and talk about ideals that often I
hope that that's that's okay so you had
mentioned that there's no support yet
for SSL or TLS seems like that might be
a deal-breaker for a lot of people can
you look comment on the roadmap ahead
about if that's a man certainly a
priority but timeline wise when that may
or may not be implemented so so this is
one of the largest outstanding and solve
problems the gentleman's put his finger
right on it if you know if there's
really blockers to acceptance of scratch
beyond the fact that the client can
understand it right now it's that we
don't have a really good story to tell
on security it's at the top of the
priority list for working on as far as a
date I would not even want to hesitate
guess we will work on it thinking about
time cycles it's not going to happen
until later in the summer at the
earliest but it's definitely a high
priority and thank you for noticing it
so hundred I may have been hey I may
miss this did you talk about error
control so I did not talk about error
control although I probably should have
I talked a little bit about packet loss
but I didn't talk about Eric control I
only get 40 minutes for error control
what we really want to do beyond the
obvious crcs and and and other kinds of
check sums is we have in the control
channel a section of data actually it's
three packets not just one that
describes what's happening on the data
channels and allows us to do akin
harris and for checking the the validity
or the the integrity of the day so
you're doing selective retransmission
that yeah and any firewall issues
firewall issues we actually went and
wholeheartedly and I knew somebody was
going to bring this up thank you for
bringing it up because I was prepared to
answer that one for that we actually
just went and grabbed the ton code
that's a that's out there is several
people are using this there's three or
four different ways I don't know if
people are aware of how to get past
firewalls with UDP but things like Skype
use something called ton which basically
does a rendezvous type of approach
basically where you establish a
connection to the first possible closest
node to your destination then you try
and open a connection a little further
back and sort of leapfrog yourself I
know I'm not doing a great job of
describing it it really needs a
whiteboard but there is technology to
help us get through firewalls if you
think about the programs that are out
there using UDP like Skype and some of
the others they've obviously solved this
problem as physicists we can consider
this to be a problem you know that we
reduce this to a problem already solved
I'm sorry multicast is definitely on the
agenda if you think about the way that
things like the peer-to-peer cash
maintenance and so forth that I talked
about work that's a multicast solution
if we look at one of the features that
we wanted to put into scratch was a
nearest object location channel which
would have data about the objects that
you know or love or have in your cash
have some association with we want to
have a data channel that shows where
those are or their nearest points near
its nearby point that's going to have to
be a multicast solution so multicast
definitely on our agenda it's a little
more complicated but it's definitely got
to be there Laura did you remember to
load the bacon oh I knew I forgot
something</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>