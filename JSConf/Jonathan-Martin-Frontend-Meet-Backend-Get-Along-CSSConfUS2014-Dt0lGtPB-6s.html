<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Jonathan Martin: Frontend Meet Backend Get Along [CSSConfUS2014] | Coder Coacher - Coaching Coders</title><meta content="Jonathan Martin: Frontend Meet Backend Get Along [CSSConfUS2014] - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Jonathan Martin: Frontend Meet Backend Get Along [CSSConfUS2014]</b></h2><h5 class="post__date">2014-07-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Dt0lGtPB-6s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well welcome to my attraction spell so
I'm just going to talk kind of briefly
about the divide we have between the
back end and the front ends and how we
can try to bridge that with some of our
current tooling so Jonathan Martin I
work at the big nerd ranch in our front
end and rails development team at each
our front-end course so if you happen to
be in that lanta area she couldn't check
us out you can also follow me on twitter
at nibbler so i'm going to talk about
something we deal with every day that is
people and specifically as front-end
developers we deal with back-end people
so that's great but very often they're a
little bit too irrational for our taste
because we have a very specific workflow
of how we like to work so when we have
to work on a full step team kind of
environment we have to pick some
different strategies for how we're going
to cope with our backend friends the
first strategy we could pick as we could
just try to survive through it and
typically that means anytime we need to
do some PRS or something one developer
on it keep them separated don't let them
get anywhere near each other kind of
like matter and antimatter reacting so
that collaboration strategy of steer
clear it's pretty much what most people
go with when it comes to tooling
deciding what tools to pick if you're
going to collaborate with rails in front
end it's typically whoever got to the
code base first and this is something
that's very common and typically makes
up the bulk of front-end back-end teams
so the solution we want is we want to be
able to thrive we want to be able to
take our front-end and back-end and make
them thrive together like an Oreo I
talked about an Oreo just because we all
know that the cookie part of an Oreo is
just the presentation and the sustaining
white stuff that's hidden or
encapsulated inside for the consumer is
the important part at least until the
cookie contents are requested by the
digestive tract so without a little
analogy we want to treat our back-end
fellow members like that Oreo cream so
too often we try too hard to mix
together the front end and back end and
try to get everyone on the
same level try to get them all educated
the same like an Oreo truffle we don't
want to do that we want to keep our
separation of concerns we want to keep
the people who are experts in the front
end and keep the experts your experts in
back end but we need to find a good way
to get us interoperating so the first
way we can try to do that is by trying
to keep the two completely separate have
an entirely separate repo for your front
end part of the appt kind of like an
iPhone clients the iphone client isn't
developed along with the server code
it's developed in isolation so you can
do the same thing just pretend that your
front end client is a client and have it
consumed the back end so that's one way
we can do it and this is a really great
strategy to take if we have the time and
resources to do it but unfortunately a
lot of times we don't have either if
you're in a hackathon of some sort this
especially comes up where you'd like to
split off the two but you have so little
time to begin with it you don't have
time to split off the to make the
separate repose configure all the CSRF
tokens and whatnot that come with a
rails based api so unfortunately that's
not always our leisure so there are some
strategies we can follow in some tooling
we can pick from the go to make sure
that the front-end developers don't go
insane working with back-end developers
and vice versa so thankfully we have
some people have already put the other
some really cool tools and we can rely
on their smarts to get started so one
strategy would be to just push through
this with a front-end developer just
make it work would be kind of our
ideology for doing that so here's one
approach to doing it tastes driven
development which means we're going to
test the two parts the front end in the
back end we're going to develop those
and test them in isolation and then come
back frequently with pairing and
deployment to do those together so when
we're working in the same git repo
because we've made the assumption that
we're going to develop our rails in
front end in the same repo we can take
one strategy where we educate the back
end developers in all the ways of the
front end and how to do those sorts of
things and how to name their CSS classes
and where to put their CSS so that's one
way
and that might work until we go to do
the reverse and try to tell the
front-end developers how they need to
code how they need to work with the
api's how they should organize your CSS
the best work with the rails asset
pipeline so after going through some of
that trauma we might be tempted to
instead d the don't share ideology where
we try to split our concerns completely
and give front-end developers their
domain of just the front end and tell
them follow rails conventions except we
can't follow rails conventions rails
unfortunately gives us poor front end
conventions on occasion so to prevent
insanity I'm going to go through just a
bucket list of some ways that we have
big nerd ranch have found make this a
little bit easier to work with between
the front end and back end so now I move
to just a live coding demo and let's see
if I can get the screens working here
alright so here i have an end result
this is just a project we did recently
for in internal hackathon but many of
you may recognize this as dashing which
is put out by shopify so as part of the
classroom project we wanted to use
Shopify but of course we took it upon
ourselves to rewrite it in ember because
none of us wanted to write Batman code
so in the process it made for a really
interesting experiment because we had to
back-end developers another back-end
developer who apparently wrote go and
one front-end developer and that
consistently changed through the period
of the hackathon because we had one jump
on and off from front end to back end so
it was an interesting consistency to
work with and we had to make sure
working at that fast pace that we didn't
get in each other's way so one of the
ways we did that was when we started out
with the rails app we wanted to make
sure that we had a conventional rails
app to be to begin with but when it came
to assets of any sort we wanted to let
the front-end team have their domain so
the first thing we did is we used Bauer
now Bauer obviously is for the front end
and must tool to make sure you aren't
just copy pasting scripts from off the
internet and putting it in your repo
so with rails we would typically pull in
some gems in the gem file if we wanted
to use backbone we might pull in that
helper Jim if we want to use underscore
bootstrap jQuery the list goes on and on
typically if you're developing rails
you're going to pull in a separate gem
but the problem is these gems are often
behind the bower version or whatever
version is on github it also doesn't
really handle assets very well gems are
meant for packaging Ruby code not so
much for packaging and managing assets
so what we'd like to do is pull Bauer
which gives us a really nice way of
specifying dependencies for front-end
developers and we'd like to be able to
use that in the asset pipeline so it's
actually not all that difficult to set
up but there are some kinks to work out
so first in our gem file we want to make
sure that we're using the bower rails
gym so Bauer rails is just a little gem
that can handle some of the asset
loading for us it also provides some
rake tasks but we actually don't want to
use the rake task because front-end
developers are going to want to use the
bower install command they don't want to
use rake Bauer chol and install so
that's the first part second we want to
define those dependencies in our bio
Jason now Bauer doc Jason if you're
using the rake task is actually going to
be defined for you under vendor assets
possibly under components depending on
where you change the path and we don't
want this we want just our plane Bauer
Jason and to put it up here in the home
directory so we'll move it up here to
find your dependencies as we're used to
here's where we get into some
interesting rails niches notice I'm
using jQuery here and actually we could
use jQuery UJS which is also available
on on on Bauer but there's going to be
some conflicts if you've already got the
jQuery gem in your J in your gem file
which is almost always the case then
you're going to have script conflicts
because I have the same name and
depending on how the rules work one is
going to win out over the other so the
first thing we need to do is make sure
we don't have the jQuery gem in here at
all now thankfully in rails for this was
not a required dependency so it's easy
to pull this out now as we can see here
I
already taken jquery out the way you can
just test some of this stuff is start up
your server check in chrome and see what
sources you already have try and get it
to the point before you convert over to
our try to get it to the point where you
have no assets at all know CSS no
javascript etc you want to get to the
point where you don't have any of that
there so you can start pulling it into
Bauer and make sure you don't have any
conflicts so once we pulled out jquery
and possibly we pulled in jquery UJS you
can pull in your other stuff you can
pull in handlebars in this case i was
also using emblem emblem is a template
language forever that just compiles down
the handlebars so emblem is kind of
tricky because there is a gem for it
because if you want to have the
efficient emblem templates you actually
do want to pre compile them kind of like
you might pre compile a handlebars
template for production that's a
production step that's not something you
just want to handle in the browser so
this is one of those situations where we
did have to use a gem so if you look at
our gem file we actually have an emblem
rails gem in here now in this case I
actually had to go off on a fork because
I wanted to make it so it would just use
whatever bauer version November we had
because if you try to use emblem rails
of the canonical version at least it'll
automatically pull an ember it'll
automatically poor pulling member data
handle bars etc all these gems that we
don't want we just want the emblem
precompiler and we want it to use our
bauer javascript files so but the rest
of them in barrage a cenar
straightforward we just got d3 and a few
other libraries that are used by dashing
so the last thing we need to do is we
need to go into config go to application
and here rails gives us a nice way to
tell it where to find some more assets
so this is just one line we're telling
it to include this vendor assets
components now that's where our stuff is
going to be installed now recall with
Bauer we need to tell it where that
components directory is so if I show the
hidden files you can see we have a bower
RC file here if we look in that
just hold it whenever installs instead
of putting it under power components put
it under vendor / assets / components
and this is important it doesn't have to
be that exact directory but vendor is
the convention vendor assets is a
conventional place to put third-party
libraries inter rails out so you're
meaning that one convention but on the
other hand with Bauer the convention is
to put it under some directory called
components so this is kind of a
trade-off between the two so just make
sure you'd find that Bauer RC file put
in that new directory you can pick
whatever directory you want so long as
it's consistent finally we go up to our
app assets the cool thing is that our
rails will will automatically expose all
of our Bauer dependencies with the
simple require paths so if I go up here
for example I'm going to go to
application jas here at the very top
I've got my required jQuery require
handlebars of acquire ember I didn't
have to put in the full path to that
Bauer component typically for something
like number you'd have to put in require
for example ember / dist /em burn njs
well we don't want to do that we just
want our paths to look exactly the same
as they were when they were a ruby gem
and this is really easy to do thanks to
Bauer rails so we can require in our
dependencies here so the asset pipeline
you'll notice is something we want to
continue to embrace since we're going
with the rails front-end kind of mix and
thankfully now that we've split out
these rubygems instead we're using Bauer
it's actually pretty easy to do so the
last part we'll get into when dealing
with Bauer is some of these deployment
issues and that's probably where the
bulk of the rest of the talk is
now you'll also notice back in the
gemfile I had another file in there
because we're laying front end
developers take control of all the
assets one gem I like to use is called
quiet underscore assets and that
basically gets rid of all asset requests
that are made to the rail server takes
them out of your log because at this
point you don't care where the assets
are coming from in rails you just know
they're coming from Bauer you want to
let the front-end team handle that that
can make it a little be easier to split
your domains the other thing to keep in
mind is that you want to script all
these sorts of things so as we see when
you're dealing with ember or when you're
dealing with deployment to hero q and
you're using Bauer you can run into all
kinds of issues so you want to write
those as bin scripts to make sure that
your front end and rails developers are
doing the same thing so when you try to
use node with your rails projects for
example if you're trying to use it for
doing any kind of builds maybe you
decide that the asset pipeline isn't
going to meet your needs or it's maybe a
little bit too cumbersome you can't
actually use node modules in it but as
we'll see it can be a little bit tricky
to deploy it so if you're going to just
stick with the asset pipeline which is
what we're doing in this particular
project because we had time constraints
make sure that you go wholeheartedly
with Bauer if you try to drop a few
things under vendor assets you're going
to get a beating from the front end team
because it's a hard to find we liked
front-end developers we like to know
explicitly where our dependencies are
coming from so for deploying to Rho Q
you can run into some issues first of
all this is primarily a rails app but it
has a node basis which means when we
deploy up to Heroku we can't just deploy
it as a rails app we actually have to
deploy it as a multi build pack app so
let's go back to that code
so notice when I was had the hidden
files exposed here and this bill packs
file this is something that Haruki
provides to us that lets us define
explicitly what kind of application were
using and what packages that we want to
use to build it so here for example I've
listed two packages first I've listed
that I want to use nodejs as my first
build pack and then I want to use the
standard Ruby one the second line is
what Heroku automatically picks for us
when we're deploying the first one we
have to give explicitly so once we
define those build packs then we just
need to do some basic Heroku
configuration we need to remove the
current build pack if you do a hero qn
you'll see that the current build pack
is probably set to ruby and you don't
want that you want to get rid of that
and instead push it with this and it'll
realize that it's a multipack and
automatically do it supposed to but when
we push it up it needs to know what to
do with that package so one way we can
do that is by creating a node package
file so here I've got package Jason I'm
just the fun a few basic parameters
notably I've set dev dependencies dev
dependencies I've said that to build
this project anywhere you've got to have
Bauer now most users are going to have
Bauer installed globally through node
modules but when we're deploying to the
server the server is not going to have
Bauer installed so we need to define the
dev pendency the other thing we need to
do is to find one of these post install
scripts so this tells Heroku or even
locally if you're using MPM install it
says that after you've installed these
packages run the script so in this case
we've told it to run the bower bin
command and call install on it so once
it calls installed it'll finally pull in
our bow jason dependencies for us so
that the server can actually run from
there the asset pipeline kicks in and
we'll get some minification in the
second part of the build step the second
part of the build step which is after
NPM is run Ruby finally kicks in
now Ruby is a pre compilation step it'll
actually minify and concatenate all of
our assets put ashes on them so the neat
thing about using Vera rails is that you
don't have to worry about Bauer rails
interfering with any event all Bauer
rails does for us is help us
automatically get these dependencies
these JavaScript packages once we have
them rails takes over and we get all the
same minus occation benefits we get the
hash codes etc so you don't have to make
a total departure from the good things
that the asset pipeline provides for us
but you can get the benefits at the same
time of using it just one quick note
watch the name of that build pack if
it's not pluralized you may find that
you keep pushing and it doesn't do
anything so that's all I have I have
some example repos up if you're
interested that show basically how you
can do this from start just a basic
boilerplate getting started so I found
this to be useful we've used on a couple
projects and it seems to be working well
so
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>