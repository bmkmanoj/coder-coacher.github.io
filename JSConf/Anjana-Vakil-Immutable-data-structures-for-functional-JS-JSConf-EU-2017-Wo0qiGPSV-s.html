<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Anjana Vakil: Immutable data structures for functional JS | JSConf EU 2017 | Coder Coacher - Coaching Coders</title><meta content="Anjana Vakil: Immutable data structures for functional JS | JSConf EU 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Anjana Vakil: Immutable data structures for functional JS | JSConf EU 2017</b></h2><h5 class="post__date">2017-05-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Wo0qiGPSV-s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everybody
how we doin got caffeinated feeling good
nice
so I'm Jenna Vecchio hello you can find
me on twitter at my name and today i'd
like to talk to you about immutable data
structures for functional programming in
JavaScript we're going to take a look at
what immutable data structures are why
they're a really cool way to handle the
immutability that we typically use when
we're doing functional programming and
how we can do that in JavaScript because
I hear y'all like JavaScript so a little
about me I'm probably the only not web
developer in the room I am an engineer
for uber research I work with them to
develop a custom query language for data
in the scientific research funding
domain I'm also an alum of the recurse
Center which is a fantastic programming
community in New York City and in the
model um I am an alum of the Outreach II
program which if you haven't heard of it
is an amazing initiative to get more
women and underrepresented folks
involved in open source project by
offering paid internships at
organizations like Mozilla so I'm also a
Mozilla community member and a mod Tech
speaker so I'm really happy to chat
about any of those things if you want to
come grab me after the talk but you
might know that I like functional
programming I think it Rock anybody else
agree with me that functional
programming is cool yeah yeah so
functional programming is a pretty great
way to avoid some of the headaches of
other paradigms like imperative or
object oriented programming in
functional programming what we typically
do is
conceive of our programs as being just
pure functions that means that they
transform their inputs into outputs and
that's all they do they don't have any
side effects
things like printing to the console or
mutated changing something in the global
state would be side effects don't do any
of that none of that
so our functions become just pure data
in data out like transformers of data
and one thing that goes hand-in-hand
with this avoidance of side-effects is
using immutable data immutable data
meaning once we've created it it never
changes so this is a really good way to
avoid accidentally changing something
outside of your function if everything's
immutable you can't change anything so
immutability is another thing that rocks
and it rocks pretty hard for some
reasons that we'll see in a moment but
speaking of rocks let's talk about rocks
so this is a rock and immutability rocks
in the way that rocks rock now I don't
know about you but I've been going a lot
of tech conferences recently and I have
been feeling like there hasn't been
enough poetry so I'd like to read you a
poem nobody sits like this rock since
you rock rock the rock just sits and is
you show us how to just sit here and
that's what we need so true so deep this
is from yes thanks don't thank me thank
I Heart Huckabees a great movie check it
out very funny
so this is really how immutable data
Rock it just sits there
it just is once we've created it it
never changes and that's amazing because
it helps us avoid some of the headaches
of mutability so the mutability we we
have something pretty easy but other
things become harder and we'll see how
that looks so let's say I have an array
called foo and it's got some numbers in
it mmm already bored ok let's make it
more fun let's say I have a zoo with
some animals more fun and I decide that
I want to change something up about my
zoo
maybe I want to replace that rabbit
there with something a little more
exotic like an alien so this is cool I'm
happy because I wanted a more exotic
flute I got an alien in my view now I
didn't have to change anything except
that one little cell in my array that's
pretty sweet but my coworker over there
was expecting due to people of like
earth beings Earth's animals and wasn't
accounting for there being an alien in
it and it's like who put this alien
there now my program doesn't work
anymore ah who did that so mutability
has a couple problems we have to manage
who's been changing what when who's been
putting which animals in the zoo we have
to add a lot of overhead to manage that
state and that gives us headaches as
individuals and as teams we also get
bugs in the code because maybe I was
only planning or my coworker was only
planning to handle terrestrial beings
and didn't have the case of aliens
accounted for and that broke something
so these are some side effects of
mutability that don't make us happy
let's try doing things the immutable way
so in an immutable world my array my zoo
once I created it it just sits and is
forever I cannot change it what I can do
if I want a new zoo with this more
exotic is I can make a puppy that's the
same size as my original array and I can
make the modification that I want so I
can put my alien there in place of the
rabbit and then I can copy over
everything else in the array that didn't
change so this is pretty sweet because
now my coworker is happy
they're like room nothing broke in my
program it's all still earth creatures
but I had to copy over that whole array
I had to allocate the space for the
entire array even all of the stuff that
didn't changes that didn't change I had
to copy all of that over as well so this
means that my code runs pretty slow and
it also takes up a lot of memory takes
up a lot of space and
time the complexity on those things are
bad because copying is a waste of both
time and space it makes us sad face we
don't want that so if we want to do
immutability we must be able to find a
better way of doing that luckily for us
a lot of very smart folks have been
thinking very hard about this problem
for a while and they've come up with
some really good solutions to how we can
deal with the mutability efficiently
immutable data structures so immutable
data structures is a term you may have
heard bandied about especially in
conjunction with functional programming
or perhaps also with react where they
also come in very handy technically in a
mutable data structure is just any data
structure that's like the rock once
you've created it it just sits and is it
never changes but you also hear the term
persistent data structures bandied about
sometimes these are used interchangeably
although they have slightly different
meanings so if immutable data is just
data that never changes persistent data
structures are ones for which we have
some kind of access to old versions so
as we've been creating like new modified
versions of our data structure we keep
the old versions around you here might
hear about partially persistent data
structures where we can we can like look
at the old versions we can access them
but we can't go back and update any of
them all we can update is the most
current version that we have and then
you might also hear about fully
persistent data structures where we can
actually time travel we can go back and
update any of our past versions and if
this is starting to ring a bell that it
sounds a little bit like version control
I get sort of the same idea so we're
going to talk about these as persistent
immutable data structures they're both
persistent and immutable let's see how
this works
the the key all this is that we want the
old versions of our data like my
original Zoo to stay put we want them to
just sit like the rock what we want new
versions can be created efficiently so
what magical tricks do we have to use to
like make this happen do we have to make
invitations do dances to the gods of
space and time complexity No
it's very simple trees and sharing it's
not sweet
these two simple concepts will get us
efficient immutable data how so let's
talk about trees because trees rock
pretty hard as well although
unfortunately I don't have a poem for
that sorry imagine that we could find a
way to represent ours new array as a
tree so one thing I could do is I could
put all of my animals all of my values
in the leaves of a tree and I could make
it so that each leaf holds one value one
animal but they might get lonely so
let's put them with a buddy let's put
them two by two so each of our leaves
will have two values and we'll hope that
the buddies get along and none of them
eat each other looking at you tiger
number six don't need that claw and then
we can connect them together with
intermediate nodes and go up and up
until we get a root node that connects
the whole structure and that root is now
our previously array now represented as
a tree so this is my zoo now in a tree
structure so given this type of
structure how do we update something
given that my zoo is immutable it can
never change how do I get a new version
that has my alien in it so here what I
need to do is take the node that
contains the value I want to change so
in this case that would be the zero one
node which is on the bottom left but
you're seeing and I have to copy that
over
changing the thing that I would like to
be different so I make a new copy where
I've still got my monkey but I've
changed the rabbit to an alien and then
I need to copy any of the intermediate
nodes in the tree that were pointing to
the node that I changed so I basically
trace a path up towards the root of the
tree which now I've got a new root which
means a new version of the data
structure so this technique of making
this update by copying the path from the
leaf I change to the root is called path
copying that's pretty cool because now I
didn't have to copy the entire array I
just had to copy the nodes
on the way from the root to the leaf
that I changed so we've turned in
something linear and copying into
something logarithmic that's pretty cool
so that's more performant and the beauty
of this is that all of these nodes in
yellow here so most of the tree it's
shared between the two versions between
the old version and the new so this
saves me a lot of space because I can
actually reuse the parts of the original
version that didn't change whereas
before I had to copy those over as well
so this means that what was before like
a lot of memory consumption becomes much
smaller because I don't have to store as
many copies of the things if they didn't
change that's called structural sharing
because we're sharing the structure of
the tree between the two versions so
we've been talking about updating things
but how do we get at the values in our
data structure how do we access them
well it turns out that this isn't just
the tree it's a special type of tree
called a TR ie tree which was originally
came from the word retrieval so people I
guess could pronounce it tree but that's
confusing because we also pronounce the
TR EE tree so we're going to call them
tries so that's sort of what it looks
like
so our tree is a try that's cool a try
is a type of tree where the values the
leaves hold the values of our data as we
saw and the paths from the root to the
values represent the keys that are
associated that that data is associated
with so often you see tries used for
storing things like words as keys so for
example if I have the word P as one of
my keys what I do to get to the value
associated with T is I traverse the tree
one letter at a time so from the roots
I go to T then I go to E then I go to a
and I get te a is my key and my value
there is three because everything else
our friends sound like e in this talk
for some reason so this is pretty cool
but in our data structure we weren't
using words as keys we were just want an
array type thing we want index
in disease right so the insight here is
that if we treat the index as a binary
number then we can pretend that that's
kind of like our word and we can descend
the tree bit by bit as if each bit in
our binary representation of our number
is a letter so let's see how that works
if I'm trying to get at item 5 in my
array so the animal at index 5
I've convert that to binary so that's 1
0 1 and then I step through that as if
it was a word I step through it letter
by letter bit by bit
so I go from the root to the branch I
have a choice of either 0 or 1
I go to branch 1 first then I go to
branch 0 and then I take the thing on
the one side so I go 1 0 1 down my tree
and I end up at my Frog and index 5 so
this is a pretty simple insight but it
ends up being incredibly powerful
because it allows us to quickly traverse
this tree structure which lets us use
that structural sharing to more
efficiently represent our new copies of
our immutable data structure and
importantly we don't have to be using a
binary tree meaning we have two branches
from each node that fits pretty well on
a slide but actually what you mostly see
is a 32 Way branching so in our trees
that we've been looking at we've had
kind of one bit of information per level
and we've been descending bit by a bit
but if we had a 32 Way branching tree it
would be five bits of information that
we'll be representing at each level so
that would look something like this
if we had a much bigger number like
eighteen thousand nine hundred and
seventy-seventh in binary that's a bunch
of ones and zeros this would be a really
deep tree if I had to defend it one bit
at a time right it would be like sixteen
levels deep too much too long so if I
make more branches at each level then I
can chunk this up into kind of
I bit letters as it were and descend the
tree that's now only three levels using
the 32 Way branching so this is a kind
of a trade-off between how deep your
tree is going to be and how big the
nodes are going to be because if I have
just one bit of information at each
level then I have really small nodes
that's quick to copy over but I have to
go very very deep down the tree for a
larger array and generally research has
found that 32 tends to be a pretty good
trade-off between the size of the node
and the depth of the tree okay so we
have just seen what's called often a
bitmap vector try sometimes also called
a bit partitioned vector try
that's just jargon we don't need to care
about that but if you want something to
Google you can google back this is cool
for array type things where we have an
index and we want to jump to but what
about objects we also want to be able to
associate values with arbitrary keys not
just indices so we want non integers of
keys how does that work so if I want a
version of my data structure where it's
no longer in our array but it's
something like an object where I am
associating letters with each of my
animals like M for monkey P for panda
etc what I can do is I can take my keys
in this case their letters and hash them
to get a number that represents the key
so that each key will have its own
number they won't be in order
necessarily but that's okay objects
don't have to be in order and then we
can use the hash of that number in
binary to just send the tree as before
so if I wanted to look up B value
associated with EF I can hash F get some
number let's say I get five like ABCD
and five that would be represented in
binary of 101 and again I defend the
tree as before here for simplicity just
using a 1 bit at a time
2-way branching tree but again we would
typically be doing this with 32 branches
per level so again we just descend the
tree using the binary representation of
our key in this case we use the hash
function to transform
from some arbitrary object into a number
and we get the animal we want in this
case our frog cool so that if you want
to google it it's the things you could
google is a hash or a map to try and
this is a data structure that was sort
of pioneered by a civil Bagwell and then
Ricky implemented them in closure and
what a lot of what I've been talking
about is kind of inspired by I work in
languages like Clojure to implement
these data structures efficiently
there's a ton of other optimizations
that are usually done on these data
structures to make them super duper fast
and lots of details that we're not
covering here but this is the basic idea
trees to represent our data structural
sharing so that we can reuse as much
information as possible between the old
versions and the new versions and this
idea of using binary representations of
our keys whether indexes or or hash keys
to descend the tree to find the thing
we're looking for
so to recap mutability induces headaches
it is to be avoided especially if you're
doing functional programming where the
essential idea is to not have
side-effects and only be using pure
functions that don't change anything
except do the computation on their input
and return a new output immutability on
the other hand is great because when I'm
using immutable data I can't mess up my
co-workers program by making the zoo
that she thought with all earth animals
suddenly have an alien in it but copying
is a really bad way of handling
immutable data because it's not
efficient either with respect to time
nor with space and structural sharing
using these tree structures and try
structures and using structural sharing
to save as much information as possible
from one version to the next is really
performant way to do this so you're
probably thinking ok these data
structures are cool but what am I
supposed to do with them I'm not going
to be like building boxes of emoji here
and I know you don't have to
in JavaScript there are some really
great libraries out there to help you
use these right off the bat there are
various solutions but I'm going to talk
about a couple of them so one is called
Mauri Mauri is a basically a port of
clojurescript by David Nolan that allows
you to leverage the implementations of
these data structures from clojurescript
which is the version of Clojure that
targets JavaScript from the comfort of
your vanilla JavaScript and it's got a
bit more of a Clojure feel to it a
little bit more of a functional language
feel the API is functional and we're
going to see what that looks like in a
moment but that's one thing that kind of
sets this library apart on the other
hand there's also immutable j/s this is
a library put out by Facebook was
created by Lee Byron and this is a
JavaScript implementation of these data
structures so it has a bit more of that
native JavaScript feel to it it doesn't
have the the kind of closure background
brought in and that means it's got a
more object-oriented style API although
it is still returning new versions of
data structures instead of changing
mutable structures in place so let's see
what those look like this is how you
might use Mori to create what's called a
vector a vector is the data structure
from Mori that you'd probably be using
as an array type thing so I've got a
vector that I'm calling a because it's
sort of a ray ish it's got one n2 in it
and then if I want to push something
onto that the function that I'd use is
conch this is from the closure world
lists peek and what I pass in to the
conjunction is the original copy a and
then the thing I want to add on to the
end so in this case 3 and you'll see
that that creates a new data structure
on the right these vectors 1 2 and 1 2 3
they look a little bit different than
regular JavaScript arrays because
they're their closure vectors they're
not really JavaScript arrays although
you can convert back and forth but the
point is that this cons function returns
a new value which then I can
catch as a2 can capture that and I can
prove to myself that my original a
didn't change by using the count
function to see how many things are in
it and there's only two things still in
it but I can prove to myself that my new
versus an a2 has the third thing by
trying to access by using the get
function to access the item at index two
the third thing which it tells me is
indeed three cool this is all you would
do the same thing in immutable jf here
you would use immutable J's list of
little interesting syntax there and
there it creates something that looks a
bit more like a JavaScript array
although it is not a normal array it is
an immutable j/s list that I'll call a
and then if I want to add something on
to a new version of a I use this this
sort of dot method notation that we're
used to I say a dot push 3 but
importantly this is still not changing a
it kind of feels like it should be but
it's not it's just returning a new value
a new version of a which I'm going to
capture as a 2 and I can prove it to
myself that I didn't change a dot 5
tells me it's still 2 and if I try to
get the item at index 2 from a 2 I find
that it's 3 as I expected so similarly
for for what are called maps which is
kind of the key value object that we
might be using if I create an object Oh
which is going to be my morning hash map
data structure I'm associating a with 1
B with 2 again we see that the syntax
for these is a little bit different than
our regular JavaScript objects because
they're not regular JavaScript objects
there's super special immutable data
structures they need special syntax so
if I want to change the value of one of
my keys I can use this a sock function
pass in my original map oh and then
change the value of a to 3 in my new
version o 2 and again I can prove to
myself that the original didn't change
by using the get function to make sure
that a in the original 1 0 is 1 and
ano 2 is 3 as I would expect and it
looks quite similar in immutable J s
except the data structure called Maps
not hash map and I can pass in a little
object a little JavaScript object and it
creates me a map
oh that looks a little bit more again a
little bit more JavaScript syntax that
were used to this has a bit more of a
syntax and a feel that you might be used
to from JavaScript programming I can use
the set method on O to create a new
version where a is now 3 and I can use
the get method on my old version o and
my new version o 2 to prove to myself
that the old one didn't change so these
are really immutable data structures
they look really weird if you try to
look at them like in the in the console
just as JavaScript objects they're
really fun they're kind of spoke down
into because they have this complicated
tree structure so highly recommend you
try out these libraries and see what
works for you I can tell you just really
briefly before I run out of time here
that how they compare is basically again
Mauri is from the closure world closure
script immutable j/s is from the
JavaScript world that means the middle
Jas has this more object oriented you
know it gets kind of feel to it which
might be comfortable if you're used to
writing JavaScript but looks like that
however for me I find it a little bit it
gives me a little bit of cognitive
dissonance there because it looks like
we're mutating things with that method
those method calls or not we're not but
for me to get more into the mindset of
functional programming I prefer the
functional api of maureen because we're
really getting used to the way we want
to conceive of everything as pure
functions that just take inputs and
return outputs or not we don't even want
to be kind of in the mindset of making
changes in place to object there's also
some minor performance differences
between the two more is a bit faster
immutable J's is a bit smaller but
they're both great options try them out
hope one of them works for you so that's
my talk hope it's been useful
go forth and don't mutate your data
here's some references for
Thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>