<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>[JSConfEU 2009] Douglas Crockford: The State and Future of JavaScript | Coder Coacher - Coaching Coders</title><meta content="[JSConfEU 2009] Douglas Crockford: The State and Future of JavaScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>[JSConfEU 2009] Douglas Crockford: The State and Future of JavaScript</b></h2><h5 class="post__date">2013-06-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/JUKPcWzsPpo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello Berlin terrorist fist jab really
happy to be here tonight the secret talk
tonight is I'm going to be talking about
the state of the JavaScript language and
its specification how it got to be the
way it's about to be and what it might
be going forward but before I begin
there's one thing I have to say about
javascript javascript is a proprietary
trademark that belongs to sun
microsystems or possibly to oracle
corporation i'm not sure where that deal
is but we're only two open systems here
and so it seems strange that we put this
proprietary label on the stuff that we
do and then fact there is an open label
which is not proprietary which we can
all use which is ECMO script which has
actually become the true name of this
language that's what it really is and we
probably should call it xmas script
except it's just an awful name it's it's
really hard to say it and so so there's
that so in describing the standard
process that got us to the fifth edition
which I hope will be published next
month Brendan Eich the inventor of
JavaScript described it as being similar
to the motion picture the Fellowship of
the Ring in which I was Gandalf standing
on the bridge at Casa doom stopping the
monstrous es for proposal of which he
calls the es for raag
my perception of it's a little bit
different and so tonight I'm going to
give you an extremely biased story my
point of view of what happened and my
point of view is a little different and
and my movie is a little different my
movie metaphor is 12 Angry Men this is a
sidney lumet's wonderful climb courtroom
drama we don't actually see the crime we
don't see the courtroom we only see what
happens in the jury room where these 12
men get together and 11 of them are
certain that it's an open-shut case the
kids guilty let's cast our verdict and
go home there's one juror juror number
seven who says I'm not sure I think this
is wrong and over the course of several
hours they fight and argue and cry and
eventually he changes everybody's minds
and they acquit the kid so there you see
juror number seven that that was me and
the guy who was about to stab him with a
knife every juror number three that's
Brendan Eich and in fact we were all
Angry Men there were no women involved
in this I don't know why that I think
there should be but there aren't it's
hard enough to get men to come to these
things there were occasions when I
couldn't make the meeting so I send
people from my team and I asked him to
report when it was done and they said oh
it was really interesting is that would
you go again no no would not go again
then there was the 13th juror know the
alternate who kept saying can we speed
this up you know I couldn't get down
with this you know can we make this go
faster so the place where this was all
happening was at tc39 technical
committee 39 of ECMO this is where the
stewardship of the ECMO script
programming language happens at the time
that i joined tc39 which was about three
and a half years ago there were no
members of the committee who actually
used the way
which there was nobody who represented
you know one who had ever written a web
app nobody they all knew the language
really well because they're all
implementers of the language and the
things that they wanted to do with it
were things that were going to be fun to
do in the implementation they really had
no idea what you need it in order to
make the language better for you at that
time was a pretty small club there was
Adobe Mozilla opera and Microsoft and
opera actually shouldn't have been there
because opera at that time was not a
member of Vecna ineptness rules are very
clear that only members of the
organization are allowed to participate
in the meetings what the committee was
doing was pursuing a design that had
begun at Netscape in 1999 and in 1999
the problems that we had with the
language as we perceived it in the way
we used it were radically different than
they are now for example at that time
there was nobody using the language and
so they were considering pretty drastic
modifications to it in order to try to
get somebody to like it that wasn't the
case at the time that I joined the
committee Ajax had already happened the
language was taking off it was hugely
popular and once something becomes
hugely popular your license to make
modifications to it is revoked you have
to be much more cautious about what
changes you can make so the design that
they had begun in 1999 was abandoned
early in the 21st century but when Ajax
happened suddenly there were people
using the language so was like oh okay
there's reason to do this now so they
picked it up again I wasn't convinced
that we should finish this language I
thought it had a lot of deep problems
but first of most was that it didn't
solve any of the problems that we had
and in my view the most significant
problem we had was on security that were
we're constantly men asking with
cross-site scripting attacks and my
company and and pretty much all of your
companies are very much at risk at that
the consequences of those attacks are
huge and they are facilitated by the
design of the
language and the es for design did
absolutely nothing to correct any of
those problems we also have problems
with inter browser compatibility and the
design that they were pursuing wasn't
helping us there either there was strong
interest in the web community to make
the language suck less although nobody
really knows what that means and there
was not a good way to articulate that
and so the committee's interpretation
was any radical change we make is going
to make it suck less which I wasn't
confident that was the case I was
concerned that it was actually going to
make it suck more by making a language
bigger and more complicated without
producing any compensating value in
return and we've seen lots of cases
where good intentions have proven to be
ineffective so I wanted to bring the
committee back to doing good design but
they did not want to hear it they refuse
to argue about their system as a whole
they refused to argue about the
necessity of individual features they
would consider arguments about errors
and specific features but they wouldn't
talk about whether or not we should even
have it or not they claim that they'd
been at work on this for many years and
I just shown up and that they would be
done in a year so essentially I'd missed
the window for proposing changes to to
the thing and so it was just done so
that was very disappointing I was too
late to affect the process but that was
just the way it was however it turned
out that the Microsoft member had
similar concerns so I took him aside at
one of the meetings and asked him what
do you really think about this because
at this point microsoft had been so
cowed on by the web community and
everybody that they were pretty much
going along with everything but secretly
they knew that this wasn't the right
thing the guy talked to was concerned
that if microsoft changed their position
on it then they would be attacked for
doing anti-competitive behavior which
turned out to be correct that intact
happened but the concern wasn't to be
anti-competitive the concern was to try
to do the right thing and I convinced
him that Microsoft should do the right
thing and to his credit he decided to do
the right thing and convinced Microsoft
to do the right thing um so we had this
big showdown in redmond at one of our
scheduled meetings it was the biggest
meeting we ever had on everybody
sandbagged it except me so microsoft
brought in a whole lot of extra people
including the IE team mozilla brought in
a whole bunch of extra people adobe
brought in a whole bunch of people
people had never attended the meetings
before they just wanted to have numbers
around the table in case we voted on
something but there'd be something to
keep score about prior to the meeting
Microsoft wanted to play hardball they
want to set up a paper trail begin
grievance procedures involving the
secretary and a techna and all this
stuff and I didn't want to have any part
of that just its technical we're
disagreeing with these people on
technical grounds let's keep the
argument technical and not try to
escalate it into other areas and they
agreed to go along with that but we were
still polarized in committee basically
as a consequence of us for group saying
we're not interested in anything that
you have to say about moderating what
we're currently doing so Microsoft took
an extreme position saying we refuse to
accept what you're doing in whole or in
part which i think was maybe a little
stronger than what they should have said
what I think they should have said was
we need to reset we need to review
individually every feature that's going
on here based on some new criteria but
they didn't say that and so that caused
some bad feelings and so the committee
was not in consensus now which was a
really bad thing because as a Standards
Committee has to be in consensus in
order to do its work so the fellowship
was now broken at this point so I
proposed an alternative project which I
called es 3.1 indicating that it would
be a much smaller increment
over es3 which was the current
specification it would be a minimalist
alternative to the maximal alternative
that was es for unfortunately the
argument went public and when it went
public it went really nasty part of the
reason why when public was that es for
was positioned as the official new
standard and that yes 3.1 was breaking
the rules that es for had already been
approved and 3.1 was trying to undo the
system and that wasn't the case at all
but that was the perception that had
been given to the public there were a
lot of accusations made at Microsoft and
at Yahoo for example Yahoo and me in
particular were accused of conspiring
with Microsoft in order to protect IES
dominance in the marketplace and if any
of you know my position on ie you know
that's absolutely not the case we were
aligned on this because on the the
technical arguments were right so I I
was able to do one thing that Henry
Fonda was not able to do and that was to
bring more jurors into the jury room so
I went out and started talking to other
companies and I wasn't so concerned
about what their positions were but that
I wanted them to come and join the
argument because my feeling was the more
voices we had discussing this the more
likely we were going to reach a
consensus because right now we were
divided into two extremes and that
wasn't good we somehow had to get back
to consensus and my hope was if I could
get more parties to join the discussion
we would be able to do that many of
those companies sat on the sideline told
me privately that they were glad that I
was fighting the fight for them but they
did not want to get involved because
they didn't want to get tarnished the
way that Microsoft was getting tarnished
sorry
so we continue to agree to disagree that
was all we could do we had formally
split into two committees but continue
to hold joint meetings it was really
uncomfortable and it was unproductive
but through that process eventually
other companies join including IBM Apple
Google opera dojo and company 100 from
Korea and it took a while to get all
those companies to the table but
eventually could we got them and things
got a lot better all through this
process ECMO was really worried ECMO
script is their biggest product and it's
their hit it's the anybody know of any
other ekman standards and so ECMO script
was going out of control and if they
lost that that would be hugely
embarrassing at least and perhaps
monetarily embarrassing they could not
tolerate two proposals if we went to the
General Assembly with competing
proposals both would have to fail and so
we got into a race will tell you about
that in a minute so akma's
secretary-general and Edmonds president
both began attending our meetings which
was really good because everybody was a
much better behavior now so a lot of the
civility was returned to the process and
and it got a whole lot nicer so with
that new spirit of niceness we we
started to try to agree to things to try
to get back to some kind of consensus
and all we could agree on was that 3.1
and four should have some sort of subset
relationship so that 3.1 should be a
subset of four but we couldn't agree on
what that meant the es poor people meant
that the s3 team could only mine
features from he s for that there are so
many features in his for that anything
we'd ever want to do is go to already be
in there but from our perspective and
3.1 we were trying to make the language
more secure and that had not been a goal
for es for and so we needed features
that they have not considered so our
position was they
had to adopt anything that we added and
they weren't real happy about that
either so we're still not in consensus
we were not converging is for it turned
out it was one of those projects that
was slipping a year every year when I
joined the committee they were planning
on having the thing be done and approved
in a year they were planning on having
it done well before adobe air shipped
that was Adobe's motivation for why they
wanted this new language standard it was
going to be the one language in adobe
air on adobe air shipped and it was
still a year away from release and so on
and eventually they got to the point
where it was clear it was never going to
finish so they began jetta singh
features now when on an attempt to get
back on schedule so they were finally
doing the feature review that I'd asked
for the first meeting but now the
motivation was to fix the schedule not
to fix the design however in looking at
that they discovered that there were in
fact deep problems and the things that
they were proposing and in the
interaction between those things so
ultimately it was determined that the es
for design had been unsound all along
and so it was ultimately abandoned on he
has 3.1 because it was a much more
modest proposal was eventually completed
and became a candidate for the fifth
edition we decided not to call it the
fourth edition because the fourth
edition had already been pre-sold so
there was an expectation as to what that
was and this speck was not going to meet
that expectation so we decided to pump
the revision number ECMO was all
confused by that smaller as a fourth
edition but we got that through so it
goes to expose General Assembly next
month we have a meeting at Google in
Mountain View California and I'm hoping
that the general assembly will vote YES
on this in
we will have the first revision techno
script in 10 years that'll be a good
thing one company has stated its
intention to vote against it in that
company is IBM and the issue is decimal
arithmetic you make me know what what
what's that got to do with with declan
script well it turns out the number one
most reported bug in mozillas database
is 0 point 1 plus point two is not
exactly equal 2.3 and there are lots of
variations on this but they all come
down to the same fundamental problem
which is that binary floating-point
cannot accurately represent decimal
numbers which is a problem because on
our planet the dominant species uses
decimal numbers and the number system in
this language was designed for some
other planet some other race of aliens
they may be really nice creatures but
they're not us say you would think if
that is the most reported bug the most
replicated bug that deserves fixing
wouldn't you think and and it does and
we should fix it so where did the bug
come from it's actually not a bug in the
design of ECMO script it's a an inherent
problem in I triple you 750 for floating
point which is a floating point system
that's used in the whole world and it's
used everywhere on it was a it came
originally out of Intel out of the
failed 432 project and it significantly
improved the uniformity of
floating-point results across different
CPUs prior to 750 for every computer
manufacturer and there used to be lots
of them had several architectures and
each architecture had a different scheme
for doing floating-point different word
sizes different mantissa sizes different
encodings different exponent sizes
different biases different on rounding
loads all sorts of different rate X's
and so writing a program saying Fortran
that would get the same results on one
another was really really difficult
perhaps impossible so making it all
common was a huge step forward and this
was a really good thing for that
although it turns out now everything's
Intel so like you know who cares that
but at that time it was an important
advance and it is very well suited to
some applications including applications
we have both very large and very small
members that interact with the Otago the
other which includes astronomy chemistry
and physics and lots of other things but
not business applications or anything
that involves the level of math that you
might have learned in middle school
binary floating-point is poorly suited
for most other applications including
everything that we do so ok so we ought
to fix that and again the problem is
that binary floating-point cannot
exactly represent decimal fractions it
can handle dollars and quarters but it
accumulates errors on pennies nickels
and dimes how to use an American
metaphor if you type a number into your
program and it has a decimal point in it
you already have an error in your
program because that number does not
represent the value that you typed in it
you're getting something else so given
the applications that echo script runs I
Triple E 754 was a really bad choice but
it was also a popular choice because the
same mistake was made in virtually every
language design completed over the last
20 years everybody adopted this thing
because it was a standard just because
something is a standard doesn't mean
it's the right choice for every
application
so so that's a problem that we need to
fix and IBM came up with a proposal for
how to fix it something that had a
working title of I Tripoli 754 r4 I
think revision it adds decimal node
modes or decimal radix is to some 54 it
corrects the problems with
representation of decimal fractions IBM
tried to get this into the third edition
in 1999 the committee at that time said
oh we'd like to get it but we don't have
time we'll put it in the next one will
be coming up next year at that time they
didn't know that es for was going to
take ten years at that point they'd been
on an annual schedule and they figured
the next one will come so IBM's been
waiting for it ever since and they think
that they were promised this feature and
that they should have it except that it
was ultimately rejected by the es for
group and by the es 3.1 group there was
one of the few things we could agree on
but we all agreed that the the decimal
problem is a significant problem and 754
are was not the solution to it at least
not in the short term so let's look at
the beast so this is 750 for this is
what Java calls a float it's a 64-bit
value made up of several fields there's
a 56 bit mantissa there's an exponent
which is biased on the reason it's
biased is so that you can use integer
comparisons for comparison comparing
normalized numbers that's a value of
value if floating-point subtract is
significantly slower than integer
subtract so you take the mantissa which
is scaled to be a number between 0 and 1
and multiply it by 2 raised to the
unbiased exponent and
and that's the source of the problem
because we're raising to a power of 2
and not a power of 10 so they came up
with this to replace it what they call
754 our deck 128 so it's now a 128-bit
number so okay memory is cheap that's
not a problem just doubling the size of
everything but the encoding is really
complicated it's divided into 11 10 bit
fields each of those fields contains a
number between 0 &amp;amp; 999 and then the
exponent has some extra bits in it as
well they couldn't fit them into another
packet of 10 so the extra bits kind of
floating around in there so unpacking
all this stuff is really time consuming
so say you want to add one to one of
these you unpack the the first triple
add one to it ask if it gets bigger than
a thousand or a thousand or more if it
does you subtract a thousand from its
door to pack up next one had one to it
and so on 11 times it's really slow it
is really really slow now one problem
with it is it will produce results that
are more correct but some applications
made to be dependent on incorrect
results this happens in the web all the
time this is why Microsoft cannot fix ie
because everybody who's written
applications on ie depends on them
failing in a particular way and when
they change the failure mode sometimes
by eliminating the failure mode it
causes our programs to break which is a
hopeless situation and we anticipate
there are similar problems in the number
representation we think that it fixes
more programs and it breaks but it does
break some programs and we're trying
really hard in the standard business not
to break anything so we're very
constrained there we considered adding a
used decimal mode to
language so that that would say I know
the numbers are going to be different
that the results are going to be more
correct that's what I want I will accept
the risk for that happening and then you
can test for it before you put it in and
then we'll know that's good we rejected
that because the new format is literally
hundreds of times slower than the old
one and right and it was vetoed mainly
by the browser makers who are now
working really hard to all make their
JavaScript engines go much faster they
weren't willing to add something that
was going to slow them way way down now
I think in in practice it wouldn't have
been that big a slow down because mostly
we're doing integer arithmetic in this
language and we could have a special
case for integers you know if it's an
integer we take the integer path and
only if it's a float do we do this super
slow thing but the browser maker said no
that was a hardship to them they didn't
want to have to do that and so that's
not an option so we couldn't do that we
considered adding a decimal library we'd
say like new decimal and pass it a
string which is what your number looks
like when you call that value dot add
and pass another one and so on it was
really ugly and unlikely to solve any of
the real problems natural use because
existing programs are still going to
fail in exactly the same way and I don't
think we could get anybody to write
programs in this new mode it's just too
ugly so it was not a solution we
considered adding another number type
but one of the really good things about
this language is there's only one number
type and so there's a whole lot of
complexity that's factored out in other
languages you've got more primitive
number types in which you have to be
aware of what the potential range of the
values are and so on and if you guess
wrong then you're injecting terrible
bugs into your program JavaScript
completely avoids that by going to the
top of the line number and saying that's
the only one we've got it turns out to
be really nice but now we're adding two
of them so that adds a whole lot of
complexity to a language which is
currently extremely simple and in that
ass
and so that might be a desirable thing
but we really want to make sure we get
that right and we did not have time in
the current process so we still want to
consider that but not right now so we
are looking at trying to seriously do
something about decimal in a later
edition because it is the most reported
problem and we do want to fix it but
there are real complexities in this now
through all of this there's been no
discussion of more suitable decimal
formats IBM's position has been its 754
are or nothing actually they didn't say
nothing it's just it's 754 are and
that's it so I did some thinking maybe
there are some other options did I do
that damn Firefox and all their updates
so so i invented some more decimal
floating-point formats because they're
actually pretty simple so this is what i
call 96 the numbers are 64-bit integers
scaled by nine million so you take an
integer x 9 million and you store it
that's a number it has some really nice
advantages addition and subtraction
happen at integer speeds which is the
fastest we can do arithmetic so and
since most of what we're adding on or
most of what we're doing numerically is
adding and subtracting that's a really
nice advantage you may actually speed up
the current language it gives you six
exact decimal digits which i think is
for more than we need for most
applications and it gives us a seventh
decimal digit so that basically we
represent anything any integer over nine
million the nice thing about that set is
it allows us exact representation of
common fractions like 1 over 60 or 1
over 360 or one-third so that 1/3 times
3 will be exactly equal to 1 in this
language which is a really nice property
you'd think
all languages all languages should do
that no language does that but this one
could if we have this number type which
would be nice there are some
disadvantages six or seven decimal
digits might not be enough for some
applications for example if you're doing
trigonometry you want to get your signs
and get a lot of bits in them so that
your rotations come out smoothly six or
seven decimal places might not be enough
for that it's only 24 bits of
significance you might want more also it
doesn't have a lot of headroom the
biggest number it can represent is just
over a trillion which for most web
applications is probably ok but if
you're doing applications which say are
about the United States federal budget
they're not going to fit now most
financial applications at that level are
dealing in tens of thousands of dollars
or even millions of dollars so when
scaled that way they will fit but you
know in whole dollars they won't so
there are other things we can consider
so here's another format i came up with
they're called x64 again it's a 64-bit
number the mantissa is a 56 bit integer
and the low-order bite is a signed byte
which is the exponent the nice thing
about this is it's really easy to unpack
on we get the mantissa simply by doing a
left debt with sign extension and the
exponent we don't even have to unpack on
decimal on Intel architectures we can
get out that bite directly we don't even
have to move it out so it's really
really fast it's much faster I expect
hundreds of times faster than the I
Triple E proposal and it's really easy
to implement in software and if we can
ever convince Intel to put into hardware
it'll go
really fast it has disadvantages it's
going to be a little bit slower than 96
because on scaling of the numbers is
more difficult because you have to do
repeated multiplication and division by
10 which cpos know how to do but it's
not as fast as shifting bits and the
range is only ten or one with a hundred
forty three zeros behind it which I
think for most of our applications ought
to be enough the current number format
in in JavaScript life let's see go up to
three hundred and eight zeros but I
think 100 is so it ought to be fine okay
so that the argument we're having with
IBM now is over goals tc39 s goal is to
repair the language not to add I
tripley's 754 our IBM's goal is to add
754 are not to repair the language IBM
doesn't care about what damage we might
be doing they want us to solve their
chicken and egg problem so IBM has
stated that they will vote against any
language standard that does not include
754 are including ECMO script so this is
my appeal to IBM it is irresponsible to
inflict damage on a language and its
community to solve an unrelated chicken
and egg problem if you're nave oat fails
you will have done nothing except to
show contempt for the web development
community if you're nave oat succeeds
you will cause a significant damage to
the web and the open standards movement
if any of you are employees of IBM or
friends of the company please go back to
the company in beg them please vote aye
on the vote of the General Assembly next
month um so assuming that arm that it
prevails we will have a fifth edition on
first new edition in 10 years and it
defines two languages and that's just
because of the way that we have to write
the specs there's the default language
which is a language which will be built
into the browser and which you'll get if
you do nothing and there will be the
strict language I recommend that you use
the strict language for reliability
because it it says that you're opting
into wanting a better language and some
of the worst features of the language
you want removed or modified so for
example we take without we change the
way this gets bound we change the way
eval gets processed a lot of things
which either cause a language to be
slower or or less portable or more buggy
we're taking those things out it's very
difficult to change a standard which is
as popular as ECMO script because every
bad feature in it has been exploited on
the problem with the bad features isn't
that they're useless it's that they're
occasionally useful but dangerous and
they're want to be ninjas out there who
found exploits for everything out there
and we don't want to break their
programs now you might argue they
deserve to have their programs broken
and I actually have some sympathy for
that perspective but we have pledged not
to do that so we require people to
opt-in to the strict mode if they want
these repairs so I'll not use the
default language difficulty to the 3rd
edition that and then don't write in the
default language because hopefully it'll
be abandoned in a few years so we have a
new title for for the what we do it
though the committee now we call it
harmony the code name of the next
proposal is harmony not es6 because we
don't want to give a false impression or
false promise about something
and its likelihood of being or its sense
of inevitability that would be an evil
thing that'd be like having out an html5
project we don't want to do that again
so harmony will be built on top of the
strict language and so that will be the
core of the language going forward and
harmony will probably have incompatible
syntax so programs written in the
Harmony language will fail hard with
syntax errors they're from on pre
harmony browsers hopefully the IE six
problem will be solved by the time we
get this Beck done if it's not this is
going to be a real short trip because
the language will not be usable so
there's a lot of design pressure on it
as always there's a lot of pressure to
suck less for some meaning meaning of
suck and some meaning of less again this
is really difficult what some people
mean by that is they want the Dom to be
better which I absolutely agree with but
that's not our business unfortunately
that belongs to w3c I think today or
yesterday tc39 had its first joint
meeting in history with that mine are
with what w3c this is long long overdue
we need to get these organizations
cooperating and working together on this
stuff because our fixing the language in
a way which doesn't anticipate what the
further damage that are going to do to
the DOM and it just doesn't fit so we
have to reconcile those things there's a
lot of demand that ECMO script to be
more like other languages that would be
more like Java or more like Ruby or more
like pearl or
or you know pick a language that's not
going to happen if you want to be
writing in any of those languages I
strongly recommend you be writing in one
of those languages I don't think it
really accomplishes anything to try to
impose those languages on this one it'll
just make it complicated and buggy r
surprisingly there is a pressure on
making it a better compilation target
years ago we thought that Java VM was
going to become the vm of the internet
but it turns out javascript is the vm of
the internet because the a lot of things
wrong with the JVM that aren't as wrong
in javascript and so we've got google
with with with GWT and lots of other
people who are taking other languages
and compiling in into javascript for
execution in the browser and they've
been asking for things to make that
easier to do for example you might have
a language which has control structures
that are that work differently than Java
scripts control structures and so to
make it easier to generate code you like
to have a go-to statement so hey can you
put a go-to statement in JavaScript yeah
so I hear some groans from the audience
so the youngsters won't remember but on
the computer industry spent 20 years
literally arguing about whether or not
the go-to statement was a good thing or
a bad thing and eventually we figured
out it was a bad thing and that we
should stop putting in our languages and
we did that so to put it back in I think
would be a tragic mistake because the
ninjas would get ahold of it and they go
oh look I can make it go so much faster
by doing a go to here and we don't want
to be responsible for that kind of crowd
so we're sympathetic with the idea of
being a better compilation target but
our first priority has to be to the
users of the language as the language so
we don't want to screw it up for us in
order to make it better for them a goal
that I have a lot of sympathy sympathy
with is the goal to make it secure as I
still think that's our biggest problem
javascript it gets a lot of flack for it
security problems it actually comes
closer to being a secure language than
virtually any other language
current use there's just a small amount
of stuff that we have to fix the caja
experiment at Google proves that this is
true my own work with add safe suggests
the same thing Facebook's f bjs allows
third-party code to run our Facebook
pages not i framed or anything so we
know that a small amount of effort can
turn this into a secure language and I'm
hopeful that we can factor that into the
next editions of the language and
there's also the goal to be better at
math that we really do what to fix the
decimal problem there are some people
who want us to have support for general
math so that you could have complex
numbers anybody want complex numbers
anybody anybody know what they are
yeah a few yeah most of those who know
what they are don't want those I
understand that but again language
designers they could be really neat if
you could design it so that you could
add complex numbers to the language and
then have them work and maybe it would
but I don't see a lot of value in it
there's also a lot of demand for begins
so you can have been sabar baterry
precision that go on forever the primary
use case for those is doing cryptography
you can do public key stuff and about
with using begins which i think is
exactly the reason for why we shouldn't
do it um if we make it easy to write
crypto routines in JavaScript than
people will and one thing we know about
crypto routines is you should never be
writing your own crypto routines because
they're really hard to get right you
want to be using stuff that other people
have written that have been very well
vetted so this is another attractive
nuisance that we can add to the language
that I think would be a mistake one
thing we probably will do is correct the
block scoped problem travel some
enthusiastic applause over there on
JavaScript does not have block scope
which would not be a problem except that
its syntax says that it does and so that
is a big source of confusion for
programmers coming from other languages
for example it causes them to put their
VAR statements in the wrong place and
and so will probably fix that by adding
a let statement and a constant statement
which will replace the bar which will be
blocked scoped so there you go we'll
probably have better support for
functions with variable numbers of
arguments the arguments of ray thing is
awful there's some new syntax that we
could add which would make it much
better we'll probably do that there's a
lot of interest in adding some sort of
syntactic language syntactic sugar to
the language in order to
add class like notation to things but
have it mapped on to the current
language it might be possible to do that
with macros so you could define your own
language at any level and that would be
easy and then we get out of the way of
that but the committee is wary of macros
so we're probably not going to do that
we'll try to figure out some other way
one other way might be to use functions
to wrap things so we use the classes as
closures pattern but there is one
problem with that which comes out of our
d tenants book the principles of
Correspondence that was published in
nineteen eighty one which doesn't get a
lot of attention today but there was one
particular principle that he outlined
which is very attractive and that is the
principle of correspondence which shows
the correspondence between variables and
parameters so here we've got two
functions booga and looga which do
exactly the same thing except booga
represents x and y as variables and woo
God represents them as parameters but in
all other respects they're exactly the
same so that's sort of an interesting
thing you know to a minimalist it might
say well we don't need variables in the
language we just need to keep nesting
our functions which may or may not be
the right thing to do but one of the
attractive ideas that comes out of this
is that maybe we could take anything and
wrap it in an immediate function because
there's some benefits that come from
that except we don't have full
correspondents because they're
disruptive statements like break return
continue and throw and implied
parameters this in arguments whose
behavior change if you put them inside
another function and that change of
behavior would cause
an error so there's been argument that
we should remove all of those things
from the language which I don't think we
can do tenant himself does not demand
that the language have full
correspondence he just uses it as an
analytical tool in talking about
languages another proposal has been that
we add a second kind of function in
which the meaning of those things don't
change but I think that's adding way too
much complexity language I think that's
asking for trouble now tenant does say a
couple of specific things about
programming language design which I
think are really useful many existing
languages manage to combine countless
features into a jumble that is neither
easy to implement more pleasure to use
he said that an 81 we've kept that up
pretty well he also said side effects
are often confusing to program readers
because they are unexpected the familiar
expressions of conventional arithmetic
and algebra do not have side effects so
tenant might be saying that we should
not have put getters and setters into
es5 but we did so we don't always get it
right so ten years that anybody think
that was too long am I the only one
maybe I think actually five years was
about right the reason Ajax happened in
2005 and not in two thousand was it took
that long to flush the really bad
browsers out of the market did to get
Netscape for out and to reduce IE for
and I III to accept ibly small numbers
it was only when ie6 had absolute
dominance that Ajax became viable so a
lot of people in our community are angry
at Microsoft for having neglected the
browser for so long my view is it is the
best thing they have ever done doing
nothing for five years is the best thing
Microsoft has ever done maybe 10 years
was a little too long but I think five
years was about right
so let me wrap up with some lessons that
I derived from this standard experience
and and maybe these will make sense to
you we need a clear separation between
research and standard setting I'm a big
fan of research on a big fan of standard
setting I even believe that the same
people can do both but nobody should be
doing both at the same time on a
standard is the last place in the world
we want to see innovation we shouldn't
have any risks or uncertainty or doubt
we should be absolutely clear on what
we're doing because once you set a
standard in place you really shouldn't
be changing it um-hmm don't promise what
you can't deliver at this the fifth
edition is just a candidate and it may
fail next month so I'm not here
promising that that's what you're going
to get I think it's likely that it will
succeed but it could fail maybe IBM will
be successful in putting us down or
maybe between now and then some very
smart review or we'll find some
tragically horrible bug in the spec and
we'll have to withdraw it at the last
minute if in fact there is such a bug in
respect I hope in fact he finds it
before it goes to the General Assembly
so we can withdraw it because once
something gets approved as a standard
it's really hard to take it out I'm
pretty confident that we don't have that
bug in there but that's a possibility
and so we need to admit that a change to
a widely used standard is an act of
violence so any changes that we make
have got to be worth it changing a
standard should involve the same trade
offs as surgery you know we want to cut
somebody open you know that generally
isn't a good idea but you might do that
if there's some compensating benefit or
if the risks of not doing that or
greater than doing that those are the
sorts of difficult choices we need to
look at when we proposed changing the
stand
and anything which is a trivial or
cosmetic fix probably we shouldn't be
messing with if you have a great idea
don't tell a standards body instead
implement it show to the world and if
the world says yeah that's right then
obviously that should go into a standard
I see a lot of people trying to do that
in the opposite order and shouldn't do
it we don't want to be taking those
sorts of risks in the standards we need
proof first standards are hard they're
really hard work they require tremendous
care and precision and fortunately we
have amazing people working with us who
are able to read the specifications of
how machines work and run those machines
and their heads and figure out where we
got it wrong and we are blessed to have
people like not working with us we are
blessed to have people like Elmer's
block of Microsoft who's our editor
whose diary Norma's amount of work and
cleaning up the specification it's a
significantly higher quality document
from the third edition was we're hoping
that the next edition will be even
better you can't please everybody this
gets back to that the hard thing they're
going to be expansionists who have
really good reasons for why they want to
grow the language and the reasons are
good but at the same time they're going
to be minimalists like me who say no we
should not be changing at all unless we
have profound compelling need to do so
and somehow we have to find consensus
and that's hard but that's sort of the
core about what the whole standards
process is about I see a lot of
standards bodies that don't do that
adequately instead they do a pork barrel
thing where if you support my stupid
feature if you agree not to argue about
it I'll support your stupid feature and
we'll both get our stupid features in
and we can both feel proud that we got
something done I'm very happy to say
that tc39 currently is not acting in
that mode
but I see other bodies that do check
your expectations of the process can
produce heartbreak and disappointment
I've talked to people at IBM and at
Adobe who both described their
experience with tc39 as betrayal I've
heard people say they were betrayed
there was betrayal there was no betrayal
um they came in with incorrect
expectations they thought that they
could get a specific outcome and you
can't you can't have that expectation
the best you can hope for is that you
can get a consensus on what you ought to
do and that's not necessarily going to
be the thing that you wanted everybody
else to do are there going to be some
trade-offs arm and there's going to be
disappointment and you need to
understand that going into the process
are you also need to check your motives
I see sometimes people wanting to get
into the standards process in order to
show off you know if I can come up with
this really complicated feature and get
it into the spec that I'll be famous I'm
the guy who put that feature and that's
my feature we really don't that's not
how we should be doing things I've also
seen people who get into power trips
like if my future gets adopted Microsoft
will have to implement it they will have
to bow to my will
and we shouldn't be doing that stuff
either um we've also seen cases not a
tech not but in other standards where
one of the parties to making the
standard is holding a patent on the
thing that he's proposing be adopted and
does not disclose that on and the patent
gets approved and now everybody uses the
patent is snagged by that and is on the
hook it has to pay them off and that's
that should be criminal but it's not a
lot of patent or standards bodies now
have rules against that unfortunately
they only apply to the members they
don't apply to the world so the rest of
us might put a feature into the standard
in good faith and it might turn out that
some third-party unrelated to any of us
has a patent and everybody gets screwed
and there is no solution to that problem
patents and open standards are
fundamentally incompatible and I think
the solution to that is to close the
Patent Office
I believe that the success of an
enterprise should depend on the quality
of its goods and services and stability
to execute efficiently and not on a
capricious government office which is
how it currently works so some companies
think it's attractive well if we can get
a patent and if we can snag one of her
competitors it's free money and who
would say no to free money except it's
likely that your competitor is also
going to snag you on something and maybe
some patent troll is going to get both
of you so it's it's like gambling and
you hope that in the long term you're
going to win but actually in the long
term you're probably going to lose the
patent system made sense in the
eighteenth and nineteenth century it
really had a fundamental impact on the
industry and the sharing of ideas and
helping us to develop the world that we
live in now and it was a good thing then
but it is long out used outlived its
usefulness and it is now a detriment and
a barrier to progress so in the patent
system nobody wins except the lawyers so
I want to get rid of it one of the other
one of the main reasons to be in
standards process is the satisfaction
that comes from getting a lot of people
to agree on anything particularly on
something good that is a wonderful and
add valuable thing and so that's that's
the good thing that comes out
accountants so ECMO script to the fifth
edition it's coming soon it will be the
best web standard in the history of the
world there's still lots and lots of
room for improvement so what we're my no
means done yet but I think we've made a
good start on it and I hope that we can
be an influence to other projects as
well I expect that the future editions
of Ekron script will be even better even
if they still suck a little
thank you and good night
so I think we have time for some
questions yeah okay anybody yes but
I have not these are paper proposals at
this point just to suggest the
possibility of considering other formats
there may be more mature better thought
through formats that I'm not aware of
and I'm hoping that by starting this
discussion will find those so I'm not
advocating any particular type I'm
advocating opening the debate to better
possibilities if it turns out that we
can't find any than the next obligation
on me is to start implementing these
things and trying to prove they could
actually work in this environment anyone
else over there
yes
why did we remove arguments khali we
wanted to remove the whole thing but we
couldn't do that the caja team at Google
was concerned about the potential for
capability leakage through arguments
collie one of the reasons we're adding
the strict mode is to reduce the the
cost of kaha and to reduce the
likelihood that you're going to somehow
get access to some capability that you
should not be getting at so removing
arguments collie was an important step
in doing that the language does provide
a way of several other ways of
supporting recursive functions and
you'll just have to use one of those
right yes
hmm
I don't know
that's not an option that IBM has been
presenting to us IBM has not been
presenting that option to us the only
the only option they gave us was the
128-bit format
good that's very encouraging
anybody else yes
um actually es5 strict mode looks a lot
like the good parts the good parts turn
out have a lot of synergy with kaha and
with the new design of vs five so the
the struggle for us was how many bad
parts could be removed and we didn't
remove nearly as much as we wanted for
example we still have semicolon
insertion the browser makers told us
that it would be a hardship for them to
fix that so watch your semicolons yes
so when will it hit the streets on parts
of it have already hit the streets for
example high-speed JSON parsing is now
built into ie8 and to firefox firefox
already has the new array methods and a
few other features we don't know yet
who's going to be the first to market
with the whole language my guess is that
Microsoft is probably a little bit ahead
right now but they can't ship until IE 9
and who knows when that's going to
happen so they're pretty constrained in
that my guess is that Firefox is going
to play tortoise in here with Microsoft
so they're going to wait until it looks
like Microsoft is getting to the end and
then they're going to go really fast and
try to beat him to market we're trying
to convince them that they should beat
him really really good but we haven't
seen that Apple was involved in all this
stuff and when I asked them what their
intentions are they say we can't comment
on future product directions and the
Google team has been telling us will do
whatever Apple does so
we're trying to get them to hurry it up
to yes
jslint should look exactly the same if
you're in the good parts then that
should work really well in the strict
mode there's one of the things that we
try to do in the design of this language
is not add any new syntax because if we
have new syntax your programs will fail
on the older browsers and so that
doesn't really do you any good look at
this new feature that you can't use for
five years so we tried to put in
features such that you could either test
for their omission or in most cases you
could your Ajax library could fill them
in for you so for example if you're
using the JSON to jas for your JSON
parsing when you're running on one of
the newer browsers there's no change
except you're Jason parson gets really
fast and we can do similar things for a
lot of the other array methods and so on
okay well done all right good night
folks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>