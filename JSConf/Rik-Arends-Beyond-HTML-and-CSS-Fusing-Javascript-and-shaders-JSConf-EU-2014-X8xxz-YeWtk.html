<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Rik Arends: Beyond HTML and CSS: Fusing Javascript and shaders | JSConf EU 2014 | Coder Coacher - Coaching Coders</title><meta content="Rik Arends: Beyond HTML and CSS: Fusing Javascript and shaders | JSConf EU 2014 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Rik Arends: Beyond HTML and CSS: Fusing Javascript and shaders | JSConf EU 2014</b></h2><h5 class="post__date">2014-12-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/X8xxz-YeWtk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello Jess Kong Hey
all right I am a recurrence I have been
the CTO and founder of cloud9 IDE and I
have in the last two years thrown myself
at the GPU and using that thing for you
is and for doing interesting things and
the the the solution that I have arrived
at is called one Jas and I want to talk
to you about that today or how many
people here are graphics nerds and how
many here are language nerds so graphics
nerds language nerds good language nerds
are good if you're making a programming
language language nerds are good
so one Jas why very simple reason the
GPU has vast creative powers the
programming languages that can the
programming language that can run on a
GPU can determine the color of a pixel
with a program not with CSS background
color or a background image with an
actual program and what that means is
that there is an enormous amount of
creative possibility that is enabled by
the use of programs on the GPU the only
problem is it is really hard to do right
now there is like a huge air gap between
your UI programming environment like
JavaScript and the programming
environment on the GPU which is GLSL
GLSL is AC like programming language
that came out of pixar kind of sort of
but it's actually kind of a pretty
language it's a it's it's pretty much
just like JavaScript if you
objects and you add instead of numbers
you can do vectors so you can do a plus
B and a is the vector and B is a vector
and the result is vector where every
component is added in parallel like Sim
D and GPUs are everywhere nowadays
everybody here is walking around with a
GPU and their phone that's more powerful
than anything we had on PC a decade ago
so here's my presentation running on the
iPad and it's 60 frames a second on the
web it's really really nice that we have
this kind of GPU power available in our
mobile devices it's not everywhere yet
WebGL is still kind of shitty on Android
actually really shitty on Android but
it's hopefully going to get there
someday when they fix the the GPU reset
bug but the main problem is that GL and
GPUs are really really hard they're very
difficult and very very elaborate to
make them do things I'm just scrolling a
bit of GL of WebGL API here it's
incredibly chatty you have to do a lot
of setup to get the GPU to do something
so what is the essence of the GPU how
does this thing work well you have to
look at it in a way that you can give it
a program a bit of code that is that is
computing pixel colors for instance and
you feed it data and variables and the
variables are referenced in the program
and the data streams through the program
in parallel and is then output it to
pixels I'm not going to go in deep in
the WebGL
explanation Steve Witten's has brilliant
demos that I you know if you want to
understand how that stuff works go look
at that I want to focus on how to remove
all this craft between programmer and
the GPU so one of the things the GPU can
do is massive parallelization this is a
something that is very easy to do in 1g
s by the way this presentation is
running in one Jas
because doing a talk about graphics
without using your own graphics engine
is kind of lame so the cool thing about
the GPU is that you can feed it data and
have these little programs do your
styling for you so essentially you
parameterize the data and then have the
little programs on the GPU do style
switches do style changes in this case I
made a very simple blob of vertex data
which are the little triangles that go
into the GPU and on every one of those
triangles is a letter it's a is a
character of a font and in that big blob
of data I encode the XY coordinates of
in this case the word the the word color
is compute and that means that this
whole thing is taking like 0.2
milliseconds of draw time in JavaScript
and is run entirely on your GPU there's
pretty much nothing going on in
JavaScript this parameterization of
styling on to the GPU I think is going
to be very very important and it's going
to find it hopefully a new way to style
things on the web that CSS has so sorely
lacked so the parallelism idea or that
this picture is trying to illustrate is
that you have to imagine every pixel as
having a function call that computes the
color of that pixel in this case that
function call takes some arguments in X
and a y-coordinate and an animation
parameter T and it decides the color of
the text or the color of the pixel it's
the same concept so we all love bread
victor talks who lost bread victor talks
whoo that guy's awesome but he also had
an interesting point about first
principles that was a bit puzzling to me
like first principles what are those
things
but this time around I try to find my
first principles of what I'm trying to
build and one of the core concepts that
I try to put into one Jas is
programmable beyond configurable
programmable is better than configurable
we all know the declarative space where
everything you want needs some
implementation from an engine designer
right oh we want another parameter to do
something in the engine if you do it
declaratively then those declarations
have to be executed by an engine that
somebody has to build you know we all
know the CSS spec stuff where everything
is configurable but configurability is
enormous limiting factor on the creative
potential of what we can do with
computers but this concept if so I
usually applied like this if you find
yourself making something configurable
consider making it programmable so
instead of making an API make a compiler
right instead of having a flag use an
expression at very least an expression
and better general function execution
and I try to put this in in the details
of one Jas another one is that style and
behavior are irreducible and by this I
mean if I am encoding a red rectangle I
have to say it's red and I have to say
it's a rectangle I cannot make a red
rectangle out of any less data than
those two statements red rectangle for
buttons is the same thing if I make a
button everybody here has probably made
a button in HTML where you go on click
you know capture the mouse move your
mouse out of the rectangle Mouse up oh
that's not a click event right that
logic is irreducible if you're trying to
implement a button the logic that
manages how you click on it with the
mouse is completely reducible so the
only way to make UI more compact in our
express ability in our in the powers of
expression is by composition make
composition the core aspect
programmability composition because
style and behavior behavior are
irreducible so there's no pipe dreams
about oh let's make the grand unified UI
kit no that's never going to happen
because somebody's gonna want this
slider to do something that you didn't
program
to it so declarative is always going to
break down and this is something new
that has arrived with the GPU in
efficiency is okay when it's parallel
because many of you might think oh the
GPU is so fast well actually it's not
fast it's parallel which means that it
can run thousands of little programs
that run relatively slowly but you can
still get a vast result out of that that
you wouldn't be able to do if it's a
serial language because JavaScript has
pretty much been a serial language we so
we're all accustomed to all four loops
are expensive well if you do it in
parallel you can do actually quite a lot
of things so what to change how I'm
gonna attack this problem so if you want
to make the GPU programmable in a way
that is more accessible from within
another programming environment because
we're not doing declarative structures
we're doing programming environments and
compilers we have to fuse GLSL into
JavaScript as far as we can right GLSL
is a c-like language with with type with
strict typing so you have a four-vector
and you have a float in you have an int
and you have an array of this an array
of that and javascript actually
syntactically is fairly close to how
what Jeolla cell looks like in terms of
C so what I tried to do was fuse these
languages at the hip probably but fuse
them in a way that you can you can
leverage the same syntax whether you're
writing a shader or whether you're
writing something that runs in
JavaScript so by the way these are
syntax shaders because syntax
highlighting is kind of lame which means
that I actually throw the ast onto the
GPU and you can write little fragments
that style your code I mean I wrote a
code editor thing with my previous
company and this was just like you want
this right I don't know why you want
this but it's awesome
so it's not about it's not about why
it's about
the potential of exploration that you
can do if I can make an error jitter in
my line of code I can add something that
is useful this is not useful but this
looks pretty so 1 GS is JavaScript I
really tried not to break JavaScript
because that's kind of annoying because
then I have to explain a million times
why I did something so I tried not to
break it but I also tried because it's a
trans compiler I tried to fix some of
the problems that are in JavaScript and
one of the things is I finally got rid
of semicolons it's very important it's
official noise and I don't like visual
noise but what you have to do to get rid
of semicolons is just make it new line
sensitive when it reads parentheses or
square brackets on the next line that's
all you need to do if you make it new
line sensitive at that point then you
can just get rid of semicolons because
everybody who's like no semicolons is
there for a reason because it blows your
foot off if you do this incorrectly like
oh now it's a call all of a sudden oh
 right it blows your foot off so
everybody who's learned that is like no
we do semicolons well if you can fix
that it's it's no problem and I try to
take the Ekman script 6 spec and 7 and
all the ideas that I could find in
CoffeeScript and all these other
languages Giulia and Lisp and I try to
fuse it down into something that
wouldn't break JavaScript but would
still add the stuff that I needed
because if you're fusing to execution
domains there is something that is very
useful about
symbolic expression so we'll get there
dead next but I'll first show you the
class because classes are another very
important aspect of the language because
because of the composability if you if
you have a button and you want to
specialize it to do something different
you need to be able to inherit a class
and just change one parameter because
that's the most compressed
representation of that idea a button
that's a different color okay well we'll
take this button and we'll change the
color right that's sort of like a
compression algorithm in your in your
expression of code so class are super
important I took the ACMA script six
thing except I changed one thing they're
not functions any
or because I hate dot prototype have you
ever tried to explain the prototype to
anybody I don't if nobody gets it it's
horrible so I just removed a prototype
my classes are just objects and I don't
have a new operator I have got new it's
very simple just because I've tried to
explain it so many times and it's just
not right work for me doesn't mean it's
not compatible with JavaScript because
it's just a it's a superset largely
except if you like to do function calls
with parenthesis on the next line then
that's your problem so the interesting
part is we have structs and vectors now
in this in this implementation and we
have symbolic expressions symbolic
expressions are an idea from Lisp where
you do quote and then you write
something in code that looks like code
but it's actually an ast node in the
language so here on the right you see X
is y plus 1 but with a colon in front of
it and the colon is the quote operator
the colon eats the whole expression to
the right and turns it into an ast node
and this is really really really useful
because now you can start to treat
expressions as useable objects in your
in your language and here's an example
of how you draw a triangle this is not a
library that abstracts away what you do
these are the actual is the actual data
the vertex shader and the pixel shader
that this thing needs to draw this
rectangle there's no matrix stack
there's no nothing this just is the
essence of what the GPU needs to do to
draw a triangle so you can make a vector
array this is the syntax of GLSL how to
do array so you can use that in
JavaScript just this compiles to a float
32 array expansion so you're really in
JavaScript here I could do a console
lock in the middle you know this is just
JavaScript except it has a few little
syntax tweaks and another one of the
syntax tweaks is that is the identify or
curly syntax because I always get very
annoyed when I have to express three
structures in a sort of a computable way
that I have to go to JSON or that I have
to go to XML just
horrible because the language should
have a construct that is sort of
modifiable to express these three
structures in a way that you can mix it
with your language like a templating
structure I could put a for loop in
front of this draw and it would do it
ten times
so this ID identifier curly syntax is
actually a call it does object call and
the Curly's are a function so this just
says device dot call blah blah blah
wrapped with function that's what it
expands to and it and it passes into
this because that is another important
thing once yes does not have Global's it
just slaps this dot in front of anything
that would be a global which means that
you can access properties on your object
without using this dot which also makes
your code much less wide so here we have
a triangle and you can see the mesh with
the empty brackets and that actually
pulls in the data from the Java Script
space so I don't have to write
attributes or uniforms and all that
that GLSL does it's generated for you by
looking at what you're using in the
shader it's just it's very simple
compilers do this all the time it's just
something that needed to be done so we
have we have device and we have draw and
draw is just a draw call but if we can
inherit from device and make a scene and
we can inherit from draw and make a
layer we can start using the
composability to build actual scene
graphs and I know it is terribly ugly
because a week ago it did nothing but
this is a very simple example of how you
do nested rectangles with the pen with
meit with matrices right the scene
graphs work in a way that you have a
rectangle that has a matrix and then
something inside it that has a matrix
and these matrices are multiplied
together to get the relative offset
that's how the CSS transforms work
that's how the browser does it that's
how you do 2d nested transforms is by
concatenating the matrices seen and
layer are nothing but a simple class
that inherits from device and draw that
just implements that multiplication of a
matrix and you can parameterize that
matrix with WH and SX loyals just you
could call it top bottom left right and
scale
axé and all those kind of things I like
them short but anybody could just change
that and make a long name for it and
here you can see instead of background
image you actually just make a texture
fetch and you do background dot sample
at a certain coordinate so this
rectangle can be parametrized in any way
I can twirl it flip it do anything with
this code it's programmable the the
styling here is programmable and the
styling actually comes from your class
model so that also means I can do
inheritance I can do CSS like style
classes that are just applied they just
apply these properties because shaders
are now composable I can reference an
object I can reference another function
on my class essentially shaders have
been fused with the class model to hurry
up so interactivity this is really lame
but it shows you a very important aspect
of of changing stuff dynamically so
unmask left down I changed the symbolic
expression of X to Mouse x and y so I
lock it to the mouse essentially the
compiler goes oh you've changed an
expression well let's recompile your
draw function and send it to the
renderer and then the renderer does the
stuff with the with the the mouse
coordinates so I've essentially told the
renderer to data bind this is expression
data binding in the renderer by using a
compiler and it's really cool you can
you can change any part of your shader
functions and variables interactively
I'm still working on animation system
and and all that but we'll get to that
later so these slides are written using
a class DSL because you have the nesting
curly identifiers syntax you can
implement a DSL by putting by making a
bunch of nested classes right you can do
class Dec and then the slide is in a DAC
this just means that I can only
instantiate a slide because it's only
known on the class deck so if I don't
put the slide thing in Dec it's just
going to say undefined so now I have a
domain-specific language that is encoded
in
a class hierarchy so you know I don't
need all these really fancy HTML things
I can just make a domain-specific
renderer for these slides these slides
are a Dom tree but a different kind of
Dom tree it's not a Dom tree that
renders all their children and I'm
hiding layers no the Dom tree is having
a custom draw command that goes I'm
gonna render the current slide and
nothing else and I know the slide ID so
you specialize the draw function in your
call to the Dom instead of this being
C++ parameterised it's a programmable
render engine that has per node draw
calls that you can just change so the
stuff is not ready for use at all three
months ago I was like yeah let's do Jays
golf course it's a nice deadline if
you're building compilers and you know
it's to get somewhere it's really far
too hello world when you start with the
language but I still need to refactor
this is a type inferencing compiler it's
kind of my first type inferencing
compiler so you know I need some
refactoring time on this thing it's
actually multi-threaded so the the code
that you saw runs in a worker and the
compiler sends the the draw calls to the
draw code to the main thread which is
really nice because I don't get I get
minimal garbage collection hiccups in my
renderer because all your user stuff
that's doing data generation for data
visualization or whatever it's doing is
not in the render thread it's perfectly
fine in a worker it's fairly large it's
130 K over the wire because I'm
compiling everything in the browser
always and I'm using browser-based local
storage to cache the output which is
really nice because I don't like server
based compilation solutions because it
limits the composability of your
programming construct if you have to pre
compile everything so it always compiles
in the browser it's actually really fast
this whole slide thing takes about 450
milliseconds to parse and compile the
whole thing which is pretty ok for
probably like 10 or 15 thousand lines of
code in JavaScript and if it's cached it
actually starts up much quicker so iOS
is great I mean I was like yeah yeah
WebGL
yeah BAM and it works you know Android
swept yellow WebGL and it doesn't work
so the state of WebGL is not that great
for mobile yet I mean this is great that
it works but on Android it's it's not
you have to manually enable it in Chrome
otherwise you can freeze the whole
operating system eventually essentially
and that's why it's disabled so it makes
sense that it's disabled but it's you
know so this is a future facing
technology this is not something you
want to use for a corporate client
anytime soon so the future is
constrained layouts cassowary is in here
and ported and I have it running and
because I have the compiler I can
actually you can just write a constraint
straight in your your code block like
this and it can run the solver on the on
the scene graph so that's coming this is
all not responsive and has no layout
engine because I haven't gotten to that
point yet but I mean I got I got away
with it because I have essentially
expression layouts so you can do minor
you know parent with -100 superposition
something from the right it doesn't
actually have a layout engine but it
will and I'm going to build a life code
editor in this thing itself because this
is of course a great way to to build a
code editor if you can do this kind of
tech stuff but also the reason is that I
need to bolt the editor onto the ast
directly otherwise the editor is going
to be this dumb thing that looks at
regular expressions which is not where
you want to be with with the code editor
you want to have the full ast and you
want to be able to operate on the ast so
the ast needs to ricci realize into
proper code which is what I'm going to
work on next and it needs to work on
this thing the Occulus at 75 Hertz so
I'm really hoping the browser guys can
get that done but I'm actually fearing
it might not happen so the cool thing
about this is that it has almost no API
exposure so I can run it in know just as
well as I can run it in the browser and
I'm going to you know make a prototype
of a new cloud 9 UI because I think it
should be quite easily doable it's on
github on 1g s / 1 GS you can look at it
and not complain about it cuz it's I
mean you
you look at it and do stuff with it if
you want but it's not something that I'm
throwing out in a supported way because
I'm in the middle of you know bolting a
type inferencing compiler into code
editor and sort of I need my brain time
for that instead of support everything
yet because I believe that if I have
that editor support is going to be a lot
easier if this actually runs on hello
dot 1 GS at i/o you can open it up and
blow your battery power because that's
it's expensive if you keep an 'm that's
why you need to stop animating this
stuff right this is great if you want to
burn through your battery bit you need
proper dirty regions and not animate
everything all the time this is by the
way how you can just throw your your
your render scene to two winamp kind of
visualizations in in five minutes
because the composability is super easy
and a good friend of mine just before I
went to Jess gone for sex like you know
what let's put fractals on the outline
of your fonts it's like dude really I
don't know it's not useful but it's so
 pretty right
so that was time better than I hoped I'm
done thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>