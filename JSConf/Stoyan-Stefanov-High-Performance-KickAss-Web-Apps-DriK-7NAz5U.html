<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Stoyan Stefanov: High Performance Kick-Ass Web Apps | Coder Coacher - Coaching Coders</title><meta content="Stoyan Stefanov: High Performance Kick-Ass Web Apps - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Stoyan Stefanov: High Performance Kick-Ass Web Apps</b></h2><h5 class="post__date">2013-01-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DriK-7NAz5U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">there's a high-performance cash with up
so well abid laid right so I don't want
to take much of your lunch time and
networking time so hopefully it's a how
to you know improve performance on web
applications web sites from a JavaScript
perspective so hopefully you know most
of these things so let this be kind of a
inspirational talk so you know you're
just getting spire to make your
applications faster in your users
happier right so my name is toy and I
work recently joined the echo search
before that I was working in the
exceptional performance team like a
central group of a kind of in internal
consulting not working on a specific
site or property but that just working
with the different properties and help
them get faster so I worked on the y
slow extension you're probably familiar
with that I also designed the second
version of it which is a complete
rewrite and face Mora actually I want to
talk about this but the thing is it's
not out there yet so it's from what I
understand because I'm a longer in team
it will be out any day now so look out
for that also did this smash it to for
image optimization if you haven't seen
it so why do we care about performance
so there's some some numbers that we
wanted to we like to show around like
there was somebody from google saying
that when their search results page
became a half a second slower they saw
twenty percent drop in traffic for Yahoo
we did an experiment with a property
where we just artificially delayed the
page so it doesn't load as fast so the
first few hundred milliseconds were
cable and when you got to a 400
milliseconds we so five to nine percent
drop in the full page traffic what it
means is people clicking away
you're hitting back or going somewhere
else without before the pages actually
loaded and there is also some some other
number from amazon that are making your
arm making their site only 100
milliseconds floor they saw a one
percent drop in sales so this is a quite
illustrative but so if you want to you
know work with your business folks to
get some time allocated to work on
performance you can show them those
numbers but take those with a grain of
salt right because every application is
different and what well like for example
in the yahoo example the fact that you
will have some full page traffic might
not actually be in any you make any
difference for for specific peppers
allocations if you have ecommerce site
where all you need to show up is the
name of the product they end up by now
button right so you don't really care
about the full page traffic so but one
thing is true is that uh when you when
you make your page slower and you're
losing traffic you losing visitors and
he was degrading the user experience at
the end it's all about the user
experience and speaking with different
companies but notice that it's kind of a
self-regulating system right so when you
when you do something stupid in your
next update of your application and you
make it slower actually nothing in me no
one dies right so the servers are okay
it's just that you have less traffic so
if you if you make it slower then you
just lose visitors yeah you have like
sessions shorter sessions and people
just get irritated from the slow pages
so the or when you when you go into
optimization so that's the first kind of
mantra to remember that a premature
optimization is the root of all evil
right so and/or is good crockford put it
yeah make it right before to make it
fast so don't just brush into an Orion
engine
like spending weeks and introducing new
bugs and fixing those bugs and wake up
unit two weeks later find out that it's
probably working pretty much the same
way so just make sure that your profile
you measure your monitors so basically
pick your battles see where where it
make more sense to spend your time so it
often the performance optimizations are
trade-offs and this is what I was
reading rereading this three men in a
boat or what the guy has to say about
trade-off that everything has its
drawbacks as the men said when his
mother-in-law died and they came upon
him for the funeral expenses so you know
everything gets like two sides so he
keeps on one like a timeline comparison
without the life of the typical page 2
point 0 like with the human life right
you start with with a request or
conception in for human so then your
server sends the HTML which is kind of
like a human birth right so after that
after once the HTML like the backend
works it the queries all those web
services gets data from databases and
since the HTML so then it says the so
called the waterfall like in the HTML
you refer to some JavaScript CSS images
so all those need to be downloaded and
eventually the onload event happens and
in typical modern application that's not
the end of it because then you start
initializing JavaScript's do some
progressive enhancement replace some
some dill note dumb note and eventually
maybe you get some more xhr data and
eventually the page kind of settles and
the user is gauging with the page so the
thing about the unload is an event right
so you know when it happens but what
about the user unload whether the user
things when the pages is loaded is not
quite clear it depends on the page right
if it's an article the page is pretty
much done when
can start reading the article you don't
care about all the ads or badges widget
and so on or the person may wait until
everything like the status bar stops
changing the like everything looks set
out so the user onload really depends on
the depends on the application so first
let's talk about the optimization you
can do to the waterfall right once the
the HTML is sent so you can do a group
of task like we can group them in to
optimize your water for basically one
this waterfall to be shorter right so
that you get all the components in the
pages right in less time so the most
obvious thing is to just put less stuff
in this waterfall like have less less
elements on the page then whatever is
left make sure it's smaller right try to
to minimize the size of it then the next
step will be to make sure that there's
no blocking going on right if one one
component blocks the others make sure
that it's you know don't stay in the way
of the other components and another
optimization is to try to start this
waterfall process as early as possible
so about less stuff so the single most
important thing probably is the the
price of the HTTP request right so just
aim to have as less HTTP requests as
possible so that may mean strip features
but not necessarily you can just combine
the components that you already have so
for example if you have so this is
pretty typical right so you have your
your JavaScript code right here my apt
ogs then you use a third-party library
and this third-party library has some
plug is that you want to use so you end
up with a with a few script tags so
quite easily just concatenate all those
into a single javascript file and have
only one only one file referred in the
head so you just say through HTTP
requests all right just by combining all
those JavaScript
so then you just do the same thing for
CSS yeah so for the images you CSS
sprites for background images so
basically the rule is anything you can
go without like decoration images
background rounded corners and whatnot
put those in a in a sprite in a single
image and then use CSS positioning to
just show part of that image and you can
also use that data URI scheme so that in
using the data you are you can you can
do both in content images from the image
tag or CSS images with a background
image so so how does that work so
basically you have my PNG let's say some
file then so this is just an example
from the PHP command line you can just
get its content and encoded using base
64 encoded and you get you get this sort
of string yeah so then you take this
thing and and use this kind of complex
convoluted syntax and you say data
column content type simcom then base64
the encoding and then the content of it
so this way you in line the image inside
of the CSS so you don't have to make an
extra request to get that image the same
thing with the content images like you
can do it an image SRC attribute then
put in your the data for the rivet so
this is really nice and it even works in
IE but unfortunately nice starting from
eight so for the others there's actually
a workaround that I kind of recently
discovered on a Russian website and I'm
you know kind of translated for the non
Russian speaking community so you have
you can use this thing called mhtml my
HTML so this is like like a email with
attachments like in one email message
you can have plain text HTML one
attachment another attachment files it's
all so everything is in one single
document so the same thing for EM HTML
so you can basically put the put images
inside of the CSS or even inside of HTML
so what I really find what I really like
about is it that means that especially
for for mobile application right when
the HTTP requests you should try to
avoid them as much as possible if you in
line all the JavaScript in line all the
CSS and in light of the images then with
a single HTTP requests you can download
the whole application right then if
you're designing application for the
iPhone like a web web app for the iphone
you don't really need to care about ie
ie before it so another way to have less
stuff on the page is to use the cash all
right so it used to be that people often
thing up but why do I care about the
JavaScript in C says their cash anyway
but uh idea who did an experiment it
show that actually the caching is not so
universal and found out that basically
sixty percent of all the yahoo users
come with a wooden empty cache and
twenty percent of all the page views are
with an empty cache so the cash is not
important is not as universal as we want
it to be right so you can do something
to help and that is set those far future
expires headers alright so that means
say that okay this JavaScript will be
cached for the next ten years so there's
an example saying okay the moment it was
access plus ten years so you can do this
for JavaScript CSS and images drawback
of course is that you cannot change this
image once it's a it's cached forever so
all you have to do is change the name of
it so that introduces a bit of
complexity but again everything's a
trade-off right so what about in line
versus external right so on one hand we
say okay have less HTTP requests which
means in line as much as possible but
then on the other hand we you can cash
those files if their external files so
here's one solution to have both of them
so on the first visit you are you in
line let's say your JavaScript and then
once the page loads with some set a time
out in a second or so they
you lazy load the the actual javascript
file which is the same is that you want
to do just in line in your h0 and then
write a cookie and say okay i'm done
with with the lazy loading so the next
time for the consecutive visits you read
that your server side will read the
cookie and say ok so this this person
already has the external files so I'm
not going to do the interlining anymore
so that about wraps it up for the less
tough in the waterfall so once you have
you know eventually settle for some
stuff to have in the waterfall so your
next task is to make those as small as
possible and the single most important
thing is to gzip right always make sure
that you're sending gzip content so this
is a graph sin shared by bill scott of
netflix so they were not jus zipping
there static components and this drop
here is the the day they turn on g
zipping after you join so basically so
all last fifty percent less traffic you
know then it would a single improvement
so bum for 4g zipping just make sure
that all the text content like
everything that is not already binary
everything does not an image or PDF or
zipper so that means so that the HTML
Javascript CSS any textual content is
sent gzipped and it's a it's a really
simple change or all you need is a
supposed to mean task to enable gzip in
another thing for the javascript to do
to make things smaller is to minify
right so this is an example so what do
you have so this comes from yui so you
have all your comments properly indented
code and like descriptive variables and
so on then you write a mini fire before
you go life and then you end up with
something like this which is much
shorter doesn't have any comments or
anything so no new lines variables are
renamed to two shorter names so what we
use is the yui compressor it's it's
written in java using rhino so it knows
about
it knows about your code so it can pre
optimize something so let's see if you
if you have study your concatenate in
static strings it will pre concatenate
them during the minification so it also
minified CSS and has a tolerance for
those hacks that we've standardized on
using the star in the underscore hack in
CSS and it will also add semi-colons at
the end of if you forget for the CSS so
it has really more than dangers
minification but trying to improve on
like static plays much as it can in your
code so another often overlooked
optimization is to minify your inline
code as well not only external files but
if you have some inline scripts and
styles they should be minified too so
the comparison is so if like some say
some people say okay I'm Gigi being
already I'm sending the compressed
content why do I care about modification
this is Julian during the creator of Yui
compressor so he took the jQuery so it
was expiring back in august two thousand
seven so it became from 60k the gzip
version was 20 k and if you minify and
and then gzip then you get only 10k so
just do both and yeah I have in mind
also that there are some clients that do
not support gzip right so for those it's
better to send a mini fide version so
talking about less smaller component so
this is the smallest component that you
can ever get is basically the component
without any any content without anybody
right so this is a 204 no content HTTP
response so basically so this is an
example some people use those for
beacons let's say if you want to log
something so you want to send a request
but you don't really care about the
response and instead of sending one by
one give something like that or a pic so
give then you can just say okay just
don't send anything and then you then
you
locking them so we talked about less
stuff so next thing is to get out of the
way so you have those waterfalls you
want them as free falling as possible
right to be as quick as as possible so
what can interrupt your and make your
waterfall slower is the dns lookups
because it's not a component by the
browser it still has to look up to the
dns for this component so don't have
more than 22 of 24 dns lookups on a
single page have less redirects because
it just wasted time you know you request
something then and the server says oh no
go somewhere else oh fetch it from there
and the other thing is about to avoid
blocking JavaScript so this is one page
that I just by chance here is violating
all of those so first yeah so first you
make a request and what it does is a
redirect they say okay now go go
somewhere else and get it from from some
other so this is a binocular here this
is a DNS lookup this is a screenshot
from ID and PG Taylor so then it says
redirect so this icon means okey go
somewhere else so it fetches another it
does another DNS lookup because it's a
redirect to another domain so then it it
gets some HTML and apparently this HTML
is doing a JavaScript redirect at this
point because it doesn't have that icon
right so it's redirecting to yet another
HTML and then so basically you can see
that may be one-third or at least
one-fourth of the time in this waterfall
we spent before we actually started
doing anything we're just redirecting
looking up stuff and then then there's
this JavaScript right so you can see
further down how several components are
downloaded in parallel but this
JavaScript here blocks the parallel
downloads and doesn't doesn't let the
others go until the javascript is
finished so you know we all here know
that javascript rocks but it also blocks
right so when when you have javascript
on the page the browser will wait for
for the javascript you will arrive
before it continues
it makes sense because the JavaScript
may change the dome in some way made you
a location nature redirected somewhere
else in which case the browser will
download components for no reason so
this is changing by the way in more
recent browsers but still a large
percent of them are the javascript is
blocking so what you can do is include
the JavaScript with the widow dome
include so basically you create that
script tag on the fly and you set it to
the SRC the source to the file name so
in this case the JavaScript no longer
blocks the down the download so the the
rest of the components can can be
downloaded in parallel with the
JavaScript so then the question is
because if you do it this way like the
normal way then your your page will know
that if you include the JavaScript in
the header page after that in your HTML
you may do some inline JavaScript which
is certain that the code is already
there your dependencies libraries are
all loaded but if you do it this way you
don't know so what about the inline
scripts so you can just set up a simple
collection or a registry of all the
inline scripts that you want to have so
the first thing is to have somewhere up
in the head you have something simple
just just an array that will contain all
your inline code so as you go in the
HTML instead of having inline script
which gets executed right away then you
can instead of that then you you you
push a function to this to this registry
or this collection of all the inline
code that you have and at the end of
your main JavaScript once it arrives
then it will just loop through
everything that you've added to this
collection ended just execute all those
inline functions so we saw that
JavaScript blocks but what about CSS oh
the thing is that it's it's mostly
harmless it most of the browser's are
fine but in Firefox to a CSS will block
the the download of the other components
and also interestingly enough when
when your script is followed directly by
if your style is that followed by a
script tag regardless if it's in line or
external script even if it's an empty
script tag then the CSS will block the
downloads so just don't do that okay
finish this so yeah yet another
improvement the last one we're going to
talk about in the waterfall is to try to
start that waterfall as early as
possible so this is the the first
different diagram here is the normal way
of I know you by your server responds
with an HTML page and then this page
refers to some components and then once
the HTML arrives then the browser will
go and fetch the other components but
you can do something to start this
process earlier so move your waterfall
earlier so this is done by by flushing
the content the HTML that you already
have while your back-end is still
pinning us or costing some more data and
working on the full response then you
can in the same time start downloading
your components so for example this is a
PHP example so it's just a function
called flush right so in in the head of
your document you can you can refer to
your JavaScript your CSS and then
because it doesn't have any doesn't have
any logic here all right nothing nothing
complex it's all just static files so
this can be done instantaneously and
then as the brows as the server is
working on on the full response then the
browser can start loading components
instead of just sitting idle okay so we
talked about on all the waterfall stuff
so what about life after onload so the
optimizing the waterfall is the most
important thing you can do but so
depends on the application then it may
be may be doing a lot more work once
everything is there like if you have
gmail or some
really fat client application it spends
most of the time after the onload so
just a few optimizations that you can do
a first thing is to so we talk about
lazy loading preloading optimizing ex
hrs and some javascript optimizations
the lazy load so basically that means
anything that is not absolutely required
for the first view just download it
right so just split your huge JavaScript
into the absolutely required part in the
more bells and whistles so if you have
on the page like a Twitter badge or
something else that is not really your
page is not really the content if you
have a blog people come to see the
article right so let me get the article
all the way and the ones the person is
engaged with the page then in the
background you start loading the rest of
theta goes to the staff and you can also
sometimes you don't actually need some
content or some functionality before a
user interaction so if you have some
tabs you don't have to actually have the
content of those tabs in the page
because there's a great chance that the
user will never click this tab so just
wait for user interaction before you
load the extra functionality so
pre-loading is actually not helping your
page it's helping the page that comes
after you all right so if you're let's
see if you're on a login page in and the
user starts to type their username so
there's a great chance that unless they
forget their password that they'll go
into the membership area right and in
this inside area will have some some
more functionality maybe more JavaScript
so as the user types or is you're
looking at your page and you can start
in the background with some time out
start pre-loading things that will be
required later so you can preload images
CSS JavaScript you can even Provo just
that just prefetch the DNA
right if you just you know that the next
page will will will need to look up an
extra hostname you send a send an image
request that returns tool for no content
in this way it is that the browser is
has the DNS cache so what about the ajax
xhr optimization so again like the
waterfall make them small and have less
of them right so making small that means
don't forget to gzip because most of the
time the you send a request to get some
JSON data or XML or even text data so
it's mostly just exel data so just make
sure it's it's gzipped as well and
you'll probably want to use Jason
because it's less or both in XML unlike
your body of the response smaller so you
can also use the expires header or you
know just instruct the browser that this
this response is valid for the next even
if it's five minutes for 10 minutes
right if you don't update the server
data that often and all you can live
with with some some latency then just
when you send there yeah the xhr
response you cannot expire skater and
say a kid don't send me don't pick me in
the next 10 minutes because I won't have
any more new data for you and the other
thing is using get over post you
probably have seen this discussion so
why is that it might fall into that kind
of a micro optimization but it depends
on the page right if you have a lot of
requests so a simple xhr request that
that posts something really small like
you just pass test equals one so if you
look at so this is microsoft net monitor
right so if you look at what's going on
here so you have a one tcp packet which
sends the request just like the headers
of the request and one tcp/ip
parqueadero tcp packet that sends the
the payload which means just this
testicles work right so these are two
two packets for for just one request
where if you were using yet then there
will be just one request so this is now
no longer true in Firefox 31 I believe
but IE and other Firefox version
searched you're doing it so when you
don't actually want to post anything if
you just want to retrieve data just use
get and the post so a little bit about
optimizing JavaScript code right so you
know just be careful with that just
don't rush into you know going through
the code and just micro optimizing it's
so easy to you know to just get into it
and spend a lot of time in don't
actually achieve much again depends on
the application but that's a most common
scenario action Microsoft when they were
developing the IE eight they looked at
unfortunately we don't have those tools
to do this ourselves but they look at
the top five hundred or so pages and
looking where the tiny spent on those
pages so it turns out that the time
spending jscript which is there a
JavaScript engine was something like
seven percent or something like that for
them for in a normal sign right and if
you have a very heavy like gmail yahoo
mail something like a very heavy Ajax
the application then it can go up to
give it was 14 something like that the
average so as the crockford puts it if
we just wake up one day and all the
JavaScript engines are indefinitely
faster for most of the sites they will
just work pretty much to say because you
know you cannot get out much improvement
because that's not where the time is
spent in the normal case but again your
application may be different so about
the local variables so you know that the
global variables are not recommended
right because you have maintenance
problems and bugs arise because people
are sharing the global space I given
some library may be using some Global's
that you override by mistake so just get
into the habit of using the bar inside
of the function and
and localize the global variables if you
have a lot of work in your function to
do with global variables then you can
create a local variable assign it the
global value and then work with the with
the local so so here's one example we
have 11 global a variable then we have
another function in which we define a
again and then another function in which
we defy a again so so if you execute
this piece of code it will alert 3 right
so if you come and tell that last a
right so then JavaScript will will look
up the scope chain and say ok inside of
the b function I don't have an a so let
me just look it up and it finds it up
there in the other function so this
order to and naturally the last thing
well when when you comment both those
local variables and just leave the
global variable it will be consulted so
the idea is to to have less of those
chain lookups as much as possible so if
you have you know if you want to refer
to a global variable many times inside
your function then you can assign it to
a local value in a works full function
it right because functions are just
objects in JavaScript so if you look at
that alert function right so the
JavaScript say ok where's this alert
defined it's not here it's not here so
it must be have to look up the global
namespace so not not having global
variables for getting less hearing more
locals it also helps the Yui compressor
because it won't rename global variables
because it's it's too risky right so the
wire compressor if you have a long
variable name it will it will minify to
a let's say but if you have like into
Yui has yahoo dot util don't get X Y so
the wire compressor will not change the
name because it's a global it's a global
probably accessible right so it's risky
to rename any of this because they'll be
breakage so yeah so it's just be careful
with that and don't fall into too much
micro optimization but where it's
important is when you have a lot of dumb
access right so basically that's where
most of the time in in the average
application is paint is modifying the
Dom right and Dom is the most expensive
part so if you just have a look like a
exaggerated loop of 100,000 iterations
and just hitting beer just getting the
the head element I put a pointer to to
all the head elements right get elements
by tag name so if you do this you can
better write it like that where you
create a local variable called get
pointed to to that global method and
then then loop through that using the
just a local local reference so this
thing is four times faster than then if
you don't use the local variable so
again so when you touch the dome again
just be careful and sometimes you touch
it there implicitly right in here i I'm
looking a hundred hunt a thousand times
adding to the documents body in a rich
tml so in this case for every iteration
I'm touching the dome twice wants to
read the volume and wants to update the
value so if you do it this way where you
just have us a local variable you
updated local variable in touch the dome
only twice right instead of two thousand
times so this is actually quite fast
it's a thousand times faster than then
if you access the inner HTML directly so
it's it's quite a quite a change so the
other thing is to clean up after
yourself right because when the when the
garbage collection runs that may cause a
noticeable slow down right so what you
can can do is when you're done with
objects or their properties and they're
big and you know that you don't want
good use them just hint and use the
delete operator to to to say that ok I
no longer do that and so the same thing
with with the Dom element right so when
you when you say ok remove this Dom
element the remove child method will
return a reference to the removed
element right but you in most cases you
don't need that so why have it just
lying around so the better way to remove
nodes is just to prepare it with with
the delete operator so as soon as this
child is removed you also delete the
reference to it you no longer need that
ok a little bit over time branching
during the initialization right so I
guess everybody at some point of the
development life with javascript is done
something like this so attaching events
right is the idea that listener
supported yes then use it oh it's not
then for IE then use a touch event and
so on so every time you you use this my
event function right every time there is
this check performed over and over again
so instead of doing this then you can do
it only once so when you define the
function you say ok if I'd event listen
every supported then you define your my
event function to use that so and this
is basically defining defining the
function depending on what supported and
whatnot so every time then you use my
event it will no longer check every time
is this support it or not so a slight
variation of that is the so called lazy
definition so inside of your my event
functioned the first time you call it it
will overwrite itself depending on what
supported and then return the then
execute right so if you don't use it
this check is never performed or but if
you use it the first time you use it
there's one check and then
from then on there is no memorization if
you have like expensive really
complicated calculations going on and
there's a chance that things will repeat
so you it makes sense to cash the
already calculated value and because you
have a script functions are just objects
right so you can you can add properties
to them so in this case I'm adding a
cash property so the first time so you
run the you run the function with some
parameter and it has some complicated
task to do so it checks first consult
the cash is it is this thing already
being calculated some point of time no
it is and then you start your
complicated task once you're done you
write the result it can be a single
value it can be an object can be
anything your right is to the cash so
the next time you call the same fraction
with the same parameter there's no
additional calculation the threads you
know javascript is a single threaded
language so when you do some really
intensive color computation then the
whole UI freezes it sounds really
friendly so modern browsers like five
thousand three-one in safari for they
support web workers like I think it
started with limit gears but now its
native for the browsers so you can have
a worker thread right and and then send
exchange messages so you let this
complicated task work in the background
and then get a notification one this is
done and for older browsers that do not
support that there was this set timeout
approach because what's a timeout you're
releasing that main thread right so you
do a chunk of work in your function then
you then you schedule with using say
time you schedule the nigga that you run
again in one just one millisecond which
is enough 40 for the you I'd not to be
locked in irresponsible so you just do
work by chunks so this would be covered
for life after unload lazy loading
preloading better xhr and some
JavaScript optimizations and the last
thing
minute I was going to talk more about
why I three but there was a beach track
discussion so I just going to say a few
words about the performance improvements
of Yui 3 so you know how search we are
excited about is because we are using
Yui to and actually one of the Ryan one
of developers went then just comment at
all the things that we don't need
because Yui to comes with ok this is the
functionality but we don't have to you
we don't use all of this so and Yui 3
first of all it's lighter so it's a it's
less unless k by kilobytes over the wire
but it also has more more modularized
and it has modules &amp;amp; sub modules so you
can more specifically define ok this is
just the things that I need I don't need
all of these edges so fine grained
control and there's a configuration
utility you can say okay I want this
isn't daddy to give you URL that you can
use so they took all so it's faster they
took the wire it into the opportunity to
to refactor and like then you can have
these these modules so they can either
be served with with what they call a
combo handler so this is if you host
your libraries that are the yahoo EP is
the main this como handler will merge oh
you're all the little modules that you
want will merge into a single file and
minify them I saw you don't have to
worry about unification and
concatenation is the one and the another
way to load Yui 3 functionalities this
soft self populating so you just include
the minimum the Yui loader and from
there when you can say okay I want the
animation module and it to actually go
ahead and fetch it for you so yeah
that's all I had to say sorry 10 minutes
late okay thank you very much let's get
so much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>