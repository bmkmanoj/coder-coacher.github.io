<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Olga Madejska: Breaking Bad - Web Components in production, what worked for us | JSConf EU 2015 | Coder Coacher - Coaching Coders</title><meta content="Olga Madejska: Breaking Bad - Web Components in production, what worked for us | JSConf EU 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Olga Madejska: Breaking Bad - Web Components in production, what worked for us | JSConf EU 2015</b></h2><h5 class="post__date">2015-10-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cRTko6m6U4A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Hi, guys, my name is Olga,i'm UX the designer
at AWS, this is my colleague Thomas, we create
the team responsible for making developer
enslavers easier. We did that beginning last
year, this year, sorry, last year for me,
no, this year and we want to tell you what
we learned along the way in the last couple
of months and we want to talk about the first
project we actually did in AWS, and I will
start by explaining why there's a big challenge
to create user interfaces on a large scale.
So, you probably kind of have used some of
our services before, they're pretty massi,
but there's also a ‑‑ massive, there's
creative aspecting in creating use erspaces.
After that, Olga will continue with the Web
Components part of the talk, why that failed,
and what we did instead. Let me start with
talking about Amazon web services, we, as
an organization, are splitted into very small
different independent teams, and each team
can work independently of each other. And
the purpose of each team is to create a service
for our customers or for other teams internally.
And the challenge there is how all of these
build their products, and we don't have any
speaker notes. But, there's also an upside
to kind of the structure, so there's a couple
of different things that make us stick to
this operational structure, which is kind
of each team can inindependently decide on
what they do and what technologies they use
to solve that problem. And ‑‑ sorry,
we're having technical difficulties here.
If you already would see the next slide, I
can continue probably.
Sorry.
Now, that's the speaker notes, that's cheating,
don't read this. (Laughing).
There we go. All right. So, the next slide.
Awesome. Kind of we measure the success, for
example also in our output, last year, not
sure if you're following what we're doing,
last year we launched 516 larger interface
features or port features, or even completely
new services that kind of comes down to one
and half large deployment store interface,
which you might have seen. I'm not talking
about all the other small deployments we're
doing, if you follow other talks or seen other
talks, like, just the amount of deployments
we do every day is just blind blowing, just
don't really get how you do that. Part of
the organizational structure where you have
all these tiny dependent teams can decide
on the technology completely the frameworks
whatever they want to use to be most effective.
The thing is thatment cos with a challenge,
like most large companies we have a design,
but we don't have a design guide on one team
implementing, we have a ton of different teams
trying to implement 
the design guide. We talked about that ‑‑
like not all designers understand how time
me meant that, not everyone that implements
understand designs, that's actual live examples,
we thought, we have to do something about
that, and the first project we're creating,
designer as code, and I wanted to improve
on that, the idea was to build something in
code that was always in line with design guides
and works across all different frameworks,
our reality is they use GOT ‑‑ whatever,
they pick their tools, and it needs to be
easy to integrate on whatever's being used
inindependent of the teams are using. This
is how we started our first experiment.
Okay, so when you think about these requirements
what comes to your mind immediately is, Ooohh
we're going to use web components, Web Components
are a series of technology, Shadow DOM, HTML
imports and templates you can think of them
as reusable interface widgets that are encapsulated
and basically reusable, so this is what we
would like to use, the two most interesting
technologies that are part of Web Components
is for Shadow DOM and Custom Elements, this
is exactly what we would like to use when
building our components, this basically solves
our problem. So what is Shadow DOM? Shadow
DOM offers encapsulation of CSS templates
and JavaScript in a download, this is pretty
cool. Now we have custom Elements, which basically
allow you to create your own HTML tags, so,
looking at the custom Elements, what can you
do with them? So basically you can say, instead
of a select you can create an AWS UI select
and that select can behave in a completely
different way. I side that select, you can
have, instead of normal options that behave
and look in a given way, you can have AWS
U I options that is pretty cool. You might
think, okay, why did we actually need those
Custom Elements, it was already possible beforehand
to add your own custom tags to HTML and your
browser would render them and they would behave
in a given way and you would be able to style
them even (AWSUI) the real cool thing about
using Custom Elements, by using them you get
life cycle call backs. That are they, actually
life cycle call backs notify you when something
happens to your Element. When you Element
is created you get a created call back, when
you Element is added to the together, you
get an attached call back, and at that point
you might want to add event listeners, notify
the Element's parent that the Element has
been created and so on. Also, same thing happens
when you remove your Element from view, you
get a detach call back, you might handle garage
collection at this point, you might want to
memory management, you night want to remove
the event handlers that you created. It's
all cool. And this actually you get only when
you use Custom Elements, what happens when
you register an Element in the browser is
that it uses the HTML Element interface instead
of using the HTML unknown Element interface
when you actually don't use Custom Elements,
so this is what makes it so cool. We look
at browser ‑‑ Shadow DOM and Elements
are support in the Chrome, we can see that
the standard is just not there yet. So what
we tried doings was using polyfills to basically
back fill the missing browser function faulty,
you probably know web component JS polyfill
for all technologies that are under Web Components,
if you tonight want the use a full polyfill,
you can use a smaller one, so we chose to
use document register Elements as a polyfill
for Custom Elements. Those polyfills are really
good, I mean they work great, but mostly when
they're used as a mainframe work in your application,
if you tray using them with different frameworks,
in our case we tried using them with Angular,
you run into all sorts of problems with those
polyfills. So what are those problems? Basically
all polyfills use mow take observers check
that has been change in the your component.
How it works in practice is if your component
changes you want to be notified. It doesn't
just observe components it observes the whole
DOM. This has an impact on performance. ‑‑ you'll
get notified about it, but maybe a bit later,
once you call a function you get notified
immediately, it works a little bit difficultly
and can cause a lot of problems when using
that together with frameworks that rely on
certain things being done at certain points.
Also, the implementation doviers per browser,
so not all browsers support mutation observers,
some of them support an older technology that's
called mutation events, and those mutation
events work synchronously, not only do we
have to care about if you do the native thing
or if we use mutation observers, but also
about the version of the browser that we're
actually using because we might end up using
something completely different. So to summarize,
web components are not there yet, we can't
use them to solve our problems, we were also
unable to use the polyfills because they didn'tplay
play nasally with the frameworks we were using.
What we found out is the concept they're using
in Web Components are really good concepts
we started looking into actually using those
concepts to build our own Custom Elements.
And this is how our second experiment started.
. So let's build a component together. This
is a native AWSUI alert, you see them quite
often, notify your user about something in
your application, in terms of the verbals,
this is how we could the ‑‑ of the verbals
we can use them for alert, this is what our
design guide says an alert should look like.
Let's build an alert, the first thing we need
to do is create the Elements, but we would
like to be able to use exactly in the same
way as we would use a Custom Element, so we
would like to get life cycle call backs. So
what we need to do fist is ‑‑ el, append
that Element to the body, because we don't
have Element ‑‑ have to call has been
attached. At the end we only get a download,
so we get ‑‑ something to this. That's
cool, now we would like to be able to interact
with our components somehow, we would like
to maybe be able to change how it looks and
how it behaves. So for that we have to find
two properties, we have a type and dismissible,
the type defines the nature of the order to
be displayed, success, info, warning, that
ever we want, dismissible if you set it, it
shows a little controller in the UI that allows
the user to dismiss the alert. Let's have
a look at actually interacting with the components,
let's say we don't want to have an info alert,
instead of blue box, we would like it to be
red. Let's say it's report .
So the component changed the component to
red, from blue, so we can see ‑‑ we can
say we have an error alert, what if we want
to make it dismissible, we say alert.dismissible
is true. There we go it gets the little icon,
so now the user can dismiss our alert: Speaking
of interacting with components, actually,
maybe in our UI you would like to be able
to dismiss the alerts, if a user clicks an
acknowledge button, let's say, we would like
to be able to do something similar to this.
So for that, we have defined a dismiss function
that basically removes the alert from view
once the user clicks it. But in, like it's
also super cool, right, it works, but, you
would like to be able not only to pass properties
and strings, but maybe also be able to pass
an HTML to elder right. Maybe you want to
say, I want to set the header and say is header
is rocks. And the content of your alert might
be something using HTML so I'm going to say
it minerals involved. How did we do it? We
added support for regions, what the regions
do is basically instead of just taking' string
they take a whole download and render the
down hold as is. So thanks to that you can
actually enter HTML to work components. Then,
obviously, maybe you would like to get notified
if something happens to your alert, so when
the user dismisses it, maybe you would like
to know about it, maybe to store it somewhere
as a preference that a certain user has dismissed
this type of alert, to never show it again,
or maybe if somebody clicks a button you would
also like to notify, be notified about that.
So we ‑‑ you can basically add event
listeners to our Elements this is pretty easy,
so let me demo that, so let's say if a user
dismisses this alert, we would like to see
the browser native alert on the screen and
it should say, Ooops, so, exactly what the
function says, okay, that worked. So you can
interact with our Element ‑‑ with our
components. So, to summarize, we have a complete
component now, we deal with the life cycle,
we create the Elements, we append it to the
body, we call the life cycle call back, then
we set the type of alert, maybe we say success,
maybe the alert is dismissible if we want
the users to dismiss the alert, then we say
regions, pass in him that. Him set the header
and then we add some eventers to our Elements
(HTML) how do we make sure that the component
is being rendered on the page? So for that,
we use Reactive DOM rendering, so, looking
at our alert, let's say it ‑‑ would like
to ‑‑ it has some content in it, right,
but we would like to also be able to set the
header, but we don't want to render the header
if it's not there. So, what we want to do
is, if the user sets a header, in our alert,
we would like to render an icon, we would
like to show the header text, right? Let me
download exactly what we would like to do.
So as you can see in the demo, the icon class
and the header appeared only after I have'ded
the header, let me remove it and try it again.
This is cool, we only ma nip late the Element
when it's actually ‑‑ manipulate the
Element when it's actually needed. We insert
those things when they're not ‑‑ we don't
insert the things when they're not needed.
It also needed styles, it has to look in a
certain way, what we know about our users
is they're not going to rebuild their whole
applications from scratch, the if they want
to use their components, they won't build
a whole new thing, we have to integrate with
their existing code. What it means for us
is that that we can't break people with our
components, if they want to use our components,
we can't bring their code and introduce some
weird behaviors, what it also means for us
is that people are going to have styles that
might link into our components, that might
break our components, so how did we deal with
this? So basically we have two rules, one
rule is if you want to use our component you
need to guess it in a &amp;lt;div&amp;gt; or Element, basically
in your application that use AWSUI class,
so that way you can use your Element quite
safely because if there is a place in your
App that is obviously broken, if you either
Element or ‑‑ anotherrer an Element or
style, this wouldn't happen. One thing is
using our Elements in a given scope. The second
thing we, do and you can see that here is
that, for example, let's say, you use an icon
class in your CSS, and obviously that icon
class has some style tied to it. What we don't
want to do is we don't want to break your
icon class, so if we add our own styles, we
tonight want the break the code for you, so
what we the in the component, in this case
it's an alert, we free fission all class name
in the component with the name of the component,
that way we can make sure that felon of our
styles actually leek out of the component
and we don't break your code. So, looking
at the component, again, this is what you
would have to write in order to use our component,
you would have to create the Element, append
to the body and then code has been attacheds
so on and so on. While this works, I wouldn't
call it super easy to use, I wouldn't want
to use that, but asan Angular developer or
something you ‑‑ as an Angular developer
you would want to write something like this.
I would love to use this instead of the thing
on the top, it's so much easier we created
frame word wrappers, what are these wrappers,
they allow to be able to use the component
natively in any framework, because the life
cycle management is complicated you tonight
want to do it manually, you don't want to
call has been attached or detached when you
delete the component, what happens is the
wrapper code gets like take cares of that
logic. What we currently have is an Angular
GWT, and we're planning on adding more wrappers
like for React and also for Web Components.
How much overmade is that? How much work do
I need to do to add this wrapper? Well those
wrappers are actually quite small and compact,
it's only a couple hundred of lines of codes
for every wrapper, it adds the support to
use the component natively. Wrappers are not
done manually, so they're actually generated
automatically out of the component code. So
how do we do that? Component has an official
description, that description we call a component
definition in the component definition, we
talk about all the properties, functions,
events and regions 245 a single component
has, and we also add some useful typing information.
So for example if you haven't defined the
property and this prop is required, you'd
gel warned about it, it's not that it will
fail silently and you wouldn't know. These
component definitions they're used to generate
the framework wrappers, we can do more with
the component definitions, we use them to
generate documentation for every component
as well as generate tests. So now to evaluate
our experiments has it been successful? Do
we think that designers code has worked for
us? We think it has, so, since I think July 29th,
teams have been using our components in production
and they're actually liking our components,
there's an actual quote from a developer,
the person claimed we have helped their team
to write recodeble ‑‑ reusable code and
style, they're now also one hundred percent
compatible with the AWS design guide. What
you can see is the graph that shows interaction
of customers with our components you can see
the tendency is growing, that looks pretty
good to me. But, we're not going to stop here,
so, yeah, we're not going to stop here, saying
thank you, but it's not a thank you yet. We
have a lot more frameworks to support and
a lot more components to add. And, actually
we're hoping you'll be able to give us also
feedback on the components, and that you'll
be able to use the components very soon because
we're planning to Open Source them. If you
have any questions, we'd ‑‑ or would
like to talk to us about the components, please
do, we're available during the breaks and
also later tonight. And, Thomas is showing
the little chocolate guy, so the Orange dude,
try to look for the Orange dude during the
breaks, thank you very much ((Applause))</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>