<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Julian Viereck: Reimplement RegExp in JavaScript -- JSConf EU 2013 | Coder Coacher - Coaching Coders</title><meta content="Julian Viereck: Reimplement RegExp in JavaScript -- JSConf EU 2013 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Julian Viereck: Reimplement RegExp in JavaScript -- JSConf EU 2013</b></h2><h5 class="post__date">2013-10-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/R9deOzRwgow" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I
you
hi I'm children I'm talking about
regular expression and basically how to
implement them in charl script so this
is what i did i do a lot of projects
like PDF chairs where you render pdfs in
firefox or developer tools heck gecko
member OpenStreetMap data in the browser
but it is like my first real cyber check
that I push to some kind of answer pre
have to present this so somewhat of
motivation why did this was like yeah
you you know dislike regular expressions
they are so small they're so cute but
how many of you re find it painful to
write them and takes hours he for you to
read them yeah many hands in the air so
this was like me so like yeah they look
cute they are nice but they're they're
they're really hard to get right so many
people ask me why am i doing
re-implementing this in Charles script
well the reason was I want to be able to
debug record expressions I want to write
my own compiler in record in in
transcript that basically compared to
regular expression from transcript to
JavaScript code again and want to
present a chase come for you so it was
like yeah my talk got accepted so ask
you and then actually well now that
means I got to get is working so that
was the hard part but let's give a demo
so this is what this is jay Furyk github
I Oh Rach xjs you want to try it out so
what we can do in the console is you
know not only would do just new records
a B then you would do regular expression
execute foo AV and get something back
and now what you can do do same thing
just with the javascript implementation
you so that works but what's cooler is
am the debugger parts so here you can
write your regular expression and you
basically have some input and you see
what matches so here you see what
happens so at the top it it looks at a
and B then tries to match a but that
doesn't work because it's be so it goes
back then it matches be and yeah that's
successful that's pretty cool so
try something more complex you see yeah
that's that's not regular X so let's
write a litte bit more cool thing is
once you implement the regular
expressions you are pretty good at
writing them it turns out so it's like
this and now we can do hello and you see
matches in real yr there's a little bit
to learn something so this is now what
happens is like it tries to you know
repeat this a few times so it matches aw
machines the chapter it matches they
tries next time and like are the column
doesn't work so does back-trace now calm
words it tries to match multiple em
spaces so another space no no that's not
a space anymore so got to backtrack okay
now repeat the W yeah that's the word
there's nothing else but yeah I'm all
right on so that's it and what you also
get is you get the results of your
matches so you see the a and B are in
groups you can share this to your
friends so if they come along oh this is
not matching you can fix it and give
them the link again so it's basic just
putting this in the hash you breathe on
school and you also get a parse tree for
basically the door directly expression
there right up here so that's pretty
cool so let's see how this works so this
is like an overview of what I'm going to
talk about so basically you're going to
tell you a little bit how the past trees
build how to internal node list works
which is basically what amateur uses
them to really go with string and see
whether it matches on art and then about
how to regular expression reg ex object
itself a few things about it and then
writing the chit and some conclusion
stuff so let's talk about past 3am the
parse tree basically in computer science
means that if you have some string you
give some rip em structured
representation of that string and that
structures described by a crammer rules
in a high-level what we want to achieve
is we have records that we put in we
have a parser and it generates the
posturing so let's take a look at an
example so here we have this expression
where you have
OOP and then inside you have a B or C
and if we will the past 3-4 this this
looks likely so at the top we have group
then we have this Junction because we
have I a B or C then we have an
alternative that means the can be
multiple things following each other and
then we have the character a and
character p and as a set a B or C so we
have the sea on the other side so this
is what a parse tree looks like am the
part of that I'd wrote it's completely
handwritten I took a computer science
class on compilers and that we used a
generator and I was I'm still young so I
thought well now write one my own my own
and call a bit painful but you're gonna
see there's only basic error handling
which could be improved and the thing is
that it uses regular expressions itself
so it's kind of cheating that you write
your regular expression parser for
transcript which uses regular
expressions from JavaScript again and
but i hope i can just replace them with
tractor off or compile my my own thing
to a transcript function and use it
there em but what I also try to do is
for the past three that it emits that to
contain useful information so for
example if you have a regular expression
like a bee or troop and they basically
give back reference it's not obvious
that / one means it is a reference for
example if you would have a slash to
there would not be such a group and you
need to figure out what to do and the
parts are already says the kid type is
referenced so it's really reference and
its reference group not one and you also
got it from to that means where the
characters starting and ending and it
got this raw string which basically
means okay this is part of pass three is
this backslash one ok so now
implementing the parcel was kind of fun
because this is like the official
grammar from the echamos back so try to
follow this back so this is where it
starts wait continues a little bit more
and this is the final end so took me a
little bit long to implement this but
yet it's pretty working now um
these are actually just the grammar
rules for character classes it was a
blog post complaining the directly
expression grammar is so horrible it
turns out that it got to be that like
that way for this reason and for example
if you have a regular expression where
you have just a character arrange a ana
minors that's an actual interpreted as
you I've imagined a or minors so if you
execute it against a minus sign that
that actually results in something
whereas if you have a minus B and you
execute it against just a minus sign
that doesn't match because it really
means the ranges of characters between a
and B and but so you you see you need to
keep some kind of track or state whether
you have a minus and something following
or you have a minus and actually
character following but we have a
context-free grammar here so there's no
real way to encode a state and their own
way to encode estate is to have more
grammar rules and that's why disposed up
such horrible a lot um someone's on a
passer so um I think looking back I
might should have used the parser
generator which would have made more
errors and more bear error messages and
also helped me too yep tube to choose
right mmm easily I try to read follow
this back as close as possible but their
thumbs things they're not in the specs
for example or I'm a transcript engine
directly expression down there which is
the closing brackets it's valid where's
there's no such rule in the grammar and
passing numbers is pretty interesting um
so this is in the parts that smell
expression so as I already said if you
have like two truths any of them as / to
that meetings a reference for sure but
what if you have number that's not a
reference and so actually turns out if
it's an actual number you got to
interpret this like you got to do ya get
an actual number and then use a string
character off to represent what
characters should match against if it's
not an octal number
just interpret the number basically
without a backslash but at least in v8 a
spider monkey does something different
it was took me some hours to get these
small details right but it's now passing
all the tests okay so now that we have
to parse tree and we're looking at the
node list which is basically you think
that match uses to execute against
regular expression and so we convert
parse tree to note list and stave
structure for the matter so simple
example is if you have red X a and B
this looks like maybe you have a node of
type care character with data a then you
have one of em thay to be and then
basically you you are done so that's it
a little bit more complicated example is
like this if you have like a crouppen
which repeats multiple times and then
followed by see that's internal
represented by you have a repeat block
which has a certain ID and you specify
how how much or how less you want to
match so it starts minimum 0 times and
I'm finding any times you want so then
you have a new node basic saying this
should be the begin croup success okay
here are starting the first index then
you have an alternative because you have
a B or C again so you have to character
a B and character c then you have a
drawing point and then you have a hand
croup stitch that you can say ok when I
can't pass along here I ended this group
so this is the sub sub match that should
track then you go to repeat again and
then I we could go there or if you
follow the sea and then you're done and
this is the thing in brackets is now
basically the a B or C that we've seen
before and you see that from the parse
tree to this representation yet from at
least for me it's way more obvious how
maybe the matter going to walk around is
mmm and I'd like industry structure ok
so then others they look pretty
complicated to build but actually is
it's easy to do if you do some kind of
walking of our past 3 which is pretty
calm for compiled
technics and then you just bind one node
after the other um so 11 side story for
NOC list so there is this backslash s
which basically and matches whitespace
all line terminators and if you look up
the white spaces it it says basically
what you what you should match the like
tabs vertical tabs and then the last
point any other unicode space separator
so huh yeah that's that's hard to get
right right but the cool thing is
there's a springer and people ready to
chop there so i just copied the function
from there that's how i got lucky and
that's also the reason why i basically
license records as records jsps dean and
to be compatible with s premar and also
that maybe there can be some code
exchange good so next I want to talk
about a mattress so the matter is really
think that basic tastes directly
expression representation and the input
string and tells you what parts matches
and or if not um the way it works is
basically passing two arguments so you
have something like a state which is
your string and where your string your
are you what are you matches and also to
trace a steady recorded and the notice
that we're selling before and it tries
to do all kind of possible matches to
draw it till he finds 10 it says well
there's no other way way and the way of
this I try something and if it fails I
just backtrack it's done by am calling
the mat recursively and if if it's
raised faith so if it tries to do
something is as well I kind of continue
here the function just returns and the
outer function try something else so
here's an example how does the word we
started with this day which is basically
our input string ABC and now we try to
match that against this regular
expression so we're there we have like
our input string and down there is like
this node list representation that I've
built before m and now what it does is
it looks at first character so that's
eight
that looks good so moves to next one and
now it has the option either to match B
or C so it chooses ok I choose the first
one and before it goes into dirt makes a
clone of the current state so we are
talking about s prime now so we said
test be yep that's good so we move to d
which st up the works basically we ran
the file so we are done so if that
doesn't work because you know the first
option is not working and it looks like
this so we have the same thing again we
come here we try to match be and we
cloned this but actually this time it
doesn't work because we have to see at
that position so what we do we do
backtracking and so we jump out the
function we try to match see this time
with another so it is also another clone
state as double Prime we try to match ok
now my slides another in right officer
so we do we test where the sea works
against that thing it does we try that
works and we are done again ok um and
while we're doing this we are also
recording this trace information that's
basically used for the debugger that
it's all before that you can see where
is due back dragging in what part is
matching and there are some pitfalls if
you implement this matter so one thing
that came across is basically if you if
you have a loop when you go back and you
get to reset all the mattress that you
did before so example and the the crew p
if you loop the outer ABC once more you
got to reset the inner group for be ok
that's that someone were the inspectors
but you also need to reset the count of
four to be so there was back there
basically of the first time ABC matches
it would still not reset the counter for
this be in a group and then just tries
to con new matching a and plus one piece
next time which didn't work also you
have two problems with infinity loops so
for example the expression
they're busy you could say while it's
just trying to match as many times an
empty string which is basically infinity
match but yeah the all the ancients just
match the a and directly so you need to
have some loop protection which you can
do pretty easily by just saying well if
you came and come here once more in this
kind of loop or this repetition and
there was no process you say okay then I
just do the other way and don't go into
group anymore okay so now we have we
have liked you can pass in a regular
expression and then you basically can
build the past three we have to make
sure but what you want to use expose
some object that looks like the building
regular expression to the user that you
can play with it so it's about building
the records J as object that you've seen
before so it has just these two
functions execute and test you could
also think about string prototype em
match etc but I said that's out of scope
of this project so just concentrate on
these two functions and that's
repetition where we already did em and
maybe it's you know the first attempt
will be that it's I mean that looks
pretty simple to rewrite just if you
have something like execute it just take
the regular expressions thing and you
parse it you build a note list and then
you just throw that a matter and see
what comes back but it turns out that's
not want to send the right thing to do
and because down there as you see the
first regular expression works fine
Boston butter the last one doesn't and
the reason is the ABC can match at an
arbitrary position so it doesn't have to
measure the first one but the first
implementation just didn't you know
looked at anything with a certain offset
from the beginning so how could that be
fixed so the easy fix is to do some kind
of fake loop and so if we have ABC you
just could convert that regular
expression to basically say well try to
match as as less possible any characters
and then the ABC following and also Duke
roofing around such that you recall
where we actually did a match turns out
the worse so where's the problem is you
end up with a lot of recursion in this
case because every time you do this kind
of match something at the beginning this
means another function call the way the
mattress interpreted and for long
strange we hit the v8 maximum function
called stack size so the implementation
that I did later was reaches don't start
at the first precision or started first
pictures and if this doesn't work move
to the next position plus one and then
do it um are things there for regular
expressions are flags and so there's the
multi-line flag that you can pass to and
that only affects the assertions for the
beginning and the end of regular
expressions and they are pretty simple
to get right that if you have a new line
before after it should also match
there's a global match which basically
means you should repeat the next time
for another precision that's also KH to
implement the tomorrow hard part is
ignore case so trivial implementation my
idea might be jet you just take the
input strings and your regular
expression is just do upper case and
then see where the character matches but
actually this back specifies it's not
just a to upper string conversation
there are also some other small things
that you get to watch out to for example
if you do an upper string on the
character or on the individual character
if it ends up to be two characters
afterwards you just use the the previous
one and before doing the upper space so
you need to apply a different kind of
function and also you have fun with with
ranges because if you have arranged a
two curly brace and you do this ignore
em case operation where you basically
transform into upper case and you only
want the a two-set good to go upper case
and the other m characters to stay the
same so this is um yep
and well they're basically more fun to
this so and the specs is there for all
the input stuff you need to call what
internal defined to strain into number
functions so um here we have an example
where we define the string as an object
with two string function which returns
false and we try to execute it against
LS with an ignore case reg ex so does
anybody know what this returns yeah
match is good and so it returns LS and
basically because it says the string you
called the two string function which
then returns false which is booting
where you call the two string function
again so you get false as a string and
then you match again against the LS and
then you you end up with two LS so
that's the small things to get right
there is the what I got nine minutes
yeah and so but there's there's luckily
a good test you from Acme script and
we're where we try to get all five
hundred and more tests passing and then
you get all the small pitfalls um so
yeah there's this wreck it xjo object
got a little bit bigger it's 240 the
lines of code so it was not as trivial
but if you're working so now we come to
to my favorite part to cheat compiler
and so a lot of compilers and our life
treats so um so no you what what we want
to do is basically we take a regular
expression and we really want to omit
trial script code itself and so this
means we're in wilmette a regular
expression in a child scrip
which just by that self is like a um the
idea is that we can match the input
stream faster or the input string faster
by using finite state machines we all
also support just a subset of Recca
expression em to make our life easier
but hopefully that gives us faster and
more efficient matches um so for example
I said well I support all features but I
don't support group matches because it's
a little bit hard to get right into the
fa m no back reference and only 3d
repetitions and there's also a lot of
stuff missing because I just did their
entire two implementations in three
evening hacks so it's still under
construction and that was is one thing
wherever you want to get things right am
done pretty fast so I just wrote this
one line without any new returns in
there just how you get really fast with
that and it's also reminds me of code
mirror in my yin how he writes code and
there's some good thing to you that I
got my leg I've noticed so let's let's
see how does this should work so
internally we create an NFA and DF a.m
who knows about what that stands for and
what it is okay only few people so try
to go slow so if we have a regular
expression A and B am in an NF a I
explain what its lair but it's more
confusing if I tell you so that looks
like this so you have a big inning
stayed with the zero you have a
transition a which means if there is a
character a matching in the state you go
to one if there's a be matching good too
and whatever there is which is a signal
for light by this epsilon you can just
go to end state and the end states are
with this college so if you have
something more complicated a B or B um
it looks like this you can go from the
first one you can't go to first Ephram
from zero state go to first or third and
then I've there's be I got for the
fourth one the problem with this and if
a thing is you have London
non-deterministic and because for the
first one you don't know where you
should go to stay one or two or three so
in DFA you solve this and basically say
ok the it's a bit more complicated but
am basically you true the transitions
that are the same and in this case you
come up with that you could do a
transition by a and then you're in final
state or if there's be you go and also
go to another state where is the final
state um so the implementation basically
dust is it converts direct object to non
deterministic final automator which is
what NFA stands
or use that you turn it into
deterministic finite automata and then
there's a code generator which ria emits
javascript code so this is the
javascript code that emits for a or b so
it's like an outer loop and then we have
this state zeros the one instead two and
there are these transitions in there and
if the character first time is a it does
the transition to stay one if it's Abby
it goes to second one m and the alphabet
for this one is a be so the alphabet
means what characters are used in this
to describe the decisions m and I was
wondering when this could be a little
bit optimized for example if you think
about re huge character ranges you would
have to add all the transitions for
character a to unicode 777 so maybe
there is a better solution and I just
because I'm running out of time going to
briefly what I did was introducing
alphabet classes so the basic idea is
like this if if we have something like
sea air weapon Rekha expression with 0
and then 1 29 it looks like okay we have
one transition from 0 to 1 state and
then from the 129 stay at from the 12
Tuesday we have a transitions for
characters 129 so our alphabet goes from
0 to 1 29 and but this looks pretty
similar to at the transition that we
have before with 0 a 0 then we have an a
we go to one and then from there we can
do be into this to second one so which
is basically say okay our a is 0 and b
is everything from one to nine and then
we basically and make it a little bit
yep the alphabet easier again now in a
more complicated setup basically if you
have more complicated you think about a
number line you basically you think out
what are the intersections and then you
come up with your alphabet again so this
is what basically apply to regular
expression this looks like up there you
have many transitions for a two E and C
to set and down there you only have two
transitions per each branch
so it makes a little bit easier so now
the question is if you read cheat code
that's good about how good is it
actually interpreting JavaScript engine
so I talked to Tom Shuster who's on the
spider monkey team for Firefox about
this and he basically put this in a
while loop and hit it against Iron
Monkey and see how good it is and yeah
so this is like the internal
representation and what he said well
this is a little bit branchy it's not
good so we yeah maybe we're meeting up
in Brussels and work on this and
hopefully we get something that's not
that branching that's actually really
tight loops and then get better
performance but as said it's it's really
under construction so closing up now and
what are what is there to do em so they
need some code cleanup to be done the
cheese is still under construction and
also once you have like the same parser
and traversal API like in this primer
that people can deal with regular
expressions easily so status of project
the matter works against all tests is
around 780 tests and most of them from
the ACMA official test shoot em but I
couldn't need some help for example
project page is basically just what you
saw before with this tracer and you have
hours so that would be awesome someone
could I out there bug fixes and also am
testers if you figure out there's a
wreck is not working just tell me I'll
try to fix it so but what's made more
important for this project is to come up
with some cool ideas where he could use
this for basically I would like to see
that like as primers for analyzing trial
script code that this could be some kind
of foundation finalizing a regular
expressions and for example implementing
a recce up slender way so while you're
not allowed to do arbitrary many matches
or something and also that you could use
this in your maybe it's a development
environment to record how often our
record are you a regular expression
executed and then maybe debug that you
should optimize some regular expressions
or do something else to to increase your
performance so with that that's it thank
you for listening and I'm</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>