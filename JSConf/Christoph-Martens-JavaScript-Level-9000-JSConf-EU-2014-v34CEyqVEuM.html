<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Christoph Martens: JavaScript Level 9000 | JSConf EU 2014 | Coder Coacher - Coaching Coders</title><meta content="Christoph Martens: JavaScript Level 9000 | JSConf EU 2014 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Christoph Martens: JavaScript Level 9000 | JSConf EU 2014</b></h2><h5 class="post__date">2014-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/v34CEyqVEuM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks for the sample introduction well
yeah my talk is called JavaScript level
9000 because I had no idea how to name
the talk otherwise and yeah let's get
started so as I said I was previously
working for Zynga and doing the
benchmarking stuff there or putting out
some open source projects like leasing a
drug box back then which were only
crappy html5 fixing stuff but after that
I founded my own project I'm called
litigious which is something like a
JavaScript game engine but it's not it's
a bit more than a game engine and scan
it and scan it something like artificial
intelligence the disk Russert and stuff
like that so it's something like a hobby
for me and yeah I was previously also
I'm fixing some Linux kernel mud stuff
so I was also implementing like the
Radeon driver or fixing or supporting
the order Radeon HD cars back then and I
got into v8 because I thought back then
when being a cinder like it's hard to
push our a game on to different other
platforms if they are not supporting
html5 so basically um I started to
realize that it would be much more
awesome when I could just use OpenGL
there or use free glue or the native GL
burning steering and then I put out a
prototype for VHDL which was basically
the age combined with OpenGL bindings
and I was using it to cross compile it
to other platforms like on Android or
iOS with the note app stuff and for even
you the advantages that you can even
cross compile it to Xbox 360 or ps4 and
stuff like that
basically I'm currently focusing on STL
stuff so my new runtime is based on OGS
and using Australia because no js' is
much easier when it comes to networking
stuff
andum yeah that's basically what I do so
this talk will be starting low and
trying to give you an idea how are the
data tabs inside a VMs are implemented
and it's focusing on add our own garbage
collection concepts or what the problems
in JavaScript are compared to other
block scoped languages for example so
it's trying to increase the level
straight linearly so yeah first data
types primitives are the basic
understandings of data types and in
JavaScript it's a bit complicated
because primitives are also objects but
they're not and so and so so in these
examples the primitives are like numbers
boolean's null and undefined
they are the primitive literals and they
folk and they are defined as primitives
but for example strings and regular
expressions because they have a length
property and stuff like that they are
objects but they are handled as
primitives I will explain it later so
the strings are primarily handled in the
runtime memory which which means they
are D allocated after the caustic is
finished or after the scope was
destructed afterwards and there's a
so-called hidden classes idea behind the
implementations so they used like hidden
classes to implement everything for you
and the hidden classes are something
like the abstraction that you need for
your memory allocation stuff so and also
unique static strings so if you write
down the same string over your call or
over you call code like 10 times or so
then it's only unlinked as a symbol
inside the JVM so yeah primitives if you
use the native constructor like new like
calling new number then you create an
object instance and the object instance
is handled differently than the literal
of the number itself so for example if
you type M like D like the epsilon
variable here 1 2 3 then it is it it is
differently handled in the VM but of
course it's um well then in essence of
object if you use a constructor or it's
not
erase objects are basically object
instances even the literals so for
example arrays of course an instance of
array but it's also an instance of
object and the objects themselves are
always instances were objects because
the literals are defined that way so the
difference here is that the primitives
are not referenceable after the scope or
not reusable there and the object
instances are refer answerable and after
the scopes closed or after the function
scope closed and destructed so yeah
that's basically the idea of DG object
in JavaScript the hard topics in
JavaScript is the dynamic typing stuff
so because you have because previously
before the WebGL standard you had no no
possibility to use something like type
arrays and the idea behind the JIT VM
was then that they wanted to optimize
everything as far as possible
so in this example both have like the
same values and the array has the same
contents afterwards but they optimized
in a completely different way the few
example here is optimized at compile
time because digit knows oh the array
has this length and it's closed
afterwards so it's finished at this
state and the bar example is allocating
everything dynamically so at first we
will just on in the first two examples
like the 13 and 37
well you stay we'll just allocate
everything after that if you change the
type it will convert everything to
doubles and that's the so-called
unboxing because it has to be unboxed
converted and unboxed again then
everything will be converted to doubles
that means the position of the 13 and 37
values will just be something like 0 and
then it selected this student integer or
a signed integer in that case and if you
allocate something differently on 3d
values like true which is an object then
it will everything convert everything to
objects or to um preferences but I will
explain it later hold it I solved
and here is basically the difference
about the objects and erase stuff in
JavaScript what is also important is
that objects have unique identifiers
even if they have the identical contents
so that you can use the deep equals you
keep equal comparison and they will
always be like completely different
because of the identifiers and but they
share the same hidden class behind them
so these examples are identically typed
and they have the identical properties
and the hidden classes inside the VM
will use the same hidden class in that
case hidden classes are based basically
on the data types of our order values of
ordered types of the values and the
order of the values or the properties so
for example in this case the foo and bar
example is identical but the crooks
example is identical when it comes to
the values but it has the properties
ordered in a different way and if the
EON properties are annotated or or
assigned to the object in a different
order then it will create automatically
a new hidden class so that is bad you
don't do that hidden classes are also an
abstraction for functions because
function templates are basically Kranz
if they are constructed creating object
instances
so in that case foo and bar have like
when they are assigned the same hidden
class of point but it will create a new
hidden class for the bar example because
you are assigning a property external to
it so JIT isn't it recognizes it oh
that's a completely different thing and
I have to create a new hidden class for
it
so bar is a fork for food and when you
want to implement custom primitives in
JavaScript there's the concept behind
the value of method and the twisting
method so if the value of the value of
method is caught on binary operators so
for example if you do something like an
addition that case it
we'll try to find out if there's an
aromatic value behind it and if the
value of method returns now then it has
no aromatic effort value at all and will
be just zero so in that case that is the
reason why you can add foo and bar in
that case and it will be the zero but
you can add another number to it and it
will be there like the nemah value
because one two three and plus zero is
of course one two three
where you are as a set value office
determine is used for the aromatic value
and if you return a number value instead
of not then it has never met value so
you can add it to other to other strings
or numbers and in that case it will
automatically convert it depending on
that that is by the way the same problem
with the nain stuff so if you have not a
number then when you add not a number to
a string it will give a different result
than adding a string to not a number
because it will be the other way around
for the conversion but in that case it's
just unlike if you want to add a string
to it then you have of course like a
string conversion from the number and so
the numbers and the values will be
identical except the types general and
after the value of stuff is called then
it will try to determine if there's no
arithmetic value it will try to UM find
out if it's a string or convert it to a
string so that's the reason why you see
something like object object all the
time when you try to dump it into into
the console or something like that back
then
when you are returning inside the value
off method even we are returning an
object instance they are then that means
that you are a high level object and not
a primitive anymore that means the to
string method is called and if you add
those two examples together or or add do
an addition to it
then you get two different results
because um because it's just converting
everything to a string then and yeah
that's basically how it works
so now have to take into the function
staff and what function templates
function instances in the prototypes are
so functions in JavaScript of course you
have to prototyping stuff and prototypes
mean that they are something like smart
pointers to the memory and if you have
like this example where you um construct
a new vector there then the instance off
factor will of course be true but the
prototype lookup will did the underscore
underscore proto underscore underscore
away is something like a non-standard
stuff to look up the prototype which is
the next observer here or here and in
this case it will of course point to
vector then it will point to object
because everything is an object instance
and of course it's not not an instance
of function but yeah the proto pro to
prote you look up will then be now
because if it's not and the prototype
chain is over image it knows oh no
there's no inheritance at all afterwards
and yeah that's basically how it works
so if you have something like a new
instance from a function then it will
then the direct proto look app will
point to the functional prototype and
that will point to the object prototype
and so on so yeah if you want to
implement something like entities
because I'm a game engine developer I
have the problem that I want to use
vectors and stuff like that and if I'm
implementing a basic entity and I want
to reuse two vector methods there then
there's the conceptual problem that you
need instances on the prototype in order
to have it fully working or integrated
with the JavaScript VM so that means if
I'm just pointing the entity prototype
like in this example to the to the
vector prototype then I have the same
methods but I don't have an instance of
a vector of course because the get
prototype of method called on the entity
instance itself will not point to the
vector itself it will point to the
vector of prototype
so yeah that's basically all the
instance of operator works when you
create a new vector instance like in
this example with this is correct mark
then you have when the prototype of
instances or the prototype of a temp
function template is pointing to a new
instance then you have of course the
correct example with the instance of
Jack there so yeah that's basically our
function templates are implemented I
hope it was easy to follow so when it
comes to hosting and closure stuff it's
pretty important to understand hosting
and closures because JavaScript has a
problem that the scoping stuff is not
easy to back-trace when it comes to
memory optimizations so yeah let's get
started with that topic
hoisting is using the something like
hosting well okay the explanation for
hosting is like you have a variable
inside your arm function scope but if
it's not accessible or not bound inside
the scope it would just go upwards and
try to use the next method out on the
other side and in that example
I'm banding I think yeah I'm binding foo
and bar but with different names so
that's the other way around when I'm
calling the auto function I'm using
inside the auto function the bar
parameter which is referenced to the foo
outer scope so if I'm basically using it
I'm banning it so that is like a closure
but if I'm refer you refer if I'm
resetting the food wearable
I'm not really overriding the bar inside
there beyond scope because that is still
referencing not to your original foo
it's just referencing to the state of
the food when the method was called so
that is why foo equals equals equals bar
will be false then afterwards yeah
closures so a typical problem is like
iterating over an array with objects or
stuff like that and you have something
like you do in a synchronous loader like
loading an image or something like that
and you have an unload method that is
called afterwards and you really want to
use da then which is the iterator and
variable there if you want to use the
Adair then of course it will have always
the last value because probably the SOE
loader stuff will be slower than the
iteration and yeah that's a typical
problem like in JavaScript so a fix for
that is just using a closure to hold
every variable so they have the same
state when you wanted it to be and you
can just reuse to reuse the property at
esterday they are already variable at
that stage and yeah that's basically how
closures work there's something like a
function that bind the variables to
their own to their own sub scope or
their own handled scope and yeah which
they are binding a variable or a
property inside their own scope when
they would be free otherwise that's
basically what I think jota's so that
leads us to the following problem we
need something like a garbage collector
as we you know because we have object
instances and stuff like that and we
want to delete them afterwards because
otherwise our member will be totally
bloated so the basic knowledge about
memory management or garbage collectors
are we have the runtime memory which are
the primitives so they are cleared
directly after your scope has ended if
your scope is being caught and after
that the scope is distracted then all
the runtime memory will just do located
and how it works is not important it's
just important that it's deleted
afterwards and you can't be can't be
reused afterwards
regular X and regular expressions and
strings are somehow exceptions because
they have like the length property and
stuff like that but they are treated as
runtime allocations and set of DVM so
they are basically primitives but
they're not promoters but yeah the heat
memory is something like the memory that
is that is available afterwards but you
are not able to use it if you're not
referencing it
but yeah for example that i Function
instances object instances array
instances and yeah that's basically what
a heap memory is if the if the
allocations or it references that you
are using here are not needed anymore
and can be deep and referenced then they
are cleared up by the garbage collector
you're creating garbage every time
you're something like overwriting the
original reference with a new object so
in that example i have only a named foo
object and creating new garbage when i'm
allocating or assigning a new object to
it so that means unreferenced object
instances always create garbage and
references variables or named properties
or arguments inside your scope which
figure the garbage collector so he knows
oh I have to do something like that
and after he scoped that was deep not
distracted the garbage collector checks
if the references are still there or if
they need to be cleared up so you can do
a hints for a garbage collector a cheap
trick is just to set everything to now
because now is not reversible and it's
the primitive you can set it to zero as
well but that would be number and give
dimension stuff is but weird yeah but
yeah if you do something like you are
assigning a variable foo and you have an
object instance allocated to it then you
can just dereference it by setting it to
null and then putting on the object
instance afterwards so the garbage
collector you ultimate up the JavaScript
code optimizer on window oh that's the
state where I can clear up everything
and afterwards it's just a plain u
object and I need to restore everything
yep so that leads us to the to the
garbage collection implementation itself
or how it works basically inside VMs so
I'm mostly referencing here to the Java
stuff because Java was one of the first
languages that implemented a garbage
collector but most of the most parts of
the methods are also used in the age or
the monkey variants and from mozilla so
when it comes to terminology a garbage
is
an object in your program that your
program cannot reference anymore so it's
not usable at all a so-called root node
is inside a graph that is inside the
garbage collector it's any direct
reference your program can access so
that means for example local variables
on a stack or or static class variables
like the length property on an array or
something like that object instances are
life if they are not garbage
that's basically the opposite life
objects or life object instances are
referenced by a root or are referenced
by another object instance that is
inside the root you can detect garbage
by having basically on detecting like if
you have a graph where all the nodes are
referencing each other then you have two
different ways to to determine if they
are still referencing and one of the are
one of the algorithms is a desperate
search or a breadth words a
breadth-first search and both of them
will lead you to basically the same to
the same result that you know if you're
having something like the DEF force
search algorithm we'll just go to each
sub node first and then try to determine
where there's a back reference and the
breadth first search algorithm will just
go downwards and look at the neighbors
if they are referring to them because
you have to dynamic dynamic linking
options local variables are in something
like a named Porter that is pointing to
somehow anywhere inside a black hole to
memory address JavaScript has basically
only pointers that you can use so
everything is that inside your
high-level language is only a pointer or
a number if it's optimized or basically
the parameters and the hidden classes
are the so-called abstraction for that
one method or basic Tschida method it is
used and pretty every garbage collector
is the markets free beverage the markets
free algorithm has two different phases
first system our faith and the second
sis we first
the mark face tries to determine
everything inside the graph notes or
inside inside the graph and walks along
all routes that it has and tries to and
and tries to mark every object that is
referenceable from each root note the
program will pause so your program is
like completely stopped then the mark
faces running and tries to to determine
all the objects that are referenceable
afterwards the sweet faces is going on
the three phase phase is traversing all
the marked objects and da locates them
and does all the garbage collection
stuff so it marks everything and marks
the memory addresses inside the
low-level and C++ code or something like
that and tries to allocate them or tries
to free up the memory as far as possible
and garbage collection you have also in
garbage collection languages we have
also the problem that you have
fragmentation so for example these two
examples are identical hidden classes
and they have like two different
properties of course with the same
values with their identically but
afterwards you're deleting one of the
properties of one of the instances so if
something like a fragmentation layer the
fragmentation means that memory is free
but could memories free at this specific
address inside the memory and could be
used otherwise so there's the so called
compaction going on that's trying to
read or order all the object references
that are highly implemented inside
JavaScript and reports them accordingly
to new memory addresses so in this
example I'm having references to I'm
trying to explain that reference are
so-called handles inside a JIT compiler
it's basically in the VM something like
a pointer to a pointer so that means if
you're using your your bar or your foo
inside your code then it will be just
basically a pointer to another pointer
the reason to do so is because on
pointers can be used as a fixed size we
have a fixed size memory array and it's
easier to optimize because you don't
have to guess what kind of
memory um sighs it will use later on the
last time is determined by a handle
scope and those handle scopes inside of
a function context are are destructed
afterwards after function is call is
over and they result in garbage
collector trying to clean up everything
so each time my scope is close the gaps
collector runs over it and tries to
determine the reference system another
algorithm to mark and sweep is copying
garbage collection it's something like a
base concept where you have like two
differents static sizes of memory and
you have like the pointers referencing
to somewhere in your code and if you are
deleting efference or creating a new
reference it's just copying it
vice-versa so that means from the memory
a it's just using everything that
defines and uses the first education in
the other memory second time it runs
will just use the first memory and go
the same way over over again the
advantages that is super fast and easy
to implement because you have like ten
lines of codes to implement it but it's
of course bad because if so much to do
if n of the references is getting bigger
and bigger a generational garbage
collector like in v8 or I guess in the
monkey variants to to is using both of
those algorithms and tries to have
something like an object lifetime
determination that means it tries to
find out if your if your code can access
other objects on previous States in the
time line and if they are still
responsible or not if they are not
responsible that means they have a
younger age because they are just like
one seconds open it can be cleared
afterwards all the objects are the ones
that can be accessed anytime so for
example if you have left something like
objects on your global scope they are
you can guess that there every data
reference with also ten seconds
afterwards so that means our objects can
be used on can be optimized by the
margin sleep algorithm and younger
objects are basically optimized by the
I'm copying garbage collector algorithm
and yeah yeah 30 seconds that's the end
and basically that's an introduction
collection works and I hope you enjoyed
it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>