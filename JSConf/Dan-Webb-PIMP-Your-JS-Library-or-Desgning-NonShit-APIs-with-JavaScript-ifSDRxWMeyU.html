<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Dan Webb: PIMP Your JS Library or Desgning Non-Shit APIs with JavaScript | Coder Coacher - Coaching Coders</title><meta content="Dan Webb: PIMP Your JS Library or Desgning Non-Shit APIs with JavaScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Dan Webb: PIMP Your JS Library or Desgning Non-Shit APIs with JavaScript</b></h2><h5 class="post__date">2013-01-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ifSDRxWMeyU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yeah so I realized that JS conf was sold
out and I panicked and I thought oh crap
the only way I'm actually going to get
to go it's I've got to propose some kind
of talk and in all my panic I came up
with the most ridiculously crap name for
a talk ever so I'm gonna have to change
that I want something really respectable
something that might get me a book deal
you know something really solid so
instead of pimp your j/s library the new
name for the talk is a designing non
shit api's with javascript so i'm gonna
start at the beginning in the beginning
I say the beginning the real beginning
of JavaScript it was all Netscape 4.6 ie
4.5 format you know it was Babylon so
let's not ignore that whole stage and
start when things actually became where
the community started to organize itself
it started to organize itself around
these sort of three main libraries
prototype dojo and one that is still
around but does it get mentioned very
often machi kit they all had their
strengths and weaknesses prototype was
probably the most popular at least
around this time about 2004-2005 it was
good general purpose library it shipped
with Ruby on Rails dojo dojo have been
around in sort of several forms for a
really long time by that point so it it
probably still is but was then the most
fully featured and probably most
advanced in terms of functionality and
the market just had some really
interesting ideas such as the concept of
deferred switch is only just made it
into jquery now but then this newcomer
came along and I remember sort of you
know that this turned up on a Jackson
one today one day click through and it
was a really simple site and sort of
right front and center was with this
code example and I think I'm probably
not the only person in this room that as
soon as they saw this it kind of changed
things for them
and I think you know we all know what
happened next it went from zero to
everything has had this sort of
skyrocketing growth and almost has got
to the point now where it's almost the
default choice of library fur bracelet
browser programming so what I want to
look at is sort of why did that happen
well at least initially jquery from the
the internals was was not actually that
in that sort of important it was it was
a lot of a cobbled together thing so it
had Dean Edwards event utilities it has
a Simon Wilson selector engine and a
load of other stuff that was just sort
of cobbled together but what made it
really really important and what was
responsible for the explosive growth is
that John had created this amazing
interface and you could just imagine it
when he was designing this he didn't
design what it was going to do he
designed how he was going to do it
before starting you even writing the
code and I've sort of want to sort of
make you think about that that the fact
there as programmers we're all designers
where designers of the API of the code
that we write and it's one of them most
important things that we need to think
about it's what John thought about as a
number one priority and it's what made
jquery and several other pieces of
software really really successful and we
should be thinking about this every time
we write some code there's a three
things I'm going to discuss which I
think make really good usable api's
predictability simplicity and
flexibility so we'll dig in to the first
one predictability when I'm thinking
about this I think of you know when when
you're a kid and it was Christmas Day
you were running into the lounge to get
your presence rip open the box it's it's
like a transformer that you've always
wanted rip open the box really excited
to get it out and stop playing
with it but what you're actually greeted
with is a very complex looking manual
and stuff in loads of different parts
and you can't play with immediately so
I'm sure many of you alike like me when
I was that age I just immediately
thought I don't know what to do with
this light handed it over to my dad made
him work it out will I ran off to the
other side of the room with the box and
made a robot outfit and I think it's
developers when we're actually sort of
choosing to solve a higher-order problem
we don't want to have to think about how
the smaller things work which is why we
go seeking libraries and we want to be
able to make our libraries as
predictable as possible so as soon as
you the developer light looks at the
code and they can almost infer how it
works rather than have to spend all of
this time digging through the
documentation so how do we get to this
sort of level of being predictable well
you need to think about your audience
like you do with any design task the
audience in our case is really easy the
we know the audience really well it's
all the JavaScript programmers and that
means we can infer a lot about what the
our audience knows about and we can use
those Prevention's within a code to kind
of add that familiar familiarity the
first port of call you can go to is is
the actual conventions and that exists
within the library the language itself
and the standard library so you can if
if we're writing a JavaScript library
you can pretty much always be sure that
this person knows JavaScript and knows
others work with the standard library so
definitely you know stick with with that
and just get this bonus predictability
is whoo-hoo snake cases their code in
the room does anyone know that's good I
was going to ask the note the person
next to you to our slappy I think you
see a lot of code front
time that doesn't use camelcase
JavaScript should always be camelcase
the standard library is in cal is camel
cased it's definitely something that
there should be no debate about at this
point so first off really easy don't
deviate from camel case and also adopt
all of the other conventions that come
from the standard library constrictors
should start with uppercase and and so
on now one thing that you sort of might
think would be a good idea to sort of
gain a sort of level of predictability
and probably is good from this point of
view is you might want to actually start
by kind of poly filling missing
functionality like we heard about
yesterday i I'm not outright against
that but all I need would like say that
is be careful with that firstly for the
reasons that Andrew pointed out your
little library that solves a certain
problem isn't the right place to fix
array for each there should be if it's
going to be done anywhere it should be a
lower level library but also I think you
you start to get into the situation
where you can surprise developers it's
pretty easy to write what you think is a
polyfill that fixes for missing
functionality but it works in quite a
different way from the real
functionality that your poly filling
even in like a small way for instance if
the native thing will return like a live
node list that where new nodes will
appear in it and then your polyfill just
returns an array you've got that
slightly different behavior which
introduces a whole level of
unpredictability another place you can
go to sort of seat conventions you can
rely upon is is popular libraries talked
before about how how ubiquitous jQuery
is I think even if you're not a jQuery
guy you can almost you you're familiar
with how it works and so we can we can
use that and we can use conventions from
other popular libraries depending on the
on the domain your end so
for instance I think a really nice
example of this is is Raphael Raphael
has got really popular really quickly it
it's and it's just incredibly easy to
use you you're you're sort of they're
doing stuff with it within minutes of
just arriving on the site and seen in
one or two code examples one of the nice
things that is it that it does to um
kind of add this predictability is it
doesn't try to make new names up for
things so if you want to set an
attribute then it's got a very similar
method to jQuery it just acts exactly
like jQuery so if you're a jQuery
programmer you don't ever have to look
this method up it's just the same as
what you already know and similarly it
adds a load of others that have adopt
jQuery conventions and it's just sort of
mess less mental overhead for the
programmer we have show and hide and
various other things in there another
area you can go to is is the problem
domain if you try to tackle a certain
problem or your library is dealing with
a certain thing like HTTP or maybe CSS
you you can you can basically model your
API around that and use some of the
conventions from it and get this kind of
added level of predictably really nice
example of that is is the jquery CSS
manipulation so you can see here that
there's such a lot of large amount of
sort of mapping between how you would
manipulate jquery CSS and jquery is how
you would actually write a CSS
decoration that you're never going to
have to be looked at the documents to
work out how to do this you you almost
in infer how that works so to start
putting a few these ideas into practice
will start an example the example is
going to be a dom builder it's kind of
an interesting problem to tackle from an
API point of view because everything
that you get given in JavaScript to do
this is pretty raw you've you've
obviously got the inner HTML way that's
kind of pretty ugly but especially when
you start interpolating
variables because JavaScript's not that
good at working with strings so you just
end up with a massive pluses and quotes
and then even worse you've got the Dom
API which you can barely do anything
useful with in its raw form like this so
it's definitely something that needs
masking so we'll try and create a nice
API around creating Dom nodes so the
first thing to do is we'll just create
the nuts and bolts of this thing will
have this function called element takes
name it takes an object with the
attributes for that for that node and it
takes an array of children and does the
very basic thing obviously there's a lot
of optimizations you could do on this
but this is just you know simplest
possible for clarity it just creates
that note sets the attributes append
trails of children and then return to
that node so if you want to use that
code this is that after our first pass
it looks something like this I've tried
to kind of creatively indent it to make
it make a little bit of sense but as you
can see in its in its raw state it
doesn't really match to our to our
problem too many doesn't look like HTML
let's like try and make it look like
HTML so thinking about the API come up
with something like this where instead
of having a single method called element
will create a method for each element in
the HTML spec so we can do HTML form and
you can already see that if we do that
then we've we're moving a lot closer to
it actually looking like something that
like an HTML document so how do we do
that well we can basically sort of layer
a little bit of of job of a sort of
intervene to face veneer on top of our
our basic element function and this is
how you do it i don't think it's worth
going through the code and everything
will be on SlideShare but essentially we
create a function for all of the for
every tag and then it just creates a
function that eventually calls HTML
element and we've got like a little bit
better there
okay so next up sim simplicity now from
from the sort of web design world there
was a really sort of classic book that
I'm sure most of you heard of many of
you will have read called don't make me
think bye bye Steve Krug it's actually
about you know creating interfaces for
the UI but I think the basic concepts in
it you can directly apply to to API
design the the basic crux of it is don't
make the user think about anything more
than they necessarily have to do to get
this solution don't don't don't make
them make decisions that they don't need
to make and and don't confuse them with
things that don't make sense to actually
solving the problem in hand and the
problem with this is it if if you do
present all of these options to your API
all of the time you end up with like a
very very big very complex and very hard
to remember API and you know you at you
end up forcing your users to like read
the mail over and over and over again
because it you've created something
which is too big to fit in a programmers
brain so we want to avoid this and so
that the time-honored way of doing this
is by the use of sensible defaults you
just decide on things that need to be
optional and just if if if an argument
is the same way ninety percent of the
time they just don't show that option to
the programmer at all unless they
actually need it this is obviously been
exemplified buyer bye-bye rails that as
a had a long history of sensible
defaults um something I really need some
sensible defaults is this particularly
laughably bad method from the the Dom
API and it's just to create a mouse
event that you can then dispatch on a
certain element but look at that
argument list how would you ever
remember that if you ever want to call
function it's basically mandatory for
you to go and look at this page
similarly if once you've used that and
you have this thing lying around in your
code no one will know what the hell that
stuff means zeros forces nulls in some
kind of arbitrary order that could
definitely do with tidying up we don't
need to make the have the design to make
those decisions and another sort of less
extreme example but also annoying and
also from the Dom API is the add event
listener we use it all the time or poet
well I end up doing sex I don't after
you can't use libraries most of the time
but it's it's it's fairly
straightforward you have the type of a
type of event then you have a handler
which is your function and then you have
this hanging bulleen on the end and
which tells the that which says whether
you want to use capture or not the other
thing is is 99.9 percent of the time you
don't want to use capture so why do I
have to worry about that and put false
on the end if you actually emit that
false from the end then you get an error
why don't we just like only let people
specify true on the end if they need
capture and then otherwise don't worry
about it so let's go back to this really
hideous example what would what could we
do to if we were writing the Dom API
what could we do to make this in any way
sensible well sort of well adopted thing
to do is use optional hat hashes foot
for the optional arguments there's
definitely a few things that we need
there we need the event type but then
probably from that point on all of the
other arguments for keyboard modifiers
and whether it where it whether it's
bubbles whether it's cancellable and so
on are all things that we don't really
need to worry about and for most cases
so why don't we wrap all of those up
into a hash so we'll have something like
this where the the event type is
required so that's just a normal
argument and then put everything else in
cider and yeah options hash and this is
something that you know like its
bread-and-butter stuff
an interesting article came out the
other day Rebecca Murphy rate which is
really well timed for me she sort of
asked around on Twitter about people's
opinions on where up when options hashes
were appropriate and when they weren't
and wrote up a really good article on it
so it kind of meant that I don't really
need to talk about it but this article
is a great read for that and it's worth
just reading it through and thinking
about it and and you know formulating an
opinion on it next up function calls
should read well if you if you're trying
to solve a problem you normally have
some kind of sentence in your head that
describes what you want to do for
instance I want to replace this node
with another node so when you're writing
your API is try and you can gain some
sort of memorability and simplicity by
trying to map that I'm not really
talking about going over the top and you
know going COBOL an applescript style
and making it read like English but
there's definitely some gains you can
get so here's three examples of sort of
doing the same thing wait and to me it's
fairly obvious which of the one which
one is the most memorable here we've got
the top one which is from the Dom API
again I trying to pick examples that
from the Dom API because I'm assuming
that no one's here who worked on that to
get offended but so the Dom API has
probably the least intuitive thing here
that probably annoys a lot of us on a
regular basis where you can't there
isn't a replace method on the note
itself you have to go to its parent node
and then you have to pass in the new
node and then the old node but really
what you're thinking in your head is I
want to replace old node with new nodes
so the method order there is the thing
that really gets me and it's just
counterintuitive and which leads me to
look at the documentation for that
method for more times i got i kind of
end up double bluffing myself and
thinking I know that it's the wrong way
round to how I think it should be but
then I get used to it
being that way around and then I think
it's what about i'm getting a mess dojo
is kind of got the middle ground it's in
dojo style it's the way that you achieve
these kind of things is a sort of much
more generic powerful method called
place that enables you to place a new
element in relation to reference element
in all kinds of different ways so it
again is like I would say that the place
of method is a little bit due to generic
to be to be easily noticeable you're
thinking replacing your head and then
you have to find place but i'm sure
that's that's not too much of a problem
again though it's suffering from an
unusual sort of argument ordering here
it's new node and all node again and
then the last argument which is the verb
is right at the end so it doesn't read
anything like replace old mode with new
note it's kind of in reverse and then
jquery obviously i think got this really
work right because it just reads so well
old node replaced with new note it's you
just get that simplicity in
predictability another thing you can try
and this is possibly on the side of
dangerous but works in some cases is try
and mask a little bit of the complexity
that in the sort of is within the nuts
and bolts of your library from from the
from the actual API user this is you
know often kind of lead you down the
path of magic and magic can often be a
bad thing because it introduces all
kinds of uncertainty into the code but
in some cases if you think about how
your interface is going to work before
you actually embark on solving the
problem you can you can come up with
some really nice simple things an
example is something we worked on a
Twitter recently which is across the
main communication library it's
basically all we do is come up with
various permutations of cross domain
communication libraries but so we set
about before we even started writing the
code we set about just designing the API
and writing code
samples and and getting a feel for how
it might work before we even knew you
know whether we were going to use
postmessage or whatever you know just
ignore that and get a text editor out
and start writing the code this is our
first permutation you sort of create a
connection object and then under the
hood we knew that an iframe would have
to be created and several things would
have to be initializing you have to wait
for them all to load before the
connection was ready to actually send a
signal so the obvious thing to do in
that case is have connection fire
already event and then before you
actually send any date or over this
connection you you just wait for the
ready event and then you can do your
thing but we looked at it and thought
yeah that makes sense but it's still
sort of a little bit messy what we what
can we do to sort of clean that that
interaction up a little bit so our
second iteration was something like this
where we had a connect method that
actually took a function which which has
the the connection pass to it and we
only call that function when the
infrastructure is is set up and that
kind of reads quite nicely but then we
notice that the the calls we make across
the cross domain bridge you are actually
asynchronous anyway so the the developer
is making a call and not expecting an
answer back for some time in the future
so why are you why are we introducing
two levels of a synchronicity why can't
we like sort of factor that out in the
API in simplifier so what we finally
came up with was something like this
where you you get the connection object
and then you can immediately start
calling methods on it under the hood we
actually just wait for the ready event
and then call all of the calls that have
happened that have been that have been
queued up since then and we sort of mask
away that a synchronicity which makes
for a much nicer interface and I think
if we would have actually started
writing the code to for the for the nuts
and bolts of the library before we
design the interface we probably
wouldn't have got here but the fact that
we were thinking about how it would be
nice to use before we started them
you know made a lot of difference in
this case back to the dom builder so we
this was how this out how far we got
last time and we want to be able to
simplify this there's a few things in
there that that are just hanging around
and they're kind of line noise so we
want to simplify this there's for
instance if if a node doesn't have any
attributes then you end up throwing in
an empty object if a node doesn't have
any children like the input tag you end
up having to always throw in an empty
array for the children and what we
really want to do is clean all of that
away so it looks more like this and it
and it starts to look a hell of a lot
more Oh another thing that I've got to
point out is if you want to just put
some text in at the moment you'd have to
do a document dot create text element
and have that in line and that's kind of
noisy as well what we want to be able to
do is get to this something that looks
that's starting to look quite a lot like
the actual Dom fragment that it's going
to create and just like move out all of
that line noise and basically default
some of the arguments we can we can do
that by actually and changing the the
sort of API sugar function we don't know
we're still calling HTML element with
the name attributes and children so that
remains solid but we're actually using
our sort of with veneering this this
sort of sugar layer on top of the solid
base and all of this code is basically
examining the audience or arguments
array and the types that are in it and
basically sorting things out and making
making things much nicer so for instance
at the bottom when we look through the
the children and then if it's a string
then we know to do a
document.createelement on it so so then
you're just passing a string in rather
than having to worry about the Dom API
at all the the final and probably most
interesting part is it's sort of how do
you build a library that that remains
flexible
and allows and fulfills as many use
cases as possible and I suppose the
comparison here is and I think that you
know this is the trajectory of nearly
all open source projects as they start
out with something really lean and mean
and a great idea so you know we've got
this pen knife it's got a knife in it
and it's also got a bottle opener so you
know what else you need when you go
camping you can cut things you can open
cans it's great but then someone comes
along and says yeah but wouldn't it be
great if like it had a compass and a
toothpick and make you know and and so
you go okay yeah i'll add a compass and
a toothpick that would be a good idea
and then so you know you're adding more
and more things on there more and more
pull requests coming and they think yeah
but i've got all of these other ideas
for features yeah if you know if you if
you write your libraries in in that way
you know then it can easily get way way
out of hand and i think the thing is is
you need to always keep in mind that
when you write a piece of code you're
never ever going to be able to please
everyone you know you shouldn't even
like try to second-guess every use case
and you shouldn't even try to
accommodate every use case and end up
with this kind of bloated feature set 1
think plan that you see a lot in lots of
different libraries and i think it's
kind of like a sort of an anti-pattern
that leads to software boat is is
actually with option Hassett the hashes
having an option hat is your only
argument is not flexibility yes you can
add new properties but it gets really
out of hand this is there's many
libraries that i could have picked on
for this it's not like so I'm not
singling out but this is something from
jQuery UI and this is the documentation
for the draggable component it has 28
options I mean how how and you know
that's probably likely to grow because
everyone's going to go oh yeah but with
my Dragon will object I want to be able
to do this and that and if you look down
then there for like kind of niche cases
like adding classes or being in a
certain container it's just all of it
you know
people are coming with feature requests
and then the concrete features are built
into this thing well I would suggest is
instead of doing that you actually think
about how you can add hack ability into
your code and your API so that you don't
have to accommodate every single niche
use but you provide the framework with
which people can sort of build their
their things on top a really sort of
first port of call thing that you could
do to fix that is this idea of there's
kind of this I think I first saw it in
in murbad chili but the idea of there
being a public API an internal API that
that's still accessible but you kind of
suggest people don't mess with and then
a protected API which you just basically
can't even get out I think at the moment
especially since the module pattern has
been around in JavaScript you see a lot
of stuff made private in JavaScript
libraries that don't need to be and then
you and once you've got truly private
things that you people just can't dig
into there and actually do their own
thing on top of it so i suppose what i'm
talking about is in a sort of you know
old school module pattern way you've got
your private methods that just existed
in the closure you absolutely can't be
messed with I think trying I I think
it's best to try and keep those as a as
a minimum really and probably only like
really really low level stuff but then
the other thing you can do is have this
idea of internal methods and and and the
the convention that I stole from herb is
is to underscore them so they're there
and if you actually looked at the this
lib module you'd see on the score
whatever and if you wanted to if you
really really needed to a developer
could actually override that and change
it and work with it and and then you've
obviously got your public API and you're
basically saying to the contract with
the programmer is you shouldn't really
mess with the underscore methods because
they are internal and they'll probably
change from version to version
so on your own head be it but if you
really really need to then it's there a
night and slightly more sort of complex
but a much much nicer way to build in
hack ability is actually by using the
fact that javascript has high order
functions wherever you accept a value
for for configuration you can accept a
function and that adds this whole level
of hack ability straightaway a really
really sort of nice simple example is
Kirk comes from from Endor which is a
library that's come out quite recently
they have this idea of they have this
this this method called underscore
select and the contract is for that
method that it takes a selector and the
root node and then it returns an array
of matching nodes now the cool thing
about that is it comes with its own
thing like a limited select selector
engine but it's really easy to just
overwrite that function with a function
that fulfills the same contract and uses
sizzle and then you've got all of the
extra jQuery style stuff in there or if
you're using the same thing on a mobile
platform then all you need to do is over
right that and there is something that
just use quick quick users query
selector all so just them having this
one foot function that allows you to
overwrite it is it sort of opened up
this whole sort of sphere of
possibilities in in this code and you
can imagine this kind of technique can
be used to add of like a really huge
degree of vaca bility another way you
can do it is by using inheritance you
can actually sort of use prototypal
inheritance and and build a set of base
objects in that basically you know map
to the problems in your library and then
you can build on top of them with the
core features but then they're also
there and you can own to expose to the
two other developers to build their own
features on top and kind of a slightly
more concrete example of that is in in a
library of mine called loadrunner load
runners a dependency manager and so the
the sort of central part of the library
is this this base constructor called
dependency and the way and what you can
do with that is all of the module
loading and the script loading stuff is
is built on top of is a subclass of
dependency but then any other developer
can make any other dependency on
anything else they like and all they
have to do is create a new constructor
that inherits from the base dependency
and then override any bits that need to
change so in this case it's a we want to
create a dependency on a mustache
template being loaded so we create this
new constructor inherit from dependency
and then all we have to do is override
the start method which is the method
that kicks off fulfilling this
dependency and in there you know we go
and get the template we pass it and then
we call complete which is the other part
of the contract once we've built this
thing we can use it at any place in the
library where you can use a dependency
so at the bottom there's a using
function that says I depend on this item
and then when it's done then the results
get past him and and so this one thing
that sort of built into loadrunner
enables anyone to build pretty much any
kind of dependency management on top of
it it doesn't have to be a script it
doesn't have to load over the network
doesn't have to be anything in
particular a sort of like a weight form
of doing a similar thing is by using
duck typing which I'm sure may see you
have come across sort of the idea that
if if an object fulfills a certain
contract it has a certain method then
we'll use that method implicitly we can
demonstrate that by adding a feature to
the Dom builder so what we'll what we do
here in our element builder function is
what we want to say is any object that
has a to DOM method then if it's there
will call that expect it to return a Dom
structure representing that object and
then we'll implicitly add it as a child
so we're just doing you know type of the
argument to da y equals function then
we'll call that function and that's
going to be the child instead of the
object itself which allows us to write
some really nice things so here's an
example we've got an object which
represents a tweet all we need to do is
add the two damn method to it that and
general and use the no builder again to
generate the Dom structure that
represents a single tweet and then we
can just drop it in and say if we had an
array of those then we drop that in as
the chapter in the child and then
they'll it'll do all of the work for you
so space the the crux of the matter is
when you're thinking about solving a
problem try not to write a code to solve
the problem think more about developing
a set of tools that will enable you to
solve that that class of problem and
then once you've got these tools that
sort of model the problem space then you
build your core features on top of that
the nice thing about that is because
you've built this sort of bag of tools
for solving different things you've
basically made yourself a plug-in
framework just by designing your code in
a certain way and I think you shouldn't
build any non-trivial piece of reusable
code that that doesn't have a sort of
plug-in system of some type everything
should be hackable because everyone has
different needs and if if you can
provide a framework for other people to
solve their niche problems then you
don't have to get that feature blow yeah
so it's a case of you know you build
tools to solve the problem so yeah now I
just showed you loads of things and
there's definitely some personal
preferences in there and there's
definitely ups and downsize to a lot of
the techniques that I showed you and you
know you are going to need to you know
make your own minds of depending on the
particular problem you're creating as
what to do but my main thing is that
you really need to think about the the
the your API design right up front and
design it like you're designing a
website make sure that it's really
usable it's as simple as it can be and
it it's predictable and not making the
programmer think about things that they
shouldn't do make use of the conventions
and yeah and lastly build in some hack
ability so you you're not responsible
for all of the niche features and so
we're sort of overtime because of my
messenger out with the display settings
but if there's no time for questions you
can heckle me on twitter at damn wrong
you can hassle me in the corridor or
better still talk to me when i'm drunk
cause i like arguing about things more
that way and yeah work for twitter and
they're hiring and that kind of thing
there you go
uh you know there are planes Chris we
didn't have to take a wagon to organ</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>