<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tim Oxley: The Structure of Node.JS Applications - JSConf.Asia 2015 | Coder Coacher - Coaching Coders</title><meta content="Tim Oxley: The Structure of Node.JS Applications - JSConf.Asia 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tim Oxley: The Structure of Node.JS Applications - JSConf.Asia 2015</b></h2><h5 class="post__date">2015-12-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yD2lMmmjB2E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you very much sunny I have four
minutes to get from this slide to the
next slide
good morning I've infected my entire
presentation with emoji I've never used
emoji before probably using it wrong but
one of my philosophies is you have to
use something incorrectly and poorly
before you can learn to use it right so
if anybody is an emoji expert I
apologize in advance so here we go it's
my first emoji attempt Who am I
Tim Oxley as signee mentioned that I'm
an Australian developer I've been living
in Singapore for the last three or four
years I grew up on PHP and all that
rubbish ended up becoming deciding I
wanted to do something with my life so I
got rid of PHP so I shouldn't bag
I shouldn't bash any technology really
but anyway moved to JavaScript and
started presenting it meetups ended up
becoming okay what I do okay I've now
worked for a company called node source
so node sauce it's trying to make node
better for enterprises so no it's going
getting going crazy at the moment and
we're building tools to help help
enterprise use node better we've
launched a product called n solid about
a month ago it's the first like big
product that I've been involved in so
I'm kind of proud of it so I'm just
plugging that a little bit we we
produced like a runtime for node that
allows you to get like cool
introspection capability so you can get
like stack traces and CPU profiles out
of it and visualize them in beautiful
graphs like that so under my talk
modular versus monolith this is
something which
some of you may be familiar with me
discussing this at length in the past at
various times one of the times in which
I discussed this was a 2012 not J's conf
it was jeaious camp J's camp it's
confusing because I have camp jeaious
and there was jazz camp so is that I
spoke about this but I have changed my
mind
so if anybody is familiar with what I
said this will be different so just a
little bit of background node node has
this compared to a lot of other
ecosystems we've got this culture of
extreme modularity the the idea is that
you can build an application up out of
like lots of little tiny pieces each has
like a single responsibility and you're
building your building using like lots
of little Lego blocks and you know you
can it's not uncommon to see projects
using hundreds if not thousands of
dependencies often hundreds if not
thousands of the same dependency which
is very unfortunate
hopefully salt resolved in NPM 3 if you
if anything will actually install
eventually anyway so in 2012 I spoke
about the idea of building modular
applications and the idea I feel like
maybe I was a little bit immature at the
time so take some of this with a grain
of salt but one of the things which I
was advocating was avoiding frameworks
because you know they they give you
vendor lock-in it's really difficult
once you're on a framework it's
difficult to move away from a framework
because all of your codes locked to that
framework and because it's locked to the
framework you're also in a situation
where when the framework dies so does
all of your code this is a bad thing and
it's something that we should be trying
to avoid if we're trying to you know
continue having our code bases live for
long periods of time my main objection
to using frameworks is actually it's
more just investment in something which
is going to go away quickly so after
every 18 months I felt like now I don't
know anything about web development
anymore this is a really frustrating
thing you know a new of every 18 months
so my solution that the solution that I
presented was rather than building on
top of frameworks - you build things
using libraries and library solve all of
your problems if you build something
with a library you know it'll be
reusable you can be more robust you know
you're right
yeah you can write documentation in the
readme for the sort of library
you know the you'll make better code
quality because you're solving smaller
simpler problems you've got less things
going on it's it's all about sort of
keeping things simple to the point
single responsibilities etc over and not
only that it the the great thing about
it is that it makes it very easy to take
something which you've built and open
source it and my the way I was treating
this was well okay if you can open
source why not open source everything
from the beginning
you know library first development build
build the concept was if you've got
something if you're you know we often
will pull tools out of NPM and use them
in our projects to solve various
problems and if you know I sort of saw
it as my responsibility if I if I feel
like I need something if I'm looking for
something and I don't find it it's my
responsibility as an open source
developer - well I'm gonna fill in that
gap if I've been able to fill in nine
out of my ten gaps it's my
responsibility fill in the the tenth one
and so if you're if you're if by
producing libraries you're producing
higher quality code overall and as you
know got a bit the benefit for the
community you know the overall quality
is better so wouldn't it make sense to
build your entire application as a big
set of libraries and start you know why
not even start with libraries at the
time I was talking about a project
called component which was thing by TJ
Holloway Jack
unfortunately between 2012 and 2015
what component died and which was okay
though it's okay one of the things that
I mentioned in the talk was that if
component dies if there's no you know
there was there's only a little bit of
overhead so a lot of the things which I
made components I made I had probably
twenty thirty components they're all now
NPN modules so that was nice but
unfortunately there are some other major
major issues with building things
library first or even having a heavy
focus on constructing libraries out of
the pieces which you're using to
construct your application number one is
that there's rabbit holes everywhere
it's very difficult if you're trying to
build the pure try to build libraries to
solve all of your problems you end up
just constantly building libraries I
remember there was one day I started out
with a particular problem and three days
later I realized I'd built like four or
five libraries and I hadn't even got all
the pieces that I need needed to solve
the original problem which it's good
because all these line these are
actually some of my more popular
libraries on NPM at the moment but they
actually they weren't solving the
problem that I had at the time which was
something actually quite simple it's
very frustrating and the the problem was
you know when there's if you think of
the idea of a library it's often it's
it's quite simple and you think oh yeah
I'll get this done in about twenty
minutes but in reality libraries take a
lot longer I find that if I'm gonna be
producing something of a you know a high
level of quality something that's open
source of all it generally takes me at
least six to eight hours and that's just
for like for example if my lab we just
has one line of code in it it's you know
maybe maybe a few more than that but if
if your work even even for the simplest
stuff it can take this amount of time
because you're you'll build your thing
you'll realize that the API is not very
good when you start writing the readme I
can't publish this this is embarrassing
it takes too many arguments so you go
and you change your API which means you
need to update your test which means you
need to update the documentation which
you just wrote
and you know you end up with this thing
which you know because it's supposed to
be reusable now you end up having to
take into account all these additional
use cases which probably never happened
in your application but because you want
this to be you don't want the next
person to use your library to pass it
you know some strange value in anything
breaks so you want to make it robust but
this is an awful lot of work and
unfortunately all those qualities that I
was discussing before you know reusable
more robust high quality code all this
stuff it doesn't just come for free
magically by building things with
libraries this is an unfortunate thing
and something I didn't really take into
account I just I sort of assumed that
reason why this stuff's taking so long
is because I'm crap but maybe it wasn't
because I was crap it's just that this
stuff things just take time or maybe
maybe I am crap and maybe I just need to
live with that that's okay I can live
with that the problem is is that if you
try to build everything at a hundred
percent quality all of the time you end
up investing an awful lot of time over
engineering because you're building
stuff which like I said
taking into account cases which you
don't need in your application you're
making it more robust than these to me
maybe it doesn't even need documentation
because it's like one function and it
takes two arguments and you know a
comment above it will be sufficient so
the thing thing is most of the time
you're not gonna need all of this
additional quality that you're injecting
and the worst part is a lot of the time
I would build stuff and then go to
integrate it and then discover I didn't
even need the thing in the first place I
could have just done the whole thing
with one line of code and this is just
such a waste of time great for the
community and I think that's probably
one of the reasons why NPM has you know
most of the it's the largest package
repository ever in the history of
humanity because a lot of people are
over engineering and it's great benefits
the community but may not necessarily
benefit the people who's out
actually paying you to build the right
thing so unfortunately if you were
building libraries first you often
you'll build the wrong thing so the the
solutions of this is to constantly be
asking yourself what problem I trying to
solve is this the simplest thing which
will work and I would often ask myself
that while I was having a shower I do a
lot of thinking in the shower so I
enjoyed that's why that emojis they just
have to explain that often if it's not
the simplest thing you know you need to
you know roll roll back I don't this is
just something which I am constantly I
have in my mind and I'm almost always
when I'm doing things the answer is no
socks but but that's okay we we try to
get better
there's a quote don't know where it from
where it came from which reads we've all
had projects in which we spent 80% of
the time working on a small piece which
we found interesting and 20% of the time
building the other 80% of the program
and this is something I've this is again
the reason why I'd like to build those
modules I'm gonna solve this problem
really well and that I find that
interesting the idea of taking a taking
something and doing a good job of it
understanding the whole thing but yeah
is that the simple thing that'll work
probably not and the the way I get
around another way that I tricked myself
a question that I asked myself to figure
out am i doing is this the right
decision should I build this is if I
asked myself is this going to be fun if
I think something's going to be fun I
probably shouldn't be building it
because I'm building it for me not for
the product this is a horrible reality I
hate this but yeah a lot of the time if
you're building something that's fun you
should probably second guess whether
you're building it for you or actually
to solve the problem it's a little sucks
but maybe there's a better way but
anyway overall the point here is that
avoid premature modularization
because you might end up putting the
wrong thing into your program because
it's difficult to know upfront all of
the things that you're going to need so
tend to build things top down I put a
saxophone in here because I had this
sort of idea of this image in my head of
starting a band I've always wanted to
start a band I've been in bands but they
were never any good but the I had this
vision of like starting a band and like
getting this writing this excellent you
know lead part but and then just jumping
on the first instrument that I saw was
like a like a saxophone and but then
later realizing and we'll hang on we're
in a metal band what the hell am I doing
with a saxophone and that so if we if
we're going to avoid premature
modularization what are other what are
our other options there are other
options of these things before my
whenever I needed to model I modular
eyes something I would just instantly go
straight for external package because
this seemed if you look at a lot of the
prolific authors of stuff this seems to
be the way that they work but I'm not
sure whether this is actually a good way
to work in your everyday work so you've
got all these other options which are
much simpler which come with far lower
overheads which you can use before you
end up moving something out so basically
what I'm trying to say is you can I
don't even mind having a whole bunch of
stuff just in one function that's fine
as long as it's not complicated
but if that gets complicated if it's too
much to hold in your head then you can
break it out to a file folder or an
internal package all these things which
are which have lower overheads before
you get to an external package next
point is assume that your first attempt
will be bad so this is another thing if
you're building things which are open
source and your first attempt is bad or
one you've now got other people using
your bad first attempt but to you've
gone and invested all this time in
adding all that documentation all those
tests in
think which may or may not be the best
solution
like tests a really good way of making
sure that your code doesn't change and
so maybe a good maybe it's important
it's important to prototype I guess is
what I'm trying to say here it's not
always clear how to best slice up the
logic for your application and you're
probably going to make some bad
decisions up front
now I'm Judah incomplete or missing
information so not only that the you'll
end up with you slice things up in a way
which doesn't make sense
next week it might have made sense for
the changes now but it doesn't make
sense later and especially if you're
building things library first like I was
the longer you leave integration with
your application the greater the chance
that you're going to discover that the
thing that you're building doesn't make
any sense
and one of the times when I realized how
bad my my first attempts were was at
purgatory so I've been very very fond
memories of doing toad retreats and we
did one for death vestager who actually
came along to that couple people one
okay there we go so that's good
more people should go next time there's
one make sure you go to this because it
was really eye-opening for me when when
I went to code read a few years ago
between 2012 and 2015
I realized so you've got the the idea of
a code retreat is that you've got 45
minutes to try and implement a very
simple algorithm using test-driven
development and after the 45 minutes you
delete your code and pause briefly for
reflection and then you find a new
partner I'm sorry you're doing it all in
pair programming you find a new partner
and then you repeat and so over the
course of the day you solve the same
problem over and over again maybe four
or five times and the general experience
seems to be that everybody starts out
building like classes and all this just
boilerplate rubbish you know you'll see
things with accesses and pretty much
everything except for implementing the
four
properties of this algorithm and I
remember there was one group who said oh
yeah know what we're nearly done we're
nearly done we just need to implement
the algorithm now and it's like that was
that's where you should have started and
so they were building all these pieces
and I was building all these pieces not
that's not just everybody else and then
it made me realize it scared the
out of me because I was like everything
that I build is usually just on the
first attempt and I'm usually I'm
probably injecting all this additional
complexity into my applications that I
never go back and delete and revisit so
this is I open it so I guess the
suggestion here is that if you're going
to be don't be don't get Precious about
your code
there's the often we try to make our
code live for as long as possible so as
you know we make it extensible and we
make it robust all this kind of stuff
but perhaps a better solution is to
start by well first validate that this
thing even needs to exist validate that
it's a good solution to the problem and
if it's not revisited delete your code
start again I guess yeah point is don't
be don't be afraid to tweet your code
start over and there's a good anecdote
from me I remember there was a Smith
days working on the speech I was late I
couldn't get this thing done I made it
really hard and I was really stressed
about it and I'd written some tests and
in the teardown of the techno in the
setup of the tests I are what the you
know the the the working folder and then
you know keep working I'll keep going
with the tests what I didn't realize is
I've accidentally put too many dots in
my which folder to delete and it deleted
my project folder and because I was
stressed I hadn't been you know obeying
best practices and I hadn't committed
for maybe two or three days
and to leave my get a folder of course
so that was just gone it was just
nothing sorry I had been committing but
I hadn't been pushing because I didn't
want the my peers to see my crappy
attempts at doing something complicated
anyway
deadline was looming I I think I had to
demo this thing at 11 p.m. and I managed
to pull it together in you know four or
five hours and I was like well what the
hell have I been doing why why did I
spend two or three days and what had
happened is that over the two or three
days I'd realize I'd gotten a proper
understanding of the problem and I ended
up I was more fighting my crappy
implementation rather than actually
solving the problem so why didn't I
delete my code earlier that's the
question so over engineering the adding
of unnecessary complexity this is
something we all do something we should
try to avoid picking emojis for these
slides is very difficult that may look
like a fat man that's fallen over but
it's actually it's a baby and I thought
that this was a good example of
over-engineering at least in at least in
Australia we often have people often use
they make a baby to save a relationship
and I thought that was a good example of
over-engineering don't do that
over-engineering it's probably a simple
solution just talk to each other when is
complexity kills projects this is like
the leading source of project death is
complexity and you want to avoid it and
but you know because complexity
increases the likelihood that you're
going to end up with bugs security
problems it creates it stops you from
being able to add additional features
it's it's the shittest so we want to
avoid complexity on any level
over-engineering adds complexity and I
found that at least in my circles that
over-engineering is far more common than
under engineering if you're
if you're if you've been reading books
about like programming a lot of the
content that you read is about
preventing under engineering they tell
you how to break things up and you know
single responsibility principle all
those kind of stuff but there there's
not a huge amount of advice on how do we
how do you prevent people from taking
that too far because often yeah the the
simple solution for today's problem is
not a simple solution for tomorrow's
problem and biggest yeah if you if you
if you're doing over engineering this is
going to be far more costly than under
engineering this is because the wrong
structure is going to be more costly to
change than having no structure at all
this is something that I found quite
often when I work on like all rubbish
applications
I find myself able to be a lot more
productive as long as they have tests
because they're you know if people are
just writing big long dirty methods and
it's disgusting you hate yourself by it
went by contributing to this mess but I
find myself
weirdly productive then if I'd gone in
and tried to make things good make
things structured make things awesome so
structure can be easily extracted from
no structure but incorrect structure you
need first you first need to reverse it
before you can change it so the way that
I've been working these days is trying
to make the least amount of decisions
possible and just let the code kind of
be a little bit crap it's ok because
you're probably not going to make a good
decision about how to make it less crap
now make it later defer decisions if
your thought the thinking with that it's
like a if you're getting if somebody
hands you a grub you don't know whether
you're gonna get a moth or a butterfly
so so you don't know whether do I do I
keep this or do I put it outside so yeah
the further making important decisions
for as long as you can because you will
always have more in from
later and this will help you make better
decisions so every decision that you
make now is going to be a worse decision
than a decision that you make later so
try not to make decisions
just leave it leave it
and the best way you can leave it is by
not well this is pretty much the exact
same point drawing pencil before you
join Inc make sure that you haven't
don't don't get not too much structure
this is something this particular point
actually something that I discovered
before I used to I wanted to be a
musician and I was working with a guy
and he was like Tim you never finished a
song you end up with just working on a
little loop I was like yeah it's a good
loop but that's not a song you know
we're trying to sell songs and I'd be
working for like hours just trying to
get like make sure the snare was
compressed correctly you had the right
EQ and you know because once I get the
good loop then I can make the song but
what ends up happening is you get so
focused on this loop that you have no
perspective of the big picture of well
what does this even look like in the
context of a song and now I have a whole
library of just loops they're not songs
there and there's nothing I can do about
them because I can't think about them in
the context of a song so the idea here
is that what this guy's just said Tim
you are not allowed to use a compressor
no let's use EQ until you have at least
have a song structure in place and
instantly as soon as I had the song
structure in place I was able to put
together songs that weren't good songs
but there were actual songs are better
than loops and then later I could come
back and fix the loops and change stuff
and what ended up happening was don't
worry about if the thing that you put
into your code now it doesn't have to be
there forever you can delete it it's
just like a starting point the you know
the I would just write the crappiest
bassline I possibly good just to get me
a starting point something to build on
and you should do the same thing in your
code just get something to start with
that you can build on top of
when you're building code you're often
trying to organize things by adding
abstractions and the abstractions will
increase sorry
they'll decrease to local complexity so
they solve the small problem while
increasing the the global complexity so
a good example is if there's a project
an open-source project I guess I won't
mention it but there's an open-source
project that I was working with recently
which had one function per file and this
is it had a hell of a lot of functions
and this was very difficult to actually
understand like to actually figure out
what was going on in the program you
have to open file file and then you have
a file which is just all it's doing is
requiring some other file and it's just
you're following this horrible endless
chain of complexity and it's very
frustrating because it's the whole
concept of can't see the forest for the
trees so every every time you add an
abstraction it adds to the global
complexity so just be aware of that and
try to reduce complexity everywhere
because we often find ourselves building
the wrong thing for the right reasons so
we can justify building our abstract
function factory factory but you know it
makes sense it'll you know it'll make
things easier in the long run to have
this thing but perhaps a simpler
solution would have worked and there's I
have to like that there's probably
people who know when I'm what slide I'm
gonna bring up next to xkcd comic
and this is what engineers do all the
time the the alt text here is I find
that when someone's taking time to do
something right in the present they're a
perfectionist with no ability to
prioritize whereas when someone took
time to do something right in the past
there are master artisan of great
foresight so but I think this is the
this is the kind of thing that we as
engineers do all the time and it's
horrible and we should stop this
so pointers build the simplest thing
that works and sometimes a good rule
that I find for trying to make sure that
I build the simplest thing that works is
flat is better than nested and this is
this is one of my favorite mantras
because it you're able to use this thing
to guide design decisions all the way
from statement level all the way up to
package level so for example at the
statement level you should try to avoid
complex chains of if if-else logic that
sucks at function level you shouldn't
have like nested callbacks class level
you shouldn't have you know multiple
levels of inheritance these are the
examples but the idea is that whenever
you have a choice between a nested
structure and a flat structure you
should probably always pick the flat
structure so because the simplest thing
is probably flat so back to what this
talks about modular versus monolith
being somebody I've built things purely
monolith and purely modular the projects
that I built purely modular are still in
development
so I think that the sweet spots probably
somewhere in the middle so I don't know
that's a good name but but maybe maybe
point is we should try to avoid
premature modular ization stop trying to
architect things too much in advance
just just simplest thing that'll work
and often the simple thing that will
work is to build a monolith
this is probably a statement which I in
2012 I wouldn't have thought I would
ever be making but I truly believe in
this now I'm converted and the reason
why the reason why is because yeah we
have all these we have all these other
options to use before we get to breaking
things out into external packages so and
the other thing is a nice and really
nice thing I think about what Facebook
and Google there's a bunch of other big
companies when they when big companies
do open source they don't just open
source everything that they're doing
that might solve a problem they solve
the problem internally first make sure
that they get it right and then and then
they open source it and I was thinking
like if you're selling somebody a toilet
you want to make sure that it works
before you give it to them
otherwise they're gonna be very unhappy
because one of the problems with NPM at
the moment is that there's an awful lot
of abandonware so these are things which
people have built to solve which they
thought they were going to use to solve
such as such a problem but it turns out
that you know they they didn't need it
or it wasn't the right fit or whatever
there's there's an awful lot of
abandonware on NPM and this sucks
and I own a lot of bandim where it's
because it's very hard to maintain or
even make good decisions about the
direction of a package that you yourself
don't use I'm very happy for other
people to use my packages but if I don't
use it I'm not in a very good position
to be making good decisions about it so
and I haven't got this in the slide but
there is a good there's a good community
driven solution for this which is it's
called open open source so if you get it
open open source dot-com net there's a
manifesto there and the basic idea is
especially in the situation that you are
no longer maintaining something when you
no longer interested in maintaining
something but even if you are a good
policy to adopt is adopting you
contribute anybody who's like interested
in being sorry anybody who makes a
significant contribution to the project
becomes a contributor and then that's
additional resources that your project
now has to field request publish new
versions etc so perhaps after the point
that you're when you're no longer
interested in whatever it is that you're
building somebody else can pick it up
and run with it and this works there's
this amazing thing which happens when
you give somebody commit rights to your
project you it might be a likes of a
scary thing you think all they're gonna
delete it and replace it with
CoffeeScript but in reality this doesn't
happen when you give people
responsibility they generally take that
seriously and you you actually see an
increase in activity because they're
they feel like they need to live up to
this responsibility that you've given
them so I found that I haven't done this
a huge amount on on my projects but I
know that it's worked very well for a
lot of other people and in fact with the
author of Express's departure from the
j/s community this is the open
open-source model is basically what's
happened to all of his packages anybody
who made significant significant
contributions through those packages are
now maintainer
so that's nice but the point is we're
talking about over-engineering let's do
this of it build the simplest thing that
works oh yeah saxophone and avoid
unnecessary complexity so the ball so I
was thinking here I'm justifying my
emoji use here when you're at home and
nobody's there do you even need to use a
bowl just eat it out of the can do you
even need to heat it up
open that lid just eat it avoid
unnecessary complexity thank you thank
you Tim thank you so much questions
questions okay maybe a couple I just
want to come in in the Oscar poll
because something about over engineering
and under engineering because I have
found that over engineering usually the
consequence of the prevails
under engineering so these things that
people swim between the two ends and
they never find the moderate meter for
example I have seen 116 like 16,000
lines over in one just keep our menu
right and so that's why that does a
people are or people try to say all the
things but apparently they failed so I
think there's a point another question
maybe you can find some middle point
that you have no no that is really hard
like the point is is that balancing this
stuff is hard but I guess the thing is
is that a lot of over engineering does
come from being yeah it's reactionary so
you get burnt by something in the past
like frameworks and then you like never
again rally against them destroy every
single framework there is so but maybe
that's a overreaction so you know maybe
the best solution I don't know what the
best solution is it's it's hard balance
right or one last question I'll be quick
yeah first of all awesome talk a lot of
great insights couldn't agree more and I
think that another thing that might
worth referring to or like mentioning is
software longer David long activity
because a lot of times we just write on
something and we hope that at some point
in the future it will be
useful for someone but in reality if we
write software for a living if we get
paid for it even at the
best-case-scenario it's unlikely that
our our code will outlive more than five
years yeah it shouldn't and I guess it's
probably a deleted slide in there about
this but one of the things which I find
best is just to yeah don't don't design
your code for extensibility design your
code so that can be easily deleted so
instead of instead of trying trying to
force your code to live forever force
your code to be deleted quickly
I think that's policy
I remember this is this is saying that
one of the virtual programmer is being
lazy lazy arrogant selfish I think that
so do you think one of your problem is
that you work too hard well I think
sometimes we think we're being lazy cuz
we'll spend like oh I don't want to I
don't want to do find and replace in
these files I'm going to I'm gonna write
a tool you know this is me being lazy
but turns out a lot of the time you
you'll spend an hour or five hours or
two days saving yourself five minutes
down the road with the idea that okay
I'm being lazy I think that's I think
yeah we do do too much and focusing on
just the task at hand I think is the
important thing
all right thank you Tim Oxley
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>