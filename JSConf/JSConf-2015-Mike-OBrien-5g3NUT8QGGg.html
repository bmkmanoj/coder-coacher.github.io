<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JSConf 2015   Mike O'Brien | Coder Coacher - Coaching Coders</title><meta content="JSConf 2015   Mike O'Brien - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JSConf 2015   Mike O'Brien</b></h2><h5 class="post__date">2015-09-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5g3NUT8QGGg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">oops go and swap for having me again I'm
Mike and I'm the head of our platform
team at famous and kind of what we
specifically work on is the rendering
engine for our JavaScript architecture
and one thing I wanted to talk today
about is mixed mode and mixed mode to us
is kind of client-side compositing for
the web what it is exactly is it's a
feature of our new rendering engine that
allows for like the complete unification
of dom and web-dl and by unification i
mean there's a single API there's one
coordinate space there's complete layer
compositing and there's no user side tax
so one API it's the idea that I move
things around in space and all of these
things affect both Dom and WebGL I don't
actually have to care about these like
how they fit into the system differently
one coordinate space I'll get talked to
more of it later but there's a pretty
different sense of spacing when you do
WebGL content person than when you do
dham content compositing what i mean by
compositing is if you take a like a
three-dimensional scene so my hand here
in my hand here what it does is
compositing is the way to understand
where things are in three-dimensional
space where the camera is and flatten
them into such a way that it looks
correct as projected onto the screen and
we want to abstract all of this away
from the user to have to deal with it so
again this is kind of what compositing
is so the question is why would anybody
even want this is this a feature that no
one really wants is what what is the
point of trying to merge these two
things and to me it's because the web is
becoming a lot less about pages and it's
becoming a lot more about full
experiences and applications things were
it's not a big piece of paper scrolling
that said there are a ton of use cases
where that is the best way for your sort
of the medium that you're in the content
that you're trying to show so if you
look at something like reddit reddit is
the perfect example of something that
needs to be in a document you have all
these news stories that are listed one
by one by one and you can scroll through
them it's really easy it really simple
and people want to view this kind of
content and list form similarly a lot of
other news outlets like BBC have
pages where it makes a lot of sense for
them to just list everything vertically
and have users scroll through it's like
a really common interface and it makes
sense there's no teaching the user how
to do something similarly ESPN you know
they love the bar at the top and
navigation but then the bulk of the
content is in the document so what are
the benefits of this one it's been
familiar for users users know how to
navigate this kind of application it's
familiar for developers there's like no
tricks this stuff has been around for
years and years and years and browsers
have were actually literally designed
for this particular purpose there's a
reason it's called the document object
model it's the idea that all of our CSS
all the way we do stuff is based around
the idea of positioning a document on
the screen it's compatible it will run
everywhere these things are super super
old and one of the big benefits for me
to is easy navigation so like this is a
little picture I drew of me on the couch
browsing reddit like I have my laptop in
my lap I scroll with my two fingers and
I don't want to have to like navigate
this big space I want like a little bit
of scrolling to get me everywhere I need
to be into my application but this is
also not the best use case for a lot of
things so if you go to like the website
for the movie Birdman they have this
really nice art cinematic with like
meteors falling down different
typography when you type in these all
pop and it's all written in WebGL and
then there's a lot of things like these
chrome experiments out there where this
particular demo what they did is they
have a they have a globe and the globe
is completely mapped to be like
correctly sized and it shows the
different arms trades between nations so
you can say art what is that if like how
many guns and ammunition go between the
United States and Canada and you can see
the lines and where they're coming from
the depth and that's something that only
really really makes sense when it's not
in the document form it gives it a lot
more expression because you're able to
use three-dimensional space to your
advantage similarly there's this one
really cool chrome experiment that is
the galaxy and it's you literally pick a
star and you zoom into the star and you
get to see all the properties about it
and this only makes sense because
spatially we want to be able to see the
galaxy in terms of like proportions as
to where they are relative to each other
so you know there is
legend that says you know 10 pixels is
one light year away or something like
that that can accurately describe what
the galaxy is and again something like
this does not make sense to be used in a
document so what are the benefits of
heavy WebGL use one it's beautiful and
inspiring you get much much better
performance than you do with the Dom you
get shapes the DOM is really really good
four rectangles and that's about it but
you can do Torres's you can do pyramids
you can do triangles you can do any kind
of shape and you can do arbitrary 3d
models also so I can import like a coke
bottle or you know an elephant obj for a
game or something and now I have the
ability to create content on the web
that's not just panels on a screen that
are moving up and down so the real thing
is that you saw a few examples that use
the document to their advantage and you
saw a few things that used WebGL really
heavily to their advantage and the idea
is you want to use the best technology
that represents your content so if you
have content that makes sense in the
document that's fine but there's also
content that's better represented in a
non document format but the one thing is
that it's not just use WebGL for like
super high like experimental stuff and
artwork and use Dom for documents the
Dom can work in a 3d environment it's
more than just an overlay if you looked
at like the prior examples with all the
chrome experiments there was DOM and
there was WebGL in all of those scenes
but the Dom was only ever used as an
overlay that fits in front of the WebGL
there was never any layering between the
two and and it the DOM is capable of a
lot more than that so here are some
examples to help show like kind of what
the upper limits for what the Dom can do
in terms of just like performance so
here's an example somebody on our
creative team made of an ad
and this is all done
you
so one more example of just something
that groups yeah that can be done in the
dawn this is my personal website just
something I had to test some stuff but
this is all dumb and you get the ability
to manipulate space and work in three
dimensions just by using DOM and so now
the question is like well this looks
really good but it still comes short in
a lot of ways Dom you're going to hit
performance issues as soon as you hit a
large number of elements on your screen
the browser does not handle it's not
designed for the case of you know
thousands of moving dudes on the screen
all at once also the Dom does not make
really good their browsers don't make
really good use of the ability to change
color frequently when you change color
you're causing repaints over your entire
screen and then you can't do certain
types of blurs you can't do post
processing all these like types of
effects that you see in games and you
see in other forms of medium are kind of
not at your disposal also you can't do
shapes you have squares and you have
circles you can do CSS arrows and you do
stuff like that but that's you know more
of a hack than anything else but you're
really really limited to the amount of
like different shapes and primitives you
have and even just the level of detail
you know I could have a square here that
has some gradient on it but I can't make
a gradient that reacts over time based
on when I click it and that's something
that WebGL does give you so again one of
these flaws exists it's because the time
Dom was not designed to do this browsers
are optimized for scrolling pages of
content they make a lot of consolations
so that when you scroll a webpage up and
down that image in that video looks
really really crisp and because of that
you because of the ability for them to
scroll up and down like make that really
really performant they take you take
hits elsewhere and again this is kind of
like the roots are in newspaper style
Dom information so where's the Dom
better than WebGL so what we want to do
is we want to be able to the best of
both of these rendering targets and use
them into a single API so what is the
Dom really good for the DOM is really
good for CSS CSS is like iterating very
fast they're getting a lot of new stuff
and you can style really really nice
looking down with it it's got a built-in
a venting system it's really good for
search engine optimization
asian it's compatible it's everywhere
you can have forms links and there are
standards that get try to get followed
and what is web geo lab WebGL is
performance gains color changes
different types of shapes like I was
mentioning before 3d models it's more
expressive and something that's also
nice is that it's more familiar for
graphics people there that are not
involved in the web currently so this
sounds good let's think about what we
want to do to like make a mixed-mode you
know rendering system and like what the
requirements of this would be so the
first thing is we need one API to roll
them all we need the exact same
coordinate space so 20 pixels to the
right means 20 pixels to the right and
we need proper layering which means we
need to have Dom be able to be in front
of GL and WebGL to be and be able to be
in front of the DOM and this again needs
to be abstracted completely away from
the user so step one let's create a
single API for the Dom so what we want
to do is because we want to make use of
three dimensional space and kind of work
the way you know WebGL kind of works the
document object model is not the way we
want to do layout we want to position
everything in terms of three dimensions
and the abstraction we use for this is
something called a scene graph and
basically it's a mutable graph of nodes
where your parent tells you hierarchical
information about where you are in the
scene so if I'm a child of a parent node
and my parent gets translated to the
right 20 pixels I am also translated to
the right 20 pixels so that begs the
question what other type of information
is hierarchical like what is
preferentially treated in our system so
that we can get this motion between you
know Dom and WebGL synced so we have
transformed so that's translation
rotation scale their size so i can set
size in terms of pixels i could say i'm
50 by 50 by 50 box or i can say all
right i'm 50 by 50 but my depth is half
of my parents depth and then also
opacity we want to passively chained
down so if my parent get soap acetate
addai also need to be a basset ated so
because of this information we kind of
have everything we need to define where
something is in three-dimensional space
and that
kind of the key to everything is just by
having these three properties on every
note in the scene we can define where
something is in space and that's kind of
the crux of the API is that you are
taking these you know if if a point if a
node has a point in space that
determines where it is and it has the
size so that gives it pretty much a cube
you're essentially positioning these
cubes in space to make your application
and the only thing left to do from that
point is we need to add the ability to
draw so the idea is that we have these
renderable components that attach onto
nodes and again nodes are defined as a
point in space a cube so if we just give
the node the ability to understand how
to draw or send information on how to
draw then we're kind of all set so if we
take a look at this example right here
you can see like the first line we're
going to create our scene and we're
going to add a brand new node and then
the next few lines we're going to
position the node we're going to say all
right you're 250 pixels by 250 pixels by
250 pixels we're going to move you to
the center of your parent your center is
going to be at that point and your
origin for your rotations is going to be
your Center so and then we also attach a
component that's responsible for
rotating the thing around the y-axis as
time moves on so this is all the code to
set up this like fictitious cube in
space rotating and that's all we need to
do and now from here what we can do is
we can attach components to these nodes
to give them the ability to draw so here
we have this node that's spinning this
like invisible node spinning in space
and we're going to say all right I'm
going to add a Dom element to it and
it's going to have a background color of
red and I'm going to add a mesh to it
and the meshes geometry is going to be a
sphere so what this ends up looking like
is exactly kind of what we would think
you know we have a single node that's
spinning and on this thing is both WebGL
content and Dom content I'll get to more
about kind of the coordinate space and
while the layering is working later on
but you can see that like this API
really abstract sawey the idea of
positioning content from the actual
drawing of the content so the next thing
we need to reconcile is the differences
in coordinate systems and unfortunately
there's a lot of differences so for the
Dom the origin of the DOM is the top
left of your screen and it's the
with in height of the screen and pixels
and the transform origin of all of these
on elements is the top left so that's
why when you put something out identity
you know it's up in the top left corner
its top left corner is up there also for
WebGL is very different the outer bounds
of the screen are negative one to one
and with and negative one to one in
height and when I throw something in at
the origin and WebGL the center of that
object is on the center of the screen so
what we need to do is we need to have
the ability to treat these to see like
systems the exact same way so for
example kind of make sense if I have a
screen that's for 1400 x 900 and we're
going to take 100 100 square to the
right and throw it 50 units down and 100
units right the Dom in the web dl are
going to be miles apart so how do we
reconcile this the first thing we need
to decide is what we decided to do is
like what do we want the API in do we
want the EPI to be in this clip space
this negative 1 to 1 this around there
or do we want it to be based in pixels
and we decided to go with pixels for a
few reasons one developers know it it's
easy and the real reason is that it
makes 2d layout so much easier when
you're using negative 1 to 1 it's really
designed for like three dimensional
environments and it's not designed for
something that you need pixel perfect
design for on you know on different
sized devices and whatever so we went
with you know the origin is going to be
up in the top left corner and our entire
API is going to be in pixels so do it
all in pixels and then we convert it for
you so the idea is that you can treat
your application and write it all in
pixels in even though WebGL doesn't want
that kind of information the rendering
part that you don't even deal with can
do the conversions for you so what we
have is we've broken up the system into
two parts there's the application part
and there's the render so the
application part does all your business
logic your layout logic it has the nodes
it has all your renderable components
kind of the code you guys saw earlier
and then there's the render and what the
renderer does is it takes draw commands
that are generated by the nodes and the
components of the note and it turns them
into the actual pixels that get drawn
onto the screen so this is kind of like
a simple diagram of our architecture
basically what happens is we
our render loop which in most cases
something like requestanimationframe and
we pass like a frame into here the frame
lots of the famous engine know that it
needs to update a bunch of stuff update
this clock and tells the scenes to
update what the scenes now do is the
scenes go through and they say okay did
anything change for me do I am i red
instead of blue did I get translated at
all and it goes through all the nodes in
the scene and anybody that has diffs
that they need to push sends all the
draw commands back over so all of this
draw command information goes back
through the compositor and from the
compositor the compositor can decide
okay this is information that the Dom
render needs to know about or the WebGL
render needs to know about or something
that they both need to know about so
from here we can do all of our stuff in
like in pixel space and then when it
gets down to the WebGL render the WebGL
renders can be the one that's
responsible for saying okay I know what
to do with this the screen is this big
and my transform is this so therefore I
can handle this for them so again if we
consider the world transform and size in
pixels and by world transform I mean
like physical place in reality like
regardless of camera regardless of thing
if we're trying to think of our
applications as three-dimensional seems
like where they are in space and again
it's the renders job to make the medium
specific investments so the Dom does
have to make some adjustments to because
we have Dom nesting now which is really
great you can use CSS and you can use
you know the bubbling that Dom Nesta Dom
gives you for free but basically the
idea is we need to account for the
parents transform if in world space I'm
500 pixels to the right and my parent is
also a Dom element and he in world space
he's 400 pixels to the right my one that
I right to the Dom only needs to be 100
because my parents already taken care of
400 for me WebGL needs to make very
similar adjustments they need to convert
the size to clip space on negative one
to one they need to convert the
transforms to clip space- 101 or yet
negative one to one and then also
account for the move of the top-left org
from the middle to the top left of the
screen so the third step in this is the
proper layer composition and this is
kind of like the biggest part of kind of
what we do so the thing is that we have
two elements that we control pretty much
so you put you know a little famous
apple
asian somewhere and we have a canvas
where we put all of our GL content and
we have a div where we put all of our
Dom content so how do we get it so that
Dom can both be in front and in back of
the WebGL it seems like it can be
possible so the big trick is that we
always have our canvas in front of our
web or in front of our Dom content and
because we're doing everything in terms
of world space we know where every Dom
element is and we can tell the WebGL
render to add a completely transparent
Dom L or plane to the scene at the exact
same location as the Dom element so what
this does is this pretty much creates an
invisible plane that is referenced in
the WebGL render so that it can cut out
a little little spot for us and so
basically the thing is that you don't
ever have Dom in front of WebGL but what
happens is that we cut out a little
scene in our web Yale scene so that you
can look through see the Dom element
there and it lines up so perfectly that
you don't even know that your eyes
pulling a trick and you don't even can't
even tell that it's like actually
layered behind it in the Dom so here's
some of like the cut out stuff in action
so this is a scene where everything is
working just some context so we have a
little light here we have a GL plane and
we have a Dom element that's right here
so if we move this around from more on
perspective to like imagine you and your
the camera this looks correct like if I
turn this the angles are right and
everything is layered the way I would
imagine it to be so let's say we didn't
have let's say we didn't have cutouts on
so that there was no cutting out of that
invisible plane for for the WebGL scene
so you can see that like this looks
somewhere you know the light this was in
front rotating and you have your plane
and when I go behind it still looks
really really good but the issue is I'm
not cutting out from there so even
though the the pink div is technically
in front in world space we're not
cutting anything out of our plane to
account for this which is why it looks
like it's behind it looks like it gets
hidden behind but even though we know
that it's in front
in terms of world space another here's
one more example of kind of the exact
same demo but this shows it pretty well
so we have an invisible div right now
and we have the same thing so imagine
the invisible div is right right around
to your right what you can see is this
is exactly what's happening is that
we're just cutting out a plane inside of
our WebGL scene and now you get this
complete interactive doing DOM and WebGL
in the same space the user doesn't need
to know at all that these are like
technically not supposed to happen this
way and we can abstract the like the
differences between the two rendering
mediums away from the user so that the
user can just focus on like okay
position everything in space in the
consistent like definition of what lay
out in spaces and then just draw the
nice things with the correct tool so we
also have a few examples of putting it
all together so these are some like of
our mixed mode demos that show you know
what you can do with this and again
these are demos but you know everybody
you know you guys probably have the jas
comp which I open on a tab in your
browser right now well i have a macbook
with a macbook with the ge'ez conf
website in here and this is completely
navigatable and i can look through this
and this is all Dom I can check the
schedule and I can even navigate
backwards to it and it's really cool and
that's the nice thing is that like I
wouldn't want to do that web page again
in WebGL I wanted to use that web page
for what it is but I can do cool things
like I can put it with this macbook obj
I can put a plane on top of it that has
some nice sheer on it so it looks like
there's like lighting glossing off of
the screen and being able to take the
best about what these both of what take
the best of what both these technologies
has to offer is a really really useful
thing here's an example that we've had
for a while now long second
cool so if you look at all of these
things they're completely done i can
highlight them i can select them i can
copy paste everything that's really nice
but i can do really cool sparkle effects
with them and do stuff i couldn't do
with just you know just the dom yeah
this could probably be images for now
but you could imagine these were like
more glowing and particle effects and
stuff with you now and you don't again
the user doesn't have to think about how
to marry these two they just had already
existed the exact same coordinate space
and then the last example of like this
is something that is completely da Mon
Lee but just kind of shows the idea more
so more along like the original point I
was making is that there's a lot of
content out there that is just not a
document and to think about something as
a document is like a really inherently
wrong way to think about the problem
space so if I have an image carousel of
things and I want to like throw things
like that nothing about this is document
the way I thought about this when I was
building it is okay i have a little
window right and what i need to be able
to see are the arrows the dots in the
middle content everything else i want to
just put over here and what i ended up
using is some physics simulation where I
move some Springs and things from
outside of the screen come in so if I
take a look and I tilt this thing back a
little bit you can see you like this is
actually kind of what the application is
and you get out and better sense from
working like this in my opinion of like
kind of what you're building and why
it's easier in that you can think of
applications is just like a small little
window into your scene you can hide
stuff you bind your head and you can do
really cool stuff like that but you have
the like really easy ability to kind of
almost work with something that's more
tangible than just a document and like
the magic rules that CSS lay I have to
give to you cool so
so what are the current limitations of
what we have so unfortunately right now
we only support rectangular dom and that
is not that bad of a thing because it's
a completely fixable solution so what we
have right now is that the cutout we
make is a complete rectangle that is
based around the size that you have
defined through the thing what we're not
listening for is let's say you have a
Dom element and the Dom element is there
and it's border radius you know 25 25 25
what we can do is we can apply custom
shaders to that cut out mesh to mimic
the CSS property so that that gets
shaped properly also we currently only
work with opaque tom so if you think
about it one of the issues is that we're
doing a full cut out for WebGL so if my
div is half like translucent I'm
actually going to miss anything that was
rendered back behind it that the cutout
was occluding so what we need to do is
have a second layer of WebGL that does
all like the color math for us we're so
that we can that so that we can pretty
much fake the idea that there's like
another layer there so one thing that
was really good about this project was
we got a chance to be architected a lot
of our system and make a lot of
improvements and as such we had a lot of
happy side effects one thing that's
really nice is because the entire system
is completely based around these draw
commands that go like from your from
your components on your nodes to the
renders this is this code can be
completely run in like in not the UI
thread so we can take all of your
application code where you create your
scenes you create your nodes and do all
this stuff and I can throw it into a web
worker and we have a build working where
you know you have all your web worker
code and then it sends it all the draw
commands to the UI thread and that keeps
your UI thread just a very very thin
client that doesn't have to do a lot
right now the performance benefits of
web web workers is kind of minimal I
think there's probably a use case out
there where people could make use of it
but the technology is only going to get
better and it's an abstraction we really
wanted to keep for a few other reasons
another reason this kind of stuff is
good is I we also have ways where I
could
on my entire application as a node
server and I could pipe through socket
messages to my thin client just what the
draw commands were so now that's really
really interesting imagine your ESPN and
I have like a scoreboard somewhere right
I don't need to have all of the
client-side logic for how that
scoreboard works what i can do is i
could just have the renderer over there
and the render is getting all the draw
commands and all of the like complicated
logic about what needs to be there
happens and you know once every hour
it'll be you know Cincinnati Reds for
and that's the only like difference that
needs to happen as a result of like
these changes so something else yeah so
some of the next steps that we're
considering taking with the project are
rendered to non web technologies so
again some one of the benefits of this
whole thing is that it's completely
based around Rock'em and so what if the
compositor wasn't compositing for da man
would do what if you used components
that output to opengl command and the
render was an opengl render so you could
have this completely JavaScript pipeline
write your application in JavaScript and
it's generating commands for like a
native open heel application also you
know possibly port to azum you know fast
math is fast no garbage is good garbage
and it also opens a way for non-web
people to build into the like get their
feet wet into the web so if you can
write haskell if you could write Python
if you can write c you can write all
your code compile it down like through
compiler to llvm bytecode and then we
can eat that lov m bytecode and just
shove it in and get stuff rendered on
the screen so there's some of the things
that we're kind of working towards so in
summary I think the big thing is you got
to think outside the document there's a
lot of cases where the document is like
the right thing to do your content
really is like newspaper style content
but it's not for everything you know 2d
layout is a subset of 3d so let's define
the world in three dimensions if I need
to do 2d it's about you know moving
something here and then just working in
two dimensions like you can make that
adjustment very very quick by like
shrinking the amount of Z you use and
then I think something else that's
really really nice is the idea of
abstracting away the rendering meet
the what the transform in the scene
graph give you is it gives you the
ability to think about like points in
space that are completely agnostic as to
like where what what I'm rendering to
these are just mathematical concepts
that are pervasive and will always exist
and if you just think of if you think of
applications and application
architecture like that and UI
development like that it's really easy
to switch in like what the drawing bits
of that are and again thin clients give
the flexibility to the web if you're not
having like full client side code and
you're just having a render on your
front and you can do a lot of cool
things you could do server-side
rendering you could do web workers you
can do a lot that you know that
currently isn't possible with a lot of
things where you're just you know
manually touching the DOM and your
entire like workflow is you grabbing Dom
elements and manipulating them yourself
so thank you guys for hear me talk feel
free to email me at might get famous and
I don't really have a website but if you
want my little demo check that out also</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>