<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CSSconf EU 2015 | Glen Maddern: Interoperable CSS | Coder Coacher - Coaching Coders</title><meta content="CSSconf EU 2015 | Glen Maddern: Interoperable CSS - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CSSconf EU 2015 | Glen Maddern: Interoperable CSS</b></h2><h5 class="post__date">2015-10-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aIyhhHTmsXE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right hi everybody my name is Glen
and I'm from Australia as basically half
the people speaking today I think but
I'm from Melbourne like Michael which is
if you don't know it's like the most
Berlin City of all of the places that
aren't Berlin and it's fun you should
come next year I'm gonna be talking
about interoperable CSS which is a
project I've been involved with for a
little while but I'm gonna start with a
bit of history a bit of background
because if you know your stoic
philosophy or have seen an episode of
Battlestar Galactica you will know that
everything has happened before
and everything will happen again for our
purposes everything happened in
September 2008 which was a dark time 75%
of the world was using ie 7 we were
about here in the global financial
crisis and we all know how that went but
we're about here in Justin Bieber's
career so I think on balance we're all
happier I think thanks
but specifically I wanna talk about
JavaScript in 2008 because JavaScript in
2008 looked like this it got the job
done it's certain you know you can still
write JavaScript like this many people
do but what I want you to look at it
critically and think about what it
implies about JavaScript at that time I
mean here we have window dot name space
implying that ahead of this other stuff
will have run and it will have started
throwing stuff on namespace sorry on
window and we don't necessarily know
what's run in front of us we don't know
what's running after it so we have to be
very careful not to delete anyone else's
stuff but to put our stuff somewhere
someone can find it later the every
piece of code that you write every piece
of code every all of your dependencies
all execute in this global soup and you
just have to try and carve yourself off
a little bit of room to work also in
September 2008 Google released a comic
book announcing that they had built a
browser the comic book was basically to
explain to the 75% of people using IE
that browsers were a thing and you could
choose another one so why didn't you
choose Chrome with that they brought v8
and v8 was a new engine it was much
faster than any of the JavaScript
engines around at the time and it sort
of sped up a catalysed a movement that
was already starting around this idea of
running JavaScript on the server
Kevin dangle back in January 2009 said
that for server-side JavaScript to
really catch on it needed some way to
include other modules and for those
modules every module to live in as
discrete namespace now there are easy
ways to do name spacing as I showed you
with the window dot namespace technique
but there's no standard programmatic way
to load a module once he then went on to
write in a wiki post saying that all of
the attempts so far all of the
server-side JavaScript frameworks were
very fragmented if a script had to do
something like access a file you
couldn't use any engine to do that
SpiderMonkey javascriptcore they
couldn't load
modules in in the same way so anything
people were writing was very tied to the
interpreter and they were often forced
to create a bunch of api's that other
programmers took for granted and to me
that sounds a bit like what happens with
CSS now something that's written for
sass is not necessarily compatible with
less something that's written for CSS
next doesn't work with either of the
others and each of those add things like
variables and loops that every other
program it takes for granted they're
trying to put in to this language
programming api's that should just be
there chris cole who was also
influential at the time wrote a blog
post and said the year has begun with a
combination of wonderous events i've
been struggling to promote the idea of a
module system in javascript for several
years and there had been a sudden
explosion of progress and i feel that
way about CSS I think we can all sort of
sense it that there's something changing
about CSS at the moment we're not sure
if we're gonna be still be doing it the
same way in a couple of years of course
Ryan doll at this point no js' started
as a project building on top of v8 and
that collective energy gave us commonjs
the first time it was called jump
commodious is july 2009 now node and
colleges have kind of a complicated
history where there were a bunch of
different attempts at doing a module
system in JavaScript come and jeff's
wanted to do more on node kind of
settled on a simple one and basically
node one whatever node did was the
standard and sub stack calls it command
J esque which is just like a reduced
version of comedy s and it's kind of
what we all call comedy yesterday but I
want you to think about the difference
before and after this change because now
instead of just assuming that our code
ran before our code that our dependency
ran before our dependency we can be
explicit about it instead of just
putting our code somewhere for other
people to find it we export it but
something in particular is that the
words namespace widgets and food bar
disappeared from this file they're in
the file system we were able to move
that in
Meishan move that repetition into the
file system and that'll kind of be
important later I guess it's fair to say
node was a success MPM came along a
little bit later things kind of went
bananas and I won't be thinking like I'm
sure that's great like I'm sure this is
all true about JavaScript but what does
it have to do with CSS I mean CSS is not
JavaScript styling code is not
server-side code but again think
critically about what changed think
about the extension to the language I
mean this line was valid before it just
didn't do anything it's valid now and it
has an entire module ecosystem built
around it and all that changed was that
there was convention added to this file
that the language didn't change it was
so powerful that it took this language
that had a single global context and
gave it multiple files which you
couldn't do before and I had no
mecha-suit mechanism for sharing code
except by throwing things on a global
object and now it has 175 thousand
packages on NPM and what makes that
really relevant to us is then in 2011
browserify came along and said you can
use that mental model you can use that
filesystem based approach in the browser
even though the browser doesn't support
it I will take that directory of files
and I'll compile it and here your your
project will run in the browser as if it
was running on a local filesystem
browserify proved that you could change
the human interface of the language of
JavaScript without needing to change the
machine interface we didn't have to wait
for a new version of JavaScript of
modules in it I mean if we had we would
still be waiting and if it dropped today
we would have to wait for browsers to
support it but browser if I said we can
separate we don't have to stay in step
with what what the browsers are capable
of so of course the question is is that
possible well in fact I'll let this guy
ask it
thank you weird alien conspiracy dude
that's what interruptible CSS is trying
to be all right and here's what it looks
like it is very small it is a very small
addition to the CSS syntax there is an
import and export directive the import
references another file and says hey
some information from that file I would
like to bring it in here and I'll call
it this but also can export things
saying hey if I get included here's
information out there's a local alias
exported token but the rest of the file
is completely global there's no other
changes to CSS but it's quite different
to something like writing modules in
JavaScript because it's compiled target
it's not something that we write by hand
it's not good enough to be a human
interface but recently a lot of our
projects have involved a tools a bundler
or a loader called web pack JVM or
browserify to be able to build up a
collection for the browser of a whole
lot of files in the file system and you
can load CSS in that manner and I CSS is
designed to be consumed by one of these
so each file of I CSS has then compiled
separately emits both CSS and JavaScript
and the CSS can get concatenated and
inserted into the browser and we built
it because we're trying to build a thing
called CSS modules which I'll be talking
about for the rest of today so it brings
me apart to Christopher Zito who works
for Facebook about a year ago presented
these seven problems as being like the
key core problems with CSS and it was it
was great because nobody had really I
don't think put the list together and
had the the scale of developers and the
scale of users on a product to really
back it up of course he went on to say
that if you write your Styles in
JavaScript a large class of those in
fact those seven just disappear
instantly and I guess it's sort of fair
to say that the CSS community wasn't
that enthusiastic with it at the time
straightaway wouldn't necessarily think
that it was the best
idea and I was certainly in that camp
but thankfully a lot of people weren't
and there's a whole host of now projects
about doing styling in JavaScript a
Facebook has sort of native support for
inline styles and the virtual Dom the 3x
file JJ sextile jss but I think radium
is probably the most promising at the
moment and they're worth checking out
they're doing something really
interesting in a way that basically no
one else has done before and they may be
onto something
but I wasn't particularly convinced by
them and in fact I wrote this in a blog
post recently and that sort of
crystallized how we'd all been thinking
about it was that it was more important
to keep knowledge about CSS keep some
good parts of CSS within your product
and your team but to solve the real
problems which were being comfortable
about making changes and being fast and
making changes on a large code base and
I said comfortable before fast because I
think it's a lot more important to be
comfortable making changes particularly
in CSS than it is to go any faster than
we can at the moment and this brings me
with the first principle of CSS modules
the thing that drives out basically half
of it is that good design should good to
lead you to good practice so if we're
looking at a new version of CSS that has
multiple files and passed symbols around
what can we do with it what will it do
what would make CSS easier for humans
and I've been thinking about this a lot
and I think it comes down to this every
time we've tried to improve CSS every
time we've tried to put a convention on
CSS we've been guiding ourselves to one
of these two things either focusing on
isolation or focusing on reuse so
isolation is when you start with your
component and then you write all the
Styles down like Ben all right you
everything is nice and separated so you
can add a component really easily and
you can delete a component really easily
because there's only one place that the
styles are defined then of course you
need to add the ability for those
components to share styles which can
lead to large payloads but
generally bam successes I think proven
that this is a good approach for a lot
of teams the other side is reused first
and this is a little bit more like what
CSS is actually good at by default which
is you start from the styles and you
build up components so a component will
have styles from many parts of your of
your codebase so CSS and tachyons like
this and it really captures the visual
information in your site with a small
file size and good performance but I
believe it's not as successful at the
moment because it is difficult for teams
particularly if people have different
abilities if you've got only one person
who can touch the CSS on your team I
think this is a symptom of what I call
change paralysis where you're just not
confident that the codebase is not in a
state where anybody can just add
something and you and you think you'll
be okay so CSS modules is trying to
unify those two approaches trying to
give you real isolation and responsible
reuse so let's talk about isolation
if you want to target a single element
on your page you can do this you can
nest a lot
if you've used CSS for probably about
four or five minutes you'll know that
that's really bad right because as soon
as your Dom changes your HTML changes
that doesn't apply or suddenly it might
apply something you weren't trying to
style the alternative of course on the
other extreme is you invent a name that
has never been seen before to target
that exact one thing and actually it's
better it's ridiculous but it's better
and so we put some you know we put some
sanity on it we say we invent them
basically we say okay every class has to
be unique but here's a nice convention
so you can think of a class name really
quickly you know exactly what it's going
to be it implies its context and yeah
there's a convention that your whole
team can learn and apply but it looks an
awful lot like JavaScript in 2008
there's so much repetition there there's
so much information that's just about
the fact that the file is global not
about what's happening and it occurred
to me that if you're running a class for
every element in your file then your
class is not a global descriptor your
class is a local variable imagine if in
your JavaScript code you couldn't use a
variable that you'd used anywhere else
in that code or any of your dependencies
had used I don't think we would still be
doing JavaScript if that was the case
and so CSS modules tries to fix that
problem for CSS let's say I'm trying to
build this beautiful button I stole the
design for this button from someone who
can design it's seven lines of CSS and
the only change that you have to make to
make this a CSS module is that just drop
the noise out of the class name just
call it normal it's just the normal
button you've already got components
like submit button dot CSS write
something else should be able to tell
the Machine what this is but for you
just call it normal
what happens in CSS modules as it
compiles to this I CSS it extracts a net
export statement and it rewrites the
selector and this is a really low-level
approach that could be used for a whole
lot of things to change the way CSS
works so here the selector becomes
normal and then a unique hash and the
export statement says what you think
normal is actually this and then you can
import it into your JavaScript and you
get the mapping from normal to the hash
once you do that you can use any method
of getting that into the mark-up I mean
the only requirement is you have a way
to load CSS from your JavaScript and you
have some control over the mark-up if
you're using angular it's really easy
you can even use the bind 1 syntax so it
has no runtime performance if you're
just using document right then you can
just do that to just build up a string
right but for my the rest of my examples
I'll be showing react because react is
already very component driven react is
already really well supported by things
like web pack and browser 5 J's p.m. and
so it makes sense it's a really easy
conversion to go from react and other
cells other kinds of CSS to react in CSS
modules and so this is what it looks
like to do a button now the class name
there is generating your JSX file is
loading it injecting it into the DOM and
that HTML is coming out but it doesn't
really matter what that class name is in
fact in development I recommend doing
something like this where you have a
longer class name which points you
towards where that file was in fact you
can actually put the line number of the
definition in the class declaration and
it all still work
note that even though I'm changing this
my component never changes no matter
what the output is the component has
complete isolation to the reality of the
CSS if you want to minify you can just
use the unique component or as I like to
do use an emoji in fact just
this morning I converted my entire
website to use nothing but emoji I mean
and you can't tell me that what is that
they select a chicken firework up
firework down Chinese lantern love heart
that's a beautifully meaningful selector
that you know packs the bytes
beautifully let's say I'm mochi
minifiers a really big feature but
there's another reason that class you
know that classes are hard there's
another reason why when you're trying to
write styles sometimes you have to over
write things and things get messy and
it's put a lot of it at the feet of
nesting if you want to name this header
one inside this edit v2 final object it
can be very easy to just nest but that
is a wide-ranging selector and if you
include another component in there that
has a h1 suddenly you have to override
those Styles because of where it's
included and lower there if you can't
think of a good name then you're leaving
this terribly named thing in your global
code base and somebody is going to be
very mad eat when they find it this uses
modules because the file is local the
pressure is off if it's a header call it
header if it's a h1 if that's how you
think about it caught h1 second thing is
fine right the weird bit at the end if
that is the thing that you're calling it
in your team just call it that it's a
local variable at least when you see
that word you will see the context from
which it comes right you'll see the
component what it is and then that will
trigger all the wee bit at the end of
that component that makes sense and so I
think if you make naming things
effortless if you never have to worry
about another global name you can target
everything directly and if you can
target everything directly you stop
leaking styles and if you stop leaking
styles
I think isolation is solved so let's
talk about reuse again I stole this
button from some of the consign let's
say you have two variations of a button
now in BIM you have the common stuff
then you have the normal stuff they
neither have the arrow stuff works fine
you then include both of those class
on your button it's fine it's better
than anything came before it I'll I like
it a lot but there's I have a problem
with it which is that when you're
looking at your markup you have to think
about how many different classes this
thing is is is being built from you
don't have any separation from your
markup and the styling they are
intrinsically connected and I think this
is the other principle of CSS modules
design is that good abstractions are
there to save you cognitive load when
you're thinking about one thing you
shouldn't be exposed to the details of
another and this brings me to part 2 CSS
modules which is called composition so
we will look at our BAM example we see
our three classes button normal an error
in CSS modules you have something called
base could be called anything and then
normal and error use a keyword called
composes or compose with what that does
is when CSS modules compiles that to I
CSS now the three classes base
normal and error they still just get
compiled and their classes and their in
their styles are still presented but the
composed statements disappear they go up
into the export statement and so now
when you talk about normal you're
actually talking about two classes when
you talk about error you're also talking
about two classes base is just one so
that export statement when being
imported now notice that this class this
component declaration hasn't changed
we're still just using one thing it
generates markup with two classes and
breaking this that I mean it seems
subtle but like breaking having to worry
about how many classes are being applied
to this element at that time makes a
huge difference to how much context
switching you're actually having to do
when you're thinking about your
component when you're thinking about
your Styles this gets kind of better
with multi file composition because each
file in I CSS and CSS modules is
completely isolated you can't reference
anything from any other file unless you
use a couple of methods one of which is
composed
this is saying that yes normal composure
space brings all those stars in as well
but it also pulls in two classes from
colors but CSS and this compiles out to
the colors file goes to the top again
this is being compiled and then
concatenated because just CSS after the
whole process goes and the button gets
rendered with all four classes you have
the blue class you have a light blue
background Class C of the base class and
the normal and the normal class actually
ends up having nothing you know that
you've said that this normal thing it's
not a class anymore it's an element in
your in your application and you've been
able to say that every part of it styles
comes from somewhere else you've just
built a piece of like a novel piece of
UI and not introduced a single line of
CSS I mean assuming you just stripped
this out with an optimizer later now I
think that's really powerful the more
times you add UI without adding CSS is
good really good and this kind of goes
on and on and on once you start to think
about well what would you want to
compose what do you want to bring
together how do you want to separate all
of the styles in your application you
start to do things like this you start
to say well my layout has things like
the Flex vertical centered a margin one
bottom padding one left padding one
right because it'll lets you express
these two objects an article in a
masthead saying the article is a
basically a vertically centered flexbox
the masthead is a forty eight to forty
eight point centered bold serif and the
layer and and needs some padding on the
sides of margin on the bottom now this
generates markup that's reasonably
complicated lots of classes but you
don't see that you see this you just see
the article and the masthead and you can
go in and change all the different
properties of that thing and it will
change which classes get compiled but
you never worry about that you worry
about one thing at a time not both what
this is effectively doing is defining an
API into your Styles the CSS module
becomes the point at which all of your
visual information is collected and
passed to your component and that it's
that layer in the middle
that I believe allows you to solve both
isolation and reuse how am I going for
time actually a bit ahead all right I'll
take a bit long with my conclusion then
um a lot of people when they start to
find out about CSS modules because I
think we we do a big blog post about a
month ago and people have been reading
it and asking questions one of the
bigger questions is how does it relate
to preprocessors and I mean when they
say pre processes they mean SAS because
66 percent right that is a bananas
number of people to use one tool in our
ecosystem and the truth is like we loves
us
I love SAS there's a lot of love for SAS
in the room because I wouldn't have ever
got through the first couple of months
of doing CSS had I not had SAS I
couldn't make sense of it without SAS if
you're trying to marry isolation and
reuse then using BEM for isolation which
is what it's really good at and SAS for
reuse is fantastic I mean the composer's
keyword works basically the same as the
extends keyword in SAS it just compiles
quite differently it has different
performance and other things
implications but conceptually it's the
same right and that was great but I do
believe that given the way I CSS opens
up a new way of doing multi file CSS CSS
modules can eventually replace the need
for SAS now I used kind of inflammatory
emoji because there's no emoji for just
like genuine respect and admiration for
the generation that's gone before so I
went with us wearing sunglasses and them
on fire but like I do actually quite
like SAS so what we're what we're trying
to do is take all of the good things
from SAS and every other technique look
at what's possible now that a CSS file
is actually legitimately local and then
see what we want see what's good see
what patterns emerge what auntie ballads
we want to get rid of at the moment with
out of three things into the mix and CSS
module I told you about two the third is
a bit smaller so I don't have time but
that's the game now we're starting from
a new generation of a baseline and we're
look
to see what works and so you might look
at this and not like it that's fine you
might look at it and love other you know
other techniques you might think we're
missing stuff but I hope that we all
agree that that these are our goals
these are our goals and if you if you
come to us with arguments about how we
could introduce things in a CSS modules
that lead to good practice then that's
where we'll go the other thing is how we
can increase will make better
abstractions that save cognitive load as
you're developing then that's the point
of this project I feel like we've made a
new capability with things like web pack
JSP and browser fly to make multi file
CSS and CSS modules is al our best shot
a best guess he didn't just me
by all means there's a whole lot of
people have contributed discussion code
ideas I want to make special mention of
mark and Tobias who did the original
work on the local by default stuff which
really opened this up really unlock to
me Tobias a maintainer of web pack which
makes a big deal is a big part of this
project my slides are up there full of
emoji you can read about it you can look
at the specifications I definitely
welcome feedback I would love to hear
about use case your use case and whether
it works with our stuff yeah thanks a
lot
happening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>