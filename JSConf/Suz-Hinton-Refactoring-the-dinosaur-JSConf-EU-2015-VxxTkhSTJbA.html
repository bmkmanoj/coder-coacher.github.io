<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Suz Hinton: Refactoring the dinosaur | JSConf EU 2015 | Coder Coacher - Coaching Coders</title><meta content="Suz Hinton: Refactoring the dinosaur | JSConf EU 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Suz Hinton: Refactoring the dinosaur | JSConf EU 2015</b></h2><h5 class="post__date">2015-10-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VxxTkhSTJbA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Hi everybody, that is an awesome piece of
trivia.
I also ran into my friend Justin here, who
I
ran the first workshop with 6 years ago, and
I haven't
seen him for almost that amount of time, so
awesome to
see you.
Thank you for attending my talk, it is called
refactoring the dinosaur.
I'm truly honoured to speak
at JSconf, so thank you to the organisers.
As Ben said,
I actually work at Kickstarter as a developer
in New
York City, and we're a pretty eclectic bunch
of people.
We tend to always have side projects going
on, and I'm
always continually inspired by my colleagues.
This is
the library at Kickstarter.
It is actually known as the
quiet space where you can work.
However, after hours it
comes alive.
We have 4D and D groups internally that
play here, and which is awesome, and there's
actually
a hardware hacking club also that meets here
every
second Thursday, and that has a grand total
of three
people in it, including myself.
But one other person of
this hardware hacking club is Zak Donham,
and you
probably can't quite tell what he's doing
here, but
there's actually shrimp in the water and he's
recording
the sounds the shrimp are making, which is
amazing.
He
is a wonderful person, an artist.
He does a lot of
technology outreach for Kickstarter, and he
is
fantastic.
Recently he created this this Kickstarter
project so people at Kickstarter actually
run their own
Kickstarters, believe it or not, and it is
called the
public radio, and it is this idea of radio
monogamy and
so if you have one station you really love,
this radio
is hard tuned to that radio station, so there's
a volume
button and also a switch to turn it on.
And I'm not
sure whether you can see that I need the video
to come
up for me for this, but I actually have the
radio here,
and that's going to form the basis for the
case study
I'll be talking about today.
And so Zak and his
co-partner Spencer write actually put together
this
radio from scratch and designed the board
and
everything, and one of the review tiers for
their
Kickstarter project was to send it as a kit,
so someone
can actually receive all the parts, including
I think
the mason jar, and they can actually solder
it together
themselves, and then they are also responsible
for
flashing the software on to the chip on the
board, and,
you know, a flashing that radio station property
as
well.
So that they can get the radio station they
want.
So if you haven't run a Kickstarter project
before,
it is actually really a huge undertaking,
and so you
know they had a lot of ledger six to take
care of, and
at the time they'd written a CLI app in order
to flash
the chip, however they wanted something a
little bit
more user-friendly just in case there were
people that
weren't used to the terminal.
So I volunteered to write
a hardware out for them, just because I've
done that
kind of thing before, and at the time they
had these
Python files they were using for the CLA,
and so I ended
up just using those files and I used a Python
GUI kit,
and this is the app I put together.
And I wasn't super
proud of it, it worked really well.
You know, you put
your radio station in, you'd pick the programmer
you're
using, which I have one here, as you can see
it is the
blue guy right here.
And, you know, you have to
obviously change your band emphasis and channel
spacing
for what country you live in for the radio.
And it
worked really well, I worked on the support
forums to
make sure no one was having an awful time
with it.
However, it had some problems, some accessibility
problems, because you couldn't keyboard tab
between the
fields, and the screen readers couldn't actually
read
what was going on, so it was kind of hard
to use.
It is
not super good looking.
If I hadn't put that picture on
there with rounded corners, it probably would
have
looked like some kind of virus about to install
itself
on your computer (Laughter).
And the aero management
was really different because the open source
software
I was using to run the flashing process, it
has status
codes but doesn't actually have anything in-depth.
You
have to regx against the standard error output,
just to
figure out what was going on.
So a lot of the time, if
there was any error, I dumped the log in the
app and it
looked even more scary at that point.
So I'm a modern lady, you know.
I have modern
tastes in software.
And so I thought we can do better
for hardware apps.
This is the way we've written
hardware apps for a long time now, we can
do way better
than this.
For both our end users, but also for
developers, like developers should have a
much nicer
time writing these kind of applications, you
know, they
can be really frustrating to write.
And so I actually
rewrote the entire app in JavaScript, and
this is
actually what it looks like.
So I'm going to do a quick
demo, if the demo gods are nice.
I'm just going to
bring up the app, and it is very small on
this
resolution, so I'm going to zoom in.
All right.
This
magnificent line.
All right, this is the new app.
First off, I can actually keyboard tab into
it, which is
great.
I can hide away these event settings if you
don't need them, and it just looks less like
a computer
virus, in my opinion.
So I'm going to turn the radio on
and hopefully you can hear that.
music plays]
I'm going to change the radio station.
Losing my
Religion -- that's great.
I don't need to change any of
these right now, because it will work well
enough for
me to flash it.
So while we had no sort of progress, I
also implemented a progress meter, and I'm
actually
going to turn this light out so you can see
the
programmer here actually programming it.
And here we
go.
Please work.
music plays]
New radio station.
[applause].
So I am just going
to turn this off.
I feel like this is a much better
experience, and I actually had a lot more
fun writing
it, but there's a lot of complications because
this is
not really your standard way of writing hardware
apps in
JavaScript, so I wanted to take you through
some of the
challenges and how I put this together.
So let's go
back.
All right.
So I actually wrote the GUI in NWJS,
so some of you might be wondering why didn't
you use
electron?
This is the new one, but you have to build
native modules for use with hardware.
A lot of the time
it is the USB interface, so it is easier to
rebuild
those to work with NWJS so that was the main
reason
I went with that, and I also created a brand
new from
scratch library that will actually drive the
flashing
process itself.
And I'll explain why, as we go through,
but this is the API I wanted to be able to
use in the
first place, and it is not the API I actually
had access
to at the time.
I have to go through very briefly what
is actually on this, what is in this radio,
how does it
actually work?
So the main brains of this circuit is
the ATtiny 45.
This is a microchip put out by Atmel.
It is super powerful.
It has four kilobytes of
programme memory.
That's amazing.
Why would you need
more space?
It also has 266 bytes of EPROM.
It stands
for electronically erasable programmable read
only
memory.
Essentially what that means is you can flash
a constant to that memory, or a couple of
constants, and
you can save on your four kilobytes if you
need to store
like values that are never going to change,
right?
So
that's actually where the radio station of
choice is
flashed to, so that, you know, you don't have
to keep
flashing the software over each time.
And it is
actually just a euro.
You can buy this for a euro and
I don't even think that's the bulk price.
You can
probably get it for less.
That's the brains behind
this.
The way they get this code, or the radio station
to actually go on to the device, is we need
a translator
in between.
So this here is a programmer which is like
the middle of the diagram, and I find it really
ugly so
I put a rainbow on it to make it prettier.
This is
a drawing I did to try to just make this stuff
seem more
interesting than it is.
And so this programmer actually
sort of takes the code that's compiled on
your computer,
which is usually C, and it is able to speak
to the chip,
and so the programmer is providing you with
a USB
interface.
And then the programmer can take that and
it
uses the SPI protocol which is the serial
programming
interface protocol in order to talk to the
chip.
So it
is doing the actual signal, sort of bit flipping
in
order to get that on to the chip.
So this is sort of
how you normally have to create your application.
You
have a GUI, it can be in any language you
want, like
Python, or even just actual regular CR objective
C,
JavaScript in this case.
It takes user input and then
obviously compiles down and then it calls
the upload
process.
That is always a child process, and that is
also that has always bothered me, and I'll
explain why
it is a child process.
It actually writes to the chip
and that's really all there is to it.
Now the application that you normally use
to upload
this, it was written 16 years ago, it is called
AVRDUDE.
And it is really cool.
It is a C executable, available
for all platforms, less than 500 kilobytes,
which is
cool, and this is what everybody has been
using since it
came out.
There's not really any alternatives at this
point other than Atmel's IDE.
So AVRDUDE stands for AVR
downloader uploader, so it is very interesting,
and an
AVR is an acronym used for the microchips
that Atmel
puts out.
They've confirmed that AVR has absolutely
no
meaning whatsoever, so I can't tell you what
that stands
for.
Look on Wiki.
It was written in C, it is open
source, which is amazing.
And everybody uses it
because, you know, it works really well.
It has been
around for a long time.
It has a lot of traction
because of that, and people have added extra
programme
and chips over time, and it has the greatest
compatibility and it is the only thing out
there that
has that strength that you don't -- you can
create
dynamic apps like this with, right, without
having to
open an I; and so even the Arduino ID and
the systems
use that over the surface.
So if you go on to your
preferences and see the logging, you can see
the AVRDUDE
command running.
It has have some limitations, however,
it is command line only, which is why I have
to spin up
a child process every time if I'm doing runtime
code,
and that can be a pain, and it also means
sometimes you
have to handle like multi-processors or threading,
because it will lock-up the EY while you're
running
that.
There are no tests in it at all, so it relies
on
manual testing if anyone requests it, and
it has this
fragmented community, if people are updating
it mostly
because it doesn't change a lot in spite of
a decade,
but it doesn't the same community feel as
JavaScript,
and that's something that disappointed me.
People can
be rude in the forums if you're a newbie,
and it has
been pretty disappointing for me.
Creating an
alternative for this piece of software itself
was
obvious to me, and so this project here with
the radio
led me down the track of just completely rewriting
this
thing.
And so why?
You know, well, we have a small
family of packages kind of mentality which
I really
like, like why do we have this monolith?
People should
be able to install the chip support and the
programming
support they want.
It has, you know, it is easier to
test that way, because they're small chunks.
It has
better flexibility for use.
So instead of just having
it on the command line, you should be able
to require it
with a common JS pattern and then use it that
way, which
is the main pinpoint for me.
It is also more
accessible.
People that are coming in now to learn
programming are not necessarily learning C
any more but
JavaScript, and this opens this world up to
more people
and provides an alternative.
I'm not looking to replace
the AVRDUDE; I just want to provide a different
alternative and have a go at seeing what modern
principles bring to it.
I also want to publish others.
I don't want to just write a keys of code
for that
programmer and that chip, want to be able
to have this
as a tool that everyone can use.
So I wrote a tool
called AVRGIRL.
[applause].
It stands for AVR general
iSP programming tool.
[applause].
I wanted to keep the
tradition going.
I respect, like AVRDUDE is an amazing
tool.
I'm not here to say it is bad in any way.
I want
to pay homage to it.
And so you go on your little
journey of programming these things and think:
this is
awesome.
Why has no one does this before?
People have
maybe rewritten pots of AVRDUDE for their
own use, but
not the whole library, like how bad could
this be?
And
while we're on the topic of dinosaurs, I found
a lot of
mammoth shave while doing this, and one popped
up
immediately, and I felt that's okay, I can
do it.
And
before I knew it they were everywhere.
And I'm
thinking: this is why people haven't tried
to do this
before.
So whenever you try and look up how to solve
this, this is usually what you run into, okay,
or you
just run into people who have used the software
but
don't know how it works.
So this posed quite
a challenge, so I want to really quickly go
over
a couple of challenges I had with this, just
so that
people can understand the hardware world a
little more.
I'm a little lonely in this world; I want
to share my
pain.
Challenge number 1: support USB programmers
this
the AVRISP v2, and it runs via USB and there
are a lot
that run via parallel ports and all sorts
of stuff, but
I want to support more modern stuff to begin
with, and
see if there's demand beyond there.
Here is an example
of four different programmers.
We have the AVRISF mark
two, the spark fund tiny programmer and the
spark fun
pocket programmer, and then we have the USB
tiny
programmer.
And so these are great, and the reason why
there's a lot of them is they all have different
advantages.
The problem is they all speak different
languages.
So in the web world we have HTTP and HTTS,
it's no different in hardware, we have a lot
of
protocols, we need to support, and so far
in writing
AVRGIRL we've come across these protocols
in particular.
I don't have time to go into them in detail
now, but
I have blogged about a couple.
So we have STK500
version one, which is by Atmel.
Then they came out with
version two, which is quite different.
We have
AVR109USP tiny AR.
There was actually a node module for each
of these
in npm, which is awesome, and that was Ryan
Day and
Jacob Rosenthal, and a lot of these modules
were written
specifically for use case and weren't really
super
generic.
So I had to pull request some of them and
some
of them I've had to rewrite from scratch,
because it
would basically be rewriting the whole thing.
And so
I learned a lot about how hardware talks to
devices, and
then how computers talk to programmers.
It was actually
really cool.
And so I got all of this information from
data sheets, and, you know, this is kind of
how it feels
when you first read a data sheet.
You're like: what is
this?
So this is an example of a data sheet for
a previous library I wrote to drive OLED screens.
And
after a while, the thing starts swimming into
a place
where they make sense.
But a lot of the time that's all
you have because Google is not going to give
you a lot
of information.
But we got there in the end.
I have
some protocols that are now supported.
All of the
Arduinos can be flashed with this software
and this
programmer here also has support right now.
So
challenge number 2, O/I have to somehow support
all of
these Atmel chips, so how many can there really
be?
Well there's 400 of them.
[Laughter].
Luckily not all
of them are actually relevant, some are architecture
and
that sort of thing.
I'm supporting risk architecture
which is what the Atmel AVR chips are, so
that whittled
it down to 135.
That's fine, that's great.
So this
configuration sits in not a format that I'm
used to.
I wanted it to look like this, and this is
not the
entire object of configurations I created
in the end, I
had to create my own spec for this.
There's about 50
properties, so here's a snapshot of the properties
you
need to know, such as the name of it, the
timeout, if it
doesn't connect within 200 milliseconds, then
it is
a timeout.
Things like that.
Really kind of in-depth
stuff.
But what I had to work with was 200 megabytes
of
XML files to pull out those configurations,
so that was
particularly time consuming, but I thought
this has to
be done, and I don't want this stuck in XML
forever.
So
writing XML translations is really -- I wouldn't
recommend it.
There are a lot of late nights, a lot of
crying, shouting at my significant other when
I was in
the middle of a bug, and he asked me what
I wanted for
dinner.
Sorry.
Sorry.
But luckily I have this awesome
module.
Well, I don't have it, but I used it.
It is
called XML to JS.
I highly recommend using it.
It is
awesome.
It passes the whole thing, you set up how
flat
you want it, and it was amazing.
So I had to deal with
pulling out the random bits of the configuration
I wanted, but actually worked out really well,
and so
I now have 135 chips converted with my spec,
only five
of them have been tested, so I need more people
to test
it.
I have no idea whether it is actually working,
and
I don't think I'll actually ever open source
the
translation file I wrote, because no one is
ever going
to want to use it, and I'm scared that my
job prospects
will go down the plughole after that.
But, you know, it
got done.
I'm actually really excited I can work with
JSXML.
After a while it felt like things were actually
moving forward, which is great.
This is sort of how
I want the architecture to look eventually,
the driver
itself is just the npm module you install,
and you get
the entire kitchen sink, similar to AVRDUDE.
So we have
our chip config where I'm storing that in
a module so
people don't have to use that.
For AVRGIRL, you can use
it for anything.
The protocols have been implemented as
specific modules, so if a programmer is not
supported,
you can still support the programmer as long
as it has
that protocol, and then in the programmer
is just like
separate wrappers around the protocols with
the vendor
ID and the product ID, and just an easy way
to connect
with it.
But I said before, that I want some more
modules, right, so I've designed every single
package to
run by itself, standalone, so that you don't
have to buy
into the whole AVRGIRL thing.
You can use it by itself
and pick and choose what you need.
So what have I done so far?
I've released four
packages, I've AVRGIRL Arduino, which flashes
all of the
common Arduinos, which pretty much made use
of all of
those protocols.
I rewrote STK500 version two, because
I wanted it to have things like writing fuses
and EPROM,
and the original model was written for the
Arduino so it
didn't support the USB library I needed either.
AVRGIRL
chips JSON is the evidence of my tears, converting
it to
JSON, and the AVRGIRL ISP mark two is this
programmer
here, so you come out of the box interface
with any chip
this programmer.
So I'm using AVRGIRL ASP mark two in
that public radio app I showed you.
Again, why?
Why go
through all of these tiers to create this
for when
AVRDUDE is perfectly acceptable?
Well, I want to
provide a better developer experience, I have
a lot of
empathy for developers, because I know what
it is like
to be one.
I want to have really great documentation
and have something that feels more native,
so that they
don't feel stupid because they don't know
stuff about
hardware.
This is just a example from the forums
I talked about.
This person, they're a little --
they're actually wrong.
So it's not cool.
It actually
ended up a typo in Atmel's data sheet and
Atmel
apologised, but it was not what David suggested
it was.
I don't want people to feel like this.
It is just not
okay, and I think as a JavaScript community
we are
really good at this stuff.
So without obscuring what
the code is, this the kind of API you have
now, so you
have this awareness you're entering programming
mode,
writing the EPROM and exiting programming
mode, it feels
natural and you know there's a callback in
there, and
we're all comfortable with that, and this
is what it
looks like right now in order to be able to
flash the
chip, ten line lines of code, which is great.
So to be nice to other developers, you want
to have
beautiful docs, which I'm trying to write
extensively
and also blog posting about it, ease of use,
and it
should be implemented in modern tools, modern
languages,
right?
And then let's provide a better user experience
for people that buy this crazy Kickstarter
kit and have
no idea what they're doing.
Let's have improved
accessibility.
The screen reader issue still hasn't
been solved in NWJS, but I'm hoping for that,
but let's
make it easier to be able to use these tools.
Let's not
make it look like a computer virus as well,
and, you
know, hopefully we'll have more uptake in
this stuff and
a much larger hardware community as a result.
And so,
this proof of concept, this app here just
taught me so
much about what it's like to have to provide
for both
users and developers and be stuck in the middle.
I feel
like I learnt a lot about it and privileged
to be able
to work with Zak on this stuff, and I'm excited
to
hopefully release this as the new official
software for
the radio for people who want to change their
mind about
the radio station.
Hopefully people will maybe take
AVRGIRL and use it for fun stuff like remotely
bricking
each other's chips through games online.
I played this
game with someone a couple of weeks ago.
It was fun.
If you'd like to follow progress, I have the
master
module which links to all of the others, it
is new
cat/AVRGIRL on github.
If you want to read a blog post,
I'm doing lots about it, there are four right
now
describing all the different challenges I've
met.
Thank
you for being here for my lessons of JavaScript,
lessons
in love and loneliness, and thank you.</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>