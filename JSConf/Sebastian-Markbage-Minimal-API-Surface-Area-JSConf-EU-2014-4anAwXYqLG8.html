<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Sebastian Markbage: Minimal API Surface Area | JSConf EU 2014 | Coder Coacher - Coaching Coders</title><meta content="Sebastian Markbage: Minimal API Surface Area | JSConf EU 2014 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Sebastian Markbage: Minimal API Surface Area | JSConf EU 2014</b></h2><h5 class="post__date">2014-10-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4anAwXYqLG8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">San Sebastian that thing there is my
last name I live in California now but
it's actually really nice to be back in
Europe or omelettes and accents are
pretty normal occurrences sorry by my
voice I think I'm allergic to bad api's
that's why I'm like this so I work for
Facebook now the react team not an
evangelist
I just code stuff in dude I also
represent facebook on tc39 the Standards
Committee on macula script but don't
worry the bad parts are not mine
there's someone else's so I guess a lot
of people here I have a favorite library
dude there what's your favorite library
nothing rekt it's good cool
do you guys use like libraries for
everything that's the same library like
a utility library like underscore how
many people use underscore it's cool
jQuery
uh something like angular high-level Yui
sorry guys well this is the great part
about JavaScript look at the art
community right if you look at platforms
like iOS or Android or dotnet that are
proprietary basically everyone just says
do whatever that platform owner tells
you is the right thing to do right
there's this stock secret black boxes
that you can't touch anything and
everyone tells you you can't do better
than date it which is not true let's be
honest that's not true in the Java
community what though it had like this
vibrant community of frameworks we even
have discussions and fights about how
many package managers we even need to
manage all of our libraries I think a
lot of them are called NPM actually but
do we really need this many ways to
iterate over an array how many ways do
we need to like access down attributes
do you even know all the concepts in
angular do you know all the api's in
ember data
I don't do you know how many ways there
are to filter like a Naren in Justin
underscore is it the same you know - I
think it's the same info - depending on
which version you use and like watch opt
in to do you know Alden API is in a
standard JavaScript library what about
es6 so job recruiters and job
descriptions are looking for this
experience with specific libraries and
if you know the same concept under a
different name you're actually not good
enough because like you're not gonna get
ramped up quickly enough before the
company pivots or whatever right it's
starting to get a little bit annoying
with all this proliferation but of
course you have a solution for this you
created your own library and now there's
only one thing you have to learn it's
probably super easy it'll solves all the
edge cases and all the names are super
easy for you to understand how
streamlined JavaScript these days is
really hard to learn imagine is like the
first day and you get dropped into a
code base a complicated web app and
you're in the middle of the web apps
your first day I have no I
his works how many calls into JavaScript
libraries do you see that you never seen
before
now imagine this is the life of like
thousands of your colleagues we had our
own core libraries at Facebook as well
one of the most common questions we had
was so which Facebook specific module
corresponds to this under core
underscore jQuery function it's not that
the library itself is too big
the library is pretty cool and it
doesn't matter if it's like too many
bytes there's this way to optimize and
filter things out it's actually the
total amount of ID is that you have to
learn to be productive in this industry
that's really difficult these days and I
don't think this is inherent to a
diverse ecosystems and offerings is
inherent to programming in general and I
think I found a process that can help us
minimize this problem first of all
listen to slow-moving standards
organizations then write some spaghetti
code never abstract until it actually
causes bugs and once it does cause a bug
add an abstraction but remove as much
surface area from the industry as you
add to it now this doesn't sound like
best practices at all and nobody wants
to listen to slow-moving standards orgs
let me get back to that a little bit
later first some history let's back to
2005 late 2005 it wasn't interesting
here for the web it was before Internet
Explorer 7 and JavaScript kind of seen
an update for like 6 years he is for was
like 4 being drafted and was gonna go
into failure but minimal JavaScript but
the library we had was just not enough
and the community had enough we started
to take things into our own hands this
was an era with all the libraries start
to see proliferation a lot of them were
like prototype base J as they those too
heavily inspired new tools would I which
I kind of worked on a little bit a lot
of those bad things were
fault but of course libraries couldn't
agree on a standard way or like
extending prototypes and having this
global namespace so the best practice
became to use things like jQuery and
underscore because they had their own
separate database then es5 came along
and it became popular to patch
prototypes again but this time is called
polyfills and a lot of those polyfills
naturally placed prototype and mootools
because they were sharing the same name
space but the libraries in their own
namespace like underscore and jquery
lived on and was still the best practice
they actually had better api's at the
time because they were better documented
and was easier to learn because there
was no standard that you can rely on and
the rationale that they still Adhan it's
because it's empowering to have an
abstraction on top of the native
features because you can tweak
performance you can fix things in the
specs there are a little bit annoying
without relying on a standards body to
try to fix it for you and even the tc39
that for JavaScript would even argue
that if you're not quite happy with this
you should just use their own Stata
library and build something on top of
the standard which one DV is there's
least two ways to do this now there's a
standard way and then there's the
library way and there's multiple
libraries so we asked ourselves because
we got this question a lot should we
just adopt an API or a popular library
like underscore or maybe yellow - but
but which one of them and which version
and this is gonna be maintained did we
even control the source is it community
driven or is it controlled by one person
do we require this library from all of
our stores or do we take couple it with
some other dependency so let's take a
minute through look at why we actually
use JavaScript to begin with it's not
the best language in the world whatever
your favorite style is there's at least
one better language out there that will
compile down to JavaScript we can just
use that instead right well we use
JavaScript because it's ubiquitous it's
something that people could agree on
this is why general-purpose programming
languages keep winning out against ESL's
and custom languages and by introducing
divergence in the library community
we're actually undermining what
javascript is great so back at Facebook
we started building source-to-source
compiler is 46 features we invested a
lot in es6 became very earlier adopters
to the class syntax throughout our
entire code base we joined tc39 to start
working on es 7 there are some problems
with this technique though there's
there's some native functions that are
actually slower than the
reimplementation of them lodash shows
this over and over again that's pretty
easy to solve oh you just monkey patch
it just override the native version with
another version this faster this is one
of the strengths of JavaScript that you
can actually do this sometimes don't
tell anyone but you can actually use
shams as well that are not quite
compatible just to get the extra
performance boost just make sure that
you can trim continuously try to follow
the standards as it's moving along and
also try to not expose dependencies on
non-standard behavior there's a lot of
compatibility problems with just relying
on polyfills so in the early days of
respect there the spec changes a lot you
basically have to live with it as a
library rather than a final draft of a
spec you continuously upgrade but you
can really only have one version in one
round at a time we have a lot of
solutions to solve this and there
another problem is that you might have
to load like a huge polyfill on initial
page load instead of doing the modular
loading and all this stuff is really
difficult to get right but we and a lot
of our people are trying to build
open-source tooling to support your
environments we stack to actually label
you to do this and this is all hard work
but it allows us to have a very simple
story at Facebook we use Java scripts
standard library it's one way to do
things and it's a standard way
and it's a voice a very simple problem
it's avoids by chatting and bike
 is the biggest waste of time of
all we leave that to the standards
mailing lists and this reminds me of the
least intuitive lessons that I've ever
learned from a large organization it's
actually the top-down Authority is best
used on very least important decisions
not the most important decisions for
example I really recommend that you
enforce a strict and comprehensive style
guide just because it avoids this
discussion of on every poll request or
every div which style your guide use and
every new person isn't going to have to
like fight to get their style but you
might be asking yourself Java scripts
then the library doesn't have all the
features of my light right so what do I
replace this with well often the answer
is just write some more boilerplate code
it'll take you a few seconds longer you
don't take on a dependency the person
coming to fix your code doesn't have to
know about your obscure function and to
plenty other versions with the same or
different names that someone else fought
was better and better looking this can
be really annoying to have all this
repetitive code it looks ugly when we
all want beautiful code right except
this process fundamentally has no end
ever
we're simply never going to realize a
state of software nirvana where
everything is supremely satisfying and
that's an important emotional
realization
this was an early quote from an early
Facebooker but put in another way you're
not going to find the perfect library
API you're good looking code now will
look bad in a year and you or someone
else will have to go upgrade it you
might not even remember what abstraction
you found was was cool today right
however it's not all gloomy often the
answer is just write your code a little
bit differently you can learn new
patterns that allows you to structure
your code in a different way to achieve
the same goal but it's more precise even
using just plain JavaScript functions
now learning these patterns is quite
difficult and it's definitely a learning
curve but that makes you a better
programmer in general large frameworks
they usually have an API for every kind
of use case you can just search for that
API like ask for it on Stack Overflow
and you can find a link to it but when
you learn patterns you have to read a
book or tutorial or find different ways
to express the same thing it's a
different way to search for things but
essentially it's the same problem it's
just a slightly different solution and
if you structure a code in a way that
uses patterns instead of black box
libraries it's much easier for the next
person to read your code to actually
understand what's going on and this is
the most important lesson I've learned
at Facebook it's much easier to recover
from no abstraction than the wrong
abstraction so this kind of says the
spaghetti code can be better than the
structured code and this is very counter
intuitive to a lot of modern programmers
please instead the structure abstraction
has overhead to what every new coder
needs to learn just to get up to speed
with your code base but you know like
one little abstraction can hurt but
abstractions tend to spread because
technology is just a little layer of
abstractions one on top of the other and
everything you have on top of your
abstraction you will need to be unwound
you have to unwind every layer with a
total and complete understanding of the
intricacies of that system to get back
to the original layer and then rebuild
from there and that means that can
actually be more a lot easier to upgrade
verbose repetitive and explicit code
than it is to upgrade an abstraction
now I'm not saying like bad code like
spaghetti code is better it's really
like fettuccine code have you ever lived
with like a large app it was built on
the wrong framework you tried to upgrade
it because you can never quit because
you can never understand this how did
the underlying framework really work or
you had an existing app it was just
written haste
it was all spaghetti code maybe it was
good spaghetti code I was a fettuccine
code few abstractions a lot of
repetition which one was easier to
upgrade and which one actually left with
you with more reusable code abstraction
comes with a significant cost and a
significant risk so it's better to
unjust abstract to begin with and once
you have a nice fettuccine codebase
start finding repeated patterns if the
pattern doesn't lead to bugs don't fix
it
it might look ugly but it's not hurting
anyone try to generalize it and you only
risk adding bugs in the generalization
it only adds surface area to it everyone
but once it start causing bugs then
becomes a problem because it's
repetition and some algorithms can be
difficult to get right and then it
starts causing bugs then you generalize
you create an abstraction but make sure
that this abstraction can be used for
wide variety variety in these cases
because it has to make it worth its
weight it might even be subject for
Standardization if it's general enough
and this is where slow moving status or
it can actually help you if it's general
enough and useful enough it will be
accepted as a standard maybe it will be
accepted as a draft and you can sort of
continue from that but if it's not then
maybe it's not actually worth the weight
setting maybe you need to rethink or
prove its value now let's talk about the
Dom there are apparently 25 methods to
work with attributes alone you can also
access attributes through properties
that's still no reason to use jQuery the
browser inconsistencies could be
polyfilled and the rest is basically
just adding some sugar it's not solving
the actual structural problem and
complexities of managing a DOM and
living down and that thing is the thing
that leads to bugs now angular and ember
they try to address this by adding
change tracking and data binding liner
base on top of the Dom now you don't
have to manage to down that like
directly and this actually solves bugs
this is the legitimate use case for
abstraction and in theory web components
and similar efforts can actually work on
standardizing these patterns and then
there's one thing you have to learn and
is this data binding web components
world except they don't actually remove
as much as they add the surface area of
these frameworks these paradigms is
still huge there's a lot of things you
have to learn learning how to use web
components in a fully structured way
with all the data binding and the
intricacies of that is still huge and
that continues to be the case even when
it's standardized but with this paradigm
it's all necessary and that tends to
happen when you keep building straight
on top of existing ideas so sometimes
you just have to rethink the whole stack
come up with a smaller surface area so
we thought mutation is actually the hard
part of the Dom so what if we could just
throw away the DOM and recreate the
whole document like a page reload so we
invented a library called react now
we're not trying to diverge from
standards like web components with this
we just think that the functional
approach taken by react means that we
can drop so much more of the surface
area and we trying to all we try to do
is make it a lot easier for you to
reason about code without having to
think about a lot of surface area
because the remaining service area is
things that you can think spent time
thinking about around your
domain-specific world so this is the API
of react you expose a function that gets
the initial state of component
a render function that you can read from
the state I call back that set state
you'll notice that the set state is
actually the only API into react in this
room this is really the only API you
have to understand in react we also have
this syntax sugar is basically because
braces are a little bit difficult to
read it looks like templates but it's
not really templates
there's no repeaters there's no special
directives there's no special
conditionals it's just plain all
JavaScript now reacts internals are
pretty complicated the differing
algorithm to update the Dom can be
fairly complicated but the surface area
that you have to face as a developer to
know and understand what's going on in
react is very simple there's no new API
it's just a simple concept you can build
an incredibly complex app like this I
mean we did and up until this point it
sounds pretty good right but nothing is
free so what are we giving up
implicitness react favors explicit api's
and for you to write out your code
explicitly as possible over built-in
magic for example in many cases we get
requests for implicit bubbling of events
because it's tedious to pass a callback
around or some extra properties around
well turns out this is terrible idea
it's really difficult to follow code
that depends on the twisted bubbling of
events because it means that if either
side ever disappears you don't know
where it disappeared let's say one call
disappears from your stack and then
later we realize that actually led to a
bug that we didn't anticipate how do you
find that you have to go through every
component in the history of every
component or abstraction along the way
to find where that and happened this is
just one example but it speaks to the
idea that saving a little bit of typing
it's actually not a good race
enough for an abstraction it's much
easier to recover from an explicit API
by adding some sugar than to undo an
existing illicit API and we take new
abstractions in direct very very
seriously while you have to live with a
little bit of extra boilerplate in
certain cases you know that you and your
successor will probably understand and
be able to refactor the code in the
future imagine easier now we make this
text - of course if you used to react
you might notice that that's not
actually how you write react right now
because we built our own class
abstraction it was very tempting and
convenient
we could add special hairpins to it but
in the next version of react with
deprecating that and we're going all in
on a six classes it's not an extended
version of 86 classes it's just es6
classes now because this is not a
one-to-one mapping it actually means a
little bit more boilerplate in some
cases but it means that since we're
removing proprietary features from the
library you can use whatever abstraction
you want preferably we just use standard
Java scripts so we don't add extra
weight to our industry but if you really
do want to use a third-party library
since we provide the standard class
system it means that you can accept any
kind of third-party class system as well
because the standard represents an
intermediate representation that can be
shared across libraries this causes the
coupling as a side effect I think about
that for a minute
react already has a small surface area
but are actively removing proprietary
free pictures from the framework just
because you should mostly use your
standard language it doesn't mean you
have to use all of it so Java Script
already has a huge surface area and if
we want to keep adding more stuff to it
then we have to remove something because
otherwise it will just keep growing and
are in the stable
run out of headspace of rare but this is
already being done through linters
strictmode
VMS only optimized certain patterns so
the next thing I want to work on is
basically just formalizing this step of
the process how do we remove features
from the existing language
I mean they will never be removed from
the web because you can't remove things
from the web but it can be removed from
our industry's mental surface area so
let's put J s on a diet use polyfills
instead of libraries write explicit and
repetitive code only abstracts actually
solve bugs not because it looks better
and then rethink the stack and purge and
then start over again
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>