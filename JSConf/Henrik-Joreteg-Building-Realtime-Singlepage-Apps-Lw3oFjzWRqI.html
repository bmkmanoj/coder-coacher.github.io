<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Henrik Joreteg: Building Realtime Singlepage Apps | Coder Coacher - Coaching Coders</title><meta content="Henrik Joreteg: Building Realtime Singlepage Apps - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Henrik Joreteg: Building Realtime Singlepage Apps</b></h2><h5 class="post__date">2013-01-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Lw3oFjzWRqI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">one of the things we've done a lot of
and yet is really stress around with
building real time applications and it's
real time is one of those things that I
feel has a has a giant pile of potential
I think we really haven't seen what it
can be used for yet as far as I mean I
really think we can push it a little
further the first the first thing people
always do is they go write some chat
application and you know that's
interesting and it's solely useful but
it's been done and it's every other week
we get somebody it's like oh you know I
wrote a chat app in 10 lines of code
like cool way to go and that's all great
but I really think that as this
continues to get easier and easier and
easier to do we're going to see people
using it for a lot more interesting
things and that's really what what
what's so amazing about what the what
Sokka do does for us but so one of the
things we have to keep in mind is as web
developers is we're actually in direct
competition with native applications
that's not really something people think
about or talk about a lot but I mean the
truth is it given the choice between
using you know Gmail or Sparrow mail
from my mac sparrow gives me a nicer
experience and and that's what i use and
i end up spending money it's from to you
know to some third-party mac app
developers to use gmail and the truth of
the matter is like experience is
everything right and i think i think one
of the things that we've kind of done i
mean i'm a little more of a front end
guy my background is actually in
business not not development got into
this stuff later but i think you know
really got to keep in mind that that
recreating as much of that the
experience that people want from native
applications in the web is very possible
these days but we're kind of stuck in
this rut of feeling like we always have
the support you know we have to limp
along all these old browsers and i
really think that's a mistake and
we're kind of shooting ourselves in the
foot a little bit and that and I think
the truth of the matter is it's totally
fine you know you go buy microsoft
office in a box you read the side of it
there's minimum system requirements so
what's wrong with requiring a modern
free browser I mean the truth of it is
if you give a compelling enough reason
to use those the people will come in the
IT departments will switch if the
business is a big enterprise guys have
good reason to you know actually get
their people downloading chrome or
whatever it is if there's enough of
business reason that the technological
stuff goes away so I think the trick is
really as web developers to focus on you
know basically stop supporting crappy
browsers because so in yeah like I said
it's really not too much to ask I think
one of the biggest components of that
and one of the things that can make the
most compelling argument for using you
know really modern browsers is the
real-time stuff I think there's a lot of
collaboration tools and a lot of a lot
of things awaiting the thought of yet
that you can do with real time that
people just need to start experiment
when experimenting with and publishing
and just you know forget i mean socket
i/o kind of makes it easier as far as
supporting older stuff but you know what
if your app requires websockets so be it
just use it if it's got a compelling
enough of an experience then you know
people will people will do whatever they
need to do use your app and i think
really that's the approach we should be
taking instead of this like endless
reverse compatibility mode that we're
kind of stuck in and i know some people
don't you know you work in a corporation
you don't have that option but i would
just say really really really want to
stress this i think that's important and
I think real-time is one of those things
that can make that happen so I would
just suggest in general on this is kind
of a soapboxing obviously but really
focus on providing the most compelling
experiences and that you can and i think
i think real-time single page apps is
actually a great way to do that and as
browsers get better at integrating with
the OS and everything else you do
desktop notifications background apps
all that kind of stuff um you know it's
up to us
community to actually use that stuff
push it and show what it can be done
with it and that's what I'd love to see
happen so one of the things that that I
think is true for a lot of a lot of
people are self-taught right and really
adoption is driven by how how easy it is
to start messing around with something
if you have to have you know this giant
full stack development experience and
you you have to know how to set up you
know like basically in to do real time
the way the way people started doing it
was XMPP kind of was one of the first
approaches to doing this and that that's
flying that's great and it's you know
you've got you've got this nice API and
protocol to work with and tons of
libraries out there and whatnot but you
know then you have to know how to how to
set up and run an xmpp server along with
everything else that you're doing the
truth is you know your average front end
dev who's going to have to implement
this isn't going to know enough to spend
his weeknights you know like at home
cranking out some real time app I mean
it could happen but the truth is the
easier it gets the lower the bar to the
level of you know basically the lower
the bar is to enter that start messing
around with it easier it's going to be
in and the faster you're going to see
adoption and I think honestly I think
that's what Guillermo is really done
with socket i/o because you can run note
it's a single process it's not that hard
to set up on your machine and you can
just have this this WebSocket server and
just start sending messages back and
forth so i mean when i first started
getting into to web development I mean I
was intimidated by ajax until i saw how
easy it was to do with jquery and mike
holy crap so I think I've belabored that
point enough but the point is it's it's
getting a heck of a lot easier so most
of you how many of you guys have
actually messed with socket i/o okay so
most of you but basically it just makes
it stupidly simple to send messages back
and forth without having to think about
the transport without having to
basically just so on the on the server
all you do now you got your normal
little node server and then you can just
start sending message
I mean you say listen to the server and
with the changes obviously this is going
to be a little different but you can
just send messages back and forth so
then on the client you know you just
create your socket and you say it's
roughly the same API on the client and
you just send messages it's just nice
super simple bi-directional
communication you don't need to worry
about serialization you're working at
the same language both places it's it's
quite simple really so like I said my
first experience with with with all this
was just using XMPP and so we use stroke
GS in the client and actually you know
connect as an XMPP client turn the
browser into the next peak peak client
connect to some you know some other
service and start receiving XML you know
then you've got it and then you get a
parse XML in the browser and all this
other stuff so it's it's really a
significantly more difficult and and the
truth is there's nothing stopping us
from messing around with this stuff and
there's nothing stopping us from from
expecting that you know a browser can
support what we're trying to accomplish
one of the most important things about
building real time outs from what we've
discovered is is state so the state is
essentially just I mean if you can think
of it as kind of a stripped-down way of
representing just the core of what's in
the application right now as far as just
data no and I completely abstracted from
views everything else and so recently
I've started I mean I've done a lot of
stuff aback on Jas and what backbone
does is it lets you create models that
are separate from your views so you
create you create a backbone model and
then you can bind changes to specific
you can say for example I care about
this property if this property change is
called this handler really easy stuff
but what happens is you can keep you can
keep that data very kind of encapsulated
in these models and then anything that
changes you just respond to it so your
view it is just you know your view gets
past the model and
so your model you you bind changes to
the model to your views in this case you
just rear-ended the whole thing here in
this simple example I mean you could dig
in and re-render certain portions of it
or change values or whatever you want
but I mean the point is once you've
attracted your state everything else
just responds to that and so one of the
first apps that we use this for backbone
dermot set up to do Ajax type
architecture so you know they've got
kind of the built-in methods for working
with jquery ajax stuff so you write a
REST API and then you can just call you
know you build your collection of models
and you just call fetch and it will go
make the server call populate your
models and off you go which is cool and
then what we did is on top of that so we
would do an AJAX call and then we would
actually go subscribe to whatever items
were were brought back in an exit PP
channel and start getting live updates
do that again it works it's possible
it's but it's kind of tedious because
you have to keep track of I mean at
least your models are on living in one
place and really the kind of this this
this pattern about distracting that into
this little observable model state is
definitely super helpful as a front end
dev and because you just you just
changed everything that happens in your
view all it does is flip a flag in your
model and then your response to it so so
what after after messing around with
with with backbone and a little bit of
socket i/o I I just thought well you get
you get all these changes through
backbone and yet you kind of do this
ajax thing which is kind of not really I
mean it at that point it's kind of you
know asynchronous you make a change then
you have to call save on that model and
then that that he'll see realize that
sends it to the server and as your
server saves it so what I when I realize
that backbone can actually run on the
server as well and that opens up some
interesting possibilities because what
you can do is
is basically send the exact same model
file so you define your models once you
send that as a script tag to the browser
and you require it as a module in node
and if you have a few other things you
can actually so what I did is capsule
JSL does it's it's an extension of
backbone what it does is includes a way
to nest models so you have kind of a one
model that's kind of your route model
and you can add collections to it you
can add models to it and you can
serialize the entire state just off of
that root model there's an export
function that you can just use to to get
that all out and to its most concise
state possible which you can just you
know send across socket i/o am also the
change events that you get there's no
there's no event bubbling by default in
backbone so I implemented just the OS
now may away basically to pass those
events up the tree just like you would
in the browser what you're used to there
and so you can listen for publish events
on the root model and so all these
things combined you can actually very
quickly you know basically in it you're
in the exact same models on the client
as you get your connection you just send
you just export the entire app state
send it to the client and from there on
you can actually just let the change
events propagate back and forth which is
there's clearly some some interesting
problems that come along with us as far
as security and scaling or not but it's
it's a really kind of fascinating way to
build applications because no matter
where the change happens it gets
propagated everywhere or you can do it
so that you know you can say the server
is the authority here and you know the
individual client has to actually you
know click send a command that sets the
change on the server and then it gets
propagated out I mean you can choose how
you want to do it and you know you
certainly have the valve validate
anything that you're using for
permissions or anything like that just
to make sure that because I mean you
could open a console on a browser and
just edit the model and those things
that just propagate if you don't have a
secured
probably but it makes basically if
you're used to using backbone and if
you're building your apps this way it
doesn't take that much to just get this
setup and and kind of have those events
magically propagate so as a little
example here this would be like your
core app model right so what I've done
is there's this little register function
that creates a uuid for that model on
the server and and then there's these
addchild collection that child model
type functions here the methods that you
can use to build basically your tree of
describes the structure of your
application and so then you know on the
server what you would do is you know
what I'm doing right now because I was I
knew he was going to do something with
making it easier to do sessions and user
data and stuff first I could i oh so I
was kind of waiting for that but all I'm
doing is grabbing the cookie on the
client and saying hey and sending it
across socket i/o Oh which is kind of
kind of wonky but it works so basically
you know you go fetch sure you get this
session event from the client and you go
fetch your user in the day database and
you know whatever the corresponding app
state that corresponds to that
particular user and then you just
serialize the thing send it out and also
you bind you know you bind the changes
for that public event on that state for
that client on the disconnect you unbind
it so it's fairly simple stuff but it
works quite well so yeah on the on the
it's all I'm doing on the client side is
sending session across the wire and then
listening for messages and the messages
basically what i did is i came up with
just basically a simple protocol for
doing this so you get your initial state
and then you get change events you get
add events you get move events and you
get removed events and then all you do
is you look it up by that ID which the
general was generated on the server and
then you can just whatever the change
was you just simply apply it on the
other side of the connection so and it's
really up to you as far as you know
what you want to do there I've in theory
you can just have it so that any client
can change anything and it just gets
propagated it completely depends on the
use case for what you're trying to do
but so anyway this is one of the little
chat apps we built with it this was all
XMPP but what we did here was actually
kind of an interesting mixture of the
two so XMPP is fantastic as an external
API right because there's all these
libraries out there that that can use it
and for say you want to write an iphone
app to go along with your application
you need to provide that external API if
all you have those models living in
memory and note it's really hard to kind
of give access to that and some kind of
predictable manner to some other client
and you could write some custom custom
HTTP API or whatever but so anyways what
we ended up doing here is basically in
this particular use case we just add
this little chat bar at the bottom and
if somebody wants to go you know open a
new tab we don't want to have to
reconnect that with xmpp again so what
we did is just maintain an XMPP
connection on the server for each client
and then everything else is being sent
and synchronized to through capsule so
as a result you open a new tab it's
immediately there it's way faster to
reconnect that way than having to
re-establish that XMPP connection so
that's just one of the things we did
with it um another thing that we kind of
a mess around with is this this little
app called and bang and it's a
collaboration app and what we're doing
here is we've got our entire team is
like 10 of us and so here you here we
have a shared team state and then
members live within that so the so your
your route state for the app is actually
the team and then each user is a member
of the team as you know it's somewhere
down on the tree so what happens is as
you make changes to your tasks and
whatnot um it just gets propagated to
the rest of the team the and and it's
surprisingly quick even if you even if
you decide
you're going to set this stuff on the
server initially and then wait for the
change to come back it's surprisingly
responsive if you're using WebSockets
see if you had a decent internet
connection so I was going to try to do a
little demo but I don't know how big the
screen is here but I mean just as an
example of something you can do with it
right so and I don't even have the
internet connection going here but
basically so you this whole thing is uh
is keyboard control too so you can just
add like you know if I add a new task
here it's actually what it's doing is
it's sending to the server saying you
know here's an ad event it's getting the
change response it's getting the the
addy event back and and then the view is
responding to that and if we had
multiple windows open of the same thing
you know the changes all happen
simultaneously right so it obviously
we've got some CSS issues going on here
but the fact is I mean everything is
simultaneous it's super fast it's super
easy to work with the truth is all you
got to do is just modify the state I
mean you're just setting you're just
setting values on this shared state and
everything else just kind of propagates
and takes care of itself we are
definitely doing some I mean some of the
obvious some of the obvious problems
here are persistence and scaling and
everything else because if you're going
to have to keep the entire application
state in memory on the server there's
some challenges there so we're working
on actually my coworker fritzy here is a
he's on the xsf Council of the XMPP only
the XMPP standards foundation Council
and you know so he's totally an XMPP guy
and what he's been looking at is
basically writing using Redis as kind of
a shared memory for for the types of
applications so basically your register
function that I called here would we
basically set up a feed-in when he's
calling thou'lt j/s and then you can use
Redis is clustering to just
I mean you can just tilt those as many
servers as you need to so and then you
know pub/sub events do that instead the
there's that I mean there's definitely
some other some other challenges here as
far as you know in the case of the team
here you can't just have one view that
responds to the same model for everybody
because you want every every member of
the team to have you know their view of
that so what we're doing is instead of
trying to I messed around a lot with in
gear most channels implementation think
would have been interesting the
multiplexing because then you could have
a team channel and you could have your
own channel but you know so what we're
doing is basically the members are
further down the tree but the view just
identifies you know this user is X user
and then so as a result anything that's
specific to that user is getting set as
a property of that users model in the
team so the entire team state is still
sink but the you know your view your
view just shows the correct one based on
session ID of that user so the other
thing is like I said providing external
api's and one of the things that that
thunk does is basically you can have
thunk is just a contract system with
Reddit and so you could actually have
just an XMPP interface to thunk that
just uses pub/sub you could have it
right you know RSS or atom feeds or
whatever so there's definitely some
stuff there that's still missing that
we're working on but just you know not
like here's how you should do real-time
just kind of showing what we've been
doing what we midpoint around with and
kind of what we found hopefully
hopefully that's useful to you guys and
anybody who has questions or anything
just any questions
now Jas yeah oh yeah I haven't spent a
lot of time looking at now Jas my
impression is that basically if you you
have this kind of magic object and if
you create a function on the client that
function becomes available on the server
which is interesting and that's that I
mean that's that's cool it's just it's
just an infection on top of socket i/o
basically right but yeah that would be
another interesting architecture choice
but I mean you could totally do that
anyways i mean i i've got a method in
here for just you know call this method
on this model on the server does
basically the same thing so it's cool I
mean I I haven't played with it a lot
other questions
oh yeah so I think I have one last slide
yeah okay so capsule capsule Jas is kind
of what what I wrote that it that adds
those features to backbone I'd love to
get more feedback on that I know it's
certainly not perfect and i know this
approach still has the shortcomings but
we're going to keep playing with an
experimental see what we can do and also
if any guys are interested in messing
around with an bang as a little pre
alpha something or other i just hit me
up on Twitter and I can get some invites
sent out because we've got that almost
we're almost ready to publish that stuff
so it's kind of a that way you can at
least have something that you can play
with and see how it works as well but
yeah and then just some other things
here one of the at jas conf which I
wasn't there at but funk unit is it
seems like a really way cool way to test
these types of apps because basically
you can just run basically it's built on
top of queue unit which is the jQuery
testing thing but they and you can bail
owes your app open an iframe and says
hey click this button do this thing and
make sure that this you know wait for
this thing to become visible kind of
thing and it's a really awesome way to
test these types of that but just as a
little side note so well thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>