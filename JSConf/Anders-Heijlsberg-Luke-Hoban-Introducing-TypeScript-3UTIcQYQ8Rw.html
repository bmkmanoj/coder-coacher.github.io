<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Anders Heijlsberg &amp; Luke Hoban: Introducing TypeScript | Coder Coacher - Coaching Coders</title><meta content="Anders Heijlsberg &amp; Luke Hoban: Introducing TypeScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Anders Heijlsberg &amp; Luke Hoban: Introducing TypeScript</b></h2><h5 class="post__date">2012-10-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3UTIcQYQ8Rw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm just gonna say a few words and then
Luke will do some demoing and then
hopefully we have time for some
questions afterwards so over the last
I'd say five years in particular we've
just sort of increasingly heard from
customers and internal teams how it's
really hard to to write an in particular
maintain large code bases in in
JavaScript variety of reasons you know
like I mean the language as you all know
doesn't really have any structuring
means beyond function so there are no
classes there's no modules but also
there's no there's no static typing in
the language with which we can
communicate contracts and teams you know
like big teams like to actually be able
to reason about if I I'm supposed to
implement this contract what's in it
what message so much functions what
interfaces and also static typing is one
of those sort of things that empowered
the IDE revolution over the past decade
if you look at things like Co completion
refactorings go to definition navigation
and large code bases it's all largely
powered by by static typing so so when
we when we were thinking about where to
go next with Java JavaScript development
tools a couple of years ago we thought
it'd be great if we could somehow
strengthen JavaScript with these things
that are missing like classes modules
and and some form of of typing but we
wanted to do so in a way that did not at
all take away any of the inherent
advantages of JavaScript II the
standards web cross-platform
and so forth and so typescript is is the
outcome of that and and sort of market
espeak wise typescript is a language for
application scale JavaScript development
but and if but technically it is a
superset of JavaScript that compiles to
plain JavaScript and the compiler itself
is written in typescript and the code
that it generates is is just plain
JavaScript that runs on any browser on
any host on
any OS and the compiler and the
associated language services are open
open-source so so unlike other languages
that target JavaScript typescript starts
with JavaScript and and and to to that
and that that means that every line of
JavaScript out there is also typescript
you can copy and paste JavaScript into a
typescript file and and just go from
there
and it also means that typescript works
completely seamlessly with all of the
existing JavaScript frameworks that are
out there like note jQuery expressed
backbone underscore etc etc and then the
thing that we add in typescript is
classes modules arrow functions rest
parameters a bunch of things that are
actually already proposed in es6 and
we're very aligned with those proposals
and then we also add optional static
typing on top and through that through
that amalgam of things we can then build
great tooling because we now have a
foundation upon which we can reason
about code and navigate larger code
bases but but the good news is that that
it all compiles away so so when we
compile to JavaScript we basically
generate what I would call idiomatic
JavaScript the same kind of JavaScript
that you would generate to do prototype
inheritance and to do function closures
for modules and and so forth and as I
said deed the final code there's no
shred of evidence left that it came from
typescript so to speak and it runs
anywhere that the JavaScript runs so
that's sort of the short spiel if you
will will have looked through some
demoing and then then we'll we'll do
some Q&amp;amp;A afterwards all right so see I
say good get to do some fun the fun part
here and just walk you through what some
of this looks like in our tools here
so as Anders mentioned typescript just
starts with JavaScript so we can paste
in a piece of JavaScript code this tool
I have here is something that's on our
web site the typescript playground which
lets you just try out the language see
what it looks like see what the
generator javascript looks like and then
run that so I'm starting here with
system JavaScript code I have a
to function a member on his prototype
create an instance of that and then play
around with the Dom a little bit a
couple things to notice one is that I
wrote this code on the left the compiled
JavaScript because this was just
JavaScript to begin with I'm getting
back exactly the same thing on the
output there's a little bit of
whitespace removed but it's the exactly
the same JavaScript code I can go ahead
and run this we see our beautiful web
application here which when I run it
seems to have you know a little bit of a
little bug in its hello world output and
so if I come back into here we can start
using the first sort of typescript value
add piece and that is to actually add a
type annotation so if I put colons
string here
that's me indicating my intent that is
the author of this piece of code I
intended this to be called being passed
a string this does a few things the
first thing is it does not change the
output at all
who knows that this just completely
disappears in the output that means that
these types won't have any performance
overhead they won't have any change in
the semantics of your code you can still
reason about your code exactly in the
same way as you would have if you just
written the JavaScript without the type
annotations that's a really really key
foundation for for the way that we think
about types the next thing is we saw
that as soon as I typed that I got this
little red squiggle here and the
compiler is telling me hey you probably
did something wrong here you said that
this thing we're supposed to take a
string and you passed at this object
literal here and so we're here is the
place where we start being a little bit
you know having a little bit of an
opinion in a sense on you know
technically in JavaScript there's no
problem with just passing this object
literal to something that maybe if you
treated as a string that'll work out all
right but probably you don't and so here
we're we're sort of saying we think
that's probably an error in your code
we're going to give you that feedback on
the fly as you type your code so I can
fix that just by removing this the next
thing we get is we start to get some of
the tooling to light up so I can come up
here and type in greeting dot and you
see we get a completion list at this
point we get feedback about it because I
know this is a string because the
developer indicated that intent we can
give you a completion list and this
tells me not just the names of the
members that are available so I can see
I've got a length property it also tells
me the types of those
members and that's really useful
feedback to get directly in the tool
because it means that for members that I
don't use that often like I don't call
locale compare all the time but if I but
if I need to I can look at it right here
I don't need to go read the
documentation and look up what the you
know what I need to pass it what is
going to give me back all that
information is sort of right there
inside inside my tool
the one thing you sort of may notice
here is that when I when I made that
change I originally was passing let me
just go back and undo this um I was
originally passing an object literal
here and you may have wondered well what
if I'd actually intended to pass an
object literal there and what if this
wasn't supposed to be a string it was
supposed to be an object literal and so
we can actually represent that kind of
thing in here as well so we can say that
this greeting is actually some object
which has a message property that is a
string so if we want to pass around sort
of structured data we can indicate that
within within the type system here and
see the soon as we do that that's
another way of sort of fixing the error
that was being reported to us now well
and I should also show of course you
know now because I have that when I hit
greeting dot we see that that thing has
a message property now of course if we
were doing this in any real program
these kind of things would get pretty
big you know if we were passing around
packets of data and we wanted to
actually type them typically our objects
have more than one member so here we can
go and just give that thing a name by
calling it a greeter options and then
putting a message property in there and
interfaces in typescript are just a way
of giving a name to some structure for
an object and so we can come back in
here and just replace this in Lion thing
with greeter options it's important to
notice that this is a structural
contract this isn't like nominal typing
like you'd get in Java or C sharp this
is just a structural contract that the
thing being passed in is this parameter
better be an object which has a message
property and that message property
better be a string so that's the the
intent that I'm indicating but we can
pass any object letter we want in here
as long as it has the right things if
though we made a typo we get that error
again and similarly if we pass the wrong
kind of data
again we see the error comes back so
we're able to sort of flow all that
information through now we could add
other things to these to these
interfaces so for instance let's say
that it's greater options also I can
have a function on it so we can say that
there's a function foo which takes an X
of type number and returns a number now
when we come back in here we can see
greeting dot gives us back that foo
function and in fact if I say var x
equals greeting dot you'll start to see
we get a little bit of type inference so
because we know that food takes a number
and returns a number that means we know
that X is a number and so we're actually
we don't have to add type annotations
for these things a lot of this
information is just going to flow
through type inference now we can do
other interesting things so properties
and functions on our interfaces is one
thing but JavaScript objects can sort of
do a few other things other than just
have properties so one thing they can do
is they can be callable they can
effectively be function like and so
imagine that we want to indicate that
our greeter options object is callable
and when called with no parameters we'll
return an element so here we can do
something like you know we can take this
greeting and while it still has a
message property in a foo property it
also can be called and we call that we
get back an element and so we get the
completion list here for an HTML element
now one last thing here
another thing that JavaScript objects
can sort of quality they can have is
that they can sort of be indexable that
they can be array like objects and so
here we can say that if I index this on
a number I'm gonna get back a date
object and so now if we come in here and
grab the 0th element of this and hit dot
we're gonna get the completion list for
date and this kind of thing can look a
bit crazy when you do it in a simple
example like this like what kind of
object is gonna be callable and
indexable and giving back elements and
dates but you know things in the Dom are
not that much more sane than this right
there there's a lot of host objects that
that have some pretty strange api's and
by trying to model taking the runtime
type system that javascript has
and exposing that in a static type
system that you can use to describe and
model your api's we can bring a lot of
the richness of those api's and just
expose it into tools and documentation
and static analysis okay so that's a
quick look at at some of the well let me
just let me just actually go back to the
the basic version of this so one other
thing with types that I should note we
added this one type annotation here and
I showed how that kind of gives you some
some tooling benefits it turns out we
were actually getting a few tooling
benefits kind of already for free in
this code even when we just pasted it in
the raw JavaScript and that's because by
default we give you typing for the core
browser primitives so all the Dom API is
all the es five core libraries and so if
I hover over document we see we know
that thing is a document and therefore
we know that create element is a
function which takes a string and
returns an HTML element and we know that
it has an errant text property and this
is all useful because it means that if I
mistyped something here we're gonna get
that error as well so even when I'm just
pasting in JavaScript code we're able to
sort of do some checking against your
code because we know something about the
the core libraries that you're using all
right so that's a quick look at types in
typescript so the next thing that we we
give you is is classes in classes
generally are just a useful tool for
kind of this structuring of code there's
a lot of good design patterns that the
developers are used to for for how to
think through classes the classes in
typescript are actually very simple and
lightweight they're they're very much
aligned with what's being discussed
currently in the echo script standards
body for ACMA script six the maximum and
minimum classes proposal it's basically
just ultimately a way of hooking up you
know the standard constructor with with
prototype properties prototype methods
pattern using a single sort of
declarative construct instead of
smashing it together manually and so
you'll see that this code if you've seen
what the es6 classes look like the code
here is is effectively identical to
those the key thing that's different
here is even typescript we let you
describe what properties you have and
what types those properties have this is
way of getting that type information
back into the tool again you can see on
the right hand
we code generate this into a fairly
standard pattern here this is more or
less the kind of code that you would
likely write if you're gonna write this
kind of thing out by hand
and so we're really trying to make sure
that the code we generate is really
simple and clean and has a one-to-one
correspondence with with a typescript
code that you write in now classes are
actually particularly interesting for
language like typescript which has a
sort of static type system that it's
offering because the class defines not
just a constructor object that you can
use at runtime
it also finds a type which is the type
of the instances that are created by
that constructor function and that means
that down here when we created that new
greeter object we actually see that we
know that that thing has type greeter
which means for instance that if we look
at the greet function here we know what
type that has we know that it takes no
arguments and returns a string and we
know that this is referring to you can
see the highlighting here you can see
this is referring to the the greet
function to find up here and that's
something that would traditionally be
quite hard to do with JavaScript to know
that there was that association between
those pieces of code because you know in
general we could have a lot of different
things happening that could make that
name bound resolve to something in a
very different place but with the static
type system we're actually able to
resolve how how those connections are
made
one of the other nice things that offers
is the ability to do some some richer
kind of ID services so if I come in here
and say rename we can come and say oops
I keep doing that too much we can come
and say change this to say hello and do
every sort of rename in line of our code
and actually change both the definition
site and the and the use site and at
once and obviously the JavaScript that
we got generated out on the other side
so we can offer some of these sort of
richer IDE services inside this kind of
environment so the the last sort of
major concept that the typescript brings
in and this one's also something that's
being worked on in in the es6 group is
the the notion of modules and so modules
and this first example might this is
just an internal module so the ability
to just declare a module that I can use
within my single file here and you see I
just took my greeter function I stuck it
inside a module
and a couple of things the outer module
here just becomes a simple sort of
closure around around the code I wrote
I'm exporting this class which means I'm
just gonna stick it as a property on the
object that I'm exporting here and we
can do the some of the standard things
that we would do inside any sort of
closure of programming in JavaScript so
I can for instance take that string I'm
using in there and just grab it out as
sort of a local private piece of state
and refer to it like this and you see of
course there were not exporting the data
property but it is being captured in
that in that closure there so do all
those same kinds of programming styles
but again modules are useful to
typescript in particular because they
provide some structure over the types as
well as a structure over the values and
so here we have a greeter type that's
defined inside a sayings module and so
when we hover over this this object here
we see that it's type is saying stock
greeter so this is part of why sort of
all three of these features kind of tie
in and together they're what sort of
makes a lot of this really nice okay so
that's that's a really quick tour
actually one more thing I wanted to show
in here if I just delete this code if
you have a top-level export from a type
script file just like in the equity of
six proposals this defines a sort of
loadable module a module which can be
loaded by a runtime module loader and by
default we actually emit code which is
compatible so the common jeaious module
system so here we we write that onto a
global exports object and so if I have
some common GS loader like if I'm in a
node environment this kind of code is I
can just use to write node modules
effectively we do have a mode on the
compiler where you can say that you want
to target AMD modules instead and then
will code generate code which will be
compatible with any AMD compatible
loader like requirejs so that's that's
sort of the the quick tour of the
language features inside the playground
one thing I wanted to show if I just go
over onto our sample site we have a
handful of samples here that show off a
few different pieces of what you can do
one of them I'll just show some of the
code for is this little you know
battleship simulate
thing here try to blow up one of these
ships good we got one so you know really
simple little app here but I'll open
this up inside visual studio here so one
of the things we made available with the
with typescript earlier this week when
we put it out was a visual studio a
plugin that can really show off kind of
this rich tooling experience inside one
of the tools that we build at Microsoft
and so this is the code for that you
know it's got a few classes in here and
you know the the cell class for instance
has a handful of properties and
functions on it a couple of things that
are interesting I'd sort of talked a
little bit about how some of the Dom API
s are available for you to program
against we have all the type information
for that stuff in in this environment
and so we have things like this HTML
element and this if I just right click
and say go to definition it'll drop us
into this file that we provide called
Lib DTS which is a bunch of declarations
of all of the capabilities that are
available inside inside the browser
environment and this for instance has
the HTML element type and the element
type if I come down here we'll see
things like on click is a property that
HTML elements have and it has you know
it's going to be a property which is a
function that takes a mouse event and
returns code return an arbitrary thing
if I go to Mouse event you'll see sort
of some of the stuff you're probably
familiar with all the kind of properties
that you have available to you on an
event passed back to a mouse event so
this file is about eight thousand lines
of code that was actually generated
automatically from some of the IDL
descriptions that the standards bodies
provide over a lot of the Dom API s and
that means that were able to take all
that information that's available in the
standard from the standard specs and
actually make that available into sort
of tooling environment here so you can
use that for static analysis you can use
that for getting completion lists and
refactoring and all that kind of thing
so this is actually a pretty useful
thing now we do that automatically for
the Dom which is one very big library
but of course we also want that kind of
information to be available for some of
the libraries that you would be either
using or writing or
with and so you see in this example
we're actually also using jQuery and so
if I do dollar you know open paren you
see we can actually get sort of some
some hints about what the different
overloads of this function are and so
it's basically seven different patterns
for how we can call jQuery and they each
take sort of different combinations of
parameters we can get that information
again in the ID environment if I do just
one of these and hit dot yeah you'll see
that we can get back you know is sort of
a list of the members that are available
in here you see things like we have add
class which again is sort of overloaded
there's two sort of valid ways to call
it one of the interesting things to note
is if I go to definition on this it's
gonna drop me into this jQuery DTS file
and this is just a file that we've
written we've sort of written this based
on the jQuery documentation and you know
there's a lot of stuff that actually
isn't captured really fully in the API
documentation so kind of going and
making sure that we have the information
correct beyond that but this is trying
to capture all of the typing of this API
surface area and this is sort of a
formalization of of documentation and so
this is something that you know
obviously we could do this for a bunch
of different libraries and we're talking
to a bunch of library vendors including
the j.crew folks about you know what the
best approach is for developing and
maintaining these things going forward
but one of the particularly notable
things about this is that in my worship
example I'm using both jQuery and jQuery
UI you can see up here and jQuery is is
uses a pattern that you know several
libraries use in JavaScript where they
still have a plug-in model where they
the plugins can actually sort of expand
the capabilities of existing libraries
so for instance typical jQuery plug-in
will actually go and extend the jQuery
prototype with some new capabilities and
also potentially extend the dollar
object itself and this kind of sort of
dynamic extension of existing objects is
one of the things that traditionally
static type systems have not been as
expressive with and it's one of the
reasons why typically you know these
kinds of things are done in languages
like JavaScript which have a much more
dynamic type system
in typescript we really wanted to make
sure we were able to capture all these
kinds of patterns because they are so so
commonly used in a lot of JavaScript
libraries and so one of things we let
you do is actually extend interfaces so
for instance when I have the draggable
member here if I go to definition on
that you'll see that actually drops me
into a different file so I'm not in
jQuery DITA TSM and jQuery UI dot DTS
and what I did here is I just wrote
another definition of the interface and
basically what types is gonna do is look
for all the definitions of the jQuery
interface and just merge them together
and this means that sort of different
different authors working on different
components which might extend one
another can work on those things in
parallel and don't have to sort of agree
on what their shared surface area is and
this actually allows sort of a lot of
that flexibility that you get with with
sort of these kind of plug-in models
okay so that's a quick look at at this
sample so I've showed Visual Studio and
I've showed the the types of playground
we also make available an NPM package so
I can you know install typescript and
when I install type script using NPM I
get a TSC type ship compiler and I can
just run that and you see it's just a
standard sort of compiler that I can
plug into any tool chains the cloud9
guys yesterday showed how they're using
this on their server to provide some
basic tooling services inside cloud 9
over top of typescript and this you know
this is basically a compiler you can
plug into to any any compilation chain
the we support both you know NPM as an
installation mechanism but of course
also if you want to use typescript for
node development or really any kind of
JavaScript development you can use it
there and so I just want to show a
really quick example of have a node app
here so let me open up this image board
app and so this image board app is a is
a basic node express based application
the one thing that's kind of maybe a
little bit different from what you might
expect to see in a standard node app is
that instead of just calling require
directly which is a very dynamic
API we have a sort of a declarative
forum for import and export this is
again based on the es6 module
import/export syntax and the key reason
this is important is because it allows
us to know not just that this Express
object has been has been brought into
the environment but also that any types
that live within that module that we can
we can refer to those so for instance
when I have expressed here you know that
refers to the Express module but
expressed our crate server actually
returns a express dot Express server
type and so this type was defined inside
that module and is something that we can
get back inside this environment now
this this application here for instance
uses a few other libraries so if I go
into this DB this is representing my
database connection and you see a few
things one it uses MongoDB and we have a
sort of fairly rudimentary library
typing over the node MongoDB wrapper but
you can also use interfaces for instance
to describe what our intent is for the
shape of data that lives in our in our
MongoDB database so if we're calling
some some remote i/o capability either
into a database or across to a some web
service we can we can sort of describe
what we expect the shape of that API to
be and we'll get checking against that
and it's no runtime guarantee that our
data does have that shape but it will
make sure that as we're writing code we
get the help against that and so let me
just let me just go in here and and just
show that running for a second so if I
come in here and I look at that file you
see we were we were looking at app TS so
I can just run TS c m TS it actually
goes and finds all those dependent
dependent files and compiles them and
then we can just run node on our app and
go - there we go so we have a simple you
know app running here against node saw
the great category theory talked
yesterday we you know we have books that
I like they the working categories for
the workingman efficient but basic just
simple app here that we can we can use
against node ok
so that's a quick look at sort of
although the main piece of technology
the last thing I want to show is Anders
mentioned at the end there we've we've
put all this out
open-source so the all the compiler and
the core language services that that you
would need to use to build any tooling
on top of this are available here on
CodePlex we we use git so you know if
you want to clone this you can you can
do that off of the CodePlex link and
yeah and we were doing don't have an
interconnection but yeah so we're using
we're using complex and and get for the
open source project so that's a quick
summary of what we're doing with
typescript but we definitely love to
have any questions that you guys have so
thanks thank you
I got a question over here
very cool is there a way to do modular
exports equals it's a great question
there is not currently we would love to
do something like that I think we we
want to make sure we work on that along
with the standards body the in the air
six proposals there was not yet a way to
do that either
but I think we I think in both places we
have to do something about that problem
so yeah so what's the support plan in
terms of Microsoft and typescript how
like if I wanted to go build something
that I would like to last for a long
time what what kind of commitment is
Microsoft happening
so I'd say you know right now we've what
we have out is a preview it's a point
you know Oh point eight release where
we're hoping to be at at one point oh
sometime in the next year certainly but
but we'll see you know we're putting it
out there trying to get the feedback now
we'll see where that goes we certainly
have you know a long-term commitment to
trying to make this thing into something
useful we would love to build great
tools around this we'd love to to
generally support this but you know
we'll see it's going to depend a bit on
you know how much you guys like it how
much investment were able to put into it
oh here I got two questions so um we're
working back on Bespin back in days
better-quality wrote in library that in
interference types for libraries like
jQuery and there's also dr. Jas and with
interference and types of JavaScript so
do you plan to come up with some kind of
tool way to stomp your library do some
kind of more advanced analysis and then
you create at least some interfaces that
don't have to do that yourself and the
other question is what are you doing if
you pass in so for an argument if if the
shape doesn't match so because you might
have one tie or you have one kind of
class which has this shape in for a same
argument different shape and then you do
an instance off track to do different
code passwords in the financials if
that's posture I could take the first
one maybe you wanna take the second one
for sure but with respect to a different
shape classes
the type system is a structural type
system so so it doesn't really matter
you can define the same interface
umpteen times as long as they are
structurally compatible have to say
members you can substitute one for for
the other yeah so I think maybe I got
the question that the way we would
normally solve that is with overloading
so I don't know if I explicitly showed
it but you can sort of have overloaded
signatures and so you can say that this
this function takes any of these five
shapes and those shapes can include two
different two different object pattern
object shapes effectively and then you
would implement that by having an
instance of check that split at runtime
or what you know however you do it in
JavaScript today but typically that can
be the intent can be described by a set
of overloads and that's how we do it we
don't have a union type for instance I
think the other question in getting the
types automatic automatic aliy out of
existing JavaScript we know that that's
sort of the whole point of this is
effectively that that's not possible to
do 100% correctly because you know if we
could just get all the types out of
plain JavaScript it wouldn't need to do
all this type annotation stuff but we do
think there's a lot we could do to try
to get you 50 60 70 I don't know how
exactly how far it is but percent of the
way along that process using some
automated tools kind of like the things
you mentioned and I think we that's
that's an area we're definitely gonna be
looking into as we try to help people to
create these library typing assets cool
all right we're out of time
unfortunately but you know where to find
these guys so uh thank you guys for
coming all right</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>