<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Dan Gebhardt: Give Apps Online Superpowers by Optimizing them for Offline | JSConf Iceland 2018 | Coder Coacher - Coaching Coders</title><meta content="Dan Gebhardt: Give Apps Online Superpowers by Optimizing them for Offline | JSConf Iceland 2018 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Dan Gebhardt: Give Apps Online Superpowers by Optimizing them for Offline | JSConf Iceland 2018</b></h2><h5 class="post__date">2018-04-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hr135pFCLU8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks a lot hi everyone I'm Dan I'm
here here today to help out this little
guy you probably know him the the
downest or if you've ever looked at him
on a Retina display and looked really
closely you may have noticed that he's a
bit sad lately
you see after all these years he's still
being scuttled on cactus thorns every
time a network goes down but it's not
just for his sake that I'll be talking
today a network outage can be game over
for your apps as well so let's show some
love to the dinosaur by making our apps
work offline and everyone will be better
off in the end
so a little bit about me before I get
get too far
I guess Vanessa already said some of the
projects I'm involved in ember glimmer
the JSON API spec orbit Jas I'm also the
co-founder of the web dev consultancy
Cerebrus so let's get started with a
gentle guide to offline web apps
nowadays most discussions of offline web
apps start and end with pwace or
progressive Web Apps the PWA initiative
was pioneered by Google a few years back
with a goal of making web apps reliable
fast and engaging essentially pwace
strive to provide a user experience
that's comparable with native apps while
retaining all the aspects of the open
web like shareable URLs that we love now
is a great time to start considering
pwace because service workers a key
technology required by pwace are on the
cusp of being supported in all major
evergreen browsers desktop and mobile
since reliable fast and engaging are
pretty nebulous terms Google's developed
a checklist to make these goals more
concrete including that the site is
served over
ts pages are responsive look good on
desktop or mobile any size the app URLs
load while offline highly relevant to
this talk that you can add your app to
the home screen just like a native app
and that the the first experience with
that app must be fast there are and
there are other requirements I'm not
going to go over every single one and
that's primarily because the lighthouse
Chrome extension does a really good job
not only listing those those
requirements but also measuring them and
providing detailed reports about your
apps compliance to that checklist
including its performance accessibility
and more there are also plenty of
tutorials blog posts and videos out
there that can guide you along the way
to building and improving your PW A's
like this guy like this guide from from
Google that uses vanilla Jas or other
guides that are framework specific like
this post from Matthew Beall from the
ember core team that can help you build
a 100% compliant PWA
with ember in about 30 minutes and there
are plenty of other guides for angular
react view and more I'd encourage you to
work within the conventions of your
framework and CLI tooling to find a good
match for you
for you and your app at the end of the
process all of this tooling will help
you develop the same basic elements of a
PWA which I'll review now first of all
there's the app shell which is the
Minimum Viable HTML CSS and JavaScript
required to bootstrap your app
service workers are a background script
that acts as a proxy between your
application and its environment
basically proxying between the main
thread of your app and in the network
layer service workers must be registered
by your app here's an example of of a
registration of a service worker that
exists at s WJ s and here's the contents
of that service worker this is about as
simple as you can get it defines the the
app shell resources the the URLs to
those resources and tells the service
worker to cache those resources when
there when when when the when the
absence stalled and and then the app can
service worker can serve those resources
back by proxying fetches to them here's
an example of a list of a service worker
that's listening for the fetch event and
you can customize the code that happens
inside that this listener this this one
is checking the caches to see for
whether they're they match that they
have a match of in the request and if so
the the cached result is returned if not
the the network fetch proceeds you can
also do fetch first and fall back to
cache another component of PW a s is web
app manifest which describes your app to
the browser you should link to it from
your HTML and the contents include the
name this short name description icons
that will be used on your home screen
also a background color that will be
displayed before the app shell loads so
that you can provide a continuous
experience from from the time that that
app is is opened to the time your it's
fully loaded so for our for our friend
the dinosaurs revolutionary to-do list
app we have we've added the checklist
and we're able to cross off all of the
all of the items and get to a hundred a
hundred percent compliance with PWA and
the dinosaurs happy
we've saved him from those cactuses
however there's legitimately one more
item that we could add to that list
interactivity in other words accepting
user input to change application state
and then syncing those changes when our
app comes back online for to-do app in
which you can't actually add to Do's or
mark them complete it's pretty
unsatisfying you know it's better than
nothing but not that much better
so web standards have helped us greatly
so far can they help us here perhaps
soon the chrome team introduced a new
Web API called background sync in 2015
and there are implementations underway
in Firefox edge and chrome but they're
all experimental and it may be a while
before this settles out as a stable API
and becomes in something that we can
rely on in our production apps now
luckily we've still got some time left
because we don't want to end on a down
No so if we're going to get to that next
level of interactivity and mutability
even while offline we're clearly going
to need some heroics we're going to take
that PWA to the next level and build one
that's not only resilient to network
outages but allows for full
interactivity so we need to step back a
bit to figure this out in terms of our
applications architecture
let's back way up look at the the
architecture of most web apps on the
back end engineers have virtually
unlimited processing power and access to
everything in milliseconds this is power
the the Norse gods would probably love
back-end engineering I I think Loki
invented micro-services in fact
meanwhile on the front end our options
are much more constrained and our job is
made much more difficult because of
those constraints modern front-end
engineering as I'm sure everyone here is
aware is a lot more than adding a nice
coat of paint to forms we often need to
manage application state data records
which usually is done in a layer I call
the backend of the front-end this layer
can get pretty gnarly if we're not
careful but this is where we need to
solve our offline interactivity problems
so what do we need to do to manage
offline state in this layer you might
come up with a back of the napkin list
of requirements that look something like
this need to track and queue to changes
that happen while offline
need to generate and assign identities
to records serialize and persist all
change sets and queues so that if the
browser is closed unexpectedly then you
don't lose all your users data then when
your app comes back online you need to
sync your changes back to your server
and of course that doesn't always go
smoothly and sometimes you'll need to
reconcile any conflicts or problems and
perhaps even revert to an earlier state
now if you're a developer and we
probably all are or most most of us are
here this probably sounds like a feature
list for a tool you use every day yet
and it was it was one of my inspirations
when I wrote orbit j/s which is a data
access and synchronization library since
orbit stabilized in the fall and guides
were launched we're seeing people using
it with every front-end framework many
of the core packages are isomorphic and
work on node as well orbit was
originally written in in j/s but
rewritten in typescript but of course
the packages are shipped with all the
standard Jas builds and you can use it
with either so orbits use cases go
beyond off line orbit attempts to solve
a number of problems client first
development where you're prototyping a
feature without prototyping the back end
to fulfill it pluggable sources
orbits very interface-based so sources
that share interfaces can be substituted
for each other for instance indexdb
could fall back to local storage most
modern web apps involve more than one
source of data often more than two if
you're writing an offline web app at a
minimum you have you have browser
storage and and remote server and you
probably have an in-memory store and you
might even have us data streaming in
from other sources like web sockets or
server sent events and speaking of the
MIT the main store it's really it's
really nice to work with immutable data
to to be able to fork stores make edits
and throw away the edits or commit them
back merge them back to the main store
but have total control over that process
and orbit deterministically tracks
changes as they're applied to each
source which enables the ability to undo
or redo those changes and because your
apps can work offline they can also work
optimistically even when they're online
your apps don't need to be hindered by a
delay in the request response cycle if
you're for some changes you can be
optimistic about their application and
then only handle failures as they come
up but show a success immediately to the
user
so stepping back sort of philosophically
Orbitz considers all these sources of
data that need to communicate with each
other and they are all have different
data in different forms so we need to
put common interfaces on them and we
need to normalize the data that flows
between them and they also need to
communicate with each other and that's
done through events so sources can be
wired up in in any order based on their
events and the events allow for some
flow control and this is the events are
promised off' ID and sources can engage
with other sources to delay the
fulfilment of of a request and then
through that chain of of requests then a
single a single request may not succeed
until that whole chain is six is
successful and the the get inspiration
really shows in the change tracking in
which immutable operations are stored
and tracked according to an ID just like
just like commits in a in a branches
history every source is essentially has
a branch with a history and that history
of course can grow and that can be
truncated when everything lines up but
you can always tell the state the
differences between between different
branches or different sources and and
essentially cherry-pick between the the
branches or the sources and and keep
things in sync and you know to create
new Forks or discard them
and immutable data features strongly in
this and especially in inside the memory
store which uses immutable data
structures to cache the data and allows
for which which allows for cheap and
fast forking so orbit has a lot of parts
there's there's a core a core library
orbit core which I'm not going to go
into too much today but essentially it
it has a lot of primitives that allow
for the log the history tracking and the
essentially the the async event
coordination so you could use it to say
think of it like an async redux almost
but at the data layer it gets more
concrete this is where some opinions are
layered on top of orbit to actually make
it useful in in applications so there's
there's there's a notion of a schema
that's shared among sources and that
schema defines models relationships and
keys not unlike a database schema every
single source in orbit data has has a
schema a log of transforms that have
been applied to it and and a couple cues
that can cue up
a sync requests and and sync sync events
and then there are optional interfaces
these are dependent upon the
capabilities of a particular source so
only some source you can only directly
query some sources you you can almost
all sources can sync with each other
so that these these inner the interfaces
that you would interact with most are
the the update updatable interface and
the queryable interface the updatable
interface
basically supports a single method
update which takes it takes a transform
and that transform has an ID and it can
be assigned a label so you can actually
you know could display that label if
it's queued up you could display that in
your UI you could say what went wrong so
you can attach some metadata to this to
this transform and transforms consists
of an array of operations those those
operations might be in this case they're
there we're adding adding to adding a
planet the planet Jupiter we're adding
the moon Io and then we're adding IO to
Jupiter as in the moon's relationship so
and that that set of operations can be
compounded into a single transform now
that's not very friendly to write so
there's a builder interface to make that
easier to construct the queryable
sources allow for for query expressions
to be passed to a query method and again
these could be labeled this is the the
raw form of a query expression and this
is the Builder form here where we're
requesting all the planets and sorting
them by name now something to focus on
here is that all the all the sources
that say implement the queryable
interface in your application are able
to understand the same query expressions
and so you can you can make a query
against the memory store in the same way
you can make a query against your
back-end remote store or your your
in-memory store so they speak a common
language and they have a common under
standing about the normalized data that
they're working with and to get them all
to talk to each other that's where the
coordinator comes in the coordinator
works with sources and apply strategies
to those sources for instance this is
adding a strategy to sync everything
that happens to the store to the backup
source which might be you know an index
DB source this is an example of
optimistic updating where a request
strategy is added so that before the
store is is is updated we're going to
push that same that that update to the
remote source if we had added a blocking
true to that it would turn into a
pessimistic update because essentially
this is now saying that the store won't
be updated until the remote push event
has has completed successfully so
depending upon whether you want to be
optimistic or pessimistic you can
control you can customize your
strategies and you can write your own
completely custom strategies that are
Eve you know have their own JavaScript
logic here so it's but there are just
some that are provided for convenience
of course they're things do go wrong
especially this it'd be irresponsible to
not have some failure handling in
offline scenarios or optimistic up
updating and so you might need to write
a strategy that responds to a failure
event and takes an action like this this
here is responding to a network error on
the remote source and it will retry the
queue
of actions every five seconds in this
scenario we're communicating back to the
user a failure based upon the label
that's put on an update and then we're
rolling back the the transform to the
we're rolling back the stores state to
just before that transform was was
applied and then we're skipping events
on the on the remote source so it's
basically a reset we're throwing up our
hands now we could be a lot more
sophisticated about this and do some
reconciliation we're obviously not going
to do the the same thing as a get
interactive rebase with our users
involved in choosing which which changes
to accept but but we can make put a
really nice interface on on a similar
process or we can just have some
hard-coded prior or priorities for which
which changes succeed in which cases so
you something like this might be a
fallback when when you've you've gone
through all your custom handling and
finally this is an example of pulling
all of the the records out of a browser
storage source the back name back up
here and then syncing those with the
store before the coordinators activated
an activation it basically activates all
of the strategies so that orbits
coordinator starts to watch everything
and keep it all in sync so getting back
to PRP lwas and applying orbit to keep
them interactive what's what does that
look like what's our strategy here well
the orbit PWI still needs a
serviceworker it needs to handle cashing
and fetching of the app shell resources
but it does not typically intercept API
fetches because those can be queued up
by orbit on the main thread or on a
worker thread they don't need to be
proxy dat in the serviceworker you might
have sources like a store a backup
source which probably would be indexdb
and a remote a remote source maybe a
json api source you might even want to
add you know a real-time source like
like sockets were server-sent events and
then the process for booting in orbit
PWA the app shells fetched from the
serviceworker went offline the stores
populated with data from backup like the
example I showed earlier and then the
coordinators activated and all the
strategies are are activated along with
it so orbit can keep monitoring things
and those strategies might be something
like this everything that this every
change to the store is synced to backup
every every change that happens that's
observed on the remote source syncs to
the store every time the store is
queried a request is made to the remote
source and same with updates so all of
this allows us to finally check off that
last item on our to-do list and it also
allows us to add a whole bunch of more
items a whole bunch of more capabilities
for our app whether it's offline or
online
and I think the dinosaurs happy if
you're interested in orbit the guides
are at orbit J s comm I'm still working
to fully flesh out the site but I hope
it can get you started and please feel
free to follow orbit on Twitter if
you're interested thanks very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>