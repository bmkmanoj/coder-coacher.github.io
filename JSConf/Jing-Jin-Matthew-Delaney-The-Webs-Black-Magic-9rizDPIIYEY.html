<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Jing Jin &amp; Matthew Delaney: The Web's Black Magic | Coder Coacher - Coaching Coders</title><meta content="Jing Jin &amp; Matthew Delaney: The Web's Black Magic - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Jing Jin &amp; Matthew Delaney: The Web's Black Magic</b></h2><h5 class="post__date">2012-10-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9rizDPIIYEY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning good morning so yeah thank
you Jed as Jed said we're basically
gonna take a quick look at some tips
tricks and hacks that you normally use
in the web but as viewed from within
WebKit
right so this is kind of a culmination
of a lot of discussions we've had with
people over the past few years we've
notice that they're doing certain things
and and realizing maybe like that the
engine can kind of do different modes
depending on like what you know kind of
little tips they use but we realized
that a lot of people don't quite realize
what's happening inside the engine when
they do that sometimes too bad effects
or sometimes a good effects so it's
basically a talk where we can take a few
of the really popular ones that we've
seen where people seem to have a lot of
misconceptions or misunderstandings of
what's going on inside of the engine and
we're gonna look into them to actually
show you what is going on right so so
Jed give a little introduction so again
I'm Matt and this is Jing and so we just
left apple early is here and are
starting her a little company together
in the Bay Area so if you see us around
you can talk to us later more about that
but we basically work together on the
Safari and WebKit team for the past few
years yeah that's better what else so so
to start off they're basically a few
demos that we had made to to kind of
illustrate the points of what these tips
tricks and hacks are that people use but
we realize demos are kind of boring
right because if we could have you know
synergy in our talk or whatever right
then then they'll be great because
everyone loves synergy so like let's
make a game out of these these these
tips tricks and hacks let's put them all
together in like one example it's fun to
do so basically last night we were kind
of scrambling to do all this and fit it
all into one so we came up with a little
simple game that we like to call Verta
fall and so a little play off the German
word vert which means words in German
the simple game that we made was was
essentially you might be you see like
these words falling from the top of the
page right so maybe like chocolate
cupcakes or whatever and your objective
for the game is to go through and type
the words as fast as you can so for
every one that you type and you get
right you get some points for the
right so if you type cupcakes really
fast before it hits the bottom of the
page and disappears then you get like 80
points or so and so on and you're kind
of just you know going against the clock
to see how fast you can type all the
words so those a little fun little
example that kind of brings together all
of our all the things we want to talk
about and so we'll so I'll show you in a
second what that game looks like
basically it's about like 2:00 a.m. last
night right and and we're totally
freaking out because we need to get this
all done before tomorrow so we know that
like there's only one way we can
possibly you know get this done in time
because we need to meet male right at
the super awesome raver Club like 5:00
in the morning he's talking about so so
it's like you know it's just it's game
time right we have 2 a.m. until 5 a.m.
to get this done and then we have all
this like super partying at the club
until 9:00 in the morning and then
breakfast now and if you have any clue
this is why we're so tired right now
this is this is a true story so there's
only one way you could possibly do this
in time right so we know we need to get
to bombers peak right so so to
illustrate such a thing we're gonna do
that right now we go through Hey Cheers
this is true story
okay so this game that we're saying
right the the words are falling from the
sky as they should be right and we're
trying to take them as fast as possible
however we get it the game done and all
of a sudden it's not working of course
you know cuz we're total noobs and so
the very issue they run into the very
first issue we see is that got it is
that all the words are not there Mart
not there right they should be they
should be basically flowing there from
the top because we have a little
transition it's like you know going from
the top at the bottom and then sliding
them down
however it's not working baby like are
stuck somewhere right so to go to look
at the code for a second and jiggle
explain what we're doing here
alright so basically in our code we have
these divs that have classes word and we
want to do is start them off at the top
of the page above the top of the page
and then I have them animate all the way
to the bottom so what we did here was
basically have like call this function
called dispatch word that crazy word
element inserts it into the Dom and then
changes the top position to the height
of the screen so we're thinking about
this last night and we're like oh wait
we're people on the web saying something
about like you need a set timeout zero
between like inserting something into
the DOM and changing its property or
else like the transition doesn't take
effect or something so so we're like
okay let's try this we changed our code
to basically do a set time at zero and
then set the final top position and
they're like okay let's try this out see
if it works and it does whoa okay you
know our game works we're well on our
way to partying and we're also making
our way steadily up bombers peak which
means we got super distracted who were
like why do we even need us it how about
zero I mean we have like one CSS value
the next one why can't the browser just
do it so we went online and we looked up
the definition of how transitions are
triggered in the spec so though the w3c
spec says when the computed value of for
property changes then then the engine
starts the transition so we know a
little bit about how web browsers work
so when you're running your JavaScript
code that each chunk of your code is
actually
run in a single run loop inside the
browser and the browser kind of like
manages one to call these wrong loops
and in between these wrong loops then
the browser does like whatever it needs
to do to actually you know render your
page respond to system events and
anything that's not directly in your
control so one of the things that the
browser does during this time between
your on loop is to update all the Styles
you've said and layout so that makes
sense because when we have a set timeout
zero we're basically saying we're done
with the first round loop do whatever
you need to do in the browser and then
and then do whatever we said later so
that's why it works awesome okay so
we're done with that and we're like okay
we want to go party with a little party
let's try playing this game huh there's
like this weird stutter when they type
this this is to slow some reason every
time we're pressing one letter it's just
absolutely slowing down so this is not
good either right so I know that the
animation works fine and it only slows
down when I'm typing so it must be
something wrong with my event handler so
I go look at my event handling code and
this is the function I call basically
every time you type a letter I go
through loops through all of the word
elements in the page and then compare
their inner text to see if it matches a
letter typed and if it does then I'll
just like change the class name which is
that some styles on there that
highlights it so as I'm looking at this
I start remembering there's this talk on
YouTube oh it's it's all Paul irons just
talk about how accessing some values in
the loop could cause reflows and slow
things down
actually now now I really remember it's
our Texas one of these properties that
causes a reflow so I think the tip was
to access all of your values at the same
time and then set your values at the
same time so I changed my code and now
I'm running two loops the first loop
gets all the inner texts and the second
loop just access there's a local
variable instead of asking for for it
from the element
so let's run that code yay
no it's responsive so breaking out that
pattern so that we do all the all the
gets of the intertext and then all the
sets have to right then we're avoiding
all of those reflows so so now we see
it's so much smoother right so of course
yeah so it again since Matt's still
holding my beer over nearly at help
farmer speak and we're like you know why
are we causing these reflows I'm just
asking for some text from the Dom so we
decided to actually just step through
this loop and look at what's actually
happening in web kids
C++ code so I put a breakpoint inside in
our text and this is the function that I
see you see that the first line there
says call um a document update layout
ignore pending sow Jade's super alarming
so I'm like what is this thing actually
do and then I kept stepping through the
stepping through I'll save you guys have
a pain of stepping through like 20 files
but at the end it comes down to calling
recalc style on the document so I go
into recounts out and this there's this
this is like this huge function that's
like three pages long and it does what
it says it does it recalculates the
style if it needs to be recalculated but
the most interesting part is that near
the end of it if the element actually
loops through all of his children and it
says if any of my children needs it cell
style recalculated then I also had to
recalculate my style even if I didn't
change so I'm going through this loop
asking for inner tags and going through
all this logic why I haven't changed
anything so this doesn't really trigger
anything okay let's see what I did next
so the next thing I did is I changed the
the class name to something else so
again I could webpage at work here and I
see that it's function called class
attribute changed got called and there's
a whole bunch of stuff it's supposed to
do but at the very very end it says sent
me style recalc which sounds like a
might sugar the thing which I saw
earlier so to help me organize my
thoughts I kind of graphed out
looks like so I had the document root
documents elements and then I had this
gain container that contains a whole
bunch of words and I just went through
the first word and set it style so the
first word has a dirty bit for if the
style needs to be recalculated so now
I'm on to the next iteration of my loop
I'm looking at the second word and I'm
asking the second word for its inner
text and as you saw earlier when you
asked for inner text it triggers all
these function calls that go to recalc
style so the document asks do I need to
recalculate my selves and it's like oh -
my children need to recalculate their
styles and the game says do my children
need to recalculate their cells and the
first word says hey I need my style
recalculated so the first word does its
own layout calculation things and it
goes back to the game and the game says
well one of my children has a style
recalculated so I guess I had to
recalculate myself - so what this
actually caused in my game was that
every single time I asked for inner text
the game element was relating out all of
its words so if I had n words I will
have n loops and inside each loop I will
really out in words so it's like
exponentially expensive to have the
accesses in the same loop as the setters
so that explains why I need to access
all the values first and then and then
send all the values so now our game is
pretty much done actually to couple that
point there for a second um you might
ask yourself like why is why does like
the browser have to do all this work why
can't it be as smart as my JavaScript
loop could be just to like cashless
values essentially and then we're
getting the big discussion of like if
you look at the the way you like style
resolution and everything works inside
of the browser it's it's obviously a lot
of really complicated CSS rules all
implemented right so there have to be
some places where we can do that sort of
thing where we can speed things up but
in a day like we don't really know like
what you're gonna do next in JavaScript
right so so a lot of cases where it's
just not worth it to possibly save
around like every intermediate you know
intermediary value between it so
basically the take-home message there is
like you just kind of accept the fact
that like this is the current code so
this is this is what you have to deal
with on the platform right
so so even the best things that can be
done in the future they currently don't
exist so it's just you know limitation
of the current implementation basically
but yeah okay so so we fixed that right
and we've we've understood that one but
now like we're looking at it and and if
you can see like like keg is kind of
just shaking as its falling down it
doesn't really look that smooth right
and since the perfectionist that we are
we want this game to be really really
smooth right so so we get so we um you
know we remember this we remember this
um this tip that someone told us before
right
that was like use like translate z0 on
elements when you're animating them
because that like like sets hardwork
celebration to happen or some such thing
right so you can get these awesome crisp
animations so on so recall this and
we're basically on we go to use this
this little hack because it sounds great
right so so it boils down to before we
had a WebKit transition you know on on
top so that it goes from you know top at
zero all the way down to the height of
the page but instead now we just added
WebKit transform with the translate Z
initially zero and then later we add
translate Z and trans like Y so it goes
down the page so same exact effect just
using transforms now as opposed to using
a transition on the top and this is the
trick that everyone uses that should
hopefully like hardware-accelerated my
you know animation right so let's check
it out let's see if it works yeah so
that's buttery smooth right so this is
the effect that everyone goes for and
it's it's like the holy grail of making
awesome animations right you can't live
without this if you're trying to this
sort of thing it seems but why doesn't
like the browser you know do this on its
own right like we're we're curious like
what's going on here so at this point of
course we're totally like a top Ballmer
peak right we are even like jumping over
the top of it high-fiving right we are
so curious about what goes on the engine
and so we start to so we start to ask
the questions right like why doesn't the
browser always do this why don't I just
always do it in my page like every
animation I do why don't I just add like
translate Z zero because that would just
make everything better right well not so
fast right so we start by looking into
the engine
and seeing like what's going on when our
curiosity is getting better us here and
we realize that there's some some some
machinery being set up we're now
entering this thing called like
compositing mode right so web kids
dropping into this code that it wasn't
in the case before when we were
transitioning just on the on the top
element and so so it seems to be
entering this compositing mode we're
setting up all this machinery right it's
creating these like layer things and you
see a lot of code paths that are now
being used that are like if step between
accelerated compositing Flags there so
what like what is compositing what is
what is this accelerated notion where's
that hardware acceleration coming into
play and whatever happened like talking
about Hardware accelerate rendering so
understand all these concepts we need to
quickly just do a little segue to give a
graphics 101 to understand this concept
of what's going on with accelerated
compositing so in the next five plus
minutes I'm going to try to fly through
rendering from top to bottom as to how
it works especially in the lens of how
it works in our rendering engines such
as WebKit and hopefully I trick you into
understanding how accelerate compositing
works all within breaking neck time so
so let's start so so compositing and
rendering or the two different terms
we're talking about here right normally
hear people talking about accelerated
rendering but what does that mean well
rendering is the overall process of what
we're doing here we're compositing is a
sub step of it so we have to know what
rendering is first we can talk about
compositing so as its define rendering
is generally the process of taking a
model and and rendering it into an image
so by an image I mean like you know a
bitmap image or you know an actual like
2d array of pixels this just a little
chunk of memory in the end right and
your model in the case of WebKit and a
rendering engine for the browser right
is just basically your Dom plus CSS so
so your model is simply that Dom that
you give us in the CSS and WebKit does
the job of simply taking that and
translating that literally into an image
right and the end of the day I'm going
to grossly oversimplify this but I let's
say that that image at the end is just
called a frame we'll just use that term
for a second and we'll say that
once we've generated that frame all we
need to do is give it to the GPU and my
graphics graphics friends are totally
gonna kill me for over simplifying this
so much let's just say it's simply the
job of the GPU is to take our frame that
image that we give it and it makes sure
that it appears in the screen okay so so
cool so so we don't to worry about
anything after we've generated this
image we just need to generate that that
like actual set of pixels right so how
my WebKit go about doing this process of
rendering well a very simple and naive
approach we'll go through in a second
with a simple example to see how we
could do it just in a very simple sense
so let's consider a very simple system
where we have a say a small screen and
we have a very simple page and so the
page is about 20 by 20 pixels and on the
body we just basically have one color so
one big color background we have one
child that's the square div and it's
just ten by ten and it has one
background color right pink so these
like simple squares going on here and
then in within the square there's like a
bunch of like little divs we'll just
call them little J Estes you'll see in a
second that are at all just a bunch of
little white pixels essentially and it's
gonna look something like this so right
so if you have that background square
and then you know the it's Cayenne and
then I'm sorry on and then we have this
pink one and then the white dots so how
might we go about like creating this
right if we were just given that Dom and
and we need to make it into this well
the first step may be to go through and
paid from back to front so we would
basically fill in the pixels of this
like frame thing right this image one by
one where we put in blue blue blue and
then eventually strap late you can go
fill it the whole thing and the next
step that we could do is to go to that
next child element that ii did that's
square it's pink and we fill in you know
just fill in the pixels boom boom boom
the values and whole thing or curse
again to the children and we go through
when you fill in all the for the J and
the s and that's that's pretty simple
right so that's essentially what boils
down to the process of rendering that's
pretty simple naive approach of how to
do it let's think about for a second
like how many operations we were doing
do it in this naive approach basically
we had that twenty by twenty square so
in the 10 by 10 square and then seven by
five that we did on top of that so this
results in about five hundred and thirty
five pixel fill operations so that's the
kind of like I'm out of time it would
take to generate every one of these
frames right but we know like the
average screen goes about at 60 frames
per second so multiply this out and
we're looking at for this tiny screen
32,000 operations to do this per second
right so for the modern CPU this is
obviously no problem to do however if
you consider like a much bigger case you
can imagine this can start to get really
expensive right so like a maybe map air
screen where you have nine nine nine
hundred five you know 1440 now you're
talking about a lot of operations like
just over you know close to about two
million so that's simply just amount of
time it takes to fill in these pixels
right but even worse I
oh sorry right so that's a person for
frame and then overall you're looking at
102
you know million per per second
operations have to do for that so be
considered like that a an average system
is is doing a lot more things than just
rendering this is a lot of time to do
this naive approach you have a lot of
room programs going on different windows
bunch of tabs open you're talking about
a lot of different people doing this
amount of work and that just becomes too
much doesn't scale and if you consider
even worse you're looking at about 600
megabits per second like for just
pushing this one set of frames from from
your screen over to the GPU which is
just a ton of data transfer we can just
totally bogged on the system right so so
basically this doesn't quite scale right
this this is not a good approach we
can't possibly make fast webpages with
this so in comes the role of compositing
right so so basically in that first
approach there we were we were just
running through and and kind of doing
all rendering as like one pass right but
compositing is this notion of breaking
up a step of where you're you're
combining visual elements from separate
sources into like one source so so we
were kind of doing this implicitly
before when when we drew from back to
front we did like the the one color the
next color over top we were
by the by the method of drawing we were
actually implicitly compositing
appropriately so so instead let's break
this up into two different steps two
discrete steps right so the first one is
drawing and the second one is
compositing like I said so in order to
do this we need to be able to take every
element and give it its own little
section of memory that it can do the
drawing into initially and then we'll do
the second step that I'll explain in a
second it's compositing which is the
process of combining all of those
separate images into this one that we
need to give over to the GPU right so so
let's start by looking at it we had like
that we have the three different look
call them layers so these are basically
like a little like off-screen kind of
frames per element that we're giving so
our Dom was pretty simple we had that
you know the body we had a little pink
layer for that background div and then
and then we have this j/s layer which is
just a bunch of those little divs that
we're just the simply the white dots
right so so we have here is it's
basically these chunks of memory that we
needs drawing as our first step so we're
gonna go in fill is in like before same
process we go through you know the cyan
dots and then all the pink dots and then
the Jas ones and now that we have these
layers we're gonna do the second step
which is compositing so this is simply
the process of taking the contents of
the one layer and copying into the other
and instead of going back to front here
we're doing now front to back so we take
the like the foremost elements that
would be in the front of the page so
that is an example here we take all of
those little divs that make up little J
s dots and we are literally copying
those into the pink one so that we
composite it into the pink one in the
right location right so it's simply just
a copy and then we copy that pink one in
to the appropriate location be
composited into the into the overall
body and now basically the layer of the
body finally has the contents inside of
it that we need to give over the GPU so
you may be asking yourself like what's
the point of this like we just allocate
a bunch of more memory and did just as
much work but we
you know didn't gain anything but you
have to consider what happens when
things are happening first at a larger
scale you have a lot of things you're
drawing on your page and perhaps your
even you know adding effects like if you
scroll literally the elements are moving
around or you do an effect like you just
saw that's a lot of if we were do that
repaint every time we were literally
like an old method of just simply
rendering in one pass
we were redrawing or frame like over and
over and over and I said before you know
600 megabits per second like throughput
to the GPU all of that that was a lot of
time so in this compositing path though
we can instead skip all that rendering
compositing that we did for that pink
layer and we can just use the contents
of that layer and recompose it in two
different locations in that overall blue
layer right that's hot most layer so
that basically saves us a ton of work
every time we can go a bit faster here
so they're obviously trade-offs we have
allocated a bunch more memory to get
some speed ups and how we do things
so of course memory is not limitless you
you definitely have you know a kind of a
trade-off of how many layers you should
be allocating dependant on you know how
much performance you need perhaps to
like speed up the rendering so it's
important remember this now now keep in
mind at this point the talk we haven't
yet talked about hardware versus
software we basically everything we've
been doing to like do this rendering and
this compositing this drawing has all
been happening you can just do it in
software like any program could do this
right so so now it's interesting to
consider how might we use the hardware
to speed up some of this stuff well
first like let's think about like what's
slow here right so CPU rendering takes a
lot of time that's what we were just
doing just in software just filling in
those pixels right as we know them
that's a ton of operations right the
second part was this really expensive to
eventually take that product and push it
over to the GPU that's just like copies
are really expensive to go to the GPU so
we want to minimize those things
altogether right
so luckily if you look at any like
graphics hardware you always see like
there's some sort of amount of megabytes
that the card has well that's the GPUs
memory right so so what's the point of
this memory like how could we use this
here well if you think back to our
process of doing you know the draw
the layers and then compositing step
that compositing step had a bunch of
these just chunks of memory these layers
that we've generated and not really
changing they're kind of just there so
what if we instead copy them over to the
GPUs memory so we say hey JP you GPU
hold on to the east right we've just
drawn these cool so we draw them once
and give them to them and then and then
so while we need at this point to to
basically finish the process is if we
just had a way to tell the GPU hey take
these layers right and squish them
together because that's like the last
step right well luckily this is exactly
what GPU is designed to do incredibly
well right so these textures that you
have on the GPU GPU acts like a
compositor for us because we give them
the simple lightweight commands on any
given frame that we're drawing to make
like say our animation around the screen
or scrolling we're saying hey take those
layers and rearranged like recompose it
that that pink one to be on the blue one
in this next location next location next
location that kind of communication is
really fast copying those frames every
time not fast so this is something that
the GPU is designed for it's a great
sandwich maker and this is basically
yeah this is basically this is
accelerated compositing this is exactly
what we do in WebKit this is the process
so back to translate see right so what's
going on here with translate C well it's
doing exactly this it's kicking us into
a mode where we start doing it in the in
the second fashion where you start
allocating these layers for things that
you translate zeon because we we can't
afford to not handle this 3d case where
you need to do it or else it's just
incredibly slow so we jump into
compositing mode we start allocating
layers so those things you give
translate Z 2 which means that they also
start to have all this extra memory
right so this is kind of like the it's
like the be careful message right this
is where you're walking with the really
heavy stick when you start translating Z
on everything but of course you can get
really fast
yups if you're doing the kind of thing
that would basically be draw once in a
layer and move it around the page
because that hardware compositing is
what works really fast right in this
mode cool so let's go back to our
example and use a little thing called
WebKit debug borders so check out what's
going on in our example when we added
translate see
so those words are following really
sweet from the top and so now we see we
see that like every single word has this
debug board around it now I'm not gonna
go into too much detail about this but
this is basically a little debug mode
that we have in WebKit to look at which
elements on the page are actually
getting these layers so they're so
they're actually getting memory assigned
to them that they get to draw into
that's reserved for just them and then
it's also backed by GPU memory right
that we that we use in order to do this
accelerated compositing last step so
obvious you can see this like a plenty
of things in the page that are getting
these these little green boxes however
we're doing this well because we're not
overusing them there's nothing in the
page that's like getting these layers
that doesn't need it to like all the
words in the background for example so
this is a perfect sample of how to use
it correctly and yeah so by the end of
talk here
and so just as like one more point right
is if I guess for fun if you if you
consider like ways to minimize the usage
of it use it just for the kind of cases
where you're doing those things that
would would benefit from accelerating
accelerating the compositing and you
could even get like really nice effects
like this in page so we kind of made a
different version of the game where
we're just really taxing a lot of things
being moved around and we have a little
bit of time left so so yeah so that was
a quick run-through of how accelerated
compositing works in WebKit and and how
rendering in general works in a in a
browser I don't have any questions
so the other browsers don't have this
problem
why does WebKit have this problem where
they need to create a new layers for
every hardware accelerated thing which
problem the the the other browsers like
have one layer and they Hardware
accelerate everything on that at least
according to their tech Doc's well right
um they may be accelerating like the
actual like body that all the time which
essentially is kind of always the case
because you always need to have some
sort of reserved chunk of memory that
you eventually draw into the ideas if
you are using intermediary chunks of
memory right like little buffers along
the way to do part of the drawing into
which anyone does when they're doing
this compositing right it's when you
choose to do it is perhaps what's
interesting
so something web has a problem it's it's
the thing that solves the problem of
doing it faster yeah that makes me sense
so you showed the example where you're
accidentally triggering the hole reflow
in the loop how can you how can you tell
that you're doing that or how can you
it's a sort of way to see that that's
happening you know all you can see is
the performance sucks but right yeah so
so of course you can always like try to
be cognizant of that but at the end of
day like when you're debugging the the
biggest tip is to go into the into the
web inspector and look at timelines if
you want to spin yeah I'm so in the web
inspector you can look at the timeline
of layout and rendering and when you're
triggering all this reflow what you can
see is a lot of life we layout really
our layout we layout in between two
renders so you really ideally only want
to do one real layout before one render
another good way for this specific cases
that you can actually find this online I
think several people have talked about
it or blogged about it they listed all
the values that would trigger this tree
layout and they're called computer
values in WebKit and if you look for the
earlier function I show like update
layout ignoring blah blah blah if you
search for that then that pretty much
lists out everything that you need to be
cognizant of not using too much
all right I think we're at a time we're
gonna have a break now and come back in
ten minutes so thank you guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>