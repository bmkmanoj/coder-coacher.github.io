<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Denis Radin: Rendering HTML via WebGL | JSConf EU 2015 | Coder Coacher - Coaching Coders</title><meta content="Denis Radin: Rendering HTML via WebGL | JSConf EU 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Denis Radin: Rendering HTML via WebGL | JSConf EU 2015</b></h2><h5 class="post__date">2015-10-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9oGQucDOaoY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Okay, so I came from Amsterdam and so seeing
the party is near in an hour, I'll bring you
some legal
stuff.
Legal stuff!
Who can guess, legal stuff four
characters.
JSL is basically a way to intercontact with
GP and now we have WebGL, and we'll talk about
HTML
library to render HTML CSS content, we have
WebGL to the
performance a bit.
In Amsterdam, I work in a company
called UPC, maybe famous in Germany and in
Amsterdam
Ziggo, and we do set-top boxes for millions
of users, we
deliver the boxes with JavaScript UI, the
operation
system, and basically performance is quite
extremely
important there.
So everybody want to have a snappy UI
on their set-top box when getting movies,
etc.
Device
is pretty weak, I mean it is comparing to
iPhone, and if
you say okay, I don't care about this, your
set-top box,
why should I take care about performance?
Because there
are a whole bunch of mobile phones and mobiles
who want
to have snappy 60FPS performance, also about
performance, it is not only the thing because
performance optimisation is not the thing
that makes the
application faster, but also it allows to
make things
which are not able to do before.
As the illustration shows, the slow turtle
can jump,
but rabbit, having a bit more speed, can.
So more
speed, more possibilities.
Basically you can add the
effects.
Okay.
The problem of HTML and DOM is that DOM
is quite complex model, it is quite slow.
I mean have
you ever tried to inspect DOM elements?
There are
hundreds of properties.
A lot of events never change,
like you touch one DOM element in document,
you have
referral chain effect and that's it.
You got a lot of
compilation to do just the one change.
So tomorrow is
slow, let's consider how image is going to
be displayed
in DOM and in canvas.
So for DOM, you need to create
image text, file, and Jim tag to DOM to calculate
styles
which calculate position based on the styles
then
display image.
Okay, but for canvas, it is much less.
It is load and image, display image.
So even GPU DOM is
slow, because it changes the only how image
is being
displayed, so DOM still stays this complex
model still
stays, and yes.
DOM is hardly predictable.
Browsers
are quite smart.
Too smart sometimes.
On the diagram
there is the same components been render it
in DOM, and
canvas, which is the engine which allows to
render to
switch from DOM to canvas and what we see
is that in DOM
it is hardly predictable, you can hardly predict
when
browser will render.
In canvas you say &quot;render please&quot;.
You can say once per frame, or once there
are two
frames, etc.
You can tune FPS as you wish, and you
really know when you render, when you change
content.
DOM browser do everything for you, so basically
it is
hardly predictable.
So HTML, the library we're talking about now,
doesn't use DOM, but only when it is animated.
When it
doesn't, it is still inspectable, so it is
quite easy to
develop, because you still have three, and
inspect
option.
Also, yeah probably, you can recognise this
one is
a GPU.
Everybody in this room, I suppose many, many
people in this room, already been a bit annoyed
by GPU
render, GPU, but yes, still we issued.
You should
understand that it is quite a powerful unit
to display
graphics, and this one is kind of professional
GPU from
now some radion with bunch of memory to GPUs
to graphic
processors and so on, but something similar
you have in
any device you can get.
Almost.
Any form, any PC, any
mac have G pin side, and even if iPhone GPU
is powerful
as PCs, you play Counterstrike five or ten
years ago.
Ifen is pretty powerful in terms of GPU.
Everybody
watch this movie, probably.
Who watch this movie?
Should we watch it?
Two people?
Three people?
Who?
Okay.
Should we watch it or not?
Yes.
So this movie
shows the difference between GPU and CPU.
Now it is not
our sponsors.
Who wants to figure this out after its release?
Wouldn't it be nice to discover and fix vulnerabilities?
Say hello to checkmarks it scans --
Is there anybody from Relic?
Come on.
I'm a nerd.
So this will show us the difference between
render
and CPU and GPU.
One after the other.
And three.
This robot emulates CPU, it puts every pixel
step by
step, it calculates which pixel it should
be, the
colour, where it should put it.
So a lot of
considerations on every step.
This one is GPU.
When it goes through all 3,100 of these tube,
into
these tube in which of the bottom of which
is a paint
ball, which is 7 feet of space and in eight
milliseconds
reach its target, hopefully, when it is all
said and
done, it is going to paint the Mona Lisa ... five,
four,
three, two, one.
(Laughter)
Ladies and gentlemen, science class is now
over!
DENIS RADLIN: Thank you guys.
Yeah I suppose the
difference is pretty big.
If you have seen before GPU
is a hardworking kit which is put in every
line by
a pencil, and CPU is another kind of kit using
stamps.
And if you use stamps you can get it more
effective and
much faster.
So modern CPUs can possess millions and
millions texture in surfaces in a second ... it
means
millions of HTML elements like textured surfaces,
we can
compare, yes?
Cool.
Why so many?
Because for some
things it is still not enough details, but
we can use
this in 2D, and yeah, if you have a look at
the power we
have in our PCs and Macs, it is pretty amazing,
so let's
try to see what CPU do in modern games, because
WebGL
and OpenGL is basically being used in modern
games and
the same technology you can use to render
HTML and CSS.
The hand of this guy consist of about 50,000
textured
surfaces.
It means you can run 60,000 of HTML elements
animated, with special effects, but the question,
the
same stuff, they can do that, run all this
effects,
bunch of surfaces, bunch of images at 60APS.
Why?
Simple: slider janks.
Now, because CPU is not involved, sometimes
and it
is quite complex.
So changing one thing, you're making
a massive change.
Chain effects, and still we can move
away from DOM and use OpenGL by using a wrapper
on the
OpenGL.
I don't know how many of you know about that.
And now we can check how performance that
GL is compared
to OpenGL, so would we be impressed by the
performance?
So let's release bunnies.
This one is a very simple
benchmark, and now we have two bunnies, like
every
bunny, to make it clear, could be compared
to HTML
element.
So now we have two bunnies running at 60FPS.
It is cool.
Two HTML elements and we added them.
5,000
bunnies, 10,000 bunnies, 50,000 bunnies, 30,000
bunnies,
still 60FPS, 50,000 bunnies.
Okay you guys.
FPS drop
a bit.
Now still 60.
I mean already 80,000 bunnies.
So could you imagine, you can animated 80,000
of HTML
elements at the same time with WebGL, and
I suppose
nobody even can imagine to do that with DOM.
But yeah,
now it is possible.
A lot of bunnies.
Yes, so why
don't we use WebGL for web content?
It is a bit tricky,
basically.
So if you compare HTML, we are coming to
this WebGL, we'll see that it is not that
easy so
display, but any with WebGL, and basically
it is not
even played by WebGL, it is 3js, it is an
engine which
allows to make everything in easy simple way.
So yeah,
it is plain WebGL, it will take five times
more.
And we
are lazy, HTML developers, we can't do that.
Basically
it is sad.
But here HTML GL changed the game.
It is
pretty simple, you can just drop your content
with HTML
GL pack and your contents are rendered in
WebGL.
It is
easy to use.
You can use it as JQuery, if you want to
meet all the things WebGL and query, and yeah,
also you
just animated.
It is as simple DOM element.
You can
put some listeners, or etc.
So how it works?
When browser meets HTML GL
element, it restores its texture, basically,
to element,
and then can put it to a full screen WebGL
surface.
So
it's being displayed, and if something -- do
I have
a laser here?
Yes, green one.
So if something changes,
there are two ways to go.
The first one is if content
changed.
I mean, if you change the font or colour,
so
you need to restore once more and display
once more, but
if element was transformed, rotated, so it
is very cheap
operations you can do on GPU.
So these transformations
animations being made with GPU on this WebGL
or
presentation of this WebGL slide, basically
it is
extremely cheap and fast.
So HTMLGL relies on DOM observers.
So it is to
react on document change on element change.
It relies
on HTML to canvas, and it relies on to render
the bit
seen here is HTML, it is basically a bottleneck
because
every restoration takes about 150 milliseconds,
so it is
quite expensive.
And if you ever map the need to
rasterise content, and you tried HTML to canvas
you
found, guidance there should be a better way
to
rasterise to canvas.
Please share the work, our trend
to make rasterisation API, then get canvas,
we only have
a polyfill as HTML to canvas, but in browser
it could be
much more performance and less buggy, and
there is an
article on my block and basically a draft
proposition
and on spec.
So if you're interested in rasterisation
API, please help you to spread the word.
Let's go to some building.
You see simple HTML, you
have.
So we have HTML GL element.
Nice.
But the issue
is that this one, this page, it doesn't include
HTML GL
library, but it is still valid HTML.
It is basically
a custom, it could mean nothing or it could
mean least
render to WebGL, so in this case it means
nothing.
And
pushing the animated button, we see that at
the H point
browser make a decision to rasterise text
once more.
So
let's repeat.
Look at the edge point, we see the image
is a bit blurry, and then browser seems okay,
let's
rasterise.
That's basically what I said: the browser
is
predictable.
WebGL allows to avoid it.
Let's move to the same
demo but basically it is absolutely the same
HTML, but
HTML GL library is included.
So yeah, if you press the
button, the same happens, absolutely the same
JavaScript
code animates, but basically we control the
authorisation, we can rasterise manually,
but we may
respond to it later, but yeah, we control
rasterisation
and we useWebGL to animate that.
Let's try to change
content and layout, so sends to the observer
all changes
you are making a note, so you are changing
in HTML or
whatever, they are being cached by HTML GL,
and not has
been rendered, so we don't care about that.
So let's proceed to the next example.
Small, more
complex, and basically this is one of prototypes
we did
in liberty level, some list of movies.
And it is
slides, basically.
What we see here, that nodes are
still on the same place, so when we animate
we only do
it on WebGL or presentation.
But actual nodes take
place, and still everything is expectable
and we can
change the content.
So WebGL, but it renders.
Also,
it's nice to mention this demo, even we click
on the
WebGL presentation, not on the node, you can
still use
the events in the same way you use them in
the HTML.
You basically click on it in listener, everything
is the
same, you still use your DOM amount as HTML
presentations.
And this one, in previous, was possible
to implement in DOM or HTML GL.
The next one is HTML GL
scene.
You can't do this with DOM.
So we have some
filters on that.
Yes, it is kind of displacement.
We
can add more, but still what is nice, it is
still HTML
content.
You still can inspect that, it's too much.
But you can apply all kind of shaders you
can expect
from OpenGL, just a bit more.
Just nobody will be
impressed by blue nowadays, but okay, we have
blue, we
have any kind of modifications.
Okay twist.
Still HTML
content.
We still can inspect that.
And basically,
yes, we still can change a content and talk
to our
content as come to it.
The next demo is quite -- could be useful
for phone
cap users, and it basically shows how you
can work with
effects, how API is built.
Yes, it is nice effect.
It
wriggles.
So it is simple page you can build with
display line or whatever, just some ideas,
you have
a regular effect on that, but the effect has
been
applied, effects attribute.
Let's add some more, let's
add some noise.
Pouffe, we have some noise.
Let's move
it to mobile, I suppose it is going to be
a mobile,
let's add there.
Pouffe, we inverted the colours.
Let's add some contrast.
I mean it doesn't look like
our initial HTML, it is basically was modified
by using
a shaders, yeah, my favourite one, twist.
So it's still
HTML guys, it is still ... yes.
You don't need to study
reconceptions, everything is you are coming
to.
So you
can add effect as a plug-in, and you can add
your one.
Have you ever heard -- no, I don't think you
have.
There is a shader, it is a website where you
can find
whole bunch of shaders like pre-defined shaders,
any
kind of effects, effects of skies, sun, and
I don't
know, heaven, hell, or whatever.
I mean just any kinds
of effects you can imagine.
You can modify your content
absolutely in any way you can imagine to.
Basically,
all power of CPU which is being used in modern
games to
service to modify your web content.
Yeah, of course it is open source.
And the nice
thing it is really agnostic, so you put your
HTML GL
tech any way you want.
So any in framework.
But there
are some bindings for ember and there is a
link, and
there is a binding for WebGL.
So yeah, we use it
together with react as HTML GL tech or use
react GL
bindings like a component.
All this stuff, the
concipiens of my work in liberty global is
set top boxes
on UI for them, and challenging native workshop,
and
that's a workshop on making performance web
applications
which are able to challenge native ones.
So if you're
interested in that, just go to this website.
You can
find some information there.
So it is a second block of
advertisement.
So thank you very much.
If you have any
questions, you might reach me here or on my
Twitter or
e-mail, thank you.</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>