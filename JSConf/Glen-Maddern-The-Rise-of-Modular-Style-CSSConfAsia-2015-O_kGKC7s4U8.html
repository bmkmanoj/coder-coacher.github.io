<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Glen Maddern: The Rise of Modular Style - CSSConf.Asia 2015 | Coder Coacher - Coaching Coders</title><meta content="Glen Maddern: The Rise of Modular Style - CSSConf.Asia 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Glen Maddern: The Rise of Modular Style - CSSConf.Asia 2015</b></h2><h5 class="post__date">2015-12-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/O_kGKC7s4U8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I
hi everybody my name is Glen Madden I
work with mark on CSS modules in fact
those conversations that he talked about
with Tobias coppers we were away at a
javascript event in Australia called
Camp Jess and so we had this quite
useful iteration cycle of wall Tobias
was asleep we would talk about stuff and
then mark would go away and talk to him
online when he woke up in Germany and in
three days we hashed out a big chunk of
this of this project I'm going to be
talking about CSS modules as well but
from kind of a different direction
because I when I got involved in the
project I had my own kind of background
the only with my own ways of doing style
and Mark and I disagreed on a lot of
points and CSS modules is really kind of
a compromise of these two points of view
that we think now has the resilience to
cover a lot of use cases and I think
it's a big benefit to have gone through
that process but what I'm interested in
talking about is the change I think it
represents in CSS not necessarily CSS
modules being successful but this shift
this this progression and I'm calling
this idea modular style which I've
started to use a little bit and that's
my talks going to be about that the
first part of my talk is about the
difference between a something that's
designed for humans and something that's
constrained by machines I'm gonna go all
the way back to the invention of the
compiler by grace hopper she wrote in a
new magazine article in 1987 that in
1952 she had a running compiler but
nobody would touch it they thought that
computers could only do arithmetic and
really it it constitutes a breaking
point where we were completely
constrained by what the machine could do
before that all you could give it was
machine instructions you had to
translate everything in your head and
this you know it's what is a 60
three years ago was the first time
anybody had ever progressed written
something that then the machine would
translate to what the machine could run
now scoot forward a little bit to
September 2008 which is a far darker
time in history at least in the history
of the web in 2008 Firefox was at
version too but 75% of the online world
used IE and I II was at version 7 it was
well basically if this is humans vs and
machines in 2008 the machines were
winning JavaScript of 2008 had started
to mature though they were started some
patterns that started to emerge jQuery
had had really started to establish
itself the plug-in ecosystem was pretty
healthy and this was sort of the best
practice in 2008 you would write
everything attached it to window make
sure that you weren't clobbering
something that was already there attach
your code somewhere that somebody else
could find it and run what I mean
there's nothing wrong with the way this
code is written but it implies the fact
that you have a global namespace you
have nothing except what's on window and
the only kind of conceptual method for
execution is sequential if you want two
things in the pot in the file simply
concatenate them all so at the end of
2008 Google came out with chrome I don't
know if you remember they released this
comic book to try to educate the 75
percent of people who are using IE that
you could choose a browser and if you
could choose and obviously you wouldn't
choose IE google chrome was quickly
popular partly because of the
performance of v8 which was its
javascript interpreter and it was far
faster than the javascript interpreters
of the day and that helped to catalyze a
movement that had already started around
the idea of running JavaScript on the
server this project at that point was
called server jas Kevin dangle wrote in
January of that of 2009 that for
JavaScript to really come
of age and to work on the server it
needed a standard way to include modules
the JavaScript specification as it was
wasn't sufficient it needed those
modules to live in discrete namespaces
you could already do namespaces just by
attaching things to window in a in a
conventional way but you couldn't
include other people's code just once
then went on to write that server side
JavaScript is very fragmented that if
you wanted to do anything beyond what
javascript was designed for like access
a file and the file system you couldn't
do that the same way on the to server
side JavaScript interpreter is right on
v8 SpiderMonkey JavaScript cool they
couldn't load the same modules external
modules in the same way and so every
time somebody wanted to use javascript
for a web framework they had to create a
bunch of AP is that other programmers
took for granted and what I think is
interesting is if you replace the year
2009 and you talk about CSS instead of
server-side JavaScript there is this
sort of sense of of a lack of legitimacy
around the tooling around CSS and that
if you want to write a framework like
bootstrap it's either very tied to less
as it was or SAS as it is now and that
sass and less and the Perseus is plug in
ecosystem do create ap is that other
programming language is now including
JavaScript take for granted okay so also
in 2009 nodejs comes out I'm sure a lot
of you aware no Jess even if you don't
use JavaScript day today in March Chris
Cole who was also blogging and
influential around this time wrote that
this year had begun with a combination
of wondrous events in JavaScript he'd
been struggling to promote the idea of a
module system in JavaScript for several
years now and there had been a sudden
explosion of progress and I also feel
that that's what's happening with CSS at
the moment there's a lot of energy
coming from the react community a lot of
new ideas maybe some bad ones as well
but the the collective kind of spirit is
that CSS is undergoing a change and
there are a lot of smart people working
on this hard problem and that maybe we
are stumbling across a solution so by
the middle of 2009
javascript had a new name the server
side JavaScript had a new name common
Jas and I'm sure a lot of you will know
that term commonjs it's sort of not
maybe what you think it is come a jess
was trying to be a standard that handled
all these different ways of handling and
dependencies in JavaScript no Jess
didn't really follow that on and node
one whatever no does the thing that node
does no jss module system is what we
call comedy is today sub stack calls it
command J desk which is a pretty good
description of what it is it's kind of
based around these two lines require and
modular exports and what it did to that
language what it did to javascript is
quite profound because previously you
had namespace widget through x equals
function and now you have to explicitly
require everything you need and
explicitly export everything you make
for something else to require but what I
like about this example in this contrast
is that the words window namespace
widgets and fubar disappeared from your
code because they're implied by the file
system your file fubar j/s lives inside
the widget which lives inside your
namespace directory so of course that's
what it's about you don't have to write
it every time and that I think is a
particularly relevant to CSS as what
Mark was talking about before so no it
must be thinking and this is CSS conf
not Jas conf this is a great history
lesson of JavaScript bet I mean
javascript has a lot more power than CSS
ever will we're not going to run CSS on
the server all right you know operating
systems in it and that's true but the
change in the ecosystem around
JavaScript can happen to CSS the change
in JavaScript was pretty small these
lines were valid before they just had no
meaning the require and module will wear
whatever you define them to be but if
you wrap a module system around it and
you wrap an ecosystem around it that can
fundamentally change how people write
JavaScript and it was successful npm
came along not long after mpm is now
extremely popular
there is a module on NPM for literally
everything absolutely everything and
everything that ever will be is already
on NPM by changing the ecosystem in
JavaScript that revolutionized what have
escaped was what it could be and what it
is today and I think the key thing was
that the human interface went from
having to remember that all this other
code was going to run before yours and
all this code was going to run after
yours to having an actual module system
and having no mechanism for sharing code
except putting one file in front of the
other and including something off a CDN
and then your script tag to having
200,000 packages of NPM what makes that
particularly relevant for us is
browserify browserify is in the similar
vein to web pack but it was the first to
really to do this browser if I said you
write your normal nodejs module code and
I'll make it work in a browser it does
that by because of the way JavaScript
works it does that quite cleverly by
simply taking your file wrapping it in a
function making sure that it defines
what require module and exports is
concatenates all of those files together
wise up all the dependencies and then
with a little runtime shim basically
boots that up and execute your code your
code is none the wiser whether it's
running on a browser or on a file system
once it stubs out the AP is browserify
proves that for the browser you could
change the human interface of a language
that we were using day to day without
actually having to wait for JavaScript
to change I mean if we were waiting for
a new version JavaScript we'd still be
waiting it's still not solidified so
what about CSS now we've been talking a
bit about CSS a lot of two talks have
been about CSS and we have been changing
this the human interface CSS as the
language has had virtually no change in
a long time but sass is incredibly
popular there was a recent survey of fun
and professionals who I think was
sixty-four percent of people used sass
in their projects less was more popular
earlier and is dying in popularity now
post CSS is kind of is rising in
popularity because people can plug and
choose the things they want
but none of them actually change what
CSS is they're just different ways of
generating the same sort of code that's
where I think CSS modules is different
CSS modules wraps a file format called
interoperable CSS which we finally sort
of settled on in in the end of June this
year I CSS is trying to be as small a
change to the CSS language as possible
to facilitate a module system so we add
to inert sorry to pseudo selectors
import and export they can pass the
recess they can pass your post CSS they
can go to the browser if you want
nothing will choke on them they're valid
CSS they just don't mean anything until
you give it this ecosystem around it
using webpack or something else the rest
of the file is normal global CSS we
didn't change anything there's no
runtime dependencies it's just CSS you
can concatenate it you can gzip it you
can put it on a CD n you can do whatever
you want with it and the way CSS modules
uses this intermediate format is that
when it sees a class like normal it
compiles it it adds an export line as
well as rewriting that class so now
normal doesn't exist except in the
metadata the export the Styles don't
change the selectors don't change it's
just the keys change then as Mark showed
you import that across the boundary from
CSS into your JavaScript component and
you get that mapping so then if you
change your markup to feed that class in
you line up with now compiled output and
I want to sort of talk about this in a
little bit with another example if you
have normal in two classes now into sort
of CSS files they can't clash anymore
they get compiled to different hashes or
two different longer class names
whatever you want them to be and they
get exported into two different places
the only way to see what's in menu is to
import it the only way to see what's in
button is to impor
and that lack of global pneus lack of
predictability about the output CSS
means that you have to be explicit about
where that code goes so for a dumb
example let's pretend our button CSS had
to know what was in menu CSS there's no
way for me to write it as an author and
guarantee i'm going to figure out what
on the right-hand side but i can import
it i can import that file I can give it
my own alias and I say whatever you call
normal I call menus normal and then I
could use it now don't do this we don't
expose this in CSS modules but this is
the underlying mechanism under Lee
underneath composition and a bunch of
other techniques this idea that the only
way for information to move between
files is if your explicit about it when
that gets compiled everything gets
linked up so that your override class
has the same class in that other file
and because we knew that you had a
dependency from this file to the other
we know which order to concatenate them
in so now you don't have this source
order unpredictability that you might
have by trying to concatenate a whole
lot of potentially global CSS so I want
to think about I CSS is being the
browserify output it's the translation
of the human interface into what
browsers can understand so I success is
a compiled target it's not a human
interface she says modules uses it if
you wanted to design your own module
modular CSS framework you could target
it as well and use all the other tools
that we've built for CSS modules the
file is completely isolated it can port
others and what it really is is
unlocking the power of web pack chase
p.m. browserify it's a set of
instructions i set a metadata to tell
webpack what part of this file is CSS
and what's JavaScript and how these
things flow around so C says modules was
with the best logo in the world takes
this and the first thing it can do is as
Mark already hinted at is be flexible
with what you output you don't have to
have normal f34 you can have in
development mode a longer path now
there's nothing preventing us
source maps but we haven't needed it
this in development mode seems to be
enough if you go further you could put a
line number of the first in you know you
could go however you like in fact we saw
this morning about selectors class
selectors using characters you wouldn't
normally type what school here is that
all three of these the middle doesn't
change you never interact with it in a
different way it's just a compile out
but why would you care your component
needs the normal class so you know you
don't mind what the output is marking to
that it they use a min ified version a
short hexadecimal string that works
great it saves and bites but it's not as
good as you could do the best you can do
thus far as I'm concerned is minify to
emoji emoji is the best bite for bite
replacement of a perfectly
understandable computer accessible term
but also human recognizable and if you
don't believe me i encourage you to have
a look at my website glenn madden calm
every selector in that site is an emoji
so this time tag has a chicken bone
class attached to it the firework up the
firework down lantern love letter
engagement ring a lot of other all the
way to the last one which is fast poop i
think it is and what's interesting about
this because apart from being a min
efficacious oak it's also actually
easier to read than minified code
normally is because if you look on the
right hand side you can start to see
duplicates of selectors you can see the
same class applying at three places
which you would never be able to do if
it's just random hexadecimal strings so
I actually think minifying to emoji is
not just a joke I found it quite useful
and yeah in real life and so this is
sort of a two-fold approach the first is
by defining a file format that unlocks
webpack browserify giving a machine
format that we're happy with we can do
better we can better target a file
format module system an ecosystem for
humans
hopeful that in the future maybe seven
years from now if you see bem style code
with their long class names that imply
that this has to live in the global
namespace and if I get this wrong things
will go badly that that looks as
redundant and unsafe as you know
JavaScript before a module system and
that this becomes the norm you have
contextual styles not contextual just
because they're local to that component
but because the tool enforces it the
tool says that you cannot possibly find
out what Lodge becomes unless you make
an explicit link across your project and
that I think is a big that's a big win
which takes me dude part two part two is
now given the increased capability given
the given a module system what might we
use it for what like what uses all this
unless we can write applications about
our node and NPM wouldn't have taken off
unless you could write algorithms more
scalable and more maintainable using
modules rather than Global's so what
does it look like for CSS so I want to
talk about a little example which is
that you have to build two variants of a
single button give a submit button
delete button submit buttons blue delete
buttons written in bem you would have
your common styles in a submit button
class your blue colors exhibit mine
already the submit button danger should
be pretty common to anybody who's seen
them before then you apply both classes
the button and the normal and the button
and the danger and you get you two
outputs the problem happens and this is
a problem that I've encountered that
started me on a bit of a journey into
digging into CSS tooling when you forget
one of those classes because there's
nothing to enforce the fact that normal
is also a button and if you do this you
break your styles and if you're the
person who built the style sheet and
then somebody comes along and writes a
component and they forget it then you
might get angry right that if they've
broken this convention and i would like
to implore you to get less angry
than you otherwise would because
something I'm recognizing more and more
is that if you're designing something
for other people to use then if people
keep making the same mistakes then you
haven't finished designing you can get
better you can make tools that enforce
these things and so when somebody makes
the mistake I want you to take it as a
challenge to make your tool better
there's plenty of stuff and CSS modules
work that people get tripped up on and
we're trying to fix it so that's my rant
that was my little rant that's a topic
very dear to me which is code for people
who are new to coding whenever you can
so anyway back to this problem you have
this button and you've got the wrong
styles on it and you think I'll look
hang on they're all buttons so why don't
we just make the thing the tag button
and I think anybody who's done any
amount of CSS should feel queasy at that
because a button using a button in a
HTML document is not a styling choice
that's an accessibility and functional
choice so attaching lots of style to
that information means that every time
you use a button and it doesn't have to
look like the others you have to do a
lot of overriding and overriding is bad
so sask um long such as a function
called extent which we had a question on
just before extend does exactly this
extend says hey if you use normal I know
that you also meant the base class so
submit my normal extend submit button
danger extends submit button that works
great it's exactly what we want we can
use one name in our output and we can
either get neither style or both it
works by rewriting the CSS by injecting
so that submit button normal matches the
top line and the fourth line and danger
matches the top and the third-to-last
works great conceptually it's beautiful
implementation wise it's dangerous I
love it I used it a lot and then it bit
me like a bit sever and bites everyone
here's a quick example of how it gets
bad you can have if you extend something
that's used in multiple places then your
selector gets used in multiple places if
you have complicated selectors yourself
and you
stand something then it gets even worse
it bloats it bloats and the i guess the
worst case is a ryanair the airline that
nobody particularly likes just released
a responsive redesign that takes
something like 30 seconds to render on
an iphone 5 something like that even on
4G even on a macbook pro I think it pegs
the CPU just passing the see the CSS for
one and a half seconds and nothing is
accessible in that one and a half
seconds it's just simply trying to
understand this mess what I like about
this example one it's rain air and I
don't particular like them the other is
that all of this code is to reset a
border radius to zero which means
somewhere else border radius is being
set for everything to something else
this is why extend gets a bad rap this
is clearly using extend and it has this
runaway output this is terrifying so you
get blog posts that written like this
what nobody told you why you should
avoid extending SAS without creating a
mess or my favorite which is SAS doesn't
create bad code bad coders do just on
the topic of coding for newcomers
writing titles like this now the rest of
the article is a lot more nuanced and a
lot more clever but titles like this
have the potential to harm people who
are new to code who are potentially
making the mistake that extend leaves
there for them and if they suddenly see
a headline saying that there are bad
coders then maybe that contributes to a
general hostility that doesn't need to
be their dog in CSS modules how does it
work well it's a one-to-one replacement
for extend in this simple case so normal
composer space danger composers base
again we don't have to use submit button
because that's implied by the file
extending and composers are identical in
this example we also have the benefit of
still using just one name right normal
in danger as we saw before doesn't
really matter what the output is we
always just use that one name and I
can't harp on about that enough because
being able to having confidence in your
markup when you're typing the line for
your markup that you only have to
right one thing is is very comforting so
go through how this works CSS module
sees these three lines the first thing
it does is it rewrites all those classes
because the classes need to be safe for
global consumption depending on whatever
rules you're using it generates these
classes it exports those classes so that
your javascript the rest of your
application can deal with it and inject
it composers instead of changing the CSS
in any way just moves the export so now
normal when you use normal you get two
classes as Mark already demonstrated and
that severely reduces the number of
places that you can use composers you
can't use it in a pseudo selector you
can't use it at a nested selector it has
to be that simple relationship that this
thing is something else which is all of
the edge cases of extends just disappear
so when you use it styles dot danger one
word you get two classes out and that
breaking the one-to-one mapping is a big
deal it means you can change it means
you have total flexibility of the number
of classes the type of classes what the
classes are how big they are when you
compose them whether they have one line
of CSS or a hundred that ends up being a
big deal and how you change in changing
how you style so the simple cases here
where the blue and the light blue
background we want to use from somewhere
else we have a colors file we have a
blue class we have a light blue
background class and now our normal
button is a base button but it's also a
blue light blue background from colors
and this is where the input syntax comes
in so that I see a sense underneath is
wiring up the dependencies building a
dependency graph which webpack and
others are very happy to consume that
gets compiled the boot the colors file
gets compiled the buttons file gets
compiled and then they just get
concatenated because it's just normal
CSS your button when you use normal now
generates for classes and what's good
about this example is that normal now no
longer has any rules it's simply a
culmination of other rules elsewhere and
in fact you put this through a min afire
and that normal line will just disappear
which means you built a novel piece of
you I something that somebody asked you
to build without adding a line of CSS
the more times you can do that in your
job the happier you will be from
experience the more CSS every line of
CSS you write is should earn its place
and this turns you to this sort of
structure now people already do this
with sass and they do it fine they do a
shared directory full of things like
colors typography layout borders
dividers sizes animations effects
whatever and then a components directory
probably alongside their JavaScript
images tests whatever it is and that
division is very beneficial it turns you
towards this idea of using single
purpose files using full of single
purpose classes that's how I code at the
moment to give another example a bit
more scary let's say an article needs to
be a vertical flexbox and a masthead
needs to be 48 point bold serif centered
with margin and padding we can pull
those all those things from other places
so lay out the word the class centered
inside layup means something different
from centered in typography which
shouldn't be confusing because those do
have meaning in those files you have
context as well as names the output you
get three classes for the article and
seven classes for the div but you don't
see that you just use the name and that
breaking of what you get what you're
generating from what you're putting in
increases your confidence with what
you're building what it's doing is
defining an API into your styles you
have the same same choices that you have
designing other parts of your
application in your CSS file so what a
what is modular style then because I
mean we talked about it it's less than
six months since that first conversation
about five months since the whole idea
of interoperable CSS CSS modules hasn't
has had a name for yet less than six
months we don't wear the right at the
beginning of this stuff so we don't
know where this is going but the one
thing I'm pretty confident on is that
the module system that we built should
be capable of supporting whatever the
next big CSS technique is whether its
CSS modules or something else because
going from having one global context to
having lots of individual contexts does
change what you're capable of Four
Seasons modules I think the key is
flexibility there's one thing that I
want to talk about a little bit even
though running out of time which is this
idea of atomic design type of design is
a great metaphor for discussing
different elements at different levels
of resolution across an entire team
between designers developers everybody
it's a excellent metaphor if you haven't
tried using it in your projects you
should but as an implementer like myself
I see all of those things and I just see
a component and once you start working
with react once you start moving two
components you realize that the level at
which or the size of which a component
is doesn't change how you build it but
it changes how you talk about it how
many times it's used what parameters it
takes and I think if modular UI is
capable through components as I feel
like it is then modular styling comes
through composing classes being able to
no matter what the metaphor whatever
whatever style of code that you're
writing knowing that you always have
that one technique which is that each
file has local scope and that you can
compose glasses from other places as we
talked about it one of the questions
just before is this idea of reusable
components so it's an area of intense
discussion about what does this mean for
the next bootstrap how am I going to
publish something that I can consume the
bits that i need and leave all the bits
that don't it's still an open question
we'd love you to contribute to the
discussion but in the same way that npm
took a little while after jeaious had
this module system it's going to take a
little while to figure out the best ways
to do this and the other big thing for
us is non javascript assistance mark
already hinted at it it's a personal
thing of mine which is that all of the
fill of the things I've been talking
about as making CSS easier for humans at
the moment depends on JavaScript being
involved
at some point whether it's generating a
static site or actually running your
application and it doesn't need to be it
can be completely offline the same way
that SAS can be used everywhere I think
CSS modules should be able to be used
everywhere we have a team of people who
are building stuff it's not just me the
project has a lot of momentum behind it
has a lot of issues a lot of people
contributing discussions patches please
if you are interested please get
involved we're right at the beginning of
this as I said my slides are up here
cesar's modules is there if you like
another introductory to the concept I
wrote a blog about it that's me on
Twitter thanks very much for time hey um
let's say you have a like a layout CSS
file would like all the different layout
techniques that you could possibly
imagine and you only use maybe half of
them in your actual application will the
CSS modules actually strip out the rest
of it or will they remain in there when
they're compiled or what at the moment
they'll remain in but one of the
benefits of actually encoding your
dependencies and having written down
that this thing needs this thing means
that we can properly crawl the defensive
graph and remove things that aren't
needed one of the things I think that
I've found as I've moved towards sharing
more CSS putting more CSS into
fundamental building blocks is the size
of my output CSS is a lot smaller that
when you have 100 components but they
share most of their code it doesn't seem
to bloat at the same speed as if you
start with a fresh file and you include
a whole lot of things and so it's been
less we've had less pressure to do that
but certainly we have the function at
their capability to that in the future
like okay so you're talking about like
having like hundreds and hundreds of
components say but I quite a big web app
there's hundreds of components in there
just thinking about like how you direct
dive them like with the directives and
stuff like that would you put components
into direct into like specific folders
or would you put them all in one area
like
one thing we've been trying to think
about actually where we are is like how
how we can go about creating directories
with things that are easy to read and
funnel through without having them all
in one area yeah you thought about that
I've thought about it I don't have a
good answer i think the divisions your
components is an art it's the same way
is dividing your styles into fundamental
blocks he's an art and it i found i've
had that same progression using angular
not react potentially react makes it a
little bit easier but with angular i
found that when you have 30 components
you're fine but then one component needs
five variants and you don't want all
those five variants to live in one file
and so tooling around that stuff is
still still coming out it's still early
days but it works well for the first 30
and it feels like it should keep working
as you have lots and lots of more
variations one of the things that I've
seen one of the approaches I've seen is
encoding more things into arguments so
there is a kind of upper level component
that the whose sole responsibility is to
dispatch to smaller components so that
it gets all the inputs is common
interface for everything but then the
implementation that's more and they
would live in a subdirectory or
something but yeah it's it's a if
everybody's mileage is varying at the
moment sir</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>