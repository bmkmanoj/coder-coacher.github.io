<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Brian Ford: Is Node.js Better? | Coder Coacher - Coaching Coders</title><meta content="Brian Ford: Is Node.js Better? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Brian Ford: Is Node.js Better?</b></h2><h5 class="post__date">2013-01-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/C5fa1LZYodQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">it's an honor and a privilege to be here
I'm very happy to be here I think I
would be less nervous if I was actually
being hung at 2:15 instead of giving you
as a talk so please bear with me the
question is this better than that is
something that we confront every day we
confront it probably more than we're
aware of and sometimes there are serious
consequences to the the question I
answer that question so is this car
better than that car is this job offer
better than that job offer is this home
for my ailing mother better than that
one
right we encountered this question all
the time my concern is that often say I
used car salesperson or some big
software company or I don't know just
about anybody who's trying to sell you
something actually may benefit if you
can't answer that question well right so
that's why that's why the question is
important to me in particular though
we're going to look at is no js' better
but we're going to use it merely as sort
of a framework to look at that broader
question I'm a big-picture sort of
person I want to try to paint you a big
picture and give you some things that
you'll go away
with either thinking about or actually
excited to go learn about so that's the
idea so you know I'm not a JavaScript
person I've never authorized ovah script
library this is actually the first jazz
comp that I've attended I was able to
hang out with any of you folks who are
at the Portland Jazz kampf last year
because I live in Portland but how did I
get here so last year just about one
year ago I was sitting at code Kampf and
it was Ryan's topped on nodejs and most
of that talk was about how they were
rebuilding the i/o subsystem so it would
have good performance characteristics on
both Windows and UNIX fast forward about
nine months and I am hearing Lee I'm
seeing all this stuff on Twitter about
no GS and I'm like at the time I heard
Ryan's talk I was fairly indifferent I
was
interested in technology we're
interested in building really good
windows support into rubinius but I was
indifferent I'm not JavaScript developer
I'm not building solutions in JavaScript
I was like oh that's interesting then I
was seeing lots and lots of people
talking about nodejs
and I posted a serious question I said
someone please tell me why people are
using node GS and please tell me with
science because I had heard a lot of
opinions and then I followed it up with
this tweet and as you probably can see
it got retweeted a lot Chris DM to me
and he said I know you're working on
important stuff what's up with this
challenge why are you doing this and I
we changed a few dm's and I was like
basically I said it's a serious question
I'm not trolling I want to understand
because I don't understand so he said
would you be interested in giving a talk
at the conference and I said yes that
would be amazing so that's how I got
here Who am I
my name is Brian Ford as you guys have
heard I work for engineer I've worked
there for about four years and I work on
rubinius and Ruby spec and I actually
worked on Rubinius for about a year
before in jannat engineer had hired me
when I started working that project it
was the first open source project that
I'd ever contributed to the project was
very young I had a feeling that the
project was going to be important based
on blog posts that Evan Phoenix had
written but I was very concerned that a
new implementation of Ruby would
possibly cause a splintering or a
fracturing in the Ruby community and I
was very much against that idea so as
part of starting with Rubinius the first
thing I started doing is writing tests
that eventually became the Ruby spec
project that all the different
implementations of Ruby are using so I
was concerned I was concerned very
concerned about the language the the
coherence of the language that people
could benefit from Ruby but I was also
beginning to work on a project where the
question of essentially the purpose of
the project was to replace the default
Ruby implementation so central to my
work was this question of
is what we're doing better than what
already exists so that's how I got here
that's who I am why do I care about no
GS though I think that's a really
important question and in big part it's
because of this there's a lot of
problems in the world today right a
really good friend of mine diagnosed
with pancreatic cancer she will probably
die next month I hope to see her before
she dies but she's probably gonna die
next month why can't we solve problems
like this when you when you think like
when this idea first was presented to me
I thought it was very very interesting
why is it that we create technology we
create organizations groups of people
where we're supposed to be solving a
problem but what we end up doing is
possibly making sure that that problem
doesn't go away because then we can keep
on solving it over time to me that
that's so bizarre right the other thing
though is that a lot of people are
afraid of change right a lot of people
are really really scared of change and
then there are people who actually
create change and what I see in the
JavaScript community in general and in
node in particular is that it is a
subversive technology it's very much
like ruby was when it was sort of taking
on the enterprise and saying there's
possibly a better way to make web
applications I see this across
JavaScript like almost every single
place javascript is being used you're
pushing the boundaries about what's
possible and showing people things that
they they didn't imagine and then they
build on that and you see more and more
more so part of the reason why it's it's
meaningful for me to come here and talk
to you is because I feel like there is a
a even though I do
Ruby primarily and most of you folks see
JavaScript I feel like there's a very
much deeper like connection between us
based on this idea yeah so AB and
Observer says the other thing is that
anytime you put two things in contrast
you're essentially creating a conflict
right in the Ruby community we have this
saying
Mott's is nice and so we are nice right
it's a great idea right except is it
nice to be in conflict with somebody I
love Ruby
I respect mots tremendously I'm so
thankful that he created the language
and yet I've been working for five years
diligently to try to replace the
technology that mots has authored so
conflict is is is basically inherent in
what I'm doing
furthermore common conflict is and
controversy is really entertaining I
mean probably I don't have any other
tweets that were 50 times retweeted
right but I throw one challenge out
there at node yes and I'm not even you
know node.js programmer or something or
really somebody who's like someone to
worry about and lots of people are like
on that retweeting retreating
furthermore when it comes to conflict
we usually have words like this we have
a shootout right or a Throwdown or a
fight right how many people feel like
fighting is something that is a good way
to resolve conflict right walk with you
know bloody lips and eyes and knuckles
and stuff I mean truly a fight is that
is that the way we want to do it the
other thing that's really interesting is
that anytime you advocate for something
right if I say this is good I don't have
to say anything more than that but I
imply that this other thing is not as
good right I can't escape that right and
if I say this is bad I'm probably not
just saying in general some you know
arbitrary abstract thing right it's this
is bad and something else right so
there's this duality we can't get it we
can't get away with it Eastern
philosophy
eun-young right it's it's sort of an
understanding of how the universe works
but what happens is when we look at
conflict it usually ends up like this
advocate if you're an advocate you're a
fanboy right to sort of perpetuate the
gender imbalance in the in the tech
community right your fanboy or if you're
a critic you're a troll and so we
invalidate what someone is saying when
they're either advocating for something
and they're excited
Susy asked about it or we invalidate
when they have a question and say we're
troll that concerns me when I was
telling someone about this talk that
basically again we suck at conflict and
that's a problem so how can we improve
it that's the question
so this talk if you get nothing else out
of it the idea would be how do we
improve how I deal with conflict
benchmarks right we could do that right
like I could just come up here and say
oh I benched mark node against closure
you know Carl Ertz is working on this
new evented like client-server HTTP
server it's like it's the new hotness
and it's like five times faster than
node right of all the people here who
have used node if I showed you a
benchmark right now that closure was
five times faster than note how many of
you would switch right now to use
closure yeah that's awesome I'm so
worried no one's gonna raise their hand
on my back come on guys statistically
someone would switch ok yeah so about 1%
of you would switch okay so benchmarks
not hit right benchmarks have this
superficial sort of we're using science
but the problem is that it's very it's
very complicated to do a good benchmark
but I think science in general is the
answer to how we improve how we deal
with conflict so let's go into that a
little bit there was a guy Alex Osborn
worked at BBDO if you've watched madmen
you know that that's an ad agency in New
York way back 1948 he wrote this book
called your creative power and in that
book he described the methodology of
brainstorming how many of you is
brainstorming to like solve a problem
like come up with this solution c'mon
you guys
nobody in this room okay yeah
that's that's that's kind of it so
brainstorming so the idea of
brainstorming is that you get like get
together you have a group of people you
throw out ideas right just throw them
out and one of the main points of
brainstorming is that you do not
criticize other people's ideas right
because the idea was that creativity is
such a delicate flower that the harsh
light of criticism would cause it to
wilt and you would fail to come up with
really good ideas right it's been used I
mean 1948 was a long time ago I was
before I was born but it's been using it
still use like people still talk about
brainstorming there's just a little
problem with it it's wrong and they knew
that within a few years because someone
actually did a study they took a bunch
of people and they have them do
brainstorming and I took a bunch of
people and they individually have them
work on tasks and they found that the
people who were alone not only came up
with more ideas but they came up with
higher-quality ideas but would keep you
know the idea that brainstorming was
somehow a good idea it sounded good so
people were willing to fall it 2003 they
did another study in this case they had
three groups they have the typical
brainstorm erse then they have these
this group where they said threw out
ideas but debate criticized challenged
your you know other group members and
your own ideas and then one group was
allowed to freely organize it did
whatever they want they just said come
on with ideas the debaters came up with
more and better ideas
criticism actually is productive when it
comes to challenging when it comes to
coming up with creative ideas
challenging people's ideas forces them
to go deeper into it or forces you to
understand it better and then one other
thing that was kind of interesting is
that they looked at a correlation
between the success of Broadway musicals
and something that they called the Q
factor the Q factor was essentially a
measure of how familiar the team working
on the musical was so if the team all
knew each other well they'd all worked
together before you'd have a very high Q
factor and if they hadn't worked
together at all you'd have a very low Q
factor what they found was that there
was a very high correlation between
people
doing teams that had sort of an
intermediate q-factor where most of the
team knew each other but a few of the
people were new so they were able to
communicate better about ideas and it
was highly correlated to how successful
the music music was so related to this
idea of brainstorming and how it was
sort of accepted without question
because it sounded plausible and also
the idea of someone like myself as an
outside of this community coming in on
suggesting things these two things sort
of go together and say that it's
possible that we can come up with better
ideas if we collaborate and if we
challenge the ideas that we have so you
can read more about it this was
published in The New Yorker magazine
it's a it's a great article it's it's
not very long what I what I see
typically happening though and what I
really want to help change essentially
is this sort of idea how many people
here know who Ward Cunningham is so Ward
Cunningham among other things invented
the wiki
he's a major figure in computer
programming and in computer science and
Ward thinks nodejs is the future the
server side and I don't have a problem
with him saying that he may or may not
be right what I have a problem with is
that people are willing to say Ward said
this so there's there must be some
validity to it sort of similar to this
successful and famous ad man saying this
is brain storming this how you come out
create solutions and people say okay
that's what we'll do so recently I
started reading this book if you read
this book I guarantee you in fact I'll
say this I will trust you I will pay the
cost of this book if you read this book
and you come back and you tell me
honestly that this book did not
significantly improve your life your
your professional life your private life
your experience of the world this is how
important I think this book is this
basically talks about the two ways that
our brains function one way is this I
challenge you to look at that word and
one not know that it's bacon not it
possibly smell see remember your last
experience with bacon like many times
the association's then you can possibly
get your hands around it happens just
instantly this is the fast thing and
this is the part of our brain where some
stimulus triggers an activation across a
network and we have a flood of
associations and ideas related to it it
happens instantaneously it happens
preconscious this is happening before we
even realize that we're seeing bacon
it's happening in our brains and then
there's this if we were walking along
and I said hey what's 23 times
forty-seven you'd be like uh most likely
you would you would stop walking
something that we do so naturally right
because a different part of our brain is
activated a brain a part of our brain
that is deliberate slow it has to think
through things so much so that it might
interfere with that doing something sort
of autonomous almost like walking those
two those two ways that we think are
very very interesting there's a there's
a ton of stuff in this book but one of
the things that's really really
interesting is that that's slow
deliberate part of our brain the sort of
the part that's sort of checking things
out and making sure that you're not
doing something stupid and that you're
understanding what you're doing or
solving a problem that part of our brain
can be easily misled and one of the ways
that it can be misled is if you feel
comfortable so in this one experiment
they had subjects put a pencil in their
mouth like this right so their face was
sort of in the shape of a smile they're
relaxed and they were much more likely
to accept a wrong answer than if you
have the pencil in your mouth the other
way so you are sort of squinting and
frowning because when you do that that
facial expression it also it's it's
related to a feeling that you're you're
you're exercising more
it's like your there's a level of
anxiety that improves your your slow
thinking part of your brain that parts
attention and you're less likely to
accept the wrong answer so the reason
why I think this is so so fascinating
right is because I firmly believe this
this was something that I sort of like
realized recently I tweeted it Kent Beck
reach we did it they sort of had a
dialog with what number of people like
what are you talking about it's like
programming as science we use math we
use computer science we you know
algorithms you learn you know like Big O
complexity you you know all these sorts
of things that we do there's there's you
know
computability and and parsers and
compilers and it's like how is that
possibly anything like psychology or the
other behavioral science as well
behavioral science is essentially a
discipline where you use observation and
experimentation to figure out you know
to look at interactions of organisms and
organisms with their environment right
so when you think about programming you
think about when we solve problems
think about methodologies like lean and
agile XP think about when we do like
talk to customers when we do interface
development and we look at like
interaction design principles we look at
things like Gestalt psychology where
we're looking at how we visually create
holes like complete things gestalt so
these sort of things every one of those
things has to do with human functioning
there's not math we apply math to a very
small part of programming programming
itself however is a behavioral science
one of the really really interesting
things about behavioral science there
are now decades of research into how to
study people and if you read that book
Thinking Fast and Slow you will see some
really hairy problems things that looked
really tangled in there like is that
this is at that and through ingenious
experiments they were able to sort of
disentangle it and tease out answers to
these questions
but what's distressing is that your
average undergrad in psychology has
better understanding of research methods
I think because they typically have to
take a class then your typical PhD in
computer science but what are research
methods research methods are a means of
trying to arrive at the answer to
whether something is valid or not if I
say to you brainstorming is this and
this is how you get you know better
creative ideas how do I challenge the
validity of that how do i how do I know
whether that's true or not research
methods basically look at two sorts of
things about about reality there's this
idea of metaphysics which is basically
sort of the nature of the universe right
and then there is this idea of
epistemology which is essentially a
theory of knowledge it's what we can
know about the universe these two
aspects are really important in coming
up with an understanding or a decision
on whether something is valid right the
validity so yeah what I want us to do is
to think about technology now coming
back from from this idea this this
generic idea about behavioral science
and computers is up and I want to think
about something that is concrete like in
the case of no yes no no js' is about
how to create essentially services
servers you know solutions to problems
that have to deal with concurrency right
if you didn't have to deal with
concurrency it wouldn't matter if your
i/o were blocking right so a sort of a
quick history of concurrency I think is
important to consider I think this is
true and I say this without any judgment
I'm a person programmers or people we're
all people but I think people in general
are selfish
they are lazy and they are easily bored
and why that's important is that you
combine it with scarcity the fact that
every little compute task that we need
if we had you know
uncountable computers then every little
thing we needed to have done could be
done you know what computer computer
career that's all done no problem
combine that with with with the idea of
scarcity and you have this this issue of
concurrency which is basically basically
the idea that you take a program the
instructions of the program and you and
you look at every possible interleaving
of those purpose so if you have one two
three four you can put them in one two
three or you put two one three four you
could put four three one two right every
possible interleaving of those
instructions is what concurrency really
is about you take a program and we'll
say that a program has a routine and it
have one or more routines and for
simplicity sake let's say that the
program P runs this routine if that
routine which is doing some computations
some sort of work Waits
then the whole program waits right
however this is the most efficient way
to deal with the the process of of
computing this thing and this is the way
computers used to work right you would
submit your job nothing else would run
on the computer your job would run all
the way until it was finished you would
get your result in the next person whom
get in line they would Smith their job
run all the way through but people are
selfish I don't want to wait for you why
can't my job oops sorry why can't my job
run before yours people are lazy they
really don't want to go through all the
trouble to put all the things in line
put in there and make the computer
efficient and they're also easily bored
right they're gonna be like sitting
around I'd be like what the hell I'm not
waiting for this thing to be done so
what you end up with like when things
can only be done one at a time the only
thing that you can do is instead of like
completing this job completely you have
to say oh I'll do a little bit of that
job I'll do a little bit of that job and
I'll do a little bit of that job
ultimately it takes longer to do all
those things because that switching is
not free so we're not using the computer
as efficiently as we
would be if we could just do one job and
then do the next job but we have to have
some sort of concurrency so then it
becomes a question of what do we use as
the pivot essentially what do we use as
the the trigger where we say we'll
switch from this job of this job and I
think there's basically three things
that you can use you can use time time
is kind of orthogonal to your program in
a sense right because whatever your
program is doing time is just going to
continue right along it doesn't really
care or you can use state right or you
can use what I'm going to call
transitions which is essentially the
idea of i/o so your program is computing
something and then it changes over here
to reading something from i/o okay if
you saw the talk about River Trail that
it'd be using data concurrency or
basically data flow to deal with
concurrency that's sort of a different
way but basically there has to be some
way that you are going to switch between
these tasks and what was developed very
early was just simply this idea of like
if I get to a point I can stop and then
later somebody else can resume me so you
get this idea of of cooperative
multitasking right very early way of
adding concurrency to essentially a
sequential process or you can use a time
slice and that is you get to run for
this long and then you get to run for
this long and you get to run for this
long and you have pre-emptive
multitasking the whole point of those
two things is that the basic node sort
of argument about events versus threads
is really apples and oranges right the
the idea that you have to have some
mechanism of switching between those
tasks to run things concurrently is much
more central and it's actually possible
to do things that are claimed that node
can do only because of the non blocking
i/o it's possible to do those with
threaded pre-emptive multitasking as
well the question is how many resources
it takes
to do one or the other and those things
aren't fixed they're very much dependent
on implementation and the whole idea of
like that just to sort of put this out
there the whole idea of IO being
non-blocking i/o is never non-blocking
right it never is it's where you draw
the line in your program if something
has to block it has to block right OS
though the people who write OSS deal
with not waiting on IO that's how the
threading scheduler works
oh that process is waiting on my oh I'm
going to suspend it right so that's
exactly the same thing that note has to
do internally when it says are you ready
to read nope okay you're suspended are
you ready to read nope you're suspended
are you ready to read oh you are okay
we'll let you read so the fundamental
technology under pre-emptive
multitasking with threads and
non-blocking i/o with no GS and doing
task switching is really the same the
implications for our programs on top of
that how many resources we actually need
to be able to use to get those benefits
and to actually get concurrency is what
differs so to switch gears just a little
bit one of the things that's really
interesting to me are some of the
justifications that I hear for using no
GS I just want to run by some of those
but basically I want to I want to put
this into a framework that we can that
we can talk about in a way that's
helpful that we can actually communicate
about and one of the things that I think
is really interesting is if I have two
things an x and a y and i make a
statement about one of them right like
if I apply my statement to one I apply
my statements together and the relation
between those is this so J of X is
greater than J of Y nodejs is better
than Ruby and I have some X Prime that's
equivalent in a way some congruent right
so you have two right triangles if this
the the sides of the legs are are
different the angles are the same
they're congroo
triangles are essentially like the same
triangle even though they don't look
exactly the same if I have some X that's
congruent to X our X prime is congruent
to X and y prime is congruent to Y I
would want to be able to infer that if I
apply that argument to that thing that's
congruent it would come out with the
same relation it would be really crazy
right if at the bottom that relation was
switched right so there's this idea that
node gives you the ability to use the
same language on the client server some
of the people I hear making this
argument are also people who claim that
their polyglots they're like it doesn't
matter I can use this language of
similar strange but in this case it's
really important that I'd be able to use
the same language on the on the client
and the server and I find that argument
to be missing a little something
somewhere if it's really okay that
you're a polyglot and you can use
multiple languages then why is it a
point that it's important that you be
able to use the same language on the
client and the server right I don't I'm
not like making a judgement about the
argument I'm just saying that that seems
like a there seems to be some
disagreement there there's also this
idea that there are many JavaScript
programmers and I think that's important
I think that in any language the more
people we have that are able to do some
sort of automation the better it is
because computer literacy is the
literacy of this century right
reading and writing was important last
century knowing how to deal with
computers and do basic automation is
going to be really really important but
what's interesting about that is that if
you're claiming that this technology is
better because it uses JavaScript and we
look at statistical distribution of
qualifications across a population just
because there are more people using a
particular language does not mean that
you're going to have more people writing
good solutions in that language so not
that you won't but that we should keep
those things separate right if we want
to write really good solutions in a
particular language we need to focus on
resources education tutorials all these
sort of things that produce good
programs not just that we have a larger
number
people making programs because remember
what we're trying to do is solve hard
problems there's a lot of stuff that
needs to be fixing school so we want to
be effective the other one is that just
know GS is fun there's a lot of
excitement and enthusiasm about no GS
people are writing libraries like crazy
they're having a lot of fun and that's
good that's something I'm really
familiar with from Ruby from the Ruby
community from growing up with early
rails and people having a great time
building things excited about the
technology okay
because I didn't want to disappoint you
guys I am going to actually throw a
little controversy in here
these are my opinions and they may be
wrong and what I hope more than anything
is that you don't either agree or
disagree with me but that you remember
that I was talking about something like
research methods and that book Thinking
Fast and Slow and you take what I say
and subject it to criticism think about
it critically my concern with no jess is
that it rejects reality and what I mean
by that is that multicore is the future
everything is going to have more and
more cores and it's going to be more and
more important to be able to utilize the
compute resources with not while not
like ballooning the amount of memory
resources that you need memory is still
you know like football fields away from
the chip if you can keep things on chip
and you can keep those cores busy you
can do a lot more computation note is
still single threaded no matter what
non-blocking i/o you make and how
perfect you make it there is still one
thing running at a time if you have four
cores you have to have four processes or
you have to have threads if you add
threads
I don't think threads are going to get
into JavaScript as the language you're
going to have some sort of non-standard
implementation of threads that is
outside of JavaScript but it's the only
way that you're going to utilize more
than one core in a single process that
concerns me tremendously we spent we
spent five years working on Rubinius we
spent a good
year and a half two years completely
rewriting the architecture so that we
could do basically two things right a
good just-in-time compiler and remove
the global interpreter lock by the time
I got done doing all the architectural
stuff
Evon remove the global interpreter lock
in about three weeks of work we took one
one lock we have about fifty or sixty
finer grain locks we have to deal with
some issues but basically you can run
multiple threads Ruby threads in
parallel now and Rubinius that's where
chip manufacturers are going the other
thing that concerns me is that there is
an entire ecosystem of tools and
libraries that must be created right
there's all kinds of things that
javascript was never sort of envisioned
doing that it's able to do now but it
requires a great deal of work to get
there
there are opportunity costs for
everything if I spend an hour writing a
node.js library that's an hour that I
can't spend doing anything else right so
their opportunity costs there are things
that you have to pay right to build
these things that you can't ever do
something else with that time that you
spent the other thing is that even
though we're reimplemented stuff that
the JVM did we're making mistakes right
in rubinius we have to fix those no
matter how much you learn from the past
as you go to redo things you're going to
make some of those spikes I feel that
node is going to sort of replay some of
the mistakes that say Ruby has made in
the last 50 years
you know MRI is still single threaded it
still has a fairly primitive and not
good garbage collector and note is going
to have to deal with those same issues
it's going to have to be able to
concurrency it's going to have to deal
with garbage collection it's going to
have to deal with process stuff across
different OSS all this sort of stuff and
I know this I know this is because I see
it happening already passenger is a way
to run multiple Ruby processes so you
can get some sort of concurrency on
these multi-core systems cluster is a
system much like passenger to run
multiple node processes so you can get
process level concurrency
so this is already happening
unfortunately I firmly believe and I
could be wrong but I firmly believe that
process concurrency is doomed it leads
to things like do you have a copy on
right friendly GC you know how crazy
hard GC is and then you want to add
copy-on-write friendly guess what
programs have a ton of state every time
you load a library you are loading a ton
of state everything you initialize there
is a ton of state garbage collection is
this big why it's basically saying you
have infinite memory and the garbage
collector is what is maintaining that
life for you you allocate like you have
infinite memory and the garbage
collector make sure that it fits in this
little finite box right as soon as you
start multiplying your processes your
memory pressure goes linear right and
sometimes worse and then you don't have
room on that that resource that box but
things like local caching and other
stuff like if you want to do a memcache
D or something like that so I think
process concurrency is really really
doomed the other thing that concerns me
is these two ideas and I'm again I'm not
saying whether this is right or wrong or
whether no Jess succeeds or fails here
but I really want you to think about two
things there's this idea of symmetric
errors when an error occurs if the
person using the program can sort of
understand the context of the air from
the air itself then you have a symmetric
error if you've ever used Windows and
you get like air one zero four five okay
right anybody ever see that dialog box
you know that sort of thing that is not
a symmetric air no idea what happened
right you just completely lost or like
okay I guess it's okay what else can you
say right so that's a violation of this
idea of symmetric errors the other thing
is chain of evidence chain of evidence
is critical in understanding why a
system fails if you've ever had to deal
with say a null pointer you never had to
debug a seg fault right seg faults
happened typically so far away from
where that value became a null right and
then somewhere over here you're reading
from zero segmentation violation you're
you're out of there right yeah I kow
where where do they come from how do I
find it right it's those errors are so
incredibly hard because the chain of
evidence on how a value became null and
how it got propagated through is really
really hard we're fairly simple that
deliberative part of our brain that can
think about something like should I do
this then should I do this has trouble
doing something like multiplying 23 by
47 it's actually a hard thing to do and
so if we're not being really really
careful the chain of evidence we are
potentially making it incredibly hard
for people to debug for people to
understand systems if it's hard to debug
it's hard to build systems it's hard to
change systems we're going to be doing
less we're going to be accomplishing
less than we would otherwise so that's
why that's important one last thought
there are multiple ways to do
concurrency there are fascinating things
with concurrency if anyone tells you
that threads are bad or threads are too
hard do not believe them please
understand something about threads I'll
tell you what's hard hard is reasoning
about things when they're really
complicated and really deeply sort of
inter interconnected but we have a bunch
of ways that we can simplify those
interconnections one of the ways that we
can make a bunch of concurrent things
really sensible and easy to understand
is if we treat them like in a sense like
organisms when I talk to somebody I
don't have to understand anything about
the complexity inside that person we
have a message we're speaking the same
language we're talking about a shared
topic that we that we both understand
communication is fairly easy so there's
an actor model that models this sort of
process with concurrent things talking
to each other through messages there is
that data flow idea right if you have
dependencies and you can sort of see
them in the data then you can decide
what things can happen simultaneously
and what things have to be serialized
right based on those dependencies
there's also the idea of using data
structures to model things we're locking
on threads can be done inside the data
structure and you get something called a
lock free concurrent data structure
where you don't deal with the locks at
all you just model your data you use the
data
the concurrent data structure manages
that stuff and it's very it can be very
efficient it can also lead to very clear
and easy to understand programs so
there's a lot to concurrency out there
there's a lot to threads I owe all these
sort of things you don't have to choose
this one and if you're interested in
learning more about it and you're
willing to take a look at what is I
think going to be the standard in Ruby
tonio CRE has been working on this thing
he's got a long history he wrote Reb
actor way back when Ruby 191 was out
years ago he's working on this project
called celluloid that provides multiple
different ways of doing concurrency one
of those with celluloid IO is a
non-blocking sort of async IO very
similar to note so that's actually all I
have thank you very much I sure I'm over
time so I don't have any time for
questions but I would love to talk to
any and all of you well I don't know if
I can talk to y'all but I'd love to talk
to anybody who wants to explore these
ideas this sorry these ideas further I I
will I will honor my my challenge if you
read Thinking Fast and Slow and you
honestly think that book has no value to
you I will I will pay you the price of
that book so please go read it thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>