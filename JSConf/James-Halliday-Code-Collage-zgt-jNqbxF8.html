<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>James Halliday: Code Collage | Coder Coacher - Coaching Coders</title><meta content="James Halliday: Code Collage - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>James Halliday: Code Collage</b></h2><h5 class="post__date">2012-10-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zgt-jNqbxF8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey everyone so I am here good to talk
so the the title of this talk is called
code collage which is sort of this kind
of pretentious artsy thing cut but I
mean what I really want to talk about is
UNIX philosophy so this is one of my
favorite philosophers it's Diogenes of
Tonopah this guy's amazing but there
really are these sort of um these higher
level kind of platonic forms in code
that I think are really amazing and so
just a little bit this is the company
that started browser lane whoops it's
just like a cross browser testing site I
mean mostly these days is just to
subsidize my experiments but it's we do
have a lot of great stuff planned so i
was just a lisbon and and this guy max
ogden gave people a fish it was really
it was really excellent but it got me
thinking yeah so max Ogden has this
really cool website called call back
he'll calm and I think it's a really
great example to start this sort of this
sort of discourse on what makes good
code and what makes good art because
there's there's a lot of similarity so
for instance if we see some code like
this right this is sort of the canonical
i took this exactly from his website
this is the canonical sort of um
terrible callback hell where you just
like have this this arrow pointing off
to the right in the distance it's it's
because we we take our state and we just
nested and we keep nesting and we go all
the way out and it's totally unreadable
but so I wrote a piece of software that
lets you take whoops take those and put
them in a more of a graphical form so
we're not really looking at the code
anymore we're looking at sort of a
graphical representation of avoided
entails so for instance in this it this
image viewer thingy gives each nested
statement a new color so you see like
the banding pattern and the more the
more of the color you see the probably
the worst the code is so it's
it's a great way to sort of visualize a
code base on a higher level and so if we
go just to the rest of this stuff on
call back hell I've got a nice little
sequence here for that so here we can we
can have a just a simple form and you
know we can have this on submit thing
that's kind of ugly because it's got you
know these nested callbacks in it you
can rewrite those so that you actually
named your functions and then you can
split them out which is really nice
because you're you're being explicit but
really the really beneficial thing about
it is when you start doing modules so if
we just could require a module we
wouldn't have to do any of that we could
sort of push it off to the side and just
make a module that just does one thing
and that's a really important thing in
UNIX philosophy it's just do one thing
ideally exactly one thing unless you
can't for whatever external constraint
but so you you have a module that looks
like this and you like exports submit at
the end there or you module that exports
and it's really amazing like I've really
fell in love with this pattern in node
because it means that you can just do
one thing really well and then you can
share it on NPM and what's really cool
also is that when you do that you start
like this is the first one right we have
we have some nesting we have this color
pattern we can you know this is where we
name it but that's just an incidental
step to get to this point where it's all
the same color because we're only ever
going one indentation level deep but I
think the most important thing also is
that you know this none of these pieces
are very big either it's you know it's
15 20 lines tops and I think that that
that is really the sweet spot you know
maybe maybe all the way up to 100 lines
but not much more than that for
modularity and so here's here's both of
the pieces of code as the final step so
we can actually split things up into
separate modules push them on NPM and
it's really great because you go from
this to this so we can get a little meta
here and actually look at the code that
generated this so the first thing as I
was creating these examples as well I
find myself doing this pattern where I
where I call child prostitute spawn all
over the place but I typically only want
to check the exit status to see if it's
if it's nonzero and if it is a nonzero
then I want to just like make an error
message and put all of the standard
error into the error message that would
be really handy so that is all of that
this function does we can actually zoom
out a bit to get more of like the higher
level what it's doing it's very short
it's let's see it's 47 lines total and
so the next piece was well maybe I don't
just want to see one piece of code
rendered I want to see the entire get
history rendered animated which i will
go to in a second so here I've got the
second this second module that just uses
the git log command and and parses all
of the commits and if I can't quite run
that but well so when when all this
module does it's one thing is that it
just takes get log and it just gives you
objects instead of like the standard get
format it's very simple and the the
final thing that I needed was a module
to actually render the things with
canvas this one is unfortunately the a
bit long it's 108 lines but that's
that's sort of the upper bound usually
for most of the modules that i make you
know it's so it uses a two modules
canvas and which is by TJ Holloway chuck
is just a wrapper in node for the native
canvas browser API and falafel is just a
small rapper i wrote around ass prima
jeaious which is really great because it
lets you take JavaScript parse the
abstract syntax tree the ast so that you
can get all the tokens and that's how i
was doing them like having the different
colors for the different bands in the
code so the next piece is called get
file there's this really excellent
command and get called get show and all
of all that this file does is it's a
really simple wrapper around the get
show command and all you do is you
specify the commit reference so that
could just be a commit hash a colon and
the file name and that lets you like go
back in time to any
II the state of any file at any
particular time so we can just have a
really simple wrapper and combined with
forget history we can see what any file
looked at for the whole course of an
entire program like how it evolved like
what's its what's its back story
basically but that's not quite enough we
actually need a final piece to really
tie it all together this one is called
get detective and it analyzes the app it
analyzes the the module dependency graph
of a file in agate history so you can
have this historical file and this
program will will analyze the abstract
syntax tree but it actually looks at the
require graph so you require a file that
file will also be included and it's and
it's sub dependencies will be included
that doesn't parse down to modules but
it just looks at the files in a project
which which I'll talk about a little bit
but this one is not very long either
it's well it's 114 lines and then once
we have all of these pieces all that we
need to do is turn the get the get
detective data structure just with a
really simple map into this piece then
we can finally run this program so this
is just the coloring logic and the
program source now this is really cool
right here we take the history and we
pipe that to our detective grapher and
then we can just create a right stream
and write all of these files to disc so
that is the entirety of this program 36
lines and let's see so if i go here to
this is the entire history of the
browserify project so i'll give it a
second to load yeah and so with with all
of these tiny pieces were able to look
at the entire history of a project this
is all the get commits this is like 620
odd commits the history of the project
and here it a little bit you'll start to
see several files there we go so this is
like breaking things out into module and
into
separate files now you might notice one
thing it's it's not continuously growing
by any means like there's a lot of
discontinuity there and that's where
I've refactored things out in two
separate very tiny pieces so like a
detective which which I showed an
example of using get with is is one of
those discontinuities where it jumps
back a step and so this is the history
browserify I also did this for d node
which is another one of my projects it's
a basic RPC system and this one tells a
similar story right it's it's the the
basic layout you know but it's tends to
be rather small right and and there are
there discontinuities and sometimes it
jumps up a bit and then it jumps back
usually because I'll split that out into
a separate module but one of one of the
big lessons here I think that I've come
across is it the best thing that can be
said of any piece of software is that
it's too small if people are complaining
and I've had people complain at me about
this very thing that your software is
too small you're doing something very
right like erring on the side of being
too small is is really beneficial for a
number of reasons so firstly um like
project modules tend to grow over time
software tends to get bigger and like
especially with you know edge cases and
things but if you start at the small
then you'll have room for that later
also it makes things a lot more reusable
and n modular so speaking of modularity
I have some examples here that I think
really demonstrate this in really
practical terms about exactly how we can
start using these little pieces to build
systems that actually do quite
sophisticated things which should be
really amazing so uh the first thing oh
and I have pictures for some of this
besides the max Ogden fish which is
great yeah it's it's all about technical
debt ok here's the image that I wanted
to show so the first module is just this
silly thing that the atom is an event
emitter
the little box with the conveyor belt is
a readable stream and all it does is it
changes like it gives you the opposite
that you gave into it so if you give it
an event emitter you get a readable
stream if you give it a readable stream
you get an event emitter really simple
stuff that is the only thing that it
does and it's a module so we can start
using these reusable modules and you
know all we need to do is we create a
new event emitter and we give that we
give that a vent emitter to emit stream
and then we get back just a stream that
we can listen for data on so here we'll
just omit some data beep boop and we can
we can then use another module called
JSON stream to actually type that
somewhere so we'll pipe it to the string
of five stream pipe is really amazing it
lets us really compose together things
in a in a super excellent way so let's
see this one is 05 so yes here we've
just got data that's continuously being
output by this program um but what's
really cool whoops is that we can we can
start piping it to places like process
gender it out for instance but the
really cool thing about about these
these modules that just use really
simple interfaces like streams is that
we can make servers simple servers that
just talk on the network so here just
with like what three extra lines we've
now made this simple streaming interface
a TCP server so if we run that then with
curl we can actually are that cat I
guess we can connect on a port and cool
we get the same data that we got on
standard out I think that's a really
really compelling reason to use these
these different interfaces so a
midstream is really great because you
can use these streaming abstractions
like like Hyrum will actually just be
listening for events now so this this
server connects to itself just to
demonstrate how you can really compose
these together so
is example 10 make that big ah cool so
this this server just connected to
itself and it's now parsing the data but
in a streaming way so for instance if
you only use things like json.parse
you'd have to like make a line a new
line terminated protocol departs things
or something silly but we can do a
little bit better with streaming
abstractions like this so the next thing
I haven't in mind that was kind of
boring I think but this thing actually
is rather practical so let's make our
own socket i/o why not right because you
know maybe we don't need all of the
opinions that something as big as socket
i/o hasn't stored for us we need like
separate reconnect logic we want to
actually turn off the debugging which is
sort of annoying sometimes in a
different way or we just really want to
layer our abstractions so we can totally
do that using using these really simple
modules that only do one thing so here
we just create an HTTP server and just
like have it serves some static content
we can use this module called shoe which
is just a very simple streaming wrapper
on top of socks yes it's like 30 lines
it's really great and the cool thing
about shoe is when you create a server
all you get is a stream there's no like
special interface on top of that that's
that's additional it's just a really
simple thing and you just hack it into
your server with like a couple of extra
lines so here with this example we'll
just right we'll write some output will
write a string and to UM the the browser
stream so this this is a WebSocket
polyfill socks jss sort of said so the
browser side of this is similarly simple
it's actually even simpler because all
you do is with a module system like
browserify you can just do require shoe
and then all you get is a stream this is
really amazing like you just get a
stream and you can do whatever you want
with that like listen for data events
and render the text content so if we run
this server should be on localhost 8050
and i have to make it big okay the first
one
sweet so zeros and ones we're getting
data back that's cool it's it's doing
exactly what it should and its really
really more amazing than that is that we
can extend this example so here's the
server again and now let's see now
instead of just writing data directly we
can use that a midstream abstraction
that I just talked about so so here
instead of streamed out right we'll do
EV Dunham it upper and that can just be
an event and so the thing about these
abstractions is you need to you have
control over the serialization part of
it yourself you're not you're not
letting another library do that for you
but it's really easy to plumb in
different kinds of abstractions so here
we'll use JSON stream but you could use
other other modules like stream
sterilizer or you could write your own
it's it's really great because you have
all of that control and all you need to
do is we'll take this Amit stream
abstraction it will pipe it to a
serialization library that just does
that one thing that's very important so
we do all these things we pipe it toward
our string of fire we pipe it to the
stream and then we should just be able
to run this so here I've just got some
intervals that that emit to events so if
I do run to jas we'll go to the second
example cool so now instead of just
outputting Gator directly we can output
data through an event emitter which is
great but it gets better because whoops
because we can use even crazier
abstractions that just do their one
thing like for instance there's this
concept called multiplexing and
demultiplexing where you can take
multiple streams and pack them into a
single stream like this is really great
in the browser where you only have like
a WebSocket connection and you you want
to be able to layer multiple kinds of
abstractions into that single WebSocket
connection so there's this really great
library by Dominic tar called
muckety-mucks that that handles this
really well so much deluxe is really
simple to use you just require
academics in the browser or the server
it doesn't really matter so much so long
as you use browser and fire something
that does is that like that I should say
and you can create a writable streams or
readable streams or through streams or
duplex dreams whatever you like readable
or writable or both and we can so for
instance this is just a server example
and here we've got our multiple data
channels and we'll just pipe from this
giant dictionary file I have my computer
and we'll we'll cut out etsy password
also just for fun don't worry that that
hasn't been a problem for like hundreds
of years whoops by which I mean like 20
years and so all we have to do this is a
network example that's why this 13 so we
do this and oh no I don't even have that
in the local directory well anyways it
in multiplexes the the stream into a
single stream in this case process that
standard out what's really cool is
because it is just a stream we can use
this over a server connection which will
be important in a minute I'm building to
something here so we we can pipe our
server just by doing that instead of
processed us to enter it out we pipe to
a server cool and we can give our
streams names so like in socket i/o for
instance you might know the the the
event names you can create like
different channels and things but it's
sort of like added on and it's it's you
have to really buy into that ecosystem
of architecture but with with tools like
this you can really just as long as you
have a stream in the first place layer
on additional connection additional
abstractions so and what's really cool
is the code we can write is just really
not very complicated also so I was
thinking about what my last example
would be and it turns out yesterday I
was at this amazing thing called node
copter and it's really great because I
was without even thinking about it using
a lot of the same as
shins that I've just been talking about
so let's write whoops let's write a
helicopter control system that will
connect that will um also be a website
that we can view image data on and it
will do color detection so the first
part the color detection is actually
really easy and we can just do this as a
simple module that just does one thing
so let's do that so the first thing is
we can use node on the server with the
canvas to to just get the pixels in the
first place so we'll pass the width and
the height and a buffer of image data to
this and it will will draw it for us
cool so you can get the array well it's
not quite an array but it's like a data
array of all of the things that you need
for it and this is the simplest possible
algorithm that could work for detecting
color red for instance like a Matadors
cape it's it's red and our helicopter
can detect colors but all we have to do
is actually just sum up all of the
colors in the image there we go and the
easiest way to do that I think is to
convert to hsl first so you take the RGB
pixels you can first them down to two
hsl and you get the hue in the
saturation in the luminosity and with
that we can just write a silly little
function that that detects the ranges of
the colors so the hues within a certain
value and the saturation has to be you
know so high over 30 will say and then
the luminosity you know it has to be it
can't be too dark and it can't be too
light so let's count those and that'll
be a threshold so that's all we need to
do color detection the really cool thing
is got this working like 10 minutes with
training data so here I'll just run the
training set so those it those values
are false true true false and here I'll
show you the images so that one should
be false true because it's got red in it
true and false because it has red but
not enough so that part was easy
the next part is is a bit harder so this
is just the the training example right
it's just like not very much code and
we're just layering these abstractions
on each other so nothing is ever very
much code what's cool about this is well
first we can make an HTTP server now and
let's see you know just serve up some
static files and we can use shoe to just
create a stream and we can fill this in
with machst du machst du Ã¤r
multiplexing so we'll need a few
different types of data going over our
communication channel so here we're just
setting up with the this called the
duplex stream that's where you take a
stream and pipe it to another remote
thing and then pipe the results back
into your abstraction but we can use
that omit the midstream abstraction that
I was talking about earlier to make an
event emitter API and so this is kind of
nice because the ar.drone stuff that
Felix wrote lets us let's see as soon as
we um hook up all of the plumbing for
the amit stream yeah here we go we can
take the ar.drone and we can actually
well disable the emergency functionality
first of all of course and we can
actually just create a PNG stream and
get PNG's out and then we can use our
other abstraction to actually pipe here
we go here's our detect algorithm and
we'll pipe each of the PNG images as
they arrive into our detection then we
can do all kinds of crazy stuff like um
let's see what should we do like I don't
know well we can omit some events to the
browser can read them but we can also
zoom forward at full speed and blink the
LEDs how about that'll be that'll be
pretty fun so yeah and then we'll turn
them off again after a second because we
don't want it to like crash into
whatever like a wall or a person or a
table or some drinks or whatever so in
the browser though and here why don't I
connect make sure that I can actually
connect to this
Oh excellent ok so the browser side of
this is not complicated either and
what's really cool is because all of
these streaming modules just do their
one thing and do it well we can just use
a browser if I to make all of this code
work in the browser with the same
libraries which is really excellent so
we can use shoe and emit stream and
muckety-mucks in our browser code just
like we we do in the server and just to
show you like we're actually in the
browser this isn't this isn't node here
we're doing query selectors and things
and and I here I've got a cross hairs
image so we can superimpose that on the
actual webcam data it's really cool if
it works and we're so on on the server
side it's actually emitting an image
event that gives us the entire buffer
and converts it to base64 and we can
just throw that in the image which is is
pretty fun and here's the the part that
does the crosshairs so once we have all
of those things in place all you have to
do is just hook up the plumbing right
because it's just a really simple
abstraction so this whole thing is not
very complicated and but suppose later
that we actually want to want to drive
it right because like it shouldn't just
be totally autonomous because that
that's hard algorithm and it's not quite
as interesting so the really cool thing
about streaming abstractions and modules
that just do their one thing really well
is that we can hook them up whoops all
right this is the browser code yeah we
can hook up streaming abstractions like
Dino to do our PC for our our crazy
robot example here so will require d
node and just a hook denote into our
plumbing first of all with um some pipes
and can list out all of the methods that
we need to UM to proxy in into the the
air drone API and then it's just a
matter of let's see oh yeah then it's
just a matter of um well doing a little
hacky thing
because they're on the prototype instead
of object object you can get with object
keys but we can just plug that into our
machinery over muckety-mucks and now we
have our event or a midstream event
emitter abstraction we have our Dino
distraction for doing our PC so we've
got both of these things in there and
they just layer on each other really
well so let's see there's more browser
stuff that's not important at all oh
yeah and we just hook it in it's it's
pretty easy stuff so that is it and now
oh yeah it's on here it is here's the
real one ok so we're connected and we
can go to this web page it just uses all
these streaming distractions and we have
a video feed and everything make it a
bit bigger so the thing I didn't show is
the keyboard controls but that's just
like a 20 line script and so I just took
I just hit a button that does the
takeoff command and you guys should be
able to see the video stream here so
I'll go forward a bit slowly go up a
little so remember that image detection
stuff right Dominic if you would hear
Dominic as some red oh it's
targeting
whoa no okay sorry guys ok so here we're
getting close again and uh let's see if
enough pixels whoa do we have enough
pixels no
and so with a little bit of UNIX
philosophy and some nice design
aesthetics we can make a matador
helicopter drone of doom
I'm just gonna keep flying this into the
kik Mouse stage so for subs deck yeah I
don't think that's not a question but
yes absolutely what the fruits took uh
why don't you think you can use streams
in like the browser like the
presentation before this one was about
Web Audio right why isn't there a
streaming API for of audio like like why
why why our screens just for no
developers right by our streams just for
no developers well they shouldn't be
we've had streams actually in UNIX for
the longest time since the 60s actually
I don't know streams are one of those
abstractions that we just kind of see
again and again and they sort of they're
like describing something more
fundamental to computing and that's
doing I oh really well and just doing
asynchronous i/o especially where you
you have pieces that just need to talk
to each other and you have to like move
data from one place to the other place
and I think that streams are just a
really good API and they shouldn't just
be four node and they shouldn't just be
four things that look a lot like node
like I do with with some browser stuff
so I don't even know if I answered the
question max but I I said some words it
was a loaded question so I think I think
that'll be sufficient anyone else does
he know going once going twice all right
thank you man
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>