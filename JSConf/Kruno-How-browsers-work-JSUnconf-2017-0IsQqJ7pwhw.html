<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Kruno: How browsers work | JSUnconf 2017 | Coder Coacher - Coaching Coders</title><meta content="Kruno: How browsers work | JSUnconf 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Kruno: How browsers work | JSUnconf 2017</b></h2><h5 class="post__date">2017-06-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0IsQqJ7pwhw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">about how browsers work I always had the
passion to understand the underlying
principles of how things actually work
and by understanding those underlying
principles it helped me to develop
things on top of it so recently I've
decided that I don't really know how
browsers work and I wanted to learn more
about it so beforehand I had to have a
very big disclaimer I'm not a browser
engineer I'm not my work is not
developing browsers but they still wants
to explore what browsers are all about
and how they do their magic this is just
me being humble that in any there might
be questions from the audience that I
might not be able to answer so let's
start with the browser components a
browser consists of user interface layer
a browser engine a rendering engine
networking JavaScript interpreter UI
beckoned and data persistence user
interface I would define as everything
which you see but you can't manipulate
so the address bar the settings of your
browser's you can't really manipulate it
and that is a user interface user
interface is working together with the
UI back end and this UI back end is the
design to develop basic widgets browser
engine works as a mediator between user
interface and the rendering engine so if
you are to press refresh on your browser
then the browser engine would take that
command and execute it for you and
refresh the webpage so rendering engine
the part which parses the HTML CSS in
JavaScript and based on the results of
that which is being parsed it's going to
display the page so networking it's like
just when you have an HTTPS or an HTTP
request networking layer is going to
make sure that the resources are loaded
JavaScript interpreter is going to
interpret the JavaScript and the data
persistence so here we are talking about
cookies local storage index DB
filesystem etc so as you can see browser
consists of lots of layers and it it
would be very challenging to cover every
single one of them in one talk and since
this is a front-end conference I'm going
to focus on the rendering engine so
first of all let's take a look at the
basic rendering engine flow so what
happens first time when you open the
website and the rendering engine is
being started first is being parsed then
after the parsing step the tree is
rendered then after that tree is
rendered then something called layout is
executed and depending on the browser it
may be called layout or reflow and after
that step comes the final step called
paint which just goes out the objects
with colors so right now I'm going to
focus on each of those steps in detail
starting first with the parsing if you
were to develop the parser you would
soon see that there are two types of
parsers there could be a conventional
parser and unconventional parser for
conventional parsers you can use them to
parse CSS and JavaScript but for the
unconventional parsers you are
of unconventional parts you are going to
need to use for HTML I'm going to
explain first the conventional parsers
and then I'm going to explain why
HTML requires an unconventional parser
and how it uses it so this is parsing
one on one if you were to go to
Wikipedia you would soon find that
parsing can be defined as translating a
document into a structure that code can
use so let's now focus what that means
you see this picture over here it
consists of a mathematical equation and
we need to parse somehow parse this
equation to a certain tree which our
code can later on use so the parsing
actually consists of a tooth like
parsing consists of grammar and grammar
entails vocabulary and syntax rules
vocabulary is like in our language we
have ABCD or more specifically we have
words and here you have instead of the
words you have numbers for this
particular case and you have these
mathematical symbols like plus and the
multiplication sign so those those
numbers and those symbols are going to
be our vocabulary syntax rules is
basically how those integers so
basically how vocabulary interacts so
you know that the multiplication sign
can be only be between two integers
floats or whatever but in this specific
case let's focus on it being just
integers and plus can be before an
integer or an author an integer or
between two injured integers and once we
take a look and how that's being parsed
we can see
that that plus is that Gaza is at the
top at left side of the three you can
see one on the right side you see
multiplication sign together with
numbers two and three and you can feed
this to a certain code which is going to
take advantage of it and generate some
kind of result so let's go a little bit
deeper into it so parsing contains
lexical analysis and syntax analysis
lexical analysis is usually being also
called lectures or tokenizer z' it is
the that part of parser is basically
creating the tokens and tokens are the
smallest elements that a parser can use
if here and the second thing is parsers
parses apply the syntax rules here we
can see a diagram where we have a lexer
and parser parser is going to constantly
request tokens from the lecture and
lecture is going to reply with with
sending the tokens parser is always
going to try to use the token based on
the syntax rules but if that is not
possible it is going to store the token
and at later time is going to see if
that token can be matched to something
so you could go the route of developing
your own parsers and that might be a
good thing to do but usually there are
ready available parsers like flex legs
yak and BISM and for these parsers you
had to just feed it with your grammar
and they are going to work using it and
the funny thing is even WebKit is using
two of these parsers WebKit is using a
flex four lecture as lecture and bison
as a
so right now let's move to the
unconventional parsers I said that for
the conventional parses you could use
them for parsing CSS and JavaScript but
for but for HTML that doesn't work and
it doesn't work because hTML is not
context-free grammar to be to put it in
layman's terms that means that as you
are trying as you're parsing the code
the HTML the h the browser is going to
try to immediately recover from any
errors that might occur on the way and
here we can see two images one image is
displaying a perfectly valid html5
document and the other one is not
displaying a no-bail html5 document you
can see that on the right picture the
closing text for paragraphs and div tag
is missing but even because those two
tags are missing those cool two closing
tags are missing the browser is still
going to render the render it correctly
how it's going to do that exactly it is
automatically going to add closing tags
for the paragraphs and the closing tag
for the DES and then you're going to get
your page rendered because of that you
can't use regular conventional parsers
so for there's still even though you're
not using conventional parsers they
still have to be some kind of rules and
those rules are defined by the HTML
document type definition defined by the
World Wide Web Consortium this is one
more rule or one more example where you
might go so this example is obviously
going to work but if you try to have
maximum
of month of text at some point browser
is just going to ignore them there is
one website which has approximately 1000
and 500 texts going one after each other
which are all of the same kind and even
though that website has so many text it
is displaying perfectly normally so how
do you parse the HTML document is fairly
simple you have you have your valid
html5 document and if you remember the
principle from the conventional parsers
the same thing can be applied here so
here the only difference would be that
your first look going to try to look for
the opening tag and then you are going
to try to match that tag with the
closing tag then that's how you're going
to slowly and incrementally build your
three which you later can use to render
things so right now let's move on to the
next step which is called render tree
render tree is generated while the Dom
tree is constructed so on one side you
have done 3 which is being constructed
and at the same time rendering of the
render tree of render 3 is being
constructed so render tree is basically
visual elements and in in which order
they need to be displayed again based on
the browser you might have the
terminology might be different for
example it might be called the renderer
or it might be called render objects
those are the small elements which this
3 consists of and one important thing to
note is that those render objects those
smallest elements are basically
rectangles now when you go and try to
render it down and you try to
investigate hope codes how it works
at some point you are going to stumble
upon a switch case which based on the
whether it is whether it is render not
based on the definition of Dom element
it's going to render it as render non
render a line rendered block inline
block or list item now let's move on to
the layout so layout or also called
reflow in Mozilla browsers calculates
position and the size so most of the
times it is possibly to calculate every
single thing in one path but in the off
chance that it is not possible then it
is going to do multiple times and try to
calculate the size and position of each
and every element it is a recursive
process and usually it begins as the
root object which is in HTML tag now it
also has something called dirty bed
system this system make sure that you
don't have to run to lay out on each
browser interaction so let's say you
just you just modify - no - nodes - Dom
elements a way inside of the tree there
is no need to re render the whole tree
you could just rear-entry layout those
two and not worry about the rest but it
is so there is also this global and
incremental layout global layout is when
you're doing a resize of your browser or
you apply new font then the whole layout
is going to be executed through the
whole page and the incremental layout is
basically using the dirty bit system to
render some of the things but not
everything so here I have a video about
get quarry flow so as you can notice in
Mozilla it's called reflow this is this
is just showing you how to layout
process happens if you see those
rectangles
and if you paid attention those render
objects are these rectangles and layout
process just calculates where each step
where each rectangle needs to be
positioned this was done by some
Japanese hackers or something like that
and afterwards afterwards they share
this and it was very beneficial in
understanding how browsers actually work
the final step is painting so you saw
those rectangles you just now need to
fill them with the color and that's what
the paint layer is doing paint is going
through the render tree and basically
executing recursively the paint method
which displays things on the page again
like with the layout there is a global
and incremental painting global if it
good there is global painting needed
then the whole page is going to be
repainted and incremental painting is
using the same dirty bit system so only
some crucial parts are being repainted
while other are being as it is the
painting order II is usually background
color than background image and bored a
border and children and finally outline
if you ever had a div which has a
background color and then they cross
image and let's say the background image
was particularly big you might have seen
that the first thing is going to be the
background color and other words you're
going to get your image now I know that
this thought was very basic but I I
wanted to do it basic and understand the
principles behind of the web browsers
and I would like to impart few words of
wisdom which is I hear and I forget I
see and I remember I do and I understand
what it was
by Confucius and it basically means you
really understand something when you try
to build something so I would try to
invite you if you have the time the
resolve and the interest develop your
own browser rendering engine because
only then you're going to truly
understand right now you saw this
presentation and you might remember it
but until you get dirty get your hands
dirty you're not going to understand the
peculiar intricacies of the browser if
you were to go that step and you want to
build your own browser rendering engine
account two very interesting links that
I decided to share the first one is how
browsers work it is it is basically what
this talk is about Barry have a woman
who decides to do the very same thing as
I did but way before me and she took the
source code of Chrome and tried to see
how chrome works
this presentation was based on her work
and later on I stumbled upon about let's
build a browser engine a person from
Mozilla team decided that just working
on on a browser as a part of the big
unit is not enough and he decides
through the small seven part series to
develop a toy rendering engine
particularly because he wanted to see
how it is to develop it on your own he
managed to in approximately thousand
lines of code to develop the rendering
engine which is able to display basic
stuff yeah I mean this is the the end of
the presentation if you want to follow
me on Twitter - my username is here and
that's
now if any questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>