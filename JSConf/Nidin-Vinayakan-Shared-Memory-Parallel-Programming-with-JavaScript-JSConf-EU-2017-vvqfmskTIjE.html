<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Nidin Vinayakan: Shared Memory &amp; Parallel Programming with JavaScript | JSConf EU 2017 | Coder Coacher - Coaching Coders</title><meta content="Nidin Vinayakan: Shared Memory &amp; Parallel Programming with JavaScript | JSConf EU 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Nidin Vinayakan: Shared Memory &amp; Parallel Programming with JavaScript | JSConf EU 2017</b></h2><h5 class="post__date">2017-05-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vvqfmskTIjE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good evening everyone my name is nadine
vinayan I'm from India I'm mainly
working on web technologies right now
you can find me in future maybe some of
you know me like this thumbnail I'm on
Twitter on zero one alchemist right now
I'm working on a startup company called
install motion powered by a lens so we
are actually trying to sell cars online
so you can buy cars online with the most
clicks if you don't like you can return
it yeah so you all know we have web
workers and it's enabled multi-threading
at some extent so for example if we have
a memory in worker 1 and we have memory
in worker too if you want to share this
data we can copy like one by one one bit
by one using force that's not the
efficient way another thing you can
actually post this in their memory to
the worker to then it will clone it's
actually copy the memory one and their
memory block and create a new memory so
in the memory it will take like two
blocks of memory another thing you can
actually transfer this end their memory
the problem is its cost but it's not
there is no cloning just transfer the
memory the problem is it's detached from
the CPU one and no more access and if
you have a knob jex it's even crazy it
will be sterilized and deserialize do
during this clone is very expensive so
for a real real time shared memory act
on parallel programming
is not an option yeah this is good news
we are now at mass script 2017 or ES 18
and there's an new feature shared memory
and Atomics like this rusty Hansen so we
have a new API or an object said array
buffer you might hear it are a buffer so
when you create an aria before it will
allocate a memory block in the run and
you can work with it but the problem is
you cannot share it share or a buffer is
the same but the underlying memory is
shared between all the work workers so
the APA is similar but these differences
you don't need to transfer this thread
or a buffer because it's all it runs
shared between workers so just pause it
so it will transfer the reference to
dismember a to the all the workers and
all the workers can access the same
memory it can read and write to this
memory so something like this in a
worker CPU 1 &amp;amp; 2 and a memory shared
between to work so let's do some
executions so we are actually counting
like 200 million numbers the whole how
long does program take time for 200
million iterations how can we make it
faster run iterations parallel so it's
just hypotheses how much faster we can
run parallel in two CPUs see a tube CPU
yeah we expect ok expecting speed-up of
two maybe less because controlling for
king of workers and message passing may
be little less than two but actually
it's slower why this we forgot these
little guys because each CPU has its l1
cache and also on top of it there's l2
cache so if you want to access the map
memory it will copy to l2 cache then l1
cache so if you are doing a computation
only in one search it is water because
all the memories are in
idiot Lee available in l1 cache so the
accessing is very fast but if you want
to share that operation between
different workers yeah you need to go to
these things and also there is another
set of problems because it can cause
data race for example the initial value
the accounting so the initial value is
zero so it will copy to lol one cache
then it's available to CPU one maybe CPU
two is already fits this data and if
increment by one and it's right to the
shared memory but if you want doesn't
know it
okay then what will if you want do it
will also increment by one and write
into the memory but you are actually do
two additions but at the end we will get
only one but you should get you because
it is the there is no coordination
between CPU 1 and CP 2 so for that we
need new set of ApS it's called atomic
so we can actually look one particular
Lane of memory access and during the log
CPU to cannot read or write from that
memory location so using atomic
operation we lock the memory and we load
it and we add it and store to this
memory and release the lock then the CPU
can increment or read and write to this
memory using lock or without lock if
it's not working the same problem it
might happen and this is the new API
Atomics it only available in digits so
we cannot do slot Atomics so you can
only use for Indies arrays so when you
do like this atomic add in 32 0 1 so at
the end you will actually get the
expected result so let's do small
general
so
that is our symbol program counting so
let's count in single thread so it takes
around 400 milliseconds to count these
two hundred million numbers then count
in parallel yeah it's take longer not
only that if the count is actually
rubbish that it's not than 200 million
if you run it again it's different each
time you run it's different data because
there's a data race it's not coordinated
it will write depending on the hardware
depending on the cycle house if you use
busy the CPU will schedule these
instructions independently we can run in
with atomic it's quite slow because it's
actually doing it kind of serial because
it's locking the memory and adding it so
during that lock stage the CPU one
cannot add it so yeah you will get the
exact truth expected result but it's
strict like 13 seconds that ridiculous
experiment
than single serve that problem is on I
will show the code say
yeah it's actually I creating for in a
for loop it's actually accessing these
atomic ads every time like 200 million
times using atomic SAP which is very
slow because it's locking 200 million
times that's really very slow so I have
another like variant count pellets
optimi or atomic but with optimization
it's like symbol optimization but this
is very fast you also get the expected
result then when you run this single
thread again
so when you run a single thread again
it's actually much faster now because
it's actually v8 is optimizing it it's
50% faster now then you compare with
these 400 so in the optimized version
what I am doing is because accessing
memory is expensive so when you
distribute some data so I'm actually
using a local count then I'm actually
counting locally because I have a threat
and I distribute this two hundred
million counting to the a thread so 200
million divided by 8 so in this loop it
only used the registers like this log
like count is a local variable so it
will store it to the CPU register and
then doing this for loop the accessing
discount and implementing its in the
register so it's very fast then after
counting that local numbers only using
one atomic add that's why it's faster so
if you're really doing any real parallel
programming you yeah the a Dimitri is
very good but we should not do do it if
you don't use it or if you don't really
need to synchronize the data
let's go back now
then yeah little demo so I was working
on a TJ's render engine it's actually
red racing engine so maybe some of you
know replacing so three days is actually
by default it's using WebGL so using
WebGL it's very hard to mimic how light
like like the physics of light it's very
hard to mimic this global illumination
and really stick shadows and soft
shadows so I developed a CPU version of
red racing engine using shared memory
okay so this is the 3GS scene and it's a
standard testing model they stand for
dragon and in order to improve the
racing performance I need to build a
acceleration structure for this I'm
using KD 3 so I need to build the KD 3
it's also visiting parallel so it took 2
point 8 milliseconds then I can start
retracing ok it's actually replacing in
real time in JavaScript so it's actually
splitting the scene in 2 or image into H
tile and it's ray tracing eight tiles at
a time so for a JavaScript yeah
the ray tracing is quite fast in this
case I can actually turn around
okay
yeah
when you toggle the WebGL region and the
rotating version you can see the shadows
are very nice and also there are color
bleed bleeding here the red swan and
also green colors here which is very
hard to mimic using AB GL because it's
really the rasterizing API it's not a 3d
a v8 every one thing is a 3d but it's
actually flattening all the 3d data and
the 2d in this ray tracing we have a
real 3d scene and I'm shooting Ray's
into the scene and an intersecting
through this 3d model and depending on
the normal it will reflect and it will
try to find out the accurate color so if
I am highlighted running little longer
we will get like a real realistic image
that's what you do there's another 3GS
demo it's a three J's demo scene those
who using three.js in the example there
is there it's actually object data with
materials and textures so it this is
actually very like JavaScript and it was
really tough developing something like
this because I have only shared memories
and it's linear memory like there is no
structure or I cannot copy objects so I
need to put everything into shared
memory it's very linear so I need to
write objects into this memory so man
doing manual is like it's not scalable
and it's not reliable if there's an bar
it's very hard to detect let's
the problem is like this so I am an
object and object has some properties
and if I cannot write or read directly
to this thread memory because it's a
JavaScript object what I have I need to
do is I need to utilize the kind of
encode this object into like normal
binaries like object ID and property one
watch value so our writing directly into
this memory it's really not not optimal
because for a big bigger project it's
not an option so I need something like
okay hand objects I'm using typescript
now so I have an object so I need to do
this automatically so I am searching for
in Internet well what's the solution I
didn't find any good solution
so I created a compiler it's called
turbo compiler and it's doing it will
take type script object like class and
it will automatically do this thing then
when we create a not a class inside
JavaScript if you likely allocate my
memory inside shared memory I need to
return a pointer so I can work with that
pointer so yeah the turbo script looks
like this so for example it's a vector
and vector has XY z-- it so for you it
looks like normal type script the only
difference is you need to delete this
allocate memory manually like C++ so you
can create this object so here I am
creating this new vector and I am
exporting this function when you export
a function it will actually export delay
it will create a module and export this
specific function to the JavaScript
world and from the JavaScript you can
access this new vector so it will create
a new vector and lieutenant pointer and
later you create two vectors and use
this function to add it it will add and
rutan a new vector then if you done with
that vector destroy this vector
otherwise it will leak
Marie and he will - okay throw Connelly
turbos cookies like this it's a subset
of typescript but it's little more a
turbo script has operated overload and
point memory pointers that lead to
difference for now and it can compile
the normal JavaScript as in J's and
webassembly in webassembly it's not
really useful usable because I
personally don't have shared memory so
when but simply to release I can really
test how the performance I can compile
the same code two to three different
different plateau targets normal valid
JavaScript and SMGs and webassembly so
it will be a really nice tool to compare
how these three things performing and
it's a still work in progress so I can
actually I'm trying to implement it so
combine complete try script - like
JavaScript web assembly combination so
if some future feature is not supporting
in assembly or in my Beamish because in
order to support all the JavaScript
features I need to real image all digit
JavaScript virtual machine inside
webassembly that's that's not doable for
now so I can actually selectively
compile some hot functions in the web
assembly and other functions into normal
JavaScript and like connect together for
example no don't mock those things I can
actually come build normal JavaScript so
it's easy maybe some hot functions a
number crunching and something like that
I can actually combine into web assembly
or SMDs then you can utilize this
personally because normally when I talk
with normal JavaScript developers they
are not interested in web assembly
because right now only C++ can combine
webassembly and when we talk about
decimally they don't know what is it and
they cannot really use it you can still
write a
in text format which is really not
scalable or it's very low it's meant for
debugging and on is writing in a real
big project in it so this is also a good
tool for normal JavaScript developers
because it's index is similar and yeah
so benchmark so when I'm using normal
JavaScript I need to act I mentioned I
need to create the acceleration
structure for red racing which is kd3 so
to building it it's actually it will
take little bit more time because it's
actually splitting the 3d scene into 3d
space into different small small pieces
normally I need without share with our
turbo script I need to build or I need
build one in the main thread and copy
these objects through post message then
actually it will clone and the
performance was slow and it will take
more than one minute to just initialize
this Stanford dragon right now I am
actually using turbo script and it will
compile and at the end it will just keep
Rutten a pointer to this cake territory
and I can just trail that pointer to the
workers and the workers immediately have
access to the all the KDP so you can it
can just drop right racing I will show
you some syntax
did you teach it
Oh
so there's an aria
is an r/a example in turbo script you
can you can also export a underclass so
it will export a something like this so
we will open a air from there so it's
easy to read okay so it will declare
appointment like this like that anew and
data set from the JavaScript you can
actually use that and new so it will
create a new instance of that data class
and one problem is I am working on it
and working on a wrapper for these
terrible classes so from the JavaScript
you can access like instance dot
properties right now you cannot access
properties but you can access methods so
you can access a set method or if you
want to access a b1 so you need to like
catch v1 flow 32
you need to do something like this to
access the property because when you a
and you instantiate the class what you
are getting is a pointer so you cannot
because it's a in 32 number you cannot
doubt it because it's a pointer so you
need to do like this but I'm planning
like a wrapper function around the turbo
object so it can actually export a
automatically a JavaScript wrapper then
you can use normal thing but I don't
know how fast it's because it will
create an object maybe for a bigger
objects like if you have a huge for
example if you have a big scene of like
millions of triangles you can create
wrapper object for the main route
objects like a scene so from the scene
you can actually access a lot of the
properties that will be useful and yeah
and also I am using this web tool like I
can come by L want them to walk this
text format so I can actually debug what
what's actually going with my button
bleep easy for debugging also I have a
log so it will limit all the data like
what bytes are retaining so it's also
easy for debugging like everything in a
log filing but it's formatted yeah and
yeah any more questions right now okay
yeah suck it just actually cook thank
you so much kneading thank you for the
excellent talk so we have a break
scheduled now 15 minutes and then the
last two talks to the conference we also
have our last community event if you
want to go and check out another live
jazz performance</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>