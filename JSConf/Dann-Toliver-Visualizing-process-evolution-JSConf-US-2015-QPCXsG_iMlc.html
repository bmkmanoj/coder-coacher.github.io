<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Dann Toliver: Visualizing process evolution | JSConf US 2015 | Coder Coacher - Coaching Coders</title><meta content="Dann Toliver: Visualizing process evolution | JSConf US 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Dann Toliver: Visualizing process evolution | JSConf US 2015</b></h2><h5 class="post__date">2015-06-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/QPCXsG_iMlc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">they go open with quote I I read a book
the other day about speaking in public
and it said something about opening with
a quote okay it wasn't actually a book
it was a webpage it was called top ten
things you should never do while giving
a talk but I'm going to open with a
quote anyway because this is where it
all started we are about to study the
idea of a computational process
computational processes are abstract
beings that inhabit computers as they
evolve processes manipulate other
abstract things called data the
evolution of a process is directed by a
pattern of rules called a program people
create programs to direct processes in
effect we conjure the spirits of the
computer with our spells so when I first
read that two years ago it was like
something that had been misaligned
suddenly snapped into place this idea
that the code that we write the artifact
that we're creating and the process that
unfurls in the system as that is being
evaluated are two separate things this
is so simple it's such a fundamental
idea but it's so easy to overlook if our
code is directing the evolution of a
process then in it many ways it's a lot
like the DNA in a Cell directing the
evolution of that cell but DNA is really
the most boring part of the cell it just
sits there curled up into little balls
being read write and all around it
there's this fantastic machinery that's
involved in finding pieces of the DNA in
a massively parallel way and unwrapping
it and parsing it and opening it up and
being pieces out of it into RNA
it down and then that RNA goes out into
the rest of the cell and causes effects
some of it gets pulled into ribosomes
which are these amazing molecular
machines that kind of ratchet in a
little bit of RNA and sort of poop out a
little bit of amino acid at the top and
they find the right amino acids to match
that sequence of codons in the RNA and
then they make this protein which is
like a data structure that has active
sites it's like an object in JavaScript
and it causes effects on other things
and we can keep pushing this biological
metaphor but the point is that there's a
party going on in there and we weren't
invited I want to go to that party so
this talk is a series of three steps of
me trying to find a path to understand
what's happening in this process as its
evolving step one is data our data
structures in JavaScript are becoming
increasingly sophisticated this is in
response to our applications that we're
developing becoming increasingly
sophisticated and in particular there's
a lot of complexity that's being added
in asynchronous processes and when we
share mutable state between asynchronous
processes we have exactly the same
problem that people in other communities
have when they share mutable state
between threads and a multi-threaded
environment right so we run into these
concurrency concerns because now we've
got something over here thing a and
we've got some other piece of code over
here thing be and these two things are
communicating through some communication
channel they're sending messages back
and forth but if they're also sharing
mutable state then they're communicating
through that too and that communication
happens instantly and it bypasses the
communication pathways passageways of
your application so that means you got
this you have this spooky action at a
distance going on when you're dealing
with mutable state right and it's all
right so so we have persistent data
structures that help us have immutable
data so we can reason about our
processes and our programs in a more
effective fashion and they do that in a
performant way rather than
to deep copy everything like you would
if you were making a mutable doubt of
yourself so we're going to look at two
of those immutable Jas and Maury from a
very particular perspective so first you
need to know a little bit about Pasha i
mopped rise or trees who says try who
says tree ok I either ways fine you're
both right as long as people understand
what you're saying I mean a try I will
try to say try because i think it
disambiguate spitter but even though
i'll try to say try a try as a tree so i
may say tree so here's what we're
dealing with this is just a super high
level surface topology of a hash area
map try they're really interesting data
structures it's a try so we put all of
our values down at the bottom and we use
pieces of the key to walk down to that
value we're going to hash those keys
first so that we can pull an unlimited
number of bytes out of them if we hit
the end of the hash we just rehash so
that gives us consistent hash lengths
and also on unlimited hash length so we
can deal with conflicts because if two
things have the same key that or say the
same piece of the hash of the key then
we have to go to the next piece of the
house so we're going to take pieces of
the hash five bits at a time and use
that to walk down the street though
spits give us thirty two possible values
so we're going to have an array of 32
possible values up to 32 values as a
child of a particular node and that's
going to dereference into its children
all right so the things you have to
remember from that are 32 and hashing
hashing gives us good distribution
properties we would rather have shallow
shallow wide trees we don't want deep
trees because depth increases our space
usage and also our time usage so we're
going to put these two libraries under a
microscope we're going to use a thing
called underscore which is kind of like
a data structure oscilloscope or
something and this is slightly the wrong
aspect ratio so you're not single the
slides that just says full history of
the data structure down there ok
so these are the joys of AV confusion so
which was my fault not theirs they did
an excellent job of recovering from that
so we're going to write out our data
structure as a single long list right
we're going to take all of the numbers
in it and for each number and it we're
going to generate a pixel that pixel
will be colored according to that number
we're then going to take that line of
pixels we're going to turn it on its
side and make a column and every time we
make a new version of this data
structure we're going to move everything
over and put that new column in place so
we can see the history of it so let's
cross our fingers and see if we can see
what that looks like here we are aspect
ratios all right so everything's kind of
up in this corner but that's cool we can
we can zoom here this is the power of
zoom all right so what we've done here
is to start putting in some numbers we
see this triangle shape that's what
we're expecting because every single
tick we're adding a new number we're in
cueing a new random number we see random
batting banding patterns here those
correlate to the random numbers that
we've added so once we add a number it
just stays in its place in this queue
the secondary feature that we can pick
out here is these shaded areas which are
shaded there they're less light because
they are down an extra level so the
lightness is corresponding to our depth
in the tree this area is down an extra
level so we can see it fills up with 32
things and then those get added to the
main data structure and we start a new
nursery at that point everybody on board
so far so both of these and I've
cleverly codenamed them blue and red
because this is not a performance
comparison between Maury and immutable
Jas it's just we're going to use these
as a way of understanding what's
happening in the process and in the
program by looking at the data
additionally even if you figure out
which is which which is not very hard
after I hit a couple more buttons I'm
using older versions of them so it's
still not a very
to performance comparison all right so
what happens if we start taking numbers
off so far they look exactly the same
suddenly we see a really big difference
so over here in in the blue zone we have
a data structure that is the same size
right so here it was growing and here
it's the same size every tick and what
we're doing every single tick is pushing
on a number and dq'ing a number off of
this end and we can see that that's
actually happening in the data structure
right there's a couple of strange little
places in here like this little blip
here that occurs about six sticks n I
have no idea why but it's there every
single time I haven't looked at the code
for either of these the point is to
understand it just by looking at the
pictures so this seems like a fairly
straightforward traditional q other than
the fact that we still have our
nurseries going right we're we're
shifting off of one end and pushing on
to the other end so there's probably
some performance implications here
because shift or on shift whichever one
we're using and javascript is not a very
fast function over here we're doing
something completely different in
particular we can see that a whole new
triangle has emerged and we're keeping
the old data up here so what we infer
from this is that rather than destroying
things as we DQ them we're keeping
pointers in fact we can see those
pointers here in this middle section
we're keeping pointers into this data
and we're floating a counter to the end
of it as we DQ things and then when we
hit the end of the old kind of master
section or new growth section we're
dropping everything and this new growth
section down here becomes a new old one
and it starts getting DQ'd and we start
over again here so it kind of makes
sense so far so what we understand at
this point is that there's a massive
difference between these two libraries
and how they handle queues and in
particular there may be some performance
implications for that difference we
understand this not by looking at the
code but just by looking at these
pictures let me show you another example
we're going to start throwing random
numbers in here so we'll take a number
and we'll give it a key that is the
number with the letter
pended and we'll insert this into the
map so what do we immediately see when
we're looking at this we immediately see
that this blue side is about twice as
tall as the red side over here and so we
can start to think that maybe there's
some spatial implications here right
that our space usage is a little bit
stronger over here let's turn on another
way of looking at this so this is a
flattened tree view what we're going to
do is take our tree with all of its
levels and we're going to flatten every
single level and then we're going to
turn the whole thing on its side so if
we look over here we can see that we
have our initial node here this blue is
a pointer to the secondary note here
this points to an array of 32 pointers
which each point to a dereference column
here and then those point to this array
over here and so on but just from
eyeballing this don't know how much of
this you can actually see we can see
that these are adding new new key value
pairs in very different ways this one is
a lot more compact so this reconfirms
our intuition that we saw just from
looking at the sizes let's try instead
of adding these randomly adding them
come on come on you can do it all right
apparently the reload button is not
actually the reload button borrowed
laptop issues all right what's happening
here now we're loading in numbers
sequentially instead of randomly and
something that we started to see it
toward the end of this one becomes very
clear we're seeing this banding effect
whereas these colors are well
distributed these colors are patterned
in a very particular way and what that's
telling us and if we look here we can
see the same story this one even though
we're adding them sequentially is well
populated it's fairly dense over here we
see something that has these increasing
sort of harmonic oscillations that are
going on in the number of collisions so
this tells us that the hashing algorithm
that blue is using is not distributing
values or keys as well as the hashing
algorithm that red is using in fact
we're getting very bad hashing behavior
out of this is probably modulo or
something like that dear fortunately
that was actually the end of the
conclusions that we were going to draw
from that so so what we've learned so
far is that you should always bring a
backup laptop when you're giving a talk
and the second thing that we've learned
is that we can make observations about a
piece of code without ever looking at
that code at all so we've learned
something about these two libraries but
we didn't have to look at any code and
that's important because it doesn't
matter how good or poorly written that
code was right it could be minified it
could be obfuscated above these are well
written libraries but even if they
weren't we could understand them and if
we can do the same thing that we just
did for a library that's producing a
data structure for a library that for
example is our framework that we're
using or that someone else is using and
suddenly we have to take over
maintenance of that code there's
hundreds of thousands of lines and the
framework so we could read the entire
thing to understand how it works or we
could try to go in the back door and
develop our intuitions by actually
observing the process unfolding so one
problem that that we saw well I guess we
didn't see but we should have seen was
that there was a limited screen real
estate we had the opposite problem there
was way too much screen real estate so
fitting everything n can be an issue all
right I will sorry will that actually
work with images it works that's so
great thank you cool so we have some we
have some issues with the amount of
available space to us so we could for
example look at a single line of code
and observe this line of code or we
could observe the entire code base right
and watch the entire process unfolding
so we can kind of pick a place along
this continuum that we're interested in
we could also on the temporal dimension
look at a single operation at a time or
we could look at the entire process
unfolding in real time and so we have
really good tools for this end of the
spectrum for looking at a single
operation one at a time right step
through debuggers work great for this
and they give us a street-level view of
what's happening right we're taking
we're walking through the town of our
process but they don't give us the
10,000 foot view of what's happening all
at once so we can develop our intuitions
about it and we don't have very good
tools for that right now so that's
what's on the left hand of the slide on
the right hand of the slide is some
mathematics that ostensibly proves that
the information we would like to have is
greater than the information that we
actually have but really it's just a
ham-handed way of trying to work the 80s
theme into my presentation all right so
what we're going to do because
javascript is huge the yes five spec is
over 250 pages and because we write huge
applications in it we're going to punt a
little on this problem and we're going
to start with a system where we can see
everything at full granularity but the
entire process all at the same time okay
so that means we're going to design
language we have some design constraints
for this we'd like to keep it very
simple so we're going to have an eight
bit architecture our memory is going to
be 256 bytes and we would like to
introduce random programs because the
whole idea is to gain intuition about
the process that's unfolding from a
program without actually understanding
the program if we understand the program
that we don't need to do that right so
we need random programs that means we're
going to fuzz the compiler we'd like
there to not be any compile-time errors
when we do this we'd like there to not
be any runtime errors
and I'll throw in an additional
constraint that we want all of our
programs to terminate so this sounds
easy right sure so oh my gosh it's so
tiny whoo all right so here is a program
in our language and this over on the
right is supposed to be the jas conf
pegasus but my pixel art skills are not
very good it looks more like a flying
aardvark with the Tommy gun or something
all right so if we run this we can see
that it's some type of image blurring
program and just so you know that I
really okay did I get bounced off the
subnet is that why i can't refresh ah
thank you okay so I was going to show
you that we could edit the program and
it would still work you'll have to take
my word for that it's the magic of a lot
of demos so that's that's great but
we're not seeing individual steps so we
want to go back and be able to actually
see things at a granular level so now we
can see the stack we can see the return
stack these are the two this is the
entire process unfolding we see the
memory we see the the code we see where
we're at in the code thanks to this
highlight and we see the full variable
structure right here so this is
everything if we took a picture of this
we could replicate this process at this
moment perfectly and we can step through
and see that it is in fact doing some
things as we step through but in in
zooming into this level we've lost our
ability to see things unfold in real
time so now we're back to the step
through debugger zone so what we can do
is we have a connection between code
which when it gets compiled down all of
these opcodes over here
or these commands over here get pushed
down into numbers so we can actually
make an array of numbers out of our code
and that's exactly what happens it gets
compiled down to a machine code which is
an array of bytes so at the machine code
level we have an array of bytes and our
memories and array of bytes so we have a
sort of trivial form of Homo iconicity
which is where your code in your data
are the same thing right in a lisp e
language you get a more advanced forum
where you're writing in the abstract
syntax tree and that's the same type of
data structure as the data structure
that you typically operate on machine
code always has a trivial form of Omaha
and necessity but in our case we have a
secondary trick up our sleeves which is
that our memory is being mapped to an
image so there's actually an isomorphism
between the memory structure and the
image and so there's also an isomorphism
between the code and an image or icon so
maybe our homo iconicity is not so
trivial after all I was a really
involved joke all right so we can look
at this as an image instead which is
where things start to get fun so this is
our program running again we could take
the snapshot and reform our entire
process at a moment in time you can see
the readhead it's this kind of white
square here that's jumping through this
subroutine and you can see that it is in
fact performing this image blur on our
memory so that's great but what we're
really interested in is random programs
oh and I can't reload this and it's
stuck in a really silly loop are we good
yes nice ok so we're watching an
entirely random program all the color
spots correlate to different types of op
codes this is an exit so it's the
beginning of the subroutine and this is
a jump so it's jumping to the next
subroutine when it hits that the gray
areas correlate to numbers that serve as
constants in our program and what can we
infer about this well it's actually hard
to infer much of anything from this
system we can see that this square is
blinking a lot and and that we're going
to take a little while before we end
because we've got 200 counting down on a
return stock so what we're doing here is
we're applying the program to itself we
put a copy of it in memory and we
haven't modify itself and then when it's
done when it terminates we're going to
take the modified version and run that
against itself and we're going to keep
doing this until we until our program
doesn't do anything interesting well
this one is certainly doing something
interesting down here at least or we
find a cycle where a program I applied
to a gives us a program B which one
applied to be gives us a program a again
and then we would be very happy and
champagne or something alright so this
was a nice experiment but it's a little
hard to infer much about these programs
because the language is a little obscure
and because we haven't looked at these
pictures long enough what if we could do
this with JavaScript that's the twenty
five thousand dollar question so what if
we could look at the interpreter for
this in JavaScript so I was hoping to
not have to do this but I have to do
this so we'll take this over here and we
will do this and we will do this oh good
okay all right everyone cross your
fingers take a deep breath and we'll see
if we can make this work all right so
what we'd like to see is our virtual
machine for this little language that
we've written running in real time in
JavaScript and over on the left that's
exactly what we're seeing so we're back
to the step-through on the right we're
stepping through one step at a time but
as we step through we're seeing three
columns over here which correlate to
three files this is the core virtual
machine this is the renderer and this is
the this is the index.html can you see
that can anyone see that at all
you can it's visible okay cool okay so
as we step through there's going to be
lots of flashing colors here we can see
different parts of this program being
evaluated so this is the actual
underlying virtual machine this for
example is the the draw function and
it's longer than you would expect and
it's also very very hot so this is
forming a heat map because there's a
tiny little virtual Dom inside here so I
just call it like 256 times a tick but
the point of this isn't to be a profiler
right we already have really good
profilers for finding hot spots in our
code the point of this is to at a 10,000
foot view understand the process that's
unfolding from our code and so another
interesting thing that we can do is not
just watch this in real time which we
can do a little more effectively if we
speed this up we can also slow it down
and watch it happening essentially a
tick at a time so we can see the process
we can see the underlying engine kind of
flowing through and unfortunately this
code is not very interesting because
it's calling the draw function 256 times
but we can rewind and try to we can
rewind okay maybe we can rewind we can't
rewind
really okay so this isn't very
interesting for me this particular piece
of code because I wrote it so I
understand exactly what's happening here
if we look at something else though
something bigger like for example a
framework of some kind that were not
familiar with this one is agility j/s
and then if we do this magical thing
that may or may not work okay good so
I'm using fondue under the hood which is
an instrumentation library written for
written for Theseus which is a debugger
four brackets typing and talking
simultaneously are surprisingly
difficult things to do well okay flashy
lights whoo all right so what are we
really looking at here what we're seeing
unfold before us is the entire process
that's that's inside of agility Jay us
as its handling the things that we've
clicked over here so if we click this
for example and then we know we can't
rewind all right so I should slow this
down a little
okay so we can observe at a high level
the functions that are being called and
the flow of functions as they're being
called
so this shows us something about the
process and we can draw some inference
from it but there's more that we need
what we'd really like to see is the data
that's flowing through here as well and
we'd like those data flow pathways to be
highlighted we want to be able to sort
of poor data in some input of our
program and watch as it trickles through
the function calls and invocations and
watch it when it pulls up in some place
and stays there for a while see how it
interfaces with other data that's
flowing through we want to be able to
understand the applications that we're
working with at the level of the process
that they're evolving and we want this
because reading code is very slow and it
requires that we have an interpreter in
our head and if we can do this
effectively than we can understand for
example frameworks that we've never used
at an intuitive level without ever
having actually use them or read through
their code or documentation so I want
this for the programs that I'm writing
and I also want it for the programs that
I'm reading and if you want it to then I
think we should work together on this I
think we should make this happen I think
we should get this not this but
something like this into devtools right
so we have it available for everything
that we're doing let's augment our
vision let's let the computer do the
hard work of helping us understand what
it is we're working with let's go to
that party thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>