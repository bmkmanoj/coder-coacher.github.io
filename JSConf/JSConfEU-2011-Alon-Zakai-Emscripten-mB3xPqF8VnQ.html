<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>[JSConfEU 2011] Alon Zakai: Emscripten | Coder Coacher - Coaching Coders</title><meta content="[JSConfEU 2011] Alon Zakai: Emscripten - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>[JSConfEU 2011] Alon Zakai: Emscripten</b></h2><h5 class="post__date">2013-06-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mB3xPqF8VnQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'll talk about using non JavaScript
code or libraries in JavaScript it just
before that two things I apologize for
the resolution of the slides my laptop
has been giving me some technical
difficulties thank you to the organizers
of the conference by the way you helped
me with a few problems and second point
please feel free to stop me with any
questions at any point did I prefer to
be asked questions and for you to wait
for the end okay so non JavaScript code
in JavaScript why is this even
interesting what would be the point well
the point is that there's a lot of
existing code out there maybe it's open
source or maybe you have a lot of code
you've written in your company typically
at C and C++ and it could simply be very
time intensive to manually port it to
JavaScript you don't want to start
writing huge applications from scratch
if you don't really need to now the
things when you develop a native that
you can reuse that code so i think we
should be able to do that on the web too
it's just a technical problem that's
stopping us really so I'd like to start
with sort of the cool stuff up front so
with some demos so demo number one
bullet so bullet is a physics engine
it's used actually in several triple-a
games it's open source it's very cool
it's a hundred fifty thousand lines and
it's pretty complicated because well
it's a physics engine you don't want to
start writing these from scratch if you
don't need to because it's so useful it
was actually manually ported to Java
called a bullet J bullet was manually
ported to JavaScript as bullet KS and
there are some demos with this but there
are really two problems with that
approach these ports since their manual
they tend to be partial the people that
are doing this it's a lot of effort for
them they don't port the entire bullet
library as is they pour the parts that
they focus on second of all they port a
that shot of bullet at some particular
point in time so there's always lag so
the trunk version is I think right now
about seven point releases later than
bullet j/s well there are actually two
manual ports here so there's double leg
so mlas is a port of bullet to
javascript with em scripting so it's
completely automatic and for that reason
it you get the entire library as is and
you get the code in its current state
have a few links but since networking
isn't working for me i'll just show you
a local demo and which hopefully will
work ok so this is a simulation of a few
cubes it's rendering using cubic V rjs
they typically fall in a bit more
interesting pattern so so this again
this is bullet running on the web in
JavaScript what's you might have seen
this demo before what's cool about this
right now is that it's actually possible
to tweak the the demo in interesting
ways so this is being used from
JavaScript so for example here gnome is
simply the number of cubes I can change
that to say 20 and just reload the page
and since it shut its JavaScript you
immediately get a slightly more
interesting result if this is actually a
case where it's much more fun to do this
in JavaScript than in C++ with that you
need to rebuild your entire project just
to change some parameters so you can do
that and you can also change things like
let me see reset positions is the
JavaScript which defines where the
bodies begin so let's change the x
position to say I so eyes the index the
number of the body you just said it to I
it should just drop them in a line i
think if i remember correctly yeah so
just sort of falling like that and just
another example we can make them fall
from a higher distance
as well see something else slightly so
it's pretty much the same that they're
falling from a higher distance okay so
that's a first demo out of three that I
wanted to show you second demo is sequel
light so sequel I'd is a very popular
open source database it actually could
have become part of the web through a
web sequel but there's the long quote
here that explains why there's a problem
with a standardization process basically
i leave the code as is i don't comment
on it it but i think the point that i'd
like to make is that the issue with
standardization is that you need to get
people to work together on a specific
API on a spec but if you just compile
the code as is the JavaScript you don't
need to convince anyone of anything you
can just compile whatever you want it
it'll run in all web browsers out there
so here's a working progress demo of
sequel light the resolution is making it
a bit hard to read what's happening here
but it basically well this is some quite
boring sequel light code it'll just
create a table create some stuff in that
table and do a select from it if I hit
execute you'll get key equals to text
equals second item which is what's
expected since we asked for the case
where value is equal to 987 which is
what's over here so we have that and of
course I can do additional commands for
thinking called it's tough so if i do
that i get all the elements and the
resolution is a bit annoying and where
thank you
and of course I can do it basically
anything else in the sequel light syntax
fight ask for less than hundred I get
just the first item since the others had
larger values and and I want to type
this from scratch but here's an example
of enjoying between two tables so
actually it's easier to read it here so
again it's just it's creating another
table more stuff inserting some values
and then it does a select which does
adjoin over the value element so I'm
just going to copy that and run it and
this is the expected data there were two
items for value equals 25 so the text
first item is from the first table it's
a change and then there's two text from
the second table more stuff and get
additional stuff but again this is just
to show that you get the entire sequel
I'd language by compiling the entire
sequel aight implementation so that
concludes demo to demo three Python Ruby
and lua these are popular dynamic
languages actually because they're so
popular there are several projects to
manually implement them in JavaScript
but these suffer generally from the
problems that i mentioned before about
bullets the these ports are generally
partial they don't implement the entire
language there are a lot of corners in
these languages they don't bother with
they lag behind the trunk version of the
language and worse in this case they
typically targeted slightly modified
version of the language for example
pajamas for Python translates Python
more or less as is into JavaScript so i
end up with the semantics of javascript
for example if you do some operations on
numbers you'll get the behavior
javascript has not the behavior of
Python so you're writing something that
looks like Python but it's not really
Python on the other hand if you compile
the entire language as is into
JavaScript and again the benefit is you
get exactly what you started out with so
if I could connect in the network ID
show you this website which was just on
Hacker News repple de it which is really
the nicer way to show this it uses
Python Ruby
with the code that I'm talking about
here but instead i'll show you a local
version of the python one so it just
brings some numbers just some random
syntax and it actually does import sis
and writes version and that platform and
the version of the platform are simply
what was there when i compiled it
locally on my linux machine it says
apple and i assume because it was built
using llvm but anyhow that's to sort of
elaborate and what is it before about
differences with the language it let's
say let's say that I i have think i
actually have a code just so i don't
forget yet let's just briefly look at
this code here so it does x equals to
the maximum possible integer then it
will print the type of X and X it'll add
one to that so it's max inked plus one
print the type and then print X to the
power of 10 why this is interesting is
because pythons handling of numbers is
very different from JavaScript so if I
execute this so the first value here
this thing is type int its max int but
when you add one to that in Python
Python changes that to type long and
type long is not just the long integer
it can be basically any value so when I
do that to the power of 10 you get this
huge number over here so this is exactly
the same result that I would get if I
were just running for example Python
natively here you see I get the exact
same numbers in this case so this is the
benefit of compiling it whereas in
JavaScript natively for just open the
console here and again I'd so this is
code that does something similar it
again it takes that max end and then
shows it to the power of 10 and of
course
the results are very different in
JavaScript the first number is fine but
the second number is a double so you
don't get the same thing we saw in
Python with this so this just shows that
you can implement the real version of
Python on the web getting you the exact
same behavior you would get in the
console native code version unlike in
sort of a manual court that does not
copy the entire language as is I hope I
was clear oh and I did want to do a
fourth demo that I didn't plan on but
given that the previous talk was about
audio I thought it might be relevant so
the previous talk mentioned the Web
Audio spec and the Mozilla audio data
API and I think the very valid reasoning
given for preferring the Web Audio API
was that it's easy to get to results
very quickly you don't need to start
writing the middleware or the libraries
to actually see results but the reason
is pretty similar to what i was talking
about Earth earlier with the Mozilla
audio data API you have access to the
hardware to the audio partner all you
need is to actually be able to have a
library that creates audio in a
convenient way we have that code it's
written in C++ we just can't run it on
the web but we can compile it to the web
and this is a demo of using espeak which
is a speech synthesis engine again
something pretty complicated that you
don't want to start writing from scratch
and if the connection is working you
should hear something but I guess it's
not working so that was underwhelming
I actually can't even hear it locally oh
the people who are sitting in the front
row might be able to hear it I doubt it
I give up oh did you hear anything
that's I think that's as close as I can
get
oh well again this was not a planned
demo okay back to the scheduled
programming so after showing you some
demos I'd like to talk about the more
boring aspects about how this works and
how you can actually use it and so forth
so how does this work the idea is you
take your C or C++ code you want to get
that into JavaScript but you need to go
through an intermediary step of lvm bit
code so llvm the low-level virtual
machine is a compiler project much like
GCC which can compile C code into native
code but it can also compile into lvm
bit code which is an intermediary is
stage which the nice thing about is that
is that it is extremely well documented
and for that reason it's used here so we
translate the high-level world medium
level c code into this low-level a bit
code and in script and then compiles
that into javascript so this is the big
picture of what happens but what
actually goes on here so and if script
when we try to translate bit code one to
one so on the left here we have llvm bit
code and on the right we have the
corresponding javascript so for example
the first thing here could you see the
mouse cursor yet the first thing here is
basically allocate which means allocate
on the stack a 32-bit integer in
JavaScript you can do something very
similar by just doing VAR local
variables stored on the stack similarly
calling a function within a 32-bit
integer parameter here is translated
simply into a function call so this is a
native JavaScript function called not
some complicated a emulation of one and
the last command is a mathematical
ed adding 22 to the variable one and
that turns into an ED so for the most
part in scripting just tries to
translate the bit code as is and that
works for quite a lot but not everything
one issue is that Seco typically
allocates memory using malloc etc and it
reads and writes from that memory you
don't just put things on the stack you
have the heat so we implement sort of a
heap variable in javascript is a sin
which is a single large array a normal
JavaScript array of course and it
represents the memory space so heap of X
is a read heap of X equals something is
a right and pointers X here are simply
integers so i hope this sort of makes
sense another complicated issue with the
behavior of C++ is that so we saw in
this lie that adding 22 is simply a
dollar 1 + 22 but in general of course
that's not correct for example in c x
equals 5 and x divided by 2 gives you
two it ramms down because it's an
integer in javascript x equals 5 x
divided by 2 gives you two and a half so
this of course is fixable by doing math
dot floor although even this actually is
not correct because this gives the
correct rounding behavior for positive
integers with that negative ones but
this works in most cases and there are
similar issues with overflows signs so
these are so c and java script or two
very different languages they their
semantics do not match one to one
obviously so much of the challenge in
writing a compiler from from the bit
code but really from c to javascript is
to get all these little behavior
differences to make them completely
vanish so there are a lot of details
here that i will not bore you with but
it will still worried with some other
and more high level details so to get
good performing code you really need to
generate code that looks like this over
here while and
fourth you want to use native JavaScript
loops and ifs the problem though is that
when you're compiling this bit code you
get what we see on the left basically
these blocks of code so block one some
commands then a branch to block to block
two is another series of commands ending
with a branch this is very low level
it's like some commands plus go tues
it's even lower level than the seco that
we started out with this is the alluvium
bit code so one of the challenges is to
get from this code to something that
looks like normal JavaScript loops and
there's a big section in the in the
optimizer an impression that tries to
reason about these loops and to recruit
to recreate them to something because
this it simply runs much much faster
with a with the loops without loops you
can emulate go tues with various
cumbersome ways it's extremely slowly
with that approach so it's necessary to
do this optimizing step and it's the
second thing I've already sort of
mentioned VAR x is a reasonable way to
implement a variable on the stack it's
of course fast because javascript
engines have been heavily optimized for
that however you can't do that for every
variable for example if you take the
address of a variable on the stack in c
you can pass that to some other function
and of course you cannot access bar x in
javascript in another function so the
optimizer needs to reason about when it
can optimize by doing VAR x and when it
can't ok so you've written your code it
runs it's optimized but how do you
actually access anything or do something
with that code you're running it inside
a web browsers are not on a normal
machine with the files with a filesystem
and so forth so basically an obscure
iftin we've written standard see system
API is in JavaScript we've basically
implemented the C standard it lives see
basically and also plastics and sdl not
all of these but the parts that we've
needed we've written a JavaScript
implementation of them that sort of
makes sense for the web so it uses an
xhr to load file
and so forth so just as an example of
what this look looks like you can set up
a virtual file system using some command
that we added called FS that create lazy
file so you give it a the directory the
name of the file the URL from where it
will actually do the load and the point
is that the compiled code the C++ code
uses the file system in a completely
normal way you do not need to rewrite
your C code the C code will include
standard i/o do F open do F read but
when it actually reads from this file
that debt that we created here the
JavaScript implementation will actually
do an xhr and load that data so we've
made it so you can use your existing C
code but you sort of hook it up to the
relevant things on the web
okay and so how does it actually look
when you eat when you try to eat try to
use this to compile a project so just
one more technical detail there are
really two parts in this project there
is the compiler which compiles llvm to
javascript this is basically what I was
talking about before it's really just
concerned with getting the code into
JavaScript in a way that works so it
just gets it there but the problem is
we're compiling this llvm bit code which
is low level and we get something that's
not easy to use for example if the code
started a C++ you'll have name mangling
you'll have these crazy long function
names that really mean very simple
things but you get them in a mangled
form there's also lifecycle issues
creating objects and destroying them
it's not easy at all in the low-level
bit code so you get code that works and
if all you care about is taking a
project and running it on the web as is
that's fine and that's what most of
these demos were except for the first
one with bullet but if you want to use
the libraries on the web in a convenient
way you really need something else and
that's what the bindings generator is
it's the work of the past few months it
parses not the bit code but the actual
header files the dut h files in your
project and generate some glue code to
connect things so i'll give an example
in two slides that will sort of i hope
make sense of this but the idea is again
that there's a compiler for the bit code
and something else that creates the glue
code that doesn't look at the vid khob
it looks at the high level hitters okay
so how does it actually look when you
compile something to javascript this is
slightly simplified but it gives you the
main picture so you build your library
almost normally you do make and
configure sorry so you build the project
pretty much normally except you use a
different compiler which basically just
changes some parameters gets it to
generate it'll be a bit code instead of
native code then you run the inscription
compiler on that bit code this gives you
some JavaScript you're on the unscripted
bindings generator
the headers this again gives you some
JavaScript and you simply combine those
into say library jas so if everything
goes right this is pretty much what the
process should be let's take look at
sort of a tiny example of how the code
would would look so if we have a C++ a a
library that looks like this so these
are two really silly classes a data
class that gets an X and Y a processor
class that gets data class instances you
would use that on the web basically as
follows you obviously import that the
script into your web page and then you
can use those objects in a normal way
data one equals into data classic and
that data class and C++ takes two
integers in JavaScript you just pass it
to integers and things are hooked up
properly can create a new processor by
doing a processor class and you can call
methods on them as expected for
comparison here's the C++ code pretty
much the same so the idea with the
bindings the thing is that it lets you
use those those cephas clough classes in
javascript in a way that really keeps
the high level interface there so you
can really use these as a library
without needing to mess with any
ugliness of the low-level compiled code
few words about the this binding API so
when you do new class and so forth of
course you don't get a C++ object
because you can't access that in
JavaScript you don't want to it returns
and said a rapper object which encloses
the pointer to the data on the heap and
so forth it has wrapper functions on it
that convert arguments and make sure
everything works so 5 a number typically
doesn't need any conversion but if other
inch there's an instance of a class
it'll translate that into a pointer and
again it does that for you automatically
so you don't need to mess with it there
are however some limitations so
basically the issue is that JavaScript
and C++ are not the same language their
semantics are different again we saw
this a bit before so they don't match
perfectly for example when you create an
instance you must destroy it manually
the reason is that while doing new class
creates an instance and of course it'll
be GC at some point the compiled code is
no way to tell when that object was G
see if we could know that we would
destroy the C++ objects at that point in
time but we can't so you need to do the
destroy manually so this is a bit
cumbersome and there are a few other
technical issues that I don't want to
waste time I'm talking about but again
the issue is that the languages do not
match up perfectly so while you can
write code that for the most part is
pretty natural and close to the C++ it's
definitely not perfect there are some
limits some can be fixed but it'll never
be a hundred percent identical so just
to summarize the section about using the
project so the product works well on a
lot of real world code this is we've not
been interested in working just on
benchmarks but on actual code so we've
ported things like doom which sadly they
sent to dmca so we had to take it down
hey so do them the popular game zelia
compression a popular a PDF renderer
open jpeg codec for jpeg 2000 images
which actually i can show you locally i
believe yeah open jpg
so and that's a JPEG 2000 rendered to a
canvas element so this is a file format
not recognized by the browser in the
native way but entirely in JavaScript it
was translated into a canvas image
basically and getting back to that free
type which renders fonts and as already
mentioned bullets equal I Python Ruby
Lua so this works on real world code but
again just to just a caveat about that
this is for the compiler which generates
working code the binding stuff which
makes the code very easy to use is very
new and obviously less mature so don't
expect that to work out of the box as is
two last points that I think I should
make to port a library to JavaScript you
do need to know the original language
that you're translating it's not a one
hundred percent automatic process that
you just push a button and you get some
code there are a few cases they're rare
but there are a few cases where you
might need to modify the original source
code so you really do need to know the
language if only just to know that the
false positives that it that warnings
that it mentions to you are false
positives so you can't just compile
something you don't understand we can
make this better but right now it's
definitely not there and while
generating working code is
straightforward in optimizing the code
to get to maximum speed takes additional
manual effort so again this is something
that we can definitely fix but at this
point you can get code to work typically
fast optimizing it to maximum speed will
take more work okay I have just a few
more slides but I should address some
something about speed so you might be
thinking isn't this terribly slow this
is JavaScript don't we need native apps
Native Client dart Java flash if you
can't read the rest doesn't matter
don't we need these other things that
are fast then isn't there are some
problem that even if you get this code
onto the web it'll just run too slowly
so I think there are sort of two parts
to this question the first part is
whether JavaScript itself is fast enough
for not a night we had to talk
previously I think we know that by now
javascript is fast enough but on the
other hand perhaps this compiler method
generates code that is not a match to
what Jess engines are optimizing for
were compiled a low-level bit code maybe
it ends up just being very very slow
even though it does work so the answer
is no this actually isn't slow there are
some numbers here they are all in time
slower than GCC dash 0 3 which means
that one is actual GCC native code and
these numbers are all for spider monkey
and ta means typed arrays so most of the
numbers especially over here in the
typed array area are not bad at all
between two times slower than native
code and five times slower than native
code with this one sort of more
depressing test but overall these are
not too bad I would say in addition a
one of the faster ones dl malik is
actually not just a benchmark these
other ones are benchmarks some some of
them are well-known some not but dl
malik is actually real world code it's a
malik implementation used in a lot of
places so the results are not bad i
would argue to look at data from a
different perspective so the computer
language that shootout benchmark site at
thalia that debian compares a lot of
languages so all these all the numbers
here are again times slower than native
code and you can see obviously by
definition C and C++ on top are all
lungs Java pretty close but there are
some places where it doesn't quite get
to native speed skala Haskell and
c-sharp are also fairly close and on the
bottom you have Python and Ruby dynamic
things which are not so fast and
JavaScript in the middle here this is
our data not from the shootout I think
it's fair that the numbers you are much
closer to the languages on top then the
languages on bottom so I think
definitely the speed is in a good place
and also this is without JavaScript
engines optimizing for it at all there
are a few minor things that if they did
they could run this specific type of
code much faster so things are
definitely good reason to believe we can
get very very very very close to native
code but some notes about that so this
be can vary greatly between benchmarks
we saw that on the data here from two to
eight and a half it's not consistent
like you see and see where you pretty
much know the performance of the code
that you write least it's simple enough
and Java which had a range of 123 but at
least it's pretty contained so here we
have non predictability which is
problematic for performance especially
since we have multiple browsers with
different j/s engines so you have
unexpected speeds in many cases issue 2
we have bugs in JavaScript engines that
often just lead to slowness for example
the memory space the heap variable that
I mentioned which represents memory so
basically every read and write ends up
being an access of this large JavaScript
array if that's not fully optimized so
that every read from it is a literal
rate from memory and a right to it as
literal right to memory if you need to
do any additional work for example if
the heap is implemented as a hashed as a
hashmap it'll be very very slow so there
are cases where chance engines get
confused and they decide to implement
the heap in a slow way also jess engines
have typically been optimized for fairly
small benchmarks and also caught on the
web was typically quite small they've
not been optimized for very large
scripts but here we're compiling 10 20
megabytes of C++ code and dumping it on
the web so that raises some issues that
need to be fixed but again these are
bugs and hopefully will be resolved
and on the other hand we have a lot of
things in new features and chess engines
that are making code run faster so so
type inference as I say optimizations
also as I said earlier it's possible
that jazz engines could optimize
specifically for this type of code so if
all that put together I I would argue
that we're not quite at the speed of
native code yet but we are getting quite
close finally I'll leave you with
thought about the future so imagine that
you could just write this this is
harmony module syntax module it see from
someplace import printf printf hello
world but imagine that you could do this
for any library in any language so
JavaScript basically basically becomes a
universal a language or environment I
guess where everything can be compiled
into it and because of that JavaScript
can use any code that exists anywhere
just compiled to JavaScript and use it
in a convenient way so I think this
could really be very very beneficial for
us on the web and again as an example
just sort of as a follow up for the what
I mentioned before about audio we can
compile an entire audio library to C++
to JavaScript and use that instead of
waiting for some web a peep from for a
Web Audio API to be standardized the
ability to use any code that we won on
the web could really help us do whatever
we want on the web which i think is a
good thing yeah that's it
questions and flow this is like crazy
powerful it's cool so my first question
was more about the kind of F open
support you know the kind of like
standard file operations where you said
you mapped it to xml httprequest I mean
are they synchronous or asynchronous
well you could you could do it both ways
you could do it but so it's asynchronous
then you would need some way for the
compiled code to know when they when
they arrived which would mean you would
be creating a little API in C++ that is
not part of standard IOH right but the
standard one is just synchronous the
standard one is synchronous so the
information we have now is synchronous
yes but there's nothing stopping you
again from implementing a tiny addition
to standard ayah which would be
asynchronous and we are I there is a
little header which adds a few functions
right now like for example it can that
you basically run any script from C++
code just by doing eval well so you can
you can bridge both ways and you can
definitely get a synchronous behavior if
you want but again it would be an
extension of the standard c-suite yeah
there's an eye meter that was the thing
I worried about ya so I kind of one more
question sorry about is um right is
anyone right in the kind of the the
wrapper for a web-like OpenGL to WebGL
yes I mean we can get so many games on
the web then yes I would be extremely
happy to have that so a few words about
that there is an a so first of all a
this project is fully open source of
course it's on github etc there is a
closed source project called Mandrell
which it's it uses some amount of code
from this project which I only know
because if you look at the compiled code
that they generate you can actually see
bits of this in there however they they
say that they wrote a compiler entirely
from scratch so I'm not entirely sure
where the truth is but anyhow my point
is they have what you just asked about
yeah they have a compiler for OpenGL to
WebGL I have no idea how it works it's
closed source but they have some demos
of games just compiled to WebGL yeah I'm
myself not in OpenGL hacker so I don't
know but I would
love to get help in doing this and the
fact that there's a close thing that
does it I think shows it it's possible
yeah it'll be awesome I mean we coo coo
thank you
so the performance numbers you showed
are basically I assume based on like a
couple of runs right oh sure yeah yeah I
mean they have reached right so I was
wondering about to start up dying
because I assume these funds are kind of
large and I mean the thing that killed
and one of the thing that killed Java
applets was startup night so in an issue
well yes I mean if you look 10 megabytes
of JavaScript code just the parsing
takes some amount of time and depending
on the engine there were there bugs and
all the engines about trying to compile
code to eagerly but they're getting
better about them so they don't optimize
too early so yes there is some startup
issue probably not represented in these
tests because they were all designed to
run for a reasonable amount of time so
if it tests takes just the one one
millisecond in C in C it's not
reasonable to compare it to anything so
I think most of these run at about one
second and see so startup is pretty much
eliminated but there is some amount of
startup issue yes and it'll be hard to
eliminate entirely
how viable would it be to say use a
javascript library of GCC compiled with
em script at javascript library yeah it
like create a JavaScript library with
and script ug sorry GCC gpg I jpg I
would like to say I would like to have
gpg in java and i would like to compile
it with em script how viable would it be
to means that in production is it fast
enough I mean this I mean I I would
assume yes unless there's some technical
detail to the implementation mg of gpg
that I'm not aware of but it's pretty
typical it right there dig if they don't
use any magical so you would go to
reduction with something like that what
I think it could work yes I haven't
actually tried it but I don't see any
reason why not
hi I was wondering what the memory use
is like let's say I have a 100k lightly
as a library that would generate hundred
K of native code how big does the
javascript file end up being to download
and and how much memory is it going to
take in the browser when it runs and it
ends up after run it through through a
min afire it ends up similar size to the
native code x actually may be a factor
of one and a half or so but it's not
ridiculously low it large but after you
run gzip on it assuming your website she
sips everything it basically ends up the
same size so in terms of that in terms
of code size I think it's very
comparable to native code as far as the
amount of memory it takes a the amount
of memory that compiled code takes it
depends on the jas engine I don't know
actual numbers the amount of memory
taken at runtime so actually as a slide
here shows there there are a few options
there like then getting to almost any of
the technical details but there are a
few ways to generate code one of the
ways uses typed arrays with a shared
memory buffer in which case the amount
of memory you would use at runtime again
aside for code the amount of memory for
data would be a hundred percent
identical to C++ because you be using a
typed array that's literally the same
thing so you can use a very similar
amount of memory in this as to the
native code version hi so um you you
compile the sea I mean lvm compiled the
C or C++ to bytecode to lv my code and
you can buy this bytecode to to
JavaScript yes by doing that apparently
you lose viable names and you have some
sort of ritual reverse-engineering to do
too yes recreate while oops why not
compiling directly from C or C++ using
ceiling or and yes I mean that was one
one approach for this compiling see
directly would probably be pretty
reasonable
but C++ is horribly complicated to parse
ridiculously complicated I
underestimated its you don't want to
write it write that from stretch it took
ceilings several years of intensive
effort to get to the point where now it
can compile most C++ code so that's
simply too much work to do but second
point by compiling the bit code you can
potentially compile many more languages
if you get Haskell to compile to hell
via a bit code which I believe it can
there's no reason why you couldn't
compile that into JavaScript too so
there's also a benefit from that and
third part to the answer yes there is a
lot of additional work to get back at
the high level data that you lost but I
think we're pretty close to getting
there so it is much more feasible to do
that then to compile the C++ hi um I was
wondering are you modifying the native
code to not depend on integer overflow
are you actually clipping every integer
after every operation and first of all
it would be better if you would modify
than the original source code to not
rely and overflows etc but that's not
realistic so yeah very briefly to get
precise behavior you do need to do
clipping and so forth and I think I have
a slight which mentions a few of the
issues there overflows also signs and
rounding part of the reason why getting
optimized code takes time is that the
default setting will perform that
clipping and sign correction etc on
every line of code which makes it very
slow but the optimizer can do sort of
like like pgo it can basically run the
code see where it actually needs to do
those Corrections generate a profile and
then compile it with that and only
perform the corrections where necessary
so the right way to get fast before my
code is either to modify the original
source so it doesn't need it or to do
this pgo like thing which is a tool that
comes with a compile that basically gets
you to the same place I hope that makes
thank you thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>