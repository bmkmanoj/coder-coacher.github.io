<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ashley Williams:  A Brief History of Modularity | JSConf EU 2017 | Coder Coacher - Coaching Coders</title><meta content="Ashley Williams:  A Brief History of Modularity | JSConf EU 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ashley Williams:  A Brief History of Modularity | JSConf EU 2017</b></h2><h5 class="post__date">2017-05-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vypCsVm5z28" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright hey everybody this is good as
you filter in I'm going to start my talk
a little strange and read to you from
the namesake of this talk which is
Stephen Hawking's
a brief history of time so this is from
chapter 1 our picture of the universe a
well-known scientist some say it was
Bertrand Russell once gave a public
lecture on astronomy he described how
the earth orbits around the Sun and how
the Sun in turn orbits around the center
of a vast collection of stars called our
galaxy at the end of the lecture a
little old lady at the back of the room
got up and said what you have told us is
rubbish the world is really a flat plate
supported on the back of a giant
tortoise the scientist gave a superior
smile before replying well what is the
tortoise standing on said the eyes of
the scientists you're very clever young
man very clever so the old lady but it's
Turtles all the way down now you might
be wondering you know of course the idea
that our universe is some sort of plate
and there's turtles floating in space
you might think that's like a pretty odd
idea but this talk is going to be the
kind of talk that's going to ask you to
look at some of the concepts that you
might take for granted and ask you why
you think they're true now what on earth
would something like that with turtles
in space have to do with JavaScript and
hopefully by the end of this talk you'll
have figured it out all right so hi my
name is Ashley Williams as introduced
you might know me from Twitter as a
g-dubs and if you
- I am very sorry do not follow me I'm
terrible I work at this tiny company
called NPM have you has anyone heard of
NPM yeah cool so yeah that's where I
work as a services engineer shout out to
the fact that we released NPM five
downloaded it's very cool this talk is
not about that but if you want to talk
about that later find me so if you're
the type of person who watches slide
sees a typo and cannot handle themselves
please submit a PR this is a git repo
I'm totally happy for them yeah so I
always like to start my talks by saying
that I like to think about thinking
particularly the type of thinking that
happens when people write code and the
point of this talk today is to maybe get
you to also think a little bit at least
about the type of thinking you do when
you write code so to get that thinking
started I'm going to pose you with this
I'm not going to give you my answer
quite yet but this is a PR that came in
to a repo for a documentation project
for a programming language and they are
attempting to remove the jQuery
dependency by adding 400 lines and
removing 200 and so this talk is going
to be questioning the ideas that we
think about when we're thinking about
the pendency and modularity how many
people think this is a really obvious
thing to choose accept it or not all
right good
all right this pops for you all right so
I'm one of these people who has for a
very long time been a teacher as well as
an engineer and I like to say that
teaching is nature's way of letting you
know how sloppy your thinking is and
over a long period of time of teaching
people node across the world some people
in the audience are in these photos
we've run into some fascinating
questions from beginners now here's one
of the most fascinating ones and this is
actually one that a student of Steve
kinney's asked him which was how did you
get permission to publish a module on
MDM true question many beginners think
that you actually
have to somehow get permission that
there's an exceptionalism to being able
to publish a package but as I think
hopefully you know that's simply not the
case literally anyone can publish a
package to NPM now once you get past the
idea of who can publish the next
question really is how do you decide
what goes inside a module and so like a
proper scientist and wanting to get the
correct answer I went to Twitter as I
always do and I was like hey what is
your primary motivation for writing or
using modular code now I got a huge
number of responses this is a topic that
a lot of people like but it was
interesting because the responses were
very diverse so one of the first sets of
responses I got was that people believe
that being able to write modular code
made them more disciplined they
debugging the code easier made it easier
to test or document alternatively some
people wrote that they were made their
code modular for reuse so that they
could do something in the future in case
their code change
I put Bradley on his own slide because
in to talk about modularity you got to
give Bradley a shout out for all of the
work he's done implementing es6 modules
so if you like es6 modules particularly
like them in node you should thank him
alright so then of course it was twitter
so there were some shitposts they might
have been from some of the conference
organizers that you know will let those
be but so the biggest theme that we got
was this idea of being able to reuse
things and in particular reuse things by
separating concerns now lots of people
love this term separation of concerns
the point that people said it almost
exactly in their responses but I thought
that it was awful vague to be something
so specific that everybody was saying so
I tried to push the question a bit
further and I said okay separation of
concerns how do you decide what the
concerns are and this really stumped
people people went from having tons of
verbose answers to going the intuition
mostly said this person this person
suggested throwing darts which is about
as scientific as you can get I guess now
even one of my JavaScript here
Brian Harvick who is here I think as an
expert he wrote the book I learned
JavaScript from even he responded and he
was like I kind of have an answer but
you know what there's a lot of like
practical accidental even aesthetic
considerations to this question of how
you separate out your code and here's
the punchline the absolute best answer
about why did you split up your code was
people got mad when I put it all in one
file so you might remember this from the
intro that I was not here for but slow
on Twitter I guess there was a lot of
people got mad but believe it or not
people do get mad and programming quite
a bit and I could definitely see how if
someone put their application all in one
file
there'd be a bunch of people grumping
about it so under but looking at the
summary of these things in general I
thought it was very interesting because
in the end people really had no idea how
or why it's module they had some kind of
inclination some intuitions but when you
drill down pretty hard they didn't
really have an answer however
overwhelmingly everybody thought that it
was good no one responded with don't
modularize your code so we're in this
interesting position where there's a lot
of people who feel very strongly about
something but don't really have a solid
grasp of why and so this kind of made me
think all right we have this huge batch
of stuff and you know maybe individually
they all make sense but we don't have a
coherent picture of the world a bit like
this store which is a real store outside
of Madison Square Garden in in New York
City I don't know if it capitalizes and
all that it promises that I would only
assume it does so this made me think and
I did something that's a very classic
Ashlee thing that a lot of people
otherwise who don't know me might not
think a normal person would do is that I
was like oh you know the way people
think about modularity is the way people
think about time you know like everybody
has this like really intuitionistic idea
like time passes but nobody has any
frigging idea of how a time works if you
do think you have an idea you should
find me at the party I'm very interested
but yeah so this made me think okay I
love this book
brief history of time because what it
does is it goes through and it kind of
chronicles the intellectual history of
how we've been thinking about describing
our universe so my goal today is not
necessarily to give you any answers but
I do want to talk about the ways that we
think about modularity and then
potentially give us some pointers to get
in the right direction when we think
about splitting our code because
fundamentally splitting our code is so
important and so critical to our daily
lives that it's pretty unsettling that
we haven't really examined it as closely
as I think we should all right so I feel
like I'm in a pretty good space to talk
about this because the packaged
ecosystem I personally think is
JavaScript's picture of the universe and
working at NPM I'm pretty close to that
ecosystem so NPM I've checked this
probably a week ago we have 472 thousand
packages which puts us about a third buy
and three times as much as the next
package ecosystem so packages and
modularity mean a lot to JavaScript
because NPM is the largest module
repository in the world potentially the
universe I don't know if aliens have
package managers but I feel like we'd be
in the running all right but what I want
to do is ask okay why is this the case
right why are we like modular eyes all
the things you know cut my code into
pieces this is my JavaScript sorry I had
to do a pizza joke I just had to it's
late got to get you guys going anyways
no now let's get really serious this is
a proper computer science talk so let's
quote Dijkstra right let's do that
all right so Dykstra says that the
programmer is in a unique position they
have to be able to think in terms of
conceptual hierarchies that are much
deeper than a single mind ever needed to
face before the automatic computer law
automatic computer huh okay
the automatic computer confronts us with
a radical new intellectual challenge
that has no precedent in our history all
right so I'm not like the biggest fan of
computer science exceptionalism but I
definitely think that he's on to
something here all right modularity is
the way we as
programmers address this challenge that
we need to be thinking in very very very
deep conceptual hierarchies
alright so we know kind of the problem
that modularity is solving but what is
modularity so again to the good sources
let's do a little Wikipedia modular
programming is a software design
technique that emphasizes separating the
functionality of a program into
independent interchangeable modules so
that each contains everything necessary
to execute only one aspect of the
desired functionality so you may or may
not be getting the idea but I'm a little
worried about this one aspect part of it
and that seems to be the clincher of
that definition all right so in
JavaScript we have this idea called the
small modules philosophy how many people
here have heard of that how many people
like it interesting all right so what is
the fiercest fighters for the small
modules philosophy and he does it with
his actions because he's probably one of
the most prolific publishers on NPM is
cinder Soros and he says it's all about
containing complexity by making small
focused modules you can easily build
large complex systems without having to
know every single detail of how
everything works our short-term memory
is finite so this doesn't get us
terribly closer to where we should
separate things but it's certainly
suggesting that we have a biological
constraint that's going to require us to
make small packages so that we're able
to actually understand the thing that
we're working on all right and so this
obviously begs the question how small is
too small now this is a classic critique
of packages in NPM people love getting
upset about this the one-line node
modules problem people do not like these
however they are installed constantly
continue to be published and are some of
the absolute most popular packages on
NPM so you have to ask yourself for all
this critique why is it that we continue
to use them now I can't talk about these
one-line node modules without talking
about done Steven
left head warning if you make jokes
about left pad to me I'm gonna get real
pissed so don't do that all right
that being said I think that left pad is
really interesting to talk about because
it comes up it brings up this idea of at
which point are we leveraging this tool
of modularity too much right because
somebody unpublished this tiny tiny
little package and the internet went
berserk all right and this is only 11
lines of code right here is it worth it
to have a way of extracting this code
out is this doing us any good so the
thing actually that I think left had was
most fascinating for me was that people
started getting really aggressive and
they've suggested that even the
existence of a left pad module meant
that we had like somehow forgotten how
to program but using this at all meant
that we were a terrible programmers and
so I kind of need a minute here all
right
this makes me think of this talk which
if you've seen it or seen me online you
know I'm not a fan of which is this idea
that there's some sort of real
programmer out there and then if you use
any sorts of tools be it a build process
a framework or yet even a package that
contains 11 lines of code you're not a
real web developer and I just have to
say not that's not cool all right build
in small reusable abstractions is the
foundation of literally all computer
science so did we forget to program when
we stopped writing see stop threading
assembly stopped doing electrical
engineering which I can only say vaguely
because I have no idea even what that
would be called I assume it has to do
with slaughtering I don't know but yeah
this idea that there's no true
programmer because you use tools all
right it's the no true Scotsman fallacy
but I don't even need to go into that so
if you're upset about tiny little
modules because you think it means
you're not a programmer I'm having none
of that okay so moving on what I do want
to say is I think that actually making
kind of little modules is a great idea
and this is because what I envision as
the best type of application so sub
stack who is also a prolific author on
NPM describes his his best like
application this way he says when
applications are done well they are just
the really application-specific brackish
residue this is such good terms here
that can't be so easily abstracted away
all the nice reusable components
sublimate away onto github and npm where
everybody can collaborate in the commons
and if you know me I'm a fan of the
Commons like a lot I'm a big fan of the
comments but comments are hard and even
though comments are hard
I think the JavaScript ecosystem proves
that we can do the Commons right this is
the graph of our weekly downloads at
this point NPM is averaging 2 billion
downloads a week which means it's
something about breaking things into
tiny packages is working well alright so
this doesn't necessarily mean that it's
without problems so this is an Alex
Norris comment and so you can just read
there instead of I want things to be
different I want things to be modular oh
no all right so this is when it comes to
this fantastic book by John gall called
system antics which is about how systems
work but also especially how they fail
and so he says a complex system that
works is invariably found to have
evolved from a simple system that worked
a complex system designed from scratch
never works and cannot be patched up to
make it work you have to start over with
a simple system and right now in the
JavaScript ecosystem we have a complex
system and this complex system has been
causing us problems and so from now on
I'm going to talk a little bit about the
problems in modularity so Nolan Lawson
wrote the more I modularized the code
the bigger it gets over 400 milliseconds
is being spent simply walking my
browserify tree and so he wrote this
interesting article called the cost of
small modules and the subtitle was why
one horse-sized javascript duck is
faster than a hundred duck-sized
javascript courses I saw this I had to
illustrate it I was like come on this is
perfect but the interesting thing that
he says in this as he goes into a
typical web application has a ton of
little modules and the reason it has a
ton of
modules because this really improves
developer experience alright there's
lots of these tools that we take to take
those little individual modules and
prepare them for when we're going to
push our code into production now these
tools are extremely important because
modularizing our code helps us as
developers but it doesn't come without a
cost alright so one of the things that
he notes in this article is the fact
that even just splitting our code up
into closures into different functions
is actually costing us a lot of stuff a
lot of time at runtime so looking at
stuff like bread pack and browserify
just playing and then comparing
something like roll-up and closure which
moves all the code up into a single
closure actually if you take a look at
these graphs has a significant amount of
runtime improvement there's very little
of that orange runtime when you're
maintaining the modularity in your
runtime code first is when you're using
something that's going to actually take
that modularity and collapsing so what
is the takeaway from this oh also by the
way these tools there's tons of new ones
there's a new one that came out like
just a few days ago it's pretty neat and
it's doing the same thing where it's
collapsing this ability for us to
modularize our code and putting it all
into one single thing because preserving
that modularity actually ends up hurting
our end users so I told them that they
have to stop publishing new tools
because I'll never finish this off and
I'll also never finish on time but the
goal here is to say that the use of
modularity has kind of grown to such a
scale that web developers are being
confronted with ideas that we've never
anticipated oftentimes when we think
about performance and web development we
think about Network latency obviously
we're like how long is it going to take
over the network but it actually turns
out that would be a number of modules
that we are using across all of the
devices that we have particularly low
power devices low-level programming
concepts are now more relevant to web
developers than ever and we're a little
bit not prepared to understand this and
so I like to say I for one welcome our
new compiler transpiler Oh
Laurance because we need a way to
mitigate the stuff that we do to improve
our developer experience and not have
that cost end up on our end users so
rich harris i think says this really
great he says yes small modules are easy
to write they're easier to test yeah
it's easier to adhere december these are
all things that make your life as a
library author easier as we've seen they
come at a cost for others so the small
modules philosophy totally benefits the
library writers but it disadvantages
application writers because they have to
deal with all of those tiny pieces when
they're putting something together and
fundamentally because that's extremely
difficult it turns out that modularity
actually harms end users by costing them
time so how did we end up here all right
and I love to quote Thomas crew in here
who says scientists work for models
acquired through education and through
subsequent exposure to literature
without knowing or needing to know the
characteristics that have given these
models the status of community paradigms
what I'm saying is that it's been a
little inconvenient for us to
interrogate why we love modularity so
much we just see it happening the tools
make it easy and so we use it so this is
the CTO of MP MCG OTT and I think what
is the neatest thing she says she's
talking about micro services here but
she says your model this is complex your
application is complex but to split it
up to modularize it actually makes it
more complex and so we're kind of in a
pickle here I'm saying modularity makes
their lives as developers easier but
somehow this is also making them harder
this is some graffiti that I saw in in
San Francisco my solution is probably
worse than the problem so now we're in
another Ono's situation so this is one
of my favorite computer scientists rich
Hickey and he says most of the big
problems of software are problems of
misconception so again I want us to be
focusing on the concepts that drive our
day to day work all right
and so what I like to say is when we
think about programming right sulfur
development is change management
fundamentally this is why we use version
controls why we have cember the hardest
part of programming is the fact that it
changes alright and this is very
interesting because this actually
features very heavily in a brief history
of time by Stephen Hawking in fact he
says it is an interesting reflection on
the general climate of thought but for
the 21st such a 20th century that no one
had suggested that the universe was
expanding or contracting which is to say
when we tried to paint a picture of the
universe they never thought that the
universe would have changed they just
assumed it was exactly as it was and I
think oftentimes when we think about
breaking up our code we evaluate it in
that same static way so it turns out
that I was like I did ask Twitter how do
you modular eyes but I also went on
Google Scholar and it's like how to
module and there's actually an amazing
paper on exactly this topic by an author
named David Parnas and this is perfect
the paper is called on the criteria to
be used in decomposing systems into
modules and it turns out that he has an
answer that nobody provided when I asked
on Twitter this is what he said he said
start with a list of difficult design
decisions or design decisions that are
likely to change each module is then
designed to hide such a decision from
the others so here's the trick the goal
of modularity we've always talked about
it being making our lives easier but the
truth of the matter is is that we should
be using modularity to hide the things
that are hard so at this point you might
be worrying oh gosh like I had a lot of
conceptions about modularity that we're
not correct how do I even go about
computering I'd Ricki comforts Leslie
says none of us are born knowing how to
write software and cinder even says you
know as someone who writes a lot of
modules I still don't really know how to
do it I'm still trying to figure it out
and so you might be feeling a little bit
of despair and so this is a famous
existentialist philosopher jean-paul
Sartre and my friend tes quotes his book
on C programming and C
every line of code is written without
reason maintained out of weakness and
deleted by chance but I need some water
anyways the based on this level of
despair what tests suggest that we do is
you suggest that not only do we write
code to help our pro our programs change
but we should not be focusing on code
that's easy to extend but rather code
that is easy to believe he says write
code that is easy to leave not easy to
extend instead of building reusable
software we should try to build
disposable software I don't need to tell
you that the leading code is more fun
than writing it and if you love to do it
you should do it every day so we come
back to this question of do we delete
this jQuery dependency and so what I
thought was very interesting about this
is first I don't think there's a right
answer there's a lot of good questions
to ask about this
but in the end yes
accepting the pr2 remove the jQuery
dependency was what people thought and
more than its saying something about
people's feelings about jQuery what I do
think it indicated was they were kind of
seeing a return of conservatism in the
way we think about using modules and and
packages in our programming for a long
time we were using modules totally
uncritically we were doing a lot of work
including lots of them and we're seeing
a lot of people go the opposite
direction now and there's a lot more of
this not invented here I'm going to
bundle in my code and not use a package
all right but what I want to say is I
think there's a really amazing challenge
here and that instead of just rejecting
the idea of using tons of modularity we
should be looking for new solutions
modularity is an old problem that we're
dealing with but at a brand new scale
that I think is really exciting so I had
asked recently a couple a few months
after the first time why do you choose
to split your code and so one of my
co-workers chris dickinson actually i
think had a really awesome answer he
said i have two answers the first one is
is kind of like what I would say like
academically but the other one is
actually how I think I really feel and
what he says is programming is like a
maze but humans lack the language to
describe completely with practice you
start to internalize the maze and so
that could seem pretty bad and what I
want to say is internalizing it and
using intuition isn't super terrible it
turns out that dogs know calculus which
is pretty neat you can read this paper
about a guy in his corgis fetching a
ball this is true they are able to
actually calculate the most efficient
route which is pretty neat so they're
made of starstuff
and so we can also use intuition to be
able to figure out how to do modularity
so we can all be a bunch of Corgi as
modular as the corgis but so in summary
modular eyes your code to make your life
easier for sure but when you're making
your life easier realize that the way
you should be separating it out is by
isolating the things that are hard
that's how you're going to make your
life easier and then additionally
modularity is not free in fact it's
pretty expensive and what works for you
as a developer can have consequences for
other developers as well as your end
users so the tools that currently exists
help mitigate a cost that you're already
enduring
too many people are like I don't know
what all that fancy stuff is I don't
need that know they're solving problems
that you already have so you should be
looking into these tools and using them
and finally this is a fast-moving space
right now and there's not a lot of
definitive answers and I can't help but
know that on Twitter recently there's
been a lot of really nasty conversations
about this so I want to say quit being
jerks to each other on Twitter all right
all right so this problem is far from
being solved and I think that getting a
lot more people into this conversation
and critically interrogating what we
think about modularity is super
important so I'll end you with this this
is from Julia Evans who is the person
who got everyone got mad at when she put
it in one file she says the more
programming I do the more things I run
into where I don't know Google doesn't
know my colleagues don't know but we got
to do it anyway and when this happens
she says right this is why they pay a
human with a brain who can investigate
and learn and these should be the
problems were most excited to solve
thank you so much this is all of the
sources from the talk install NPM five</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>