<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Bitcoin Protocol Explained 1 - Bitcoin paper broken down step by step. | Coder Coacher - Coaching Coders</title><meta content="Bitcoin Protocol Explained 1 - Bitcoin paper broken down step by step. - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/sentdex/">sentdex</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Bitcoin Protocol Explained 1 - Bitcoin paper broken down step by step.</b></h2><h5 class="post__date">2014-01-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UieiMU-ImvI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone and welcome to tutorial
video concerning the original Bitcoin
paper which discusses the design of
Bitcoin as a you know peer-to-peer
electronic cash system so so this is
kind of the protocol of Bitcoin where as
you know there's some videos out there
on the how Bitcoin mining works and all
of that this video is going to be
discussing Bitcoin as a monetary system
so anybody who's interested in and what
bitcoin is and what it represents has a
monetary system and how it works and why
scientifically why it's so good this
video should help you out so if you
spent much time at all looking into
Bitcoin you've probably quickly found
yourself being directed to this Bitcoin
paper then you're finding yourself you
know skipping over bits of information
and then probably soon giving up
completely on understanding it see there
are political and philosophical ideas
that back up Bitcoin and why you ought
to use it and what makes it awesome
but then there's also scientific reasons
that are just phenomenal see bitcoins
invention the actual solution or
solutions that Bitcoin has solved it's
an incredible feat that many people
still can't believe that is a even been
done and it actually solves you know
multiple highly complex problems all at
once so the paper describes this this
system that I've just told you a little
bit about above the problem is the paper
is extremely challenging to it you know
a typical person or even someone who
knows a little bit about programming
networking and cryptography first off
the paper is highly condensed the full
paper describing this this amazing
Bitcoin and protocol and all this eight
pages long and the ninth pages is
referenced so in a mere eight pages
Bitcoin is just completely condensed and
this solution to an impossible problem
is just like shot I you write this task
of actually writing all this down in
eight pages alone is actually pretty
impressive but it proves
pretty challenging to consume for many
people so what I'm going to do is
attempt to break this paper down
completely for anyone who's interested
or anyone who's confused about something
so this is going to be a full complete
breakdown of this paper you won't be
required to know anything about
programming cryptography or networking
if I do my job right you'll learn
everything you need to learn here with
me in a nice easy understand tutorial so
by the end of this hopefully you'll
understand the incredible brilliance of
Bitcoin and at least this paper I make
no promises obviously again on the
mining part probably old cover mining a
little bit later but the the actual
protocol how the network works and and
how its secure and everything is
something that really everyone should
understand not everyone really needs to
know how mining works so anyways I'm
going to break it down into separate
videos explaining each section pretty
slowly otherwise this video might be
like ten hours some of the sections are
really dense and may require many videos
but I'll try to keep them pretty concise
and easy to swallow yeah as informative
as possible so you guys really do
actually get something out of it if you
don't understand what's happening so my
goal basically is to explain literally
everywhere that someone might not know
so you've got hash and you've got proof
of work and best-effort system that I
bet a lot of people just don't even know
what that means so I'm going to show you
guys and at least tell you guys at least
with hashing I'll be able to show you
guys but some of these other things are
it's more of like a concept so I'll
explain those so I seem to have been
able to do this pretty well in Python
programming tutorials so hopefully I can
transfer that here for everyone else as
well so first in this video let's begin
with the actual abstract so here the
problem that we're trying to overcome is
explained as well as the very brief
introductory solution so let's review
the abstract also if you don't have the
paper you can get the paper by going to
Bitcoin org slash Bitcoin dot PDF I will
put a link in the description as well
you don't really necessarily need the
paper to follow along where we're going
to be literally covering every single
one but if you do want it a
along alongside or I guess if somebody
wants to take notes or something
you can do that so let's begin so
abstract a purely peer-to-peer version
of electronic cache would allow online
payments to be sent directly from one
party to another without going through
it a financial institution digital
signatures provide part of the solution
but the main benefits are lost if a
trusted third party is still required to
prevent double spending so here we've
got the problem and it's discussed
peer-to-peer electronic cash is
obviously just a major goal and it would
be really great if we could achieve this
and the reason why is we could cut out
the middleman entirely and doing this
creates extreme efficiency it's it's
pure it's perfect right if you can do
this so this is known in the computer
science world or at least this this
problem with with a middleman or at
least the necessity for a middleman is
known in computer science mostly
networking field is this um it's known
as this Byzantine general or even
generals problem and the issue is how
can two or more remote entities send
messages between each other while also
knowing that those messages are
authentic and not manipulated in some
way so in the sense of a large network
how do we know that everyone in that
network is working towards us the right
goal right so broken down entirely the
problem suppose is like the reason why
it's called this Byzantine general
problem is that this general or generals
they're trying to coordinate an attack
or a retreat on the city and they're
trying to do this with their lieutenants
but the problem is obviously the
coordinated attack you've got to be
spread apart around the city and you
want to you know get it on all fronts
but the problem is how do we send
messages to all of the other you know
groups and armies that hey we want to
attack now right the the problem is
first of all you need the messenger
themselves could be a bad person but
they're also the bigger problem is that
there might be conspirators who
are planning to turn on the general and
misreport the attack or retreat commands
right and then so in the computer
science idea of this is it's 0 or a 1
right so you know attack would be a 1 in
retreat zero let's say you know so the
question is how can we do this how can
we ensure that the messages that are
being sent between you know these
generals are legit and and they haven't
been manipulated along the way so only
until recently there were there were
just proposed beginnings to the solution
and then comes along satoshi nakamoto to
write an eight-page paper and just
completely blast all this all these
problems away
so moving on in the paper so again we
just kind of explain the beginning and
what the problem is so moving on back to
the abstract we proposed a solution to
the double spending problem using a
peer-to-peer network the network time
stamps transactions by hashing them into
an ongoing chain of hash based
proof-of-work forming a record that
cannot be changed without redoing that
proof of work so now we're going to
discuss you know how the the Byzantine
generals problem applies to Bitcoin
which is a peer-to-peer electronic cash
system the main threat to a system like
this is the fact that people will lie
people will double spend transactions so
these are the traitorous people right in
the Byzantine generals problem this can
and will cause the network to become
corrupt extremely quickly and pretty
much worthless
so it's proposed that the network time
stamps and logs transactions and the
transactions occurrences and all this by
hashing them into an ongoing ledger
we'll call it and as you'll hear it
called quite often which is a hash based
proof-of-work
ledger which can't be changed without
redoing that proof-of-work well that's a
pretty big mouthful and I imagine a lot
of people this is one of the lines that
I think people gloss over so it's the
first part where people might trip up
here is hashing and we're hashing these
timestamps so what what the heck is
that so so so let's talk about what a
hash is so hash functions are used to
generate fixed length bits of data it's
like a shorthand way of like it's a
shorthand note that corresponds to the
original input so this can be used as a
way to store and retrieve data
associatively but in our case we're
actually more interested in its
cryptographic benefits so in
cryptography hashing is used to validate
the integrity of data so with hashing
identical input will always produce an
identical hash so at this point you
might still be thinking okay uh what's a
hash though reckon all right so so I
think in this sense of a hash I think it
would be best that I crack out some some
real hashing and show you guys what a
hash is and how it works and so you can
actually visualize the hashing process
so if you have Python 2.7 feel free to
open up your Idol and follow along
otherwise just watch it'll be very quick
like one minute example anyways it's not
too too long but it really I think
drives the point home of what a hash is
because I bet a lot of people don't know
what a hash is so so let's go ahead and
get to that alright so here I have
brought up Python 2.7 an idol if you're
not familiar with pythons just a popular
programming language it's very easy if
you're interested in Python I have a lot
of tutorials on them anyway so we've got
Python to 7-up it's important that
you're using Python 2 7 this code won't
work in 3 3 you'd have to change up a
few things so just please note that it's
to 7 not Python 3 3 so let's go and
begin so oh and just one more thing as I
put the code in here and then when I run
it it's going to output all the output
out here so that's what to expect if
you're not familiar with programming and
Python so first thing we want to do is
so we're going to show you guys some
hashes so we're going to import the
library called hash Lib in Python then
we're going to go ahead and what we're
going to be using md5 hashing so I'm
going to do md5 hash and that's my
variable name and we're just going to
say that equals hashlib md5
and then what here what we can do is we
can begin to test it out so what we're
going to say is we're going to say md5
hash update and we want this hash to
we're just going to say this is a simple
hash okay
and then what we're going to do is we're
going to print out this and we're going
to say print md5 hash hex digest and
that should be it barring any typos or
anything like that so let's go ahead and
save and run that and now we see our
very first hash so let's go ahead and
continue on and explain why why one this
is they're always of equal length so
right this is a sample hash like this
might act this probably has more
characters than that but anyway I'll
show you guys another example so now I'm
just going to copy and paste this a
couple times so I'm going to paste this
down here and I'll just throw in a short
here so we'll save and run that again
and you'll see that again we started
either this first this is a sample hash
is it identical to the previous hash we
could run it again again they're all
identical to each other but I shall show
you guys one what I was about to say in
a second so let's copy this and now let
me just show you see like they're all
equal length this is why so see it's
useful for that but anyway um very long
it's still have equal length hashes Wow
save and run anyway again you see we
have an identical hash there now comes a
couple of the importance important parts
of hashing if we take this exact line
copy paste you can see right now
it's 7:27 a de starting right we've made
a full copy and paste we're going to
save we're going to run it and you'll
see here that it's different it's not
seven two seven eighteen now the
original one is 77 so if we ran this
again again the same input produces
same output but the same input is
considering this one this one this one
and this one so by the same token if we
change something in this this hash with
short right here and we change it to
that and we run it you're gonna see that
not only dot does like this one stays
the same because it's the first but this
one changes then this one
that's unchanged changes and this one
that's unchanged changes so the order of
the input actually it matters and by
that same token if we let's say we get
rid of all of this and we just print out
this is a sample hash so we see the
original same one that we've always been
seeing 24e one de ba ba-ba-ba-ba
if we just change this to a Z right this
is a sample how do you write tiny my new
difference we run it now you can see
that the the hash is pretty much 100%
different I don't see anything that
matches up at all actually and so you
can see here that this is kind of the
idea of hashing and you can maybe start
to see especially as we explained down
the road why this matters with hashing
this stuff to this this global ledger
why that matters but hopefully now you
have a firsthand idea of what hashing is
what it's going to produce and kind of
look like why the order of input must be
the same no matter what and even in my
new difference is going to result in a
vastly different uh you know outputted
hat but also if you know the prior hash
is somewhat different all of the the
subsequent hashes are going to be just
messed up they're not going to be right
and so so that's why hashes are going to
represent a very valuable part to
Bitcoin so let's go ahead and revert
back to what we were doing I'm just
going to close out of this stuff and
we'll continue on with this paper here
so now that we know what a hash is at
least somewhat um and also I'm not
positive I I just really drove home the
point that if it just it's it's truly
that basically the rules of a hash are
that truly identical input always gives
you no identical output slightly
different input will give drastically
different output you and then finally
even if you have like the same singular
input it's still a vastly different
output hash so so now that we know I
understand what hashes and I've just
reiterated that now let's go ahead and
attack this notion of a hash based so we
know what hash is now proof of work
system so this is where the magic
happens because we we marry the idea of
hash and proof of work and so now let's
go ahead and discuss what a proof of
work system is so a proof of work system
at first and initially in its history
and at least saw it so at least the
first that I've ever heard of such a
thing is a way to deter like DDoS
attacks or even spam but can also be
used for network protection for very
similar reasons why it works with DDoS
and spam so brute forcing or trying over
and over again to break something
becomes very very costly so uh and also
if you don't know what a DDoS attack is
it stands for a denial of service and
these attacks are carried out pretty
much by like overloading a network with
simultaneous requests so like a request
is like you request something from a web
server when you visit the web page so
the idea behind a proof-of-work system
is that actual computational work is
required to make a request on the
network so for the ease of understanding
this let is let's go ahead and assume
that the requests that we're talking
about is indeed visiting a web page in
your browser since in this case you are
what you're going to you request data
from the web server that data is sent to
you in your browser and then displayed
for you so if this web page
use a proof-of-work system to deter
let's say DDoS attacks then each time
you visit this website your computer is
going to need to solve a calculation in
order to validate its request so before
the webserver actually serves it some
data it's going to request that you do
something for it first to just kind of
legitimize yourself so the idea here is
to make the cost of a brute force or
DDoS attack or spam quite high in terms
of CPU power since both brute force and
DDoS attacks are usually in like the
thousands of requests a minute per
second or even more right so without
proof of work then it's relatively cheap
initially to perform a DDoS attack right
you can do it with your own computer and
at least request a few thousand a second
and most average computers can do that
no problem so if you begin to require a
proof-of-work per request the legitimate
user will likely notice that you know no
performance difference they won't even
know that you've done this but the user
will incur just astronomically higher
costs and makes spam DDoS brute-forcing
all this stuff economically less
feasible the challenge here however is
making this proof of work system
asymmetrical so where it's you know
arbitrary and very simple for the main
server the website to confirm that you
got the answer right much simpler than
it is for you to actually solve it
otherwise we're getting nowhere alright
so back to the abstract again so we
propose a solution to the double
spending problem using a peer-to-peer
network the network time stamps
transactions by hashing them into an
ongoing chain of hash based proof of
work forming a record that cannot be
changed without redoing that proof of
work the longest chain not only serves
as proof of the sequence of events
witnessed but proof that it came from
the largest pool of CPU power so when
you add hashing
proof of work you have hash-based proof
of work even further yet in a very crude
way if you remember the live hashing
example before you see that as the chain
gets longer it gets harder and harder to
replicate an even identical bits of
information in different succession or
if you're missing a succession are
totally different just completely
different so over time the network only
gets stronger and stronger even though
it already started off very strong as
time goes on it's only getting harder
and harder to fake transactions see this
is really where things start to get
brilliant in my gosh were like still in
the you know abstract here like a few
seconds into this thing but in order to
fake or change like a current block one
would first need to compute every single
previous block and redo all of the work
contained that's an insanely high amount
of work already
and really it's just getting bigger
every day so moving on as long as the
majority of CPU power is controlled by
nodes that are not cooperating to attack
the network they'll generate the longest
chain and outpace the attackers so so
the chain basically to understand this
just in case you don't follow along -
yet it takes CPU power to generate these
hashes so it's just mathematical
certainty that whoever has the most CPU
power will have the quickest you know
replicating or not replicating the
quickly quickest generation of these
hashes
so as long as you know the amount of
people working with the network is you
know and not cooperating together like
you could have multiple people
coordinate or you know trying to attack
the network on their own but as long as
they weren't cooperating and exceeding
are becoming the majority of the CPU
power then the good people would
generate the longest chain so here is
what we have the
51% attack threat right this is where it
comes into play maybe you've heard about
it with like gee hash do for example
recently this basically means that as
long as there are legit people or as
long as they're more legit people than
illegitimate people will always outpace
the illegitimate in legit people and
legit people its measured in cpu power
and this is why someone controlling 51%
of the computing power of the network
can be problematic because they can
figuratively you know run away from the
religious people with it though they're
able to compute faster than them so this
has been discussed in a few of my videos
even if someone does reach this 51% they
actually still don't have that many
options it because the reward for
attacking the network is gonna be less
and very messy than the reward for
actually working with the network so if
the motive is financial then the attack
is really economically not feasible
right it doesn't make much sense if you
have that power you'd be more you make
more money most likely and at least you
make a lot cleaner money either by
siphoning so in the case of G hash tile
we were talking about it and you know
the true the true way to make money if
your G hash do and you're being
malicious would be to siphon the power
and not let anybody know about it it
wouldn't be to attack the network
because those network attacks you can
only continue that attack right so like
double spending for example was an issue
so you could only continue to double
spend so long as you maintained 51% of
the network and it's computational
ability so because of this you would
have to continue that and continue your
double spending and every double spend
double spent that you need to do you
would have to maintain your 51%
throughout all the confirmation that
your you actually had that money to
spend so within the case of G hashed out
I oh if they ever did hit 51% people
would just leave them right and we've
seen this happen
both times and the reason why they
continue hitting 50 they're getting
close to 51% is because they offer no
fees to their mining pool so if you
don't know what gee hash dough is is the
remaining pool and the idea of a mining
pool is so it's you know it's really
rare that you'll be able to mine Bitcoin
and actually get some Bitcoin yourself
it's just the likelihood is very low so
you might have to mine for a really long
time before you actually acquire some
Bitcoin so the idea of a mining pool is
that you just kind of pull together with
people and you kind of you get more of a
steady stream of Bitcoin instead so
everyone shares the Bitcoin and this is
why siphoning the Bitcoin would make
sense for a mining pool and the reason
why G hash do so popular is because they
charge no fee so I mean that's that's
why so anyways even if someone you know
reaches that 51 percent the reward for
attacking the network is less than the
reward for either siphoning or working
with the network so like let's say they
aren't G hashed out let's say this is
like some billionaire somewhere and he's
like man I want to be a trillionaire um
he can't do it either because it doesn't
make fiscal sense to it if you have that
computational power it just doesn't make
fiscal sense to attack the network it
makes more sense to work for the network
you'd make more money so that's just an
example in that sense now let's say the
motive is malicious towards the network
itself and like the government you know
wants to take it out well this is
extremely costly so you could stop the
network from working basically if you
controlled 51 percent you could just say
no wow we don't validate these chains
yeah and and that in your chain could be
the longest you know by one block let's
say so you could use your power for
something like that but this is
extremely costly and it would be pretty
much impossible to maintain over a
suspended you know period of time so
that's why you really both of these 51
percent attacks this is kind of why the
protocol is just incredible because if
the attack itself can't last it doesn't
make sense if your motive is financial
and it doesn't make sense if your
motive is to destroy the network it just
it just doesn't make sense it just
doesn't work mathematically so that's
why it's epic now finally after I don't
even know how long it's going to be we
get to the end of the abstract so the
last of the abstract is the network
itself requires minimal structure
messages are broadcast on a best effort
basis and nodes can leave and rejoin the
network at will accepting the longest
proof-of-work chain as proof of what
happened while they were gone so here
just the reiteration that this is a
simple structure yep we got that and
then we get this you know messages are
broadcast on a best effort basis what
does that mean so a good example of like
best effort in play is you typically
going to be your internet service
provider so your plan is usually a
best-effort plan meaning you let's say
you have a 50 megabytes per second plan
you're you're you would ideally get the
50 megabytes per second you pay for but
you're not guaranteed to get 50
megabytes per second so in networking a
best-effort system means there's an
attempt to deliver everything but
there's no attempt to retry and there's
no guarantee so another comparison here
that's often you know made in real world
terms is like the Postal Service's
Parcel Post a sender can send some mail
but there's no guarantee that it's going
to arrive and if it doesn't arrive
there's no attempt to retry by the
system nor does the sender know through
the postal services system that the mail
has arrived
now obviously now you can get like you
know delivery confirmation and all that
and tracking and all this stuff but just
the most basic Parcel Post from the post
office is a pretty good representation
of what best effort is so we'll continue
to break down the use of best effort and
a little bit here but there there is
good reason for it actually for now
we'll just leave it what it is and just
with the explanation of you know what
best effort actually means so you
understand it so congratulations we've
made through the abstract it might not
sound like it's much right but actually
was a lot of them from
and it really serves as a fantastic
explanation of Bitcoin already
I hope not everyone leaves at the end of
this video there is still a lot more to
explain but this just the abstract alone
just like this little paragraph gives a
pretty good explanation of how Bitcoin
works and why it works so um I hope you
guys are all still following along if
there's any part that was confusing up
to here please go ahead and post below
I'll do my best to clarify anything if I
was confusing so stay tuned for the
future videos regarding this Bitcoin
paper as always thanks for watching
thanks for all the support in the
subscriptions and until next time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>