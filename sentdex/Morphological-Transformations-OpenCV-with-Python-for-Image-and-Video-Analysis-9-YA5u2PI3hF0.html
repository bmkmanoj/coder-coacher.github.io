<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Morphological Transformations - OpenCV with Python for Image and Video Analysis 9 | Coder Coacher - Coaching Coders</title><meta content="Morphological Transformations - OpenCV with Python for Image and Video Analysis 9 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/sentdex/">sentdex</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Morphological Transformations - OpenCV with Python for Image and Video Analysis 9</b></h2><h5 class="post__date">2015-12-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YA5u2PI3hF0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">what's going on everybody welcome to
part 9 of our open CV with Python
tutorial series in this part what we're
gonna be talking about is using
morphological transformations to remove
white noise or just noise in general
from your filters or whatever else so so
far we've got something that's filtering
basically for the red hat that I have on
and we we did the blurs in the previous
tutorial but now we're in time on
morphological transformations so
actually the only thing that I'm going
to retain here to show at least is the
frame and the results and then I'm going
to remove these things here and then
basically remove all of this okay so
we're starting with some code if you
don't have this code for whatever reason
all these tutorials are posted on Python
programming net head there and grab this
stuff so to be in the data analysis tab
so so anyways here's our starting point
and let's go ahead and just run that
real quick just to show you guys
obviously if you're probably not going
to have a Red Hat so use whatever object
you happen to have I've got a Red Hat
and so that's what we're filtering for
but as you can see there's noise in the
Hat and there's noise behind me in that
bookshelf is causing some noise so let's
close this and go ahead and get started
so there are multiple different types of
morphological transformations the first
two that we're going to cover we're
going to kind of cover these in pairs
the first two is going to be erosion and
dilation
so what erosion is going to do is it's
going to go around everything and
basically it's going to keep it's got
this little slider that you decide what
size the slider is and it slides it
around and if all the pixels in the area
are identical color then great it moves
on but if there's any color or if
there's any pixel in that little slide
that is not of the same color as all the
all the others so let's say every color
is a zero except for one one so
everything's black except for one white
pixel well it's going to remove that
white pixel so it goes around it just
a roads away and then you've got
dilation it basically does the opposite
so it's sort of a roading away it pushes
out until it can't push out any further
so so let's go ahead and show an example
so underneath this mask and res
definition where say our colonel is
going to be equal to NP 1 so numpy ones
these will be a 5x5 you can use a
different size if you want and then the
data type is numpy un state now we're
going to specify erosion as being equal
to C v2 dot erode we're going to Road
using the mask part just simply we could
Road on there the result well not really
not very well so anyway we could
eventually return back to color though
but just for the this is just purely to
show you how erosion works if you wanted
to return back to color you would use a
bitwise operation just like this where
mask is equal to erosion instead of mask
okay anyway Road mask the colonel is our
colonel in the iterations will be one
basically the exact same thing is going
to happen for dilation whoops
so erosion dilation cv to dilate and
then let's take this actually it's just
tickling and then paste paste and then
we'll say erosion is equal to erosion
and dilation is equal to dilation great
so here should be relatively simple to
see what's going on so so in this case
in the case of erosion I'll just do this
so I can look at it and talk at the same
time I'm a baller anyway nerd so we've
got erosion you can see that the hats
actually being eroded away a little bit
here and you can see those little black
boxes that are continuations of noise
are actually based on the erosion rather
than anything else and then over here
you've got dilation where
you can see actually the the noise in
the background has actually been nothing
more than amplified so great so that's
probably not what we really wanted there
so moving along there are two more
versions here or two well actually we
have four more in total and there's even
more but they just four more that I'm
going to show or speak of the next one
is opening and closing so the goal with
opening is to remove false positives
okay so with opening you're going to try
to remove stuff usually from like the
background basically and then closing is
going to try to remove false negatives
so let me pull it up real quick actually
and explain that a little better so the
false positives are these noises in the
background right these are false
positives false negatives would be in
the Hat right now these black pixels in
my hat those are false negatives so so
opening is to remove the false positives
so we're going to say opening is equal
to cv to morphology capital e lowercase
X we apply it to the mask CV - all caps
here morph underscore open and we'll use
that same kernel that we already defined
copy that paste change this to closing
and then this instead of open it will be
closed and then we'll take these two
copy/paste again if you are experiencing
lag or something feel free to only show
like one you don't have to show all of
these cool okay so you can run that and
here at well let's see I don't really
have space on my screen there's the
result and I'm trying to find opening
and closing where it is closing
did I not change it maybe I didn't
change the no here we go okay
so opening remove the false positives
from the background right and we can see
that that actually was the case it
appears to have actually significantly
we don't I don't see any background
noise at all
and then closing removes false positives
within the Hat itself unfortunately we
have this little shark or whatever it is
so it's actually allowing some false
negatives to continue along because it's
in the way we probably have better
results if I turned it backwards it's a
little better you can see it's
definitely better than both of the
original images though so I suppose it
improved anyway so it's opening and
closing and dilation and erosion now
there are two more I'm just going to
copy and paste them from the from the
text-based tutorial here just explain
them real quick so you've got top hat
black hat so top hat is the difference
between your input image and the opening
of your image and then black hat is the
difference between the closing of the
input image and the input image okay so
that's those are how those work now oh
yeah we didn't mean actually code the
black hat part anyway the result in our
case is actually pretty useless just so
you can just know those exist and if
that sounds useful to you like if you're
working on a project and you're like man
I sure wish I could get the difference
between the input image and the opening
of the image there you go you don't
actually have to use like a some sort of
self-made function or something I can't
think of a time when that was necessary
but I'm sure if that exists in OpenCV
there is a need for it so that's it for
this tutorial
questions comments below in the next
tutorial we're me talking about is
gradients and edge detection so stay
tuned for that otherwise thanks for
watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>