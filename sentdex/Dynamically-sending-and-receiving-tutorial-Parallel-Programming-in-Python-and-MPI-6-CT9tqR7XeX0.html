<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Dynamically sending and receiving tutorial - Parallel Programming in Python and MPI 6 | Coder Coacher - Coaching Coders</title><meta content="Dynamically sending and receiving tutorial - Parallel Programming in Python and MPI 6 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/sentdex/">sentdex</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Dynamically sending and receiving tutorial - Parallel Programming in Python and MPI 6</b></h2><h5 class="post__date">2014-03-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CT9tqR7XeX0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody and welcome to another
parallel programming high-performance
feeding in supercomputing tutorial using
MPI in the last video I showed you guys
how we can use conditionals and how we
can send and receive data and also we
stumbled upon a you know a form of
threading I use that's kind of the whole
point of supercomputing is like doing
what threading does for parallel
programming though generally if people
want a thread they use a threading
module with Python and to be honest with
you it seems to me like actually using
MPI for pi is the easier method for
threading so if you happen to do a lot
of threading operations I highly suggest
you check it out I was able to hit a
hundred percent at CPU which is pretty
substantial because I usually can't I if
I run Python normally I use about like
0.5% or something so anyway not gonna
spend too much time on that since that's
not really what this series was for and
so instead in this video I'm gonna show
you guys an interesting little trick for
sending data to and from nodes and a
little bit more of a dynamic way instead
of hard-coding it so with that let's go
ahead and get started what we're gonna
go ahead and do here is from MPI for PI
import MPI and then again con equals MPI
comm underscore world and rank equal
oops let's under case this rank equals
con rank-size equals conduct size and
name equals MPI doc get underscore
processor underscore name okay now we're
gonna do shared for the data we want to
share and for this you can put whatever
you want I'm gonna say rank plus one
times seven and now what we're gonna do
is we're gonna send and receive data but
we're gonna do it in a fancy way so
instead we're gonna do conduct send what
do we want to send shared what
destination do we want this data to go
to and for this we're gonna say
we want to send this to rank plus one
but if let's say rank let's say we're
gonna use only two nodes for this if we
used only two nodes rank plus one would
yield let's say we have rank zero and
rank 1 well Rank 1 is gonna send one -
what - and if we haven't specified
someone to take over that rank we're
gonna get an error saying we don't have
such a rank so in order to compensate
for that we use the modulo and then size
and what this will do is cycle over for
us so let me do the other side of this
now so data equals comm dot RS are a CV
source and again here we're gonna have
to use the same set up only it's gonna
be rank minus 1 modulo size because
obviously for rank 0 we need to go back
to the end of the list basically so now
what we're gonna say is print name and
that's gonna print the processor name
then we're gonna print rank rank and
then print and we're gonna say received
what did we receive data and then we're
gonna say which came from rank and all
data is gonna come from this rank minus
1 modulo size okay so basically what
we're doing is we're using this size
functionality to grab the total amount
and then we're using rank to find out
where we are in that rank and then we're
just basically going to shift over so
it's basically we're set we're taking
data from one node and sending it to the
next node over basically and at the end
we just send it back to the front so
let's go ahead and say that and I'm
gonna move this via SCP to my two nodes
and whenever you're done doing that
down here hit the up-arrow make sure
you've got number processors - and we're
gonna run SCT 6 pi run it and here we
have it spits out the names masters user
1 node 0 to rank 1 Rank 1 receives a 7
which came from rank 0 obviously you
know 0 plus 1 times 7 and rank 0
receives a 14 which came from Rank 1 now
by the same token we could do something
like this since we didn't you know
everything in here remember before when
we were gonna in the previous video when
I wanted to do the threading and then I
was like oh let's see why what would
happen if I just put the 2 in and then
we'll hit 3 later well the problem was
we specified one of those ranks because
we're hot we hard-coded right and so you
obviously know that hard coding probably
by now is not the best idea you want to
have as much dynamic code as possible or
variable code so let me bring up this
again so as you can see here nowhere in
here do we have to have you know X
number of ranks we just have ranks so
now we could specify an unlimited number
so let me go do let's do 5 ok like that
and as you can see now that we've got
you know the master node master master
node and now we've got all of these
different things that they've received
28 21 14 35 7 obviously all multiples of
7 so as you can see that we're on it
we're able now to change the number of
processors really simply so it's a lot
more dynamic so if you begin to use
stuff like what I've just shown you now
like with modulo here for your sharing
purposes it can become a lot more useful
down the road so you're not having to
hard code how you know processor 1
always must interact with processor 8
and 15 and all this kind of stuff you
can you can make it a lot more dynamic
so anyways that's gonna whoo this video
as far as how to reference kind of a
hammock rank or node hopefully you guys
enjoyed if you have any questions or
comments please feel free to leave them
below as always thanks for watching
thanks for all the support in the
subscriptions and until next time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>