<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Python 3 Programming Tutorial - Threading module | Coder Coacher - Coaching Coders</title><meta content="Python 3 Programming Tutorial - Threading module - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/sentdex/">sentdex</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Python 3 Programming Tutorial - Threading module</b></h2><h5 class="post__date">2014-07-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NwH0HvMI4EA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody and welcome to another
Python 3 tutorial video this videos
gonna be covering writing in Python I'm
including this in the basic series not
really sure I should include it as a
basics video but it is a pretty general
topic to do some threading and so I
thought it would be a good video to
cover plus Python by its nature is very
linear and it'd be nice to do some
parallel tasks from time to time and use
a little bit more of your your
processing power so let's go ahead and
get started with threading so with
threading it's a part of your standard
library so you don't have to actually
download anything install on anything
you already did it when you installed
Python 3 so let's go ahead and import
threading and that's the name of the
module and then we're going to go ahead
and use also this cue ability that is
also part of your standard library with
Python so whereas a from queu e import
capital queu e and then finally we're
going to import time and what we're
going to use time for is actually just
to mimic processing time but later on
you know you would add its anything
we're going to use sleep right in place
of sleep you would do some sort of
function in calculating but anyway
moving on so the idea of threading is
you can perform multiple tasks at one
time now one of the things that can
cause trouble really quickly when you're
performing multiple tasks is if there
are any shared variables between the
tasks that might be performing
simultaneously so say two you've got two
tasks in each task you know goes around
and I don't know counts Skittles and the
starting variable was 5 the task found 5
more Skittles it adds 5 plus 5 and it
updates the new variable to equal 10
well what if at the same time another
thread was searching for some skittles
and it found 3 skittles and at the same
time he references at the same time that
the other thread is working and
referencing that variable
they both reference that variable is a 5
1 adds 3 to that 5 the other one adds 5
to that 5 whoever updates last gets
their say but both of them are wrong no
matter what
right so one guy says there's ten one
guy says there's eight
whoever updates last gets their say but
no matter what they're incorrect right
because the right answer is actually 13
okay
and so this causes problems when you
have shared variables because there
might be double modification but really
only one of the modifications gets
passed through so anyway it's pretty
much integrable so you might see a lot
of threading tutorials my first
threading tutorial was a great example
where we did not account for this and
this is kind of a major issue I think
that it's kind of silly like you would
do threading um and not use this there
are some tasks I suppose or they might
not ever coexist as far as or they might
not share a variable but a lot of times
they are going to share a variable or a
database or whatever it's important that
we use what is known as a lock so the
idea of a lock is each lock that you
mean so say you've got you know the
skittle count variable you put a lock on
the skittle count variable and the way
this works is whenever a you know
function or whatever wants to access
that variable it locks that variable and
then whenever it's done you know
modifying that variable so from the
point of reference to the modification
basically we want to lock up that
variable as we're using it and modifying
it and then from there we're finished
modifying it and then we unlock it and
this means that another thread or
process can access it modify it so if
you know thread tries to access a lot
variable it will sit there and wait sort
of like a queue until that variable
becomes unlocked then it will lock it
back up do it easy to do and then unlock
it and move on now describing this
process it takes a little bit of time
but actually this happens very quickly
so you're not really sacrificing too
much time doing this but it's absolutely
necessary if you have shared variables
so the first thing that we want to do is
we're going to we're going to use a lock
on printing so we're going to say print
underscore lock equals threading dot
okay so we're referencing the locking
ability of the threading module and
print lock basically we have to have is
you have to have a lock / thing so for
our for printing um what happens is
we're you know using this print function
it's not even a variable really but it's
a print function so each time something
wants to use the print function it
checks to make sure that if the print
function is locked or not because what
will happen and I think did happen in my
original threatening tutorial was we
would print out what what thread was
running at the time and the problem with
this is sometimes you would have this
like overlap or head it would be like
this jumbled up mess of texts because
they printed it like a same time and so
it kind of converged the - and even
though this was you know not like a
catastrophic thing that they were mixed
it was a perfect example of what will
happen and you'll get data corruption
basically like that so anyway print lock
we're going to use this to lock printing
now
try to think of what order I want to
start with but first of all we want to
kind of we're going to try to visualize
what we're going to do so what I'd like
to do is like have um you know we go you
want to define a worker you want to
define how many workers we haves or
having threads we have and then what do
you want those threads to do so I kind
of think that what we'll do first is
we're going to say cue the letter Q
equals Q you eue the capital Q which is
what we've just imported up here and
then we're going to say for X in range
of ten okay so how many threads are we
going to allow we're going to allow for
ten threads to do some work now
depending on what kind of work you're
going to do so the workers all have the
same working function here they might
have different working functions and you
might you might still start with four X
and range of ten because you have ten
threads and then you might have
something that picks the function that
it runs specifically but for now we're
just trying to keep this as simple as
possible but yet as useful as possible
as far as education is concerned
so we're say for X in range of ten
t is going to equal threading dot
capital thread and then we're going to
say our target is going to equal
threader okay so these are just for
defining our threads and the target of
our threads let me make some more space
okay and now what we're going to do is
we're see T dot Damon and then we're
going to say that equals true so we're
comp whoops why is it not turning yellow
um so we're classifying this as a demon
and so basically what's gonna happen is
it will die when the main thread dies so
that's all we're doing there now the
next thing that we want to do is after
you've done your demon definition then
we can do T dot start so we start the
threading right after we've defined it
so we couldn't do it until we said what
it was and so we've done it
naturally by default I believe this is
actually false and so you would you have
to have this so for X and range of 10 do
that and that's really it now we'll come
down here and we're going to say start
equals time dot time and what we're
going to be doing here so this is the
starting time and then at the end we'll
do the ending time and we'll we'll see
how much time this is taken for like
performance calculations and the idea
here is to see you know how much time it
took versus how much time should have
took if it was programmed in parallel or
I mean if it's program linear linearly
talk so now what we're going to do is
assign some job so we're going to say
for worker in range of 20 so what this
does is it just says for whatever
variable we want so we're calling that
variable worker in range 20 so basically
we've got 20 instances here for the
workers we're going to say Q dot put and
then worker so basically we're putting
literally putting to work a worker to
the Q which is here okay
so we're doing that now um what we're
going to go ahead and do is come down
here after this for loop we're going to
say Q dot
and what this does is basically wait
until the thread will terminate and
after that um will come down to the
bottom here and we're going to say print
entire job took and then if you recall
we had start so we'll take start and use
comma start - time time and what that's
going to print out for us is oops
actually what we need to do is time to
time - start and that will print out you
know how many seconds basically this
this whole process took now a couple of
things that we need to do here is first
of all we have we've got everything set
up basically how we want to organize
this queue we've got 20 jobs that we
want to do and we've got 10 workers that
will work on this job okay now what we
want to do is we've got Q equals Q um
above this we'll do define and we're
gonna say our example job and basically
this is you know what job are we
actually going to have these workers do
and the parameter that will pass through
is worker for the example job and all
this example job is going to do is some
really heavy processing that just so
happens to take time dot sleep 0.5 so
half a second for this this job to
complete and then what we're going to do
is we're going to say with print lock
and so it's going to with this lock what
is it going to do it's going to perform
this operation and the operation is
going to be its lock on it's going to be
print but you can't perform this
operation without while this lock is
locked basically we're going to print
and will print threading whoops
threading dot current underscore thread
dot name and then we'll print worker so
this will print the current threads a
threader's name basically and the worker
so and then when it's all done with this
it will release that print lock okay so
we can you can see how how um open this
lock is with what we can do so anyway
when it's done there now what we need to
do is we've got everything done except
for the target so the target is what
threader so we don't have anything that
corresponds to thread or yet so we have
to define that and that'll be the last
thing we have to define here so we'll
define threader empty parameters and
basically what threader is going to do
is the actual threading operation that
we have to do so this is you know this
is our cue basically here this is our
cue job assignment and then how many
threads we have and now we actually have
to thread whatever worth reading okay so
we actually have to perform the
threading operation so we're going to
say wow true so this will continue going
on until the main thread dies and then
all of the demons will die because the
main thread is complete so while true
we're gonna say worker equals Q dot get
so this is getting the worker from the
cue we literally put the workers toward
to the Q I just love Q dot put worker
sorry anyway and then what we're going
to do is we're going to say example job
worker so we're passing worker through
what we happen to call worker and the
example job puts that worker to work and
what all that worker is going to do is
this example job that sleeps for five
set or 0.5 seconds half a second and
then prints some information about the
threader out for us so example job
worker and then finally um we're going
to go Q dot task underscore done and
then basically we're saying this thread
is complete and we're ready to move on
okay so a lot of code before I go and
explain it let's go ahead and run it or
do it like one more explanation real
quick through of summary but let's go
ahead and run it for
come over here and we get a thread you
know nine all the threads basically that
ran and then we get the job number
basically the work job number so these
are we have 10 threads total so 1 2 3 4
5 6 7 8 9 10 so these are all unique
numbers and then below it are all unique
numbers so you've got thread 5 5 8 8 4 4
tune you see the similarities there so
those were the threads we had 10 threads
total and then this is basically job
number okay so we can close this and now
let's go ahead and talk about why this
is so important so we had again we had
10 threads 20 jobs each job took 0.5 0.5
seconds so normally this should have
taken with 20 tasks to do at 0.5 seconds
each should have taken 10 seconds total
to perform this operation but as we can
see it actually took more like one
second now why did it take one second
well we had 20 jobs and 10 workers so or
10 threads rather so each thread by
sheer math had to do two jobs each job
was 0.5 seconds so our total time was
actually only one second a little bit
over one second but probably some time
is spent just printing you know doing
print operations so you can see how much
time was spent doing those
so that's thread okay
and that's why threading is so powerful
and useful is because while we have one
thread idle we can actually be doing
work with another thread but it of
course it's necessary to have the locks
and all of that so let's run through the
script one more time just to do kind of
an overview of what what we're what
we've done here since this can get kind
of confusing for people so importing
threading you ported cue accuse its own
little thing you can use cue for all
sorts of things you don't have to use
cue for threading but it's really useful
to do it and then time just so we can
sleep print lock is a special lock that
we've applied to any print function if
we remember our counting Skittles
example so let's say you're counting
skittles and then you were also counting
starbursts
some candy you know you would have a
skittle lock and you'd have a starburst
lock and they'd be two totally different
things right you would want to have
candy lock because you'd be screwing you
know anytime someone was counting
skittles it would be blocking out
everyone that was trying to count
starbursts and M&amp;amp;Ms okay so we've got
print lock it's a lock here we've just
defined an example job that job is just
mimicking any sort of rough computing
saying it's taking a half a second to
compute whatever it is and then we're
saying with that lock we can print some
information and when it's done printing
it releases the lock and then someone
else can print then we have threader and
basically the threader is literally a
core function here and the core idea and
it the idea here is that we can thread
things
so we're saying worker or the thread
right we're saying queue get and we get
the thread or worker and then we run
that worker through example job and then
as soon as that worker is done we say
cute cat task done and basically what
we've done is we've released that thread
or daemon back to the queue and say okay
he's available again to be given some
work so that's the threader now then we
come down here and we actually start
using these functions and we say okay Q
equals Q for X and range of 10 so these
are our 10 threads we're saying T equals
threading a thread targeted with sweater
so basically we're saying that T's are
kind of like our worker sort of our a
thread and its target is to run through
threader which will run them through
example job again just really want to
drive this point home with the functions
as you can see here example job normally
when you define functions it's you can
either define an after-the-fact right we
could say this equals this but we could
have also put threader above example job
if we wanted that would have been
totally fine anyway coming back down
here we run them through we're saying
the T this thread is a demon we're
saying that's true and what that means
it's kind of like a background little
task that does operations you can
literally think of it like a little
demon or something doing work in the
background basically what it means
though is that when the main thread dies
so when we get through all 20 jobs all
of these little dudes will die because
we don't need them anymore so we've done
that start equals time at time really
simple stuff it's just we're just taking
note of when this function started and
then we're saying for worker and range
20 queued up put the worker to work so
if there's a worker available in queue
we put them to work for up to 20 jobs
and then when we're all done we say
queue join which is basically saying
wait until this thread terminates to put
the queue of the worker back basically
and then also at the end or just kill
everything and then at the very end
we're just saying entire job took time
time so what's the current time minus
the starting time equals how many
seconds it took and we saw that was
basically 1.5 seconds so anyway
hopefully that is a useful overview of
the threading functionality hopefully
it's a little bit better I didn't I
wasn't too happy with my original
threading tutorial for Python 2.7 so
kind of nice to be able to go through it
again with Python 3-1 since I have a
slightly better understanding of how
threading works now and I've actually
used it on various jobs so anyways if
you guys have any questions or comments
please feel free to leave those in the
section below I'll do my best to help
you guys out if you have any trouble
here as always thank you for watching
thanks for all the support and
subscriptions and until next time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>