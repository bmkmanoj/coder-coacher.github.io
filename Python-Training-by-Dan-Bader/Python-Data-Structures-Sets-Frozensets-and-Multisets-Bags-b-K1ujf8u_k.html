<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Python Data Structures: Sets, Frozensets, and Multisets (Bags) | Coder Coacher - Coaching Coders</title><meta content="Python Data Structures: Sets, Frozensets, and Multisets (Bags) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Python-Training-by-Dan-Bader/">Python Training by Dan Bader</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Python Data Structures: Sets, Frozensets, and Multisets (Bags)</b></h2><h5 class="post__date">2017-04-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/b-K1ujf8u_k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey there this is Dan and today I want
to talk about the set data structure in
Python basically we're gonna talk about
what is a set in a computer science
sense and what can you do with it and
how can you implement sets in Python
because there's a couple of ways for you
to use a set data structure in Python
there's different kinds of sets does the
regular set there's also multi sets or
also called bags and there's difference
between mutable and immutable sets and I
just want to give you a quick overview
of what's available in Python so if what
the general idea is and then just to
give you some pointers so you can dive
in and learn some more alright so let's
start with a really simple example so
what I'm gonna do here is I'm gonna
define a very simple set and then we can
talk about some of the properties that a
set data structure has so what I did
here was I created a new set object in
Python that holds all of the vowels
right just the the characters AE iou
when we inspect that you can see that
python actually prints us out a little
bit differently because the syntax that
I used up here is kind of old-school
there's actually a shorthand to creating
sets and it looks exactly like this so I
could have created the exact same set in
in the same way so this sort of looks
like a dictionary but the difference to
a dictionary expression is that you
don't have the columns so a set doesn't
really map keys to values it's it's just
a collection of objects that it holds
all right so now we've created a set
object now what actually makes us set
special you know what what do we need it
for can we just use a list okay which is
use a dictionary so here's the key
distinctions number one a set is an
unordered collection of items a list is
an ordered collection of items so if I
had this list there's pretty much the
worst choice of elements here cuz I it
sucks to type it out so if I had this
list it actually has an order to it and
you've seen this effect where the set
doesn't retain the order but the list
does you can see that here because when
I initially created this set you can see
here I passed it an ordered list of L
like I actually gave it a list and what
Python spit out the second time it kind
of flipped the order around right
because the order in a set is not
important so the order doesn't really
matter and this is exactly what you're
seeing here now with a list the order
has a meaning the order is important in
Python retains the order that the
objects were added to the list so this
is a key distinction sets are unordered
lists are ordered
now the other distinction is that a set
does not allow duplicate elements so to
give you an example here let's copy and
paste this set and I'm just going to
create a bunch of duplicates here so I'm
gonna add the old character twice I'm
gonna add the you twice and I'm gonna
add a whole bunch of A's here now when I
evaluate this expression I can see here
we get the exact same result that we
actually got before so Python is weeding
out all the duplicates when you create a
set and that's kind of the whole point
right a set does not allow duplicates
whereas with a list I can create
duplicates all day long right the the
list does not care about duplicates at
all it just cares about the elements
that are contained in it and the order
of those elements so this will work
beautifully and with a set it will
remove the duplicate elements and just
stick to the non duplicate elements and
it's gonna ignore the order as well so
key distinction here right now let's
talk about some of the performance
characteristics for these sets so in a
proper set implementation you would be
able to quickly test for set membership
so if I wanted to test for membership in
a list for example like this I in list
vowels what happens internally is that
we search the whole list one by one
right so pythons gonna go all right I'm
supposed to look for I in list of vowels
all right so let's take list of vowels
and let's look at each element in
sequence and make sure it's I or not I
right so all right we're gonna take a
look at a well that's not high and we're
gonna take a look at a well that's not I
we're gonna take a look at I
all right that's I I can return true
install
search so in the worst case our list
here if we search for an element it
actually has to search the whole list so
with a list a test for membership in the
worst case it has to search all of the
objects in the list in sequence and that
can be quite slow so this is in a linear
time test for membership which is not
that great if you have a lot of elements
now with a proper asset implementation
like the built in set implementation and
Python the situation is actually quite
different so here when I do the same
membership test with a proper set object
it actually happens much faster I mean
in this case you know honestly doesn't
really matter because we only have a
small number of elements and in this
case the list might actually be faster
but if you imagined we had thousands of
elements the set will be much faster
because a set is backed by a Python
dictionary which is a hash table
internally it can test for membership
much much much quicker so we can
actually do this in constant time so
once the set has been constructed it is
very very easy for us or very fast for
the computer to check whether a set
contains a specific character so in this
case what happens internally is that
Python doesn't actually search through
all these characters to find the I or to
make sure that I is an element in this
set but it can do a faster lookup
because of the way the set is structured
internally so it can basically say hey
are you in this in this bucket or are
you in this part of the set and if
you're in there well then I know I know
I can return true and if not then we're
done and I don't have to search the rest
of it and it's basically a trade-off
you're trading some space like a set
data structure is gonna take up more
space than that I've done a flat list or
than just a plain list data structure
but it can provide much quicker
membership tests so it's kind of it you
know it's always about these trade-offs
in when it comes to these data
structures but that's kind of the key
distinction so a set is very fast for
doing these membership tests it doesn't
allow duplicates and it has an unordered
collection whereas the list is kind of
the opposite in these aspects right it
is ordered it is kind of slow for
membership tests because it needs to
search the full list and it cares about
the order so these are the
key distinctions here and this is what
makes a set data structure special so we
looked at the simple set expressions
here to create a set and you may
remember you may have heard of other
kinds of expressions in Python that
allow you to create these structures for
example list comprehensions and
dictionary comprehensions and it turns
out there is something very similar when
it comes to sets and python as well so
there is actually a set comprehension
that works very similarly or looks very
similar similarly to the dictionary
comprehension so basically this is a way
to express a simple for loop in like a
one-liner that creates a new set object
very quickly and very conveniently for
the programmer and I've got a video
tutorial that I'm gonna link that tells
you a little bit more about how these
comprehensions work if you haven't seen
them before but you know just as a heads
up these comprehensions also work with
sets which is great now there's one
caveat so if you want to create an empty
set in Python and you do this you
actually get a dictionary so what you
need to do to create an empty set is you
need to use the set constructor so if
you do this then you're actually
creating a proper set object this is
just something to keep in mind because
otherwise it gets kind of hard to create
an empty set object and you need those
from time to time so now I want to talk
about some of the set implementations
that are available in the Python
standard library and you have seen one
of them already so that was just the
built-in set object so the set type in
Python is built into Python as part of
the core language and it is mutable as
you've seen so it means we can
dynamically insert and delete elements
from a set and sets are built on the
dictionary data type in Python and they
share pretty much share the same
performance characteristics so I went a
little bit into that and I'm gonna put
some more links into the description if
you want to go deeper and learn a little
bit more about this so with the set
built-in you've kind of seen how to
create these sets with the vowels
example right and then also you can use
the set constructor to set
to create new set objects I want to show
you some cool features with the built-in
sets just really quickly so you can
actually create sets from all kinds of
sequence objects so in this case I'm
passing a string to the set constructor
here and what this will do it will sort
of explode this string into its
characters and because sets are
unordered you know this doesn't really
resemble what I put in but contains all
of the characters and what I can do now
is I can use a bunch of different
operations working with sets so for
example I can calculate the intersection
between the word Alice or the name Alice
and the letters in it and the vowels
here in my vowels set so the
intersection between those two sets
would be a I and E and these kinds of
operations are really handy and this is
really why you're using sets right
because they can do these intersection
tests in in linear time and just like
you can do these intersection
calculations you can also compute all of
the other classical operations you want
from a set for example doing a set Union
or doing the set difference or sub set
operations and these all run in linear
time which is great because that's what
you would expect from a set
implementation now these sets in Python
they are dynamic so you can add new
elements to a set so in this case I just
updated the vowel set here and you can
add any element or any object to a
Python set as long as it's hashable so
it needs to follow the hashable protocol
in python and you can add it to a set
which means that's really flexible so I
could also you know put in all kinds of
other objects numbers and then even
generic objects if they support or if
they're hashable and if you don't know
what hashable is I'm gonna put a link to
that as well so it's just a definition
of kind of the methods an object needs
to provide for it to be considered
hashable and so you can add it to a
Python set alright so that's the set
built in now another built-in set
implementation is
frozen set remember how we created this
vowels object previously with the set
built-in and I was able to add new
elements to that set now Python also has
something called a frozen set which is
also a built-in data type and what a
frozen set is or does well it's pretty
much the same as the regular set but the
key difference is that I can't modify it
so a frozen set is immutable it's
completely static you can't delete
elements from it or add elements to it
and that's sometimes useful if you have
some kind of constant so remember when I
added the the letter X to that vowel set
that didn't really make any sense right
it would be much better if the vowels
set would have been static so I couldn't
make that mistake in my program and this
is what you can get with a frozen set so
they are really useful now another
benefit is that they are hashable
themselves so you can use a frozen set
as a key inside a dictionary which can
sometimes be useful if you want to do
you know some kind of lookup table to
map a whole set to some output value so
this can be really handy and frozen sets
are great they're helpful every time you
need some kind of constant or a hashable
object so ya should definitely know
about them they're built into pythons
that are part of the core language you
don't even need to import any module for
it and just like the set built in the
frozen set built-in exists all right so
one more set data type so the Python
standard library includes a pretty
interesting class in the collections
module so I just imported the
collections module and what I'm gonna do
now is I'm gonna create a counter object
and the counter class and the Python
standard library implements a multiset
or also sometimes called a back this is
a set data type that allows items or
elements in the set to have more than
one occurrence so this is really helpful
if you need to keep track not only if an
element is part of a set but also how
many times it is included in a set so
let me give you an example all right so
I created a new counter object and I
called it inventory so you can imagine
this would be the inventory of some
character in a game right and some
role-playing game maybe and right now
it's empty now the character kills a
monster and the monster drops some loot
right so let's say the monster has one
sword and it has three pieces of bread
now I can add that to my inventory
let's take a look at inventory alright
so we can see here we picked up the
three pieces of bread and the one sort
now let's say we venture on and kill
another monster and this time it dropped
another sort and also dropped an apple
now if we pick up that loot if this was
a regular set then we wouldn't really
know you know how many pieces of bread
and how many sorts and how many other
things do we have but because this is a
multi set it actually keeps track off
the number of times each of these these
objects occurs in the inventory so now I
know exactly all right I have two sorts
right because we added one more sword to
our inventory when we picked it up and
I've got these three pieces of bread and
I've got exactly one Apple
so the collections counter is considered
to be a set data type and it is handy if
you need any time you need a multi set
or a bag and it can be a little bit hard
to find in a Python standard library
because I mean it's not called a multi
set or a bag but it's called a counter
which in in my mind well I guess the
name makes sense but often I like if
things are named after the the abstract
data structure because then I find them
a little bit easier to find
but Python has a slightly different
naming scheme here and I mean it makes
sense but it's sometimes sometimes it's
a little hard to find things that way
all right so I hope that gave you a nice
overview on sets how they work in Python
if you ever need to implement a set in
Python or work with a set data structure
in Python this is how you can do it
you've got the set built in you've got
the frozen set built in and you've got
the collections counter class all of
them are excellent implementations from
a performance perspective so you don't
need to worry about you know unexpected
performance hits there this is sort of
what you would expect from a proper set
implementation and if you would like to
see more tutorials just like that then
subscribe to my youtube channel I'm
gonna put a little bit more info in the
description below the video so you can
find a tutorial that I wrote that gives
you some more background in some more
links about this topic and talking about
sets and Python alright so thanks for
listening and happy Python ink take care</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>