<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>AngularJS UI Router: Understanding &quot;Resolve&quot; | Coder Coacher - Coaching Coders</title><meta content="AngularJS UI Router: Understanding &quot;Resolve&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Tech-CBT/">Tech CBT</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>AngularJS UI Router: Understanding &quot;Resolve&quot;</b></h2><h5 class="post__date">2017-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Z3zKvXou7w0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in this video we are going to take a
look at resolve in you a router and how
it works as part of your router enabled
angular application if you are already
familiar to resolve in NZ route the
concept is quite similar
before even jumping and trying to
understand resolve in your router let us
have a quick look at various ways on how
we can switch to different states and
also on how we can load data into those
States while switching to those states
there are typically two ways on how we
can begin the switch from one state to
another as part of you a router the
first one is using routing URL so which
means the users can specify the routing
URL directly as part of the browser
location bar or you can switch to
another route simply by using an anchor
tag with HF or you is ref which were
usually made up of the mark up so we can
typically use any kind of routing URL to
be actually used to switch to the new
state the second one is using dollar
states always so as part of your code so
which means you might be working with
controller or scope related code in
which you would like to really switch to
a new state as part of your angular
application if such is the case dollar
state service really comes into the
picture where we can use the method go
in order to switch from one state to
another
you can also provide parameters or data
where you would like to switch to a new
state whatever the various ways are
loading the data whenever you would like
to switch from one state to another
the first one is we switch to the new
state and then load the data the second
one is we load the data first and then
switch to the new state so which means
in the first case here we are actually
switching to the new state without even
loading the data of that state so we
switch to the state which means the user
will be literally seeing the UI of the
new state and then we try to load the
data using a
well it actually shows the progress
message and once the Ajax completes its
own operation we fetch the data and get
it bounded and then finally the UI of
the same state where we have been in
will be refreshed to show the latest
results coming - before switching so
which means the user will not be seeing
the new state related UI at all which
means is not even into the new state
however we try to load the data first
and after completing the loading process
then we carried that whole data into the
new state which actually refreshes the
UI along with the data at once so those
two are the usual ways on how we can
really work with data while switching to
new states and the later which is
nothing but loading the data upfront
before even switching to the new state
is usually called dissolving so which
means we try to load the data before you
are switching to the new state so if you
are following the second approach of
loading the data while you are switching
to data it is nothing but you are
working indirectly with the concept of
resolving ok let us see how the workflow
really happens as part of our execution
so which means how the UI writer
actually raises various events while we
are trying to switch from one state to
another and at the same time how the
resolve really works if that is
integrated as part of our application so
every state configuration whenever you
do is what a viewer router will have an
option called resolve and if you include
that resolve option then the workflow or
the lifecycle of that particular
switching of the new road will be taking
a different direction so let us see how
it works the in the first case we would
like to see using the routing URL
workflow so which means how the
execution workflow really works as part
of the UI router mechanism whenever you
are using routing URL imagine you have
an angular application and you are
redirecting to new state or new route
from an existing route bicycling so the
first thing is that it is going to raise
the event dollar location change
stat so this is the first event which
gets fired and again whenever you use
routing URL that is pretty important so
this is the first event which gets fired
and immediately the second event is
dollar stage change start so we covered
dollar state change stat and location
change that in our previous videos so if
you are already handling those events
you are going to see that those are
getting executed the moment you have
switched to a new state using your
routing URL once these events are fired
then the browser actually changes the
URL and once the URL gets changed again
three more events will be fired in a
successful manner that is the location
changed success and previous state data
on exit so which means if your
particular state switching is actually
containing the previous state and the
current state so which means this is
your old state and the current state is
a new state so UI router fires the old
state related on exit method if it
exists and if it does not exist then it
will be simply not raised
so again if the new state has got this
method on enter that is going to be
fired if that is not available it just
simply won't fire it so every state can
have two options along with those
particular events those are on exit on
on entered and these two can be
specified as part of your state
configuration and only if it is
necessary or your application demands
for it okay once all of these events are
fired then it actually jumps or switches
to the new route or remove state loads
the state and then it executes or set
fires to stage change success event and
once that is them then it actually
executes your controller or related
associated scope so all the scope
related configurations and scope
executions all of the switching of data
everything will be happening right here
and immediately after the controller you
can see if you are already having any
kind of handlers at the scope level
those are going to be executed and after
that we are going to be working with
Ajax operations so typically
this is where you are likely to have the
loading of your particular data and as
you can see you have already switched it
to the new route changes the URL you are
on to the new route or new state already
the new state has been loaded the you I
should have been already rendered by
this time and then you are trying to do
some kind of Ajax operations so the UI
is already ready and then you are
performing some kind of Ajax operations
which means they actually talk to some
web service fetch the data and once the
data has been first we are going to use
that data to actually bind it or scope
and finally get the UA rerender so
during this particular workflow we are
switching to the new state and then we
are loading the data so let us go to
another scenario using resolve so there
is no resolve option here now the same
URL workflow here but with the option
resolved so here we don't have resolve
but in this case we are going to
introduce resolve as part of state
configuration so if such is the case
again I have an angular application and
we are trying to redirect to a new route
or new state and now you can see it is
pretty similar to what we have in place
that is location change start is going
to be firing and similarly you can see
this state change that is going to be
fired the change URL happens and
location change success is happening
until here it is very similar and almost
identical but after that you can see it
has jumped to a new branch so it is not
actually loading the state here it is
actually trying to execute the resolve
option if it is already available so if
your state configuration is having the
resolve option that resolve is going to
be executed before even loading the
state so as what of that result
typically the users or the application
developers will be actually trying to
load the data and now you can see this
particular Ajax operation will be trying
to load data from the web service even
before loading the state so we have not
loaded the state yet we just change the
URL but we did not load the state yet so
once the data is available
from the web service and the data is
brought to our angular application then
actually it tries to execute on exit of
the previous state from where you would
like to switch and that we if it exists
and after that immediately it is going
to execute on enter of the current state
so that is important so the current
state is nothing but the new state which
would like to switch to so this state
related that is the new route or new
state related on enter if it exists it
that gets executed and there is one
arrow here the yellow arrow which says
result results so this is pretty
important as part of the resolution we
are actually trying to do some kind of
Ajax operations which actually work with
a web service and this is ex operation
or this resolution will not proceed
ahead until and unless this data is
completely returned back to our angular
application so our angular application
simply waits there till it actually gets
the entire data from the web service all
the way back to our angular application
if the web service is hanging there so
which means if it is not returning any
data our angular application is not
going to show any information here so
that is very important and now once we
are there so which means the data is
already there as part of Ajax operation
as mentioned it fires on exit and fires
on enter and the data whatever it has
received through the web service is
called result result in general so all
the data whatever we fetch from the web
service during this resolution is
usually called result results and those
results can be automatically injected as
part of your on inter method or on enter
option you might be specifying so if
you'd like to take use of those results
after resolution as part of your on
enter you can still make use of them and
once that is done then it actually loads
the outer state so this is the step
which actually occurs here so you can
see all the Ajax operations and
resolutions are carried out first before
even jumping and loading our new state
this that is the only difference between
this versus this
and that too during the resolution and
once the switch to the new state has
been happened immediately it follows
with the rest of the events like state
change successor so this needs to be
renamed this is not a route change this
is state change success and after that
you can see it actually executed the
controller so which is pretty similar to
what we have in place so this is execute
controller here and again there exists
an a low arrow here so our controller
can also receive all the resolution
related results whatever we had earlier
directly injected as part of our
controller function so if we would like
to take advantage of those resolution
related results then we can inject those
results directly into our controller to
get the data into the controller before
event binding happens and once we have
that results or those results into the
controller we can attach to the
respective scope or on top of it we can
have our own event handlers to be
executed at the scope level which is
very similar to what we have in here and
then finally all the result results
along with the new scope data will be
bound to overview using the scope and
this is the only difference here we bind
directly to the X results and here we
bind to the result results which in turn
are nothing but the results of our Ajax
operations so except this part and the
injection of our results the rest of the
workflow is pretty similar and again
this is whenever we are using routing
URL way of switching the states but
there is another way that is we can also
switch the route using state that go as
mentioned we can use dollar state
service in order to switch from one
state to another as part of your router
and the workflow will be slightly
different if you are using dollar state
service versus routing URL the
difference here is that you can see the
first one is always we are trying to
redirect the new service but sorry new
state but now you can see it actually
files state change start first
it is not firing location change because
the changing of URL
has not happened yet or not even at the
beginning so we are trying to switch the
state first on not even the URL yet so
that is the reason it actually fires
state change start first if you are
working with state go and not using
routing URL and you can see again if the
previous route or from the route
whatever you would like to switch to has
already defined on exit that gets fired
and the new router related on enter if
defined will be fired and then it
actually switches to the new route again
even though it is switching to the new
route the URL has not been changed yet
now it actually tries to change the URL
so before even trying to change the URL
you can see the state needs to be
successfully loaded and after that it
fire state chains access event and then
it actually fires location change start
so you can see in this case this is
quite different so we cannot expect
these events to be always running in the
same fashion because routing URL related
way of firing the events is bit
different from the life cycle of how the
State DOT go works when compared with
the routing URL and once the change URL
has successfully completed it will be
going through the change access then
that is location change access then from
then onwards it still follows the same
way of going through the execution of
controller and a later scope related
event handlers do ajx operations and get
the results from the web service and
finally get the data to Ajax get it
bound to overview and to the scope
directly so this is a different way on
how the events are going to be executed
when our using dollar go so that is
dollar state that go so let us see how
this one works whenever you are using a
resolve along with the dollar straight
go so you can see this is a dollar
straight go with resolve and here we do
not have resolve so this is just drawing
URL with resolve so this will be pretty
similar to what we have in place here so
it will be a combination of these two so
let us see so we are trying to redirect
to the new route and as mentioned you
can see it is going to start the
change that is state changed at low
location because we are not switching
the URL yet and at this point it will be
just waiting which means it will be
trying to execute the resolve option if
it is available if the resolve option is
available then it goes through the Ajax
operations gets in touch with our web
service waits there till it completes
facing data from the web service once it
is successfully retrieve all the data
related to those operations and
completed the Ajax request successfully
then it actually tries to execute on
exit of the previous Street from which
we are trying to switch to and the
current state related on enter that is
that a new state to which you would like
to switch to that related on enter if it
is available that is going to be fired
and while firing just very similar to
the previous one all the results of
those Ajax operations which are usually
called as a result results can be
actually injected into an enter and
taken advantage of those and finally it
jumps to the new state that is it still
trying to load the new state until here
you can see the URL has not been changed
yet and that's the reason there is no
location related events firing and once
the state has been successfully loaded
then the success of the state change
will be firing so this is supposed to be
state change success and after that you
can see location change that is going to
be fired vice because the browser URL is
going to be changed and once it is
changed it is it actually fires location
change success and from then onwards it
still goes in the same fashion as
explained earlier so the controller and
on enter those two are the components
which are going to receive the result
results which are nothing but the data
which come after all the Ajax operations
have been successfully completed and
those results with results need to be
injected into the respective controller
or on inter methods whenever you would
like to take advantage of and although
the result results once injected will be
available through scope and can be
bounded to our views in whatever the way
we want
so these are other ways on how we can
switch to various routes using you a
router and at the same time take
advantage of resolutions as part of
switchings either using dollar state
service or using the routing URL
workflows let us wrap this one up if you
are not using resolution so which means
you would like to jump or switch to the
new state first and then get the data
later if you are using resolving you
would get the data first fetch the data
first and then you are going to switch
to the new route bypassing this data so
that is the only difference between
working with low resolution versus
resolution okay I have a simple example
here which currently has no resolution
so that is no result has been specified
and it is just a typical add operation
which is actually the same thing
whatever I explained in my previous
video so if you check the UI of this one
I go to calculate or the moment I click
on the calculator you can see I have a
new route or new state which has been
loaded with the name calc so you can see
this is the state so if you switch back
to our application you can see calc is
the state which is actually trying to
fetch calculate dot HTML and if you open
that you are going to see two text boxes
and a button and that's exactly what we
are seeing here and the moment I provide
10 and 20 so let us clear everything
here and let us make sure I do not have
anything else part of the network also
here and the moment I click on add now
you can see it has already switched to
the new state waiting for the data and
once the data has been fetched it
actually renders or refreshes the
current state with latest bind values so
all the data whatever we have fetched
using the Ajax are going to be bound
through the scope and all the UI
elements bound to the scope get
rear-ended as part of our particular
angularjs lifecycle so this is a typical
process so let us go back here and again
try to accomplish the same thing so now
I provide 20 and 30 so just observe
a URL here and the state as well so the
moment I click on add the URL gets
changed and the US state is also loaded
and after waiting for a couple of
seconds then the data gets loaded and
finally assigned or the you is refreshed
so this is how a typical state without
any resolution works so that is we
switch to the state first and then get
the data later okay let us modify this
so that is I would like to have a new
button called multiply to be made
available and the moment I click on that
multiply I would like to make use of the
resolution that is I would like to use
the resolve method and fetch the data
first for the respect to multiply
operation and after getting the results
of the multiply then only I would like
to switch to the new state called
something like multiply so let us work
with the new stuff that is I would like
to add a new stage for multiply alone so
for that purpose I am going to say
something like a new stage needs to be
added and for this new state I would
like to name this one I simply like
multiplying and on top of that I need to
provide all the options and for the
options the first one is obviously the
URL the routing URL so in this case I
would like to follow very similar to
what I have in here so that is instead
of add I just would like to go with
multiply so on top of it I would like to
use the same result so that is this will
dot HTML which will essentially have go
back so that is so let me show you
so these buttons like the back and even
this one and along with this label which
actually shows the result so I would
like to use reuse the same result
template for the multiply operation as
well so that is the reason and just
specifying result dot HTML as part of my
new state configuration also and on top
of that I would like to have a new
controller to be maintained here and I
would like to call this controller as a
multiply controller so earlier in this
case I was using add controller but in
this case I would like to have multiply
multiply controller
okay now comes the interesting part that
is providing the resolve so you can
provide your resolution method by
specifying resolve so a resolve is
nothing but an object so this object can
have multiple properties where each of
those properties will be evaluated with
the data before even switching to the
state so these particular members
usually are nothing but functions and
those functions usually return the
promises doesn't necessarily be always
the case but that is how a typical
resolution really goes with so in order
to fetch any kind of data from the Ajax
we typically use promises and any kind
of resolution related member typically
will be a promised method which actually
returns a promise for returning all
those particular Ajax related data and
all the promises and need to be
evaluated successfully as part of the
resolve before even jumping or switching
to the new state that is pretty
important and if we do not have promises
and just you would like to initialize
with some data just provide the data
directly here without even providing the
promises but in our case I would like to
have some kind of Ajax operation to be
performed right before I jump to the new
state that is before even switching to
the new state and I would like to have
that whole data of the Ajax to be placed
in one single variable or property
called result in this case so for that
purpose I would like to use a member
called result you can provide any member
and this could be a or B also
so I just would like to go with result
so this will be a function in my case
and I would like to use data service
which actually communicates with my Ajax
services so earlier I was having add
operation
and now I would like to use multiplier
operation which actually takes a and B
and goes to multiply later URL of the
web service staying at this particular
location 8000 so I am going to use this
data service and in order to use this
data service I need to inject it so
there service and of course our multiply
has got a couple of ceramic
so I need to send these two parameters
directly to data service for that I
might need to use state params as well
so those two are essential and once I
have those two injector the first thing
is that I need to get the values of a
and B and then actually call the data
service related multiply method which
has been exposed so I just would like to
call this method by sending a and B and
in return anyway it actually returns the
promise so I can just return the same so
I go back here so in this case first of
all I try to get the value of a using
state params dot a and again where it
will be which is going to be state for
am dot B okay so how a and B values
fetch from the URL that is a and B from
the state now I need to call the data
service for that so this will be the
promise object which will be returned by
my data service so I'm going to say data
service dot multiply and as part of the
multiplier I just need to send the
values of a and B and finally just
return the promise object and of course
instead of writing two statements I can
just write one one statement by writing
a return data service dot multiply so
that will make of life much easier so I
can just say return data service dot
multiply so this multiplied in turn
actually returns the HTTP related object
which is an ultimate promise in this
case and all the promises will be
evaluated successfully and completed
before you when switching to the new
state so that is important as part of
our resolution process okay so this is
how the resolution has been configured
for my new state so as mentioned if
there is always-there it gets executed
first okay now I need to actually add a
new controller pretty much similar to
what we have in here so I just would
like to copy this
and of course the first thing is that I
need to modify this one to multiply an
int me to you scope
state and I don't need state parameters
or data service because I am already
using those two state parameters and
data service as part of my resolution
process so I don't need any of these
tools I just delete all of this stuff of
course I need to use go back as because
I have two buttons as part of my
calculate HTML so not this was the
result rht ml so i have this go back so
this go back needs to be still working
so i have that one here so that should
be good enough so let me remove
everything else okay
but the resultant needs the data to be
made available in the form of the result
so that is the object which is supposed
to be having some information through
scope or one way or another but you can
see our resolution is happening here and
once this Ajax is completed the result
of the Ajax that is the data fetch it
off to the Ajax call will be always
stored as part of this result so I need
to inject this result into the
controller so I go back here into my
multiply controller and then inject it
so this is the most important thing so
if you don't use this you will not be
able to fetch the data which has been
returned as part of this resolution so
if you have multiple members here try to
get all the members whatever they have
in place and get them injected so in
this case I am using result the same
thing that data whatever we fetch
through this Ajax operation will be
showed inside this and I inject this
right inside the controller and using
the same thing I can just assign
directly to the scope so which means
whatever the data I received from the
exact results is going to be directly
assigned to a scope that result and in
that way we are going to fetch the
result and finally have that result to
be stored and retrieved as part of our
result dot HTML okay so that looks like
the multiply controller is already done
but one thing that is I need to add a
new button for the multiply
so just like do add in my calculate dot
HTML I need to add multiply and of
course once I click on multiply it has
to execute do multiply so I don't have
code for do multiply I need to write it
as part of my calculate controller and
you can see in the calculate controller
I already wrote something related to do
add and very similar to do add I am
going to write something like do
multiply and as part of the do multiply
all I had to do is just go to new route
called multiply and get the values out
of a and B which are nothing but
whatever we are providing as part of our
text boxes so you can see those text
boxes are currently being bound to a and
B and those two are the values which we
are fetching and sending them across to
the new state called multiply and that
new state has been already configured
with the same name here called multiply
which actually takes those two variables
and those two state parameters will be
turned into our Ajax request and finally
get the values in the form of result and
the result gets injected into our
multiply controller to the scope and
finally the scope is actually being used
right inside our result or HTML so if
everything works fine we should be able
to get the result out of our output so
let us go to the network and make sure
that we clear the browser cache go to
home refresh this and let me clear
everything here okay we have a mistake
somewhere so let us make sure that we
don't have any problems so I injected
result but I did not use the result here
so I need to use a result here so that
is the mistake so let us go back here
and go to the network let me clear this
entire browser cache a bit go to home
and refresh this and everything works
fine so let me clear everything and
clear everything here so I go to
calculator now and now you can see it
has already fired state change that and
it has successfully completed state
change success also let me clear this
one and now I would like to provide
10 and 20 so let us see the difference
first of all I would like to go for add
operation and we have already seen this
add operation so I click on this first
of all you can see the switching has
been already done start and success are
completed but after the completion we
are actually loading the data and then
afterwards it is actually doing the
process and gets bound so this we have
already seen so let me clear everything
and let us try to accomplish the same
using multiply so I go provide 10 and 20
and observe here how it is going to work
I click on multiply you can see the URL
is not changed the UI is not changed
that it's still hanging there after
couple of seconds after getting the data
then the URL change UI changed and then
it has actually fired state change
success so that is important so in this
case there is no loading message
available in the UI because we have not
switched it to that state yet it is
still loading so let us go back
let us try once again and observe it so
if you see carefully we will be still
waiting in on this UI or on this state
without even switching to the new state
when I click on multiply multiply see we
are still on the same one but once the
data is done then we switch to the new
state along with the data refreshed
automatically so at once we see all the
results so that is the difference
between our ad versus multiply so if you
see ad the first thing is that it
actually jumps to the new state first
waits for the result and then we get the
result ok so this looks better because
you know the you I can show some kind of
progress but in the case of multiply you
know the user will not know on how
actually this multiply is working you
will be just standing there for few
seconds doesn't even know what is it
about it is doing and finally after a
surprise it might actually come out with
the result or an error so in order to
show some kind of progress message we
have to show it in the previous state so
it is not how we can show as part of AD
for the ad we are jumping to the new
state and showing the progress message
but for multiply we have to show some
kind of progress message here and we
need to delete that or probably remove
that once
that particular state is done and once
we are switching to the new state so let
us quickly check on how we can add
progress to be shown whenever we are
clicking on multiply so let us jump back
here so I already have these two even
handler States changed add and change a
state change success so I would like to
make use of these two events in order to
work with the progress message so for
that I would like to check if two state
the two state is nothing but the
variable which contains the new state to
which would like to switch to so that
particular object contains all the
information related to the new state to
which you would like to switch to and if
that particular one contains resolved
member so that is easy so the State DOT
resolve gives us the definition of the
result and if that particular result
definition is already available then I
am going to simply say something like
root scope dot is loading equals true so
make sure that we are actually
specifying is loading at the root scope
level so which means this member will be
made available through all the scopes as
part of our application as because
typically almost all the scopes inherit
from root scope so which means that root
scope has got a new member it is
immediately made available through all
the scopes as part of your application
so right now this is the simplest
approach of course we can make it much
more efficient but I would like to make
use of root scope in this case so
similarly I would like to use success
and in the success I would like to check
with the same to state that resolve and
I would like to say false so which means
if it is successful which means we are
already into the new state then I'm
saying is loading equal to false which
means there is nothing else to load
however in the previous case the as it
is trying to start which means it is
trying to load I am going to say is
loading equal to true and now the rest
is simple all you have to do is make use
of this is loading as part of your
calculate to ml which shows the input
boxes or the text boxes as mentioned we
can only show
the progress message as part of this one
but not really inside the other one as
because the new state is not going to be
loaded until and unless the data is
fetched so in this case I just would
like to have a new do to be created and
this is going to show if and only if
this member is actually could be
evaluated to throw and if is loading is
true then I would like to show some kind
of message and in this case I would like
to have the message to be something like
color or equal to red and probably I can
say a loading please wait okay so that
is pretty much the modification I can do
so let me clear the browser cache and
let's go home and refresh this and now I
click on calculator so let me clear
everything and click on multiply once I
provide the values I brought the values
and click on multiply and now you can
see it is actually showing loading
please wait and still you can see absorb
once it has fished successfully it is
actually firing this even success and it
has switched from the previous state to
the new state so in that way we can show
some progress even whenever you are
using resolution methodology however we
will have to make sure that those those
particular progress messages need to be
shown in the previous stage but not in
the current state as because the current
state will not even be loading at that
moment but for the case of ADD method we
are used we are not using resolution so
it actually switches immediately to the
new state and that is where we can take
advantage of showing the progress as
part of the new state itself so that is
how the resolve really works as part of
you a router</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>