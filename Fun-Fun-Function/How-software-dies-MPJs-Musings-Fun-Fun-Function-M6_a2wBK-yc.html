<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How software dies - MPJ's Musings - Fun Fun Function | Coder Coacher - Coaching Coders</title><meta content="How software dies - MPJ's Musings - Fun Fun Function - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Fun-Fun-Function/">Fun Fun Function</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How software dies - MPJ's Musings - Fun Fun Function</b></h2><h5 class="post__date">2017-03-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/M6_a2wBK-yc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good Monday morning today I would like
to talk about the lifecycle of software
from the point when you write your very
first line of code as a loan developer
to when you have hundreds and thousands
of lines of code and a big team and
later
I am npj and you are watching fun fun
function so the big problem that is
going to run through this new thing if
that complexity grows over time as
software developers the fact that
software complexity grows over time not
is the single most important challenge
and job as a software developer managing
that constantly growing complexity I've
been a software developer for a pretty
long time like 10 12 12 years during my
career I have grown through I think four
phases that in how I relate to the ev
the problem of ever growing complexity
in software my first phase was rewrite
when you are starting out as a developer
you you like to write code you just
write code and you are I want to add a
feature and you add a feature and you
eventually end up with this mountain of
math that is just so entangle and hard
to deal with and nobody wants to work in
it and eventually you decide that are
made so many mistakes we're just going
to rewrite this thing in the right way
this time and that never ever ever ever
ever ever ever have work for me that as
always every time I have been involved
in a rewrite or when I have taken the
initiative to do a rewrite it has been a
mistake and been a bad thing every
single time I've already done a video on
why rewrites don't work you can find it
here in the in the upper right corner or
clicking in the episode description or
reading a Joel Spolsky excellent article
on it I link
in the episode description to my second
face was managing text yet that was the
face that came after her banging my head
against the rewrite mistake enough times
but actually also make another episode
on on managing tech that year but
basically in my my textured face I spent
time with constantly managing the the
level of tech death that that arose like
as ass development went on you you need
to constantly clean up after yourself
and rethink how is this still the way we
should structure this application or
have things change do we need to move
things around and and clean things up
and restructure that kind of thing to
make your software workable the problem
is that even if you manage tech that
perfectly complexity is still don't grow
in your application over time because
there are two kinds of complexity
there's accidental complexity and there
is essential complexity accidental
complexity is complexity that you you
create that's basically complexity that
you write in code it's uh it's when you
write code a little bit more messy than
you could have it's not as clean as you
cut out and there might be an
abstraction that is unnecessary or you
might have added a cache that didn't
really have to be there that's
accidental complexity on the other hand
you have essential complexity and that's
not really related to how you write your
code but related to the problem that
your software is trying to solve code
might be complicated because the problem
that it's trying to solve it's
complicated writing a text editor that
is a big complicated problem like
there's only so you cannot there's you
can only make the code so simple and as
months and years go by
and you add feature after feature and
setting after setting and some of them
are intermingled complexity in your
project is inevitably going to grow
because even though you manager you do a
very good work of managing your tackk
depth and your accidental complexity
goes down we keep that stable the
essential complexity will just grow and
grow and grow and grow
so after this realization that tech that
only Kate takes you so far I went into
phase 3 phase 3 is removing features my
reasoning in this space was that because
we were constantly adding features and
settings and stuff and that was
inevitably increasing our complexity of
the software no matter what we did we
tested we also had to remove features
the ones that were least used from our
software at the kind of hygienic thing
so in the teams I've worked with I
became kind of like this Grim Reaper
where I was just constantly pushing that
we should remove features and and and
remove this setting if not necessarily
we should decide if on one default and
just make that the only condition and to
a certain extent that actually worked I
we managed to identify a lot of features
that had very low usage and at the same
time had a very high maintenance cost
and we got those out of the product and
as we did we did end up with more more
maintainable code removing them did
increase the speed and quality of the
software in total however in the grand
scheme of things it doesn't work because
removing features takes a long time a
surprisingly long time and like many
many times longer than you intuitively
anticipate them to and because it's so
slow and adding features is so fast that
means that the ever-growing tide of
complexity
will outpace the speed that you will be
able to remove it the reason why are
removing features is so surprisingly
hard is mainly related to the fact that
it's such ungrateful work you are never
going to see like this big-ass cool
event where the CEO of a company says
yes we have removed and clean out these
three underperforming features and
everybody will go like applause no there
will like the people that benefit from
it by the slight development increase in
speed they will not care because it's
just too ephemeral of a benefit and the
people that actually did use this
feature will let go because you have
essentially destroyed a little bit of
their life there for doing this work of
culling the least performing features in
in an application it's not going to be
very popular it's not going to get a lot
of resources and employees are not going
to be terribly excited about doing it
it's also just very complicated work if
the feature is of an entangled into the
product in many interesting elaborate
ways and you also have to do a lot of
research on on how this is being used by
what users on what clients and figure
out interesting migration paths and you
have to work with customer service to
figure out how to how to communicate it
the removal and doing the timing of it
so removing features a hard slow
ungrateful-- work you will never be able
to remove features in even close to the
same pace as they are being added so
again complexity to keeps growing I now
entering my fourth phase of
understanding and where I I think that
software must eventually be allowed to
die once I was asked to sit in on the
interview with a a a product manager and
I am I asked them why how to deal with
this problem and their answer was
interesting in that they didn't think
that it had a solution the way that they
had dealt with the problems in one
instance was simply that the old product
they are let it sit there and meanwhile
they developed a new product not a
rewrite or the old product no this was a
completely new product based on the
realities that they had now as a company
as opposed to the realities that they
had when they started the development of
the old product ten years ago and they
just gradually over time would use
migrated people from this old product to
the new product by finding little things
that were missing in order to get the
loggers behind and and eventually almost
all customers had moved to the to the
new product there were some people that
just never never did this leave the old
product and eventually you take they
basically had to let those customers go
but I guess that was a bit of a
revelation for me and I've been thinking
about it for a long time and I think
that that might be the way the thing
things have to go there is a software
called for bugs built by a company
called Fall Creek it's the people that
has been involved in making Stack
Exchange fog bugs it's the kind of
software you know when you use it it's
just how do I put this
it smells 1997 you know can you relate
to that at all like your software your
smell of a certain certain year of
development era and I think that the
people at 4 Creek days they realized
that they the something was eventually
going to give with this thing and they
should but they also had the wisdom of
that rewrites don't work and they ended
up building a product called Trello and
Trello was massively successful when you
you probably know about it and but you
didn't really care about fall creek or
fog bugs Trello is a completely
different product from bug bugs it's
it's not even a bug tracking system it's
just basically some kind of structured
whiteboard kinda things you could not
have possibly achieved that by doing a
rewrite or by removing features or
refactoring things of doing things
gradually it's just a completely new
thing in the same thing we have perhaps
another example would be Instagram
Facebook is very complicated and like I
don't know if ever I don't understand
how people could possibly get into
Facebook today when I opened
facebook.com it's just a marvel of
buttons buttons blue galore and as their
and they're like how would you ever
understand that complexity has just
grown to ludicrous levels there and
somewhere along the line Instagram
started getting popular and Facebook
didn't own it at the time but Instagram
was yes it was everything Facebook
wasn't it was just post the picture you
can like it and you can kind of comment
on it and there's filters and that is
that it was so simple Instagram had kind
of identified one thing that was
particularly good about Facebook and
they had
filled it into one piece of software and
did yes that only they could do that
because Facebook could not do that
themselves because if they started doing
even if they knew that this thing was
the best thing about the products if
they had just started removing features
gradually it would or changing into that
gradually that would just have been a
slow grinding torture for their user
base and everybody would just hate them
what Instagram could do it because lane
we're starting from scratch and once
once people saw the nice cohesive
experience that Instagram offered a lot
of people started migrating to it and it
had this enormous ludicrous user growth
now I know Facebook had to acquire
Instagram because they saw that the
trajectory that Instagram had was this
ha ha but I think that Facebook could
probably internally hypothetically could
have done what for quick software did
with phone box and Trello comment if you
think that this is taking things too far
and too out there but isn't this kind of
how nature works like death is part of
life as people we grow old we stagnate
and we die for good reason and our
children can take over with fresh new
eyes and freshening skills and without
the baggage that we carry with us as as
the elders it's the circle overall I'm
kind of imagining like a monkey holding
up no Jay you know what I'm going to go
fetch a board game this turns into an
impromptu ad for this one has the game
called small world you can but you can
buy it using the affiliate link in the
description if you want to support the
show but what I wanted seriously what I
wanted to show it's this mechanic you
you control these are these people these
races that enter the board from
different different places and they
dominate the dominate of space it's
pretty cool oddly the races are time
am i generated so they can be south
giants or or fortified Giants or forest
humans but the thing is that after a
while after a few turns you are your
people your race they start getting
weaker and they end up going into
stagnation so you turn them over you
still have them around and they still
get you still get points for them while
they are still on the map but you do get
a new race generate a new race sort of
for example Alchemist or and you enter
on the map on another plane and you just
race over another race it's an
interesting and brutal analogy to
software development small world great
game every game by Days of Wonder is
amazing so so pretty and well
Illustrated I really recommend it and
that's my source of the day wasn't it
wonderful we uplifting your software
complexity will inevitably grow over
time until it stagnates and dies
however I do really think that there is
hope in embracing this circle of life
and being the facilitator of of your own
product killers so to speak instead of
waiting for a for a competitor to do it
for you and that's my thoughts if you
have any experience on this but please
post post Gulu Gulu post it in a comment
down below do you have just watched an
episode of fun fun function
I release it's every Monday morning Oh
800 GMT if you don't want to wait until
next Monday you can watch this video
that are the Google prediction
algorithms that are actually just
completely arbitrary have selected for
you I am mpj until next Monday morning
stay curious</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>