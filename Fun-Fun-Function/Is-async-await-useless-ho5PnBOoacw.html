<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Is async / await useless? | Coder Coacher - Coaching Coders</title><meta content="Is async / await useless? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Fun-Fun-Function/">Fun Fun Function</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Is async / await useless?</b></h2><h5 class="post__date">2018-03-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ho5PnBOoacw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good Monday morning today we're
embarking on a little thought experiment
is a sink a weight really useful or is
it just fluffy sugar for people that
can't be bothered to learn functional
programming
I am mg J's and I'm David you are
watching function
you may notice that there are two people
here instead of the ordinary one person
you might recognize David from earlier
episodes yeah I wasn't the facebook
messenger both pair programming video
and I'm also doing a lot of business
stuff behind the scenes behind the
camera today's episode is sponsored by
tip top because they are currently
hiring if you know someone who would
like to work with react native yay no
js' mmm in the heart of Stockholm then
please send them to a tip at comm / FF
that link is also in the episode
description it's a second wait really
that useless wait well I don't know
really the thing is everybody went a
sink away to arrived on the scene
everyone was really really excited about
it and finally we can program like we
used to do in the old days synchronously
yeah exactly in that that's it's kind of
like the the thing that irks me about it
it's a way of kind of hiding that things
are a synchronous but not really and I
don't know it the idea behind it and I
made an entire episode in the only a
sink await keyword is to create write
code that is a synchronous but flows
like synchronous code the thing is we
already have sort of that with promises
and I would just like to attack
I think await for a little bit like
really attempt to where for every like
nine so sync away to example out there
try to really write some nice promise
code and see if what like how big of an
improvement is this really when it comes
down I I posted like yesterday when
recording this video I posted a thread
on the front on forum asking this same
question and see that hey can we just
help each other out and try to post some
examples where we really try to like
make a sink away shine as much as
possible and then just try to rewrite
that with promises as well we can and
people post some really really good
stuff all right so why don't you that
isn't super familiar with this example
walk through it all right we have this a
synchronous function get hamburger it
takes a server and a default burger so
we'll check here if and then we are wait
the server has any hamburgers if we
don't have that let's just before return
the default burger and then we check do
we have eaten any burgers and we just
make an ordinary call get number of
eaten burgers today yeah so that call is
synchronous that's a synchronous okay
and then we check for max burgers so we
have we can see that do we have a
maximum number of burgers that we allow
to eat every day and but we have to ask
the server for that yeah and that is a
synchronous so we await for that and
then before eaten less burgers than we
are allowed to then we can ask the
service to load us a burger yeah and if
we like if we're having then we just
return the default burger yeah so this
is of course a silly example like and it
also has horrible software architecture
like why is the get number of burgers
eaten today synchronous but the maximum
number of burgers per day it's like it
seems like it should be eating worse but
like a Magnus what is this but that's
not the point of this thing like the
point is to find an example where a
sinker weight really works so let's
let's try to look at I try to rewrite
this all right it wasn't just me
like I it was a combination of the other
four members and and me try to rewrite
this into a synchronous flow and this is
what we ended up with we have like just
like the previous function we except the
server and a default default Burger then
we call server has burgers which returns
a promise
which resolves into this has burgers as
burgers boolean and if it doesn't have
any burgers on the server we return the
default burger and then we otherwise we
revert to calling get max number of
burgers per day and once we receive that
we can get the number of burgers today
and compare that to the backs burgers
that we received and if we are allowed
to eat more burgers today we load burger
otherwise we just return the default
burger as one does in enterprise-grade
programming so I sort of like this but
it starts to feel like the whole purpose
with promises was to like get out of
this callback hell yeah because
everything got nested and now we're back
into the nested world yeah this example
is chosen because it gives this the
sample burger example like it has no
nesting because this is a these
variables here are available to the
entire function we basically write a
sort of a shared global State for the
function and that means that we it kind
of it becomes like the nesting is it's
not there but if we have a look in the
in the refractor we see that we actually
get a level of nesting it's not too bad
it's just one level of nesting really it
looks more here because I indented so
that you can watch it on a tiny screen
but it's it's there's still some
indentation that said I think that I'm
doing quite a bit of clever stuff here
as well which makes it more yeah it's
the the ternary expressions is something
that you I tend to fall into using
because yes feels cool to just have
these one-liner functions which use
ternary expression then I used to turn
expressions a year like like it just
feels cool to do this but if I actually
just allow myself to fall out of use
turn Aries and allow the co2 sprawl a
little bit this is the same code except
that I use like these multi line
functions instead and just use if
statements instead of the turn Aries and
now the code doesn't look all that scary
it looks pretty similar to the image I
think the weight code yeah exactly lets
me show you that again like suddenly it
doesn't look all that scary in fact I
think that almost the the promise
example almost looks bit even more
straightforward because we like the
asynchronous flow is more in your face
depending on how if you want that in
your face or not really but if you like
IKEA takeaway for me when I did this was
that huh
a lot of the asynch awaits examples out
there look often look more approachable
and nice because there isn't a lot of
cleverness going on in them because
promises tend to for at least for me
encouraged a bit of cleverness and then
return Aries and stuff like that which
just isn't mmm
for me like like that might look scary
but if you do it like this it's kind of
approachable so here we have another
example we have a synchronous function
process all users in earth we call the
database and we wait for it get the
users from the database but then we want
to iterate through each user and process
them in some way and we need each user's
ID to do that and then we wait for the
result before we continue on yeah
exactly
so this processes each users quench aliy
this is actually the the example that I
used in the sink of wait video to show
where a sink of weight really works well
compared to promises and I I do a
refactoring in that video where I use
like a reduce to
to create like this this promise promise
thingamabob but that replaces it which
which isn't too bad but I kind of like
to revisit it and see if we can do it
even better than that this is also real
code from an application sort of with
that I go right across where we actually
needed to do something like this let's
have a look at the refactoring I ended
up with a lot of people help up with
this as well so if you if you're a
member of the fund conform you can check
out the full thread by clicking here or
that's it's also linked in the episode
description so there's a lot discussion
going on around this topic and a lot of
the farm topic yes it turned out to be
really really interesting alright so
this is what I ended up with my initial
solution where this was much worse but
Chris Collins really nailed it with
these cool destructuring things so let
me walk you through this we do the DB
query just like the earlier thing but
then we get a promise and the users we
pass them into this wait for each
function and we also pass in this
processing function so for each we wait
for each user to be processed here so we
call process user where the user ID and
that will return a promise which we will
wait for and then just promises like
just like the other one all right so
wait for each is a generic function it's
not really aware of abusers it's not at
all aware abusers it takes as its first
argument this process function which is
this one and as its second argument it
takes an array and it uses a raid
structure in here to break apart the
head from the tail the right so head
will be like the first item of the array
and then tail is going to be like the
remainings its first remaining the
remainder is an array and the item is
not an array precisely
and let's disregard this for now because
that's that's on the second loop when we
get the head here we pass it to process
function and process function will
process the user return a promise which
we then wait for it to resolve and then
we create a new wait for each function
here we recursively call ourselves
precisely so we call ourselves
we're like the rest of the tails so to
speak so we processed the head and now
we process the tail which is then all
the users and then we like sort of just
dick dick dick dick cut off the head and
yeah keep on working downwards exactly
so we used this is a very standard this
is standard functional programming you
saw instead of using loops we you use
recursive functions which like get a
smaller and smaller and smaller part of
our Reese part of our result set all the
time so we cut off the head pass down
the tail cut off the ted pass down the
tail but then we have to have an end
case as well exactly and that's what
happens here it's when we when we don't
have a head anymore
we just poof resolved and then we're
done I like this because it's pretty
neat because it's recursion and I just
like recursion because it just feels
it's very I know it's oddly what you
mean it just feels good somehow it's
it's a very satisfying way of
programming it's it's a bit tricky to
reason about but it's also at its
essence very simple so like this case
here it was hard for me to figure it out
but once I have it like the code is so
simple it just look and I know it's how
all of this this weight for each is so
it's it is generate because you can use
it for for anything basically yeah and I
feel like this is kind of like the
drawback and the advantage of using
promises at the same time
mentioned on the forum that I felt like
promises tend to encourage cleverness
and scale I said yeah but you could also
think about it as if they encourage you
to think about your code oh so what what
happens here I actually found that we
could break this apart into a generic
case so now we can use if we have more
of this kind of sequential processing we
now have a generic function to do that
and probably to be honest in if there is
a functional promise library this
function would probably be in it so that
we wouldn't have to write it so promises
tend to make you think about
composability and what can we extract
while a sinker weight tends to not quite
do that because the the the it doesn't
become quite obvious that it might have
some room for decoupling or extraction
here and also I think it's very I it's a
very clear Co always like when it's a
clear coat like you understand what's
going on you return there the query you
get the users and then you have to
process each user wait for them and your
Protestant it's just simple and clear
all right so there's more stuff in the
forum topic that I want to talk about
there's there's a really really good
example of where I think a way it really
does well and it's super tricky to get
work which is basically when you have
multiple things like when you start like
aggregating data start collecting data
into one thing this is also error
handling that's my main topic I love how
are handling like promises when you need
to like diverge and handle up handle
stuff as you go like promise has become
a lot more appealing but this episode is
coming up on 50 minutes or so and I
think that I want to say that for next
week and like
cut this off and like just summarize
what we talked about sure so we looked
at the burger example we collect burgers
and see if we have burgers on the server
and the refactoring looked a little bit
like this it gave us more indentation so
it doesn't have the flat appeal of the
ascetic of weight but it's really it's
still not overly horrible to to deal
with I could still very straightforward
and easy to reason about and especially
when we broke it up and didn't we didn't
do much cleverness at all then we looked
at this example which did sequential
processing our user and we were just
sort of like the best case for I think
your weight right yeah this is the this
is the typical example case of using I
think awaits yeah I think that this is a
very a lot of people use this to sell
think away don't say I like it no it's
it's fine I like I don't want to
too much on a sink away that's not the
point of this episode this is just
challenging like an ocean yeah and see
you like if is this really correct like
a weed there's no hate against a sink
away and this is what we ended up with
it which is this a little library
function called that we call wait for H
this is probably in a lot of functional
programming languages that just
recursively processes an array and
assumes that every process every call to
this returns promise and then it just
keeps chaining it and it turned out okay
and again today's episode is sponsored
by tip top and they are currently hiring
if you know someone who would like to
work with react native and nodejs in the
heart of Stockholm please send them to
tip-top calm slash FFF that link is also
in the episode description you have just
watched an episode of fun fun function I
released these every Monday morning oh
wait
under GMT if you are forgetful you can
subscribe by clicking here or you can
watch another episode right now by
clicking here
I am mpj and I'm David until next Monday
morning stay curious</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>