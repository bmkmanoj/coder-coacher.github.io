<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Leaky abstractions - MPJ's Musings - FunFunFunction #58 | Coder Coacher - Coaching Coders</title><meta content="Leaky abstractions - MPJ's Musings - FunFunFunction #58 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Fun-Fun-Function/">Fun Fun Function</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Leaky abstractions - MPJ's Musings - FunFunFunction #58</b></h2><h5 class="post__date">2016-11-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gRsyY0kzXfw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good Monday morning I am mpj and you are
watching fun fun function you might be
noticing that I have a bit of a sexy
voice going and that is because I have a
cold so let me give you an overview of
what today's video is going to be about
today we're going to talk about leaky
abstractions abstraction allows us to
treat something complicated as one
simple thing abstraction is a lot harder
than we think and therefore it mostly
fails a leaky abstraction is an
abstraction that fails at encapsulating
and a leaky abstraction might add more
complexity than it removes let us start
by being a little bit philosophical what
is an abstraction really like not just
programming but in general an
abstraction is an imaginary concept that
allows us to think about something big
and complicated as one small simple
thing for example in the real world we
can bundle chihuahua and labrador and a
pug into a concept an imaginary concept
called dog this generic abstract dog
does not really exist if you were asked
to draw a dog you would probably draw
something stylized with a tail and some
ears right even though the actual thing
a dog is way more nuanced and
complicated than that why do we do that
what is the purpose of humans using
abstractions well we use abstractions to
think and communicate more effectively
if we did not have abstractions we would
not be able to say sentences like if
your dog is sick you should take your
dog to the vet so the words dog and
veterinarian they are abstract concepts
that encapsulate a lot of complexity so
that we can think about them without
being distracted by all the complexity
that is behind
the word or the obstruction in
programming abstractions serve
essentially the exact same purpose we
use it to bundle often many complicated
things into a single simple entity one
example would be authenticating a user
there's a lot of moving parts to
authenticating a user and let's say that
you are currently working on an app that
has users but you are currently working
on the profile image upload flow you
want the authentication to be abstracted
away separated from the world that
you're currently in the profile image
upload world if authentication is
properly abstracted away you will be
able to think about you know the user as
a very simple concept and not care about
details about it such as whether it's
authenticated or not and that is good
because that will allow you to focus
fully on the profile image upload
problem that you're trying to solve at
hand
most abstractions are created by you in
your own app but abstractions are at
their best when we managed to create
abstractions that we can share with
other programmers in your company or
perhaps even in your industry for
example hashing you don't want to store
plaintext passwords in your database so
mathematicians have invented hashing
algorithms pretty much all applications
that have some form of authentication
needs hashing and luckily enough there
are plenty of ready-made abstractions
that are available to us you just go MPM
east nor a sha-1 and woof
your you have hashing in your app this
problem is so well encapsulated that
I've actually never had to implement a
hashing algorithm myself it's just
fantastic that is the pink and fluffy
and nice side of the coin but I want to
talk about the the darker side of apps
action what is leakage hashing is a good
example of an abstraction that leaks
very little and what I mean by that is
that it's very rare that you need to
know anything about the intestines so to
speak about the the hashing
implementation in order to work with it
it's this very simple black box that you
stuff a thing in and you get a thing out
and it works that way every single time
and the reason why hashing works really
well as an abstraction or at least the
main reason is that it has successfully
identified the general case what I mean
by that is that millions of apps need
hashing and they largely need hashing in
exactly the same way you stuff in a
string and you get a hashed string out
okay so what would be an example of the
opposite what would be an example of an
abstraction that does not identify its
use case as cleanly and therefore is a
more leaky abstraction for this I think
we should reach for HTTP requests
libraries the high level ones and for
this particular example I'm going to
focus on Axios if you haven't heard of
Axios that's completely okay I'll
explain in order to do HTTP requests
there is this API in modern browsers
called the fetch API the fetch API is
kind of bare-bones
so libraries like Axios aims to be a
little bit more high-level Axios offers
features that the fetch API lacks such
as cancellation or custom timeout
settings
Axios also does a couple of things
automatically for you that
Axios considers to be extremely common
one example is that
Axios will parse JSON for you
automatically
while you have to tell the fetch API X
basically that that is something that
you want to do another example of that
behavior in Axios and the one that I
want to spend some time talking about is
the fact that
Axios will coerce HTTP errors into
javascript errors so if the request
status code is say 404 then
Axios will actually throw that or return
that as a javascript error the fetch API
built into browsers does not do that it
the as long as the network request is
successful then fetch will consider that
to be a successful response and it will
give you the response object and then
you will have to read the status code
and determine if you think that a4 or
the 404 is is an error in your app or
not I think it's safe to say that most
developers would actually do it the
access way but it's absolutely not
everyone the case is not that general we
had a library that did just this it
cursed 404 errors into JavaScript errors
but the backend API that we were using
had 404 as a kind of valid case when the
user had not been created yet so we
needed to handle that that was a normal
flow in the application so what we had
to do with this high level library was
to create wrapper library on top of it
to curse the error back into a response
so that we could have a generic layer
that worked the way we expected it to in
our app now Axios is a lot better than
the library in my story access as a way
of overriding this behavior but it
doesn't change the fact that you have to
know things about how Axios works inside
in order to use Axios and that is what
we mean by a leaky abstraction when you
put something like Axios next to a
what's the label for a non leaky
abstraction an air-tight perhaps like
the sha-1 package on NPM
which is just a function that takes a
string and gives you out a spring hash
then you see that there's a huge
contrast between how much you need to
know about the underlying reality behind
the abstraction in those two cases and
some of you are probably thinking and
well this doesn't seem like a fair
comparison the problem that Axios tries
to encapsulate is much broader than what
sha-1 tries to encapsulate but that is
kind of the point it is the reason why
sha-1 doesn't leak the way that access
does sha-1 works really well as an
abstraction because it's so very
constrained so am i saying that Axios is
a bad library that you shouldn't use no
I'm not saying that but I'm saying that
it is a leaky abstraction and you need
to be aware that you're bringing a
certain amount of complexity into your
project when you're bringing in a leaky
abstraction
if you pull in a non leaky abstraction
like sha-1 into your project nobody on
your team will have to spend time
familiarizing themselves with the sha-1
show and leak so little that you're very
unlikely to have to actually delve into
how that works behind the scenes but you
will if you use an abstraction like
Axios because it is leaky and it's
important to note here that that might
be okay like leaky doesn't mean that a
library is useless and that you should
avoid it it just means that you need to
be aware of the cost yes access will add
a little bit of complexity to your
project but it also might remove a lot
of complexity for example if your app
uses custom time outs or cancellation
then the case where access becomes a lot
stronger because if you can get out of
writing that logic yourself it's a much
more obviously good trade-off on the
other hand if you add access to your app
maybe because you reason that Oh am I
need these these features that access
offers in the future but you never
actually end up using them then you have
just added a kind of net negative in
complexity to your app by adding axials
and that sucks in that case you would
have been much better off by just using
fetch straightaway and creating your own
little wrapper around that probably as
the simple function and that could have
been a lot easier for your team to
reason about because they could just go
look in the function and see what the
hell was happening allow me to summarize
my thoughts we have talked about leaky
abstractions abstractions allows us to
treat something complicated as one
simple thing but abstraction is harder
than we think and therefore most mostly
fails which brings us to the fact that a
leaky abstraction is an abstraction that
fails at encapsulating and a leaky
abstraction might add more complexity
than it removes this does not mean that
leaky abstractions are worthless but it
means that you need to be able to spot
when an abstraction is leaky and be
aware of the cost of bringing it into
your project that's my thoughts on that
but more importantly what are yours
please feel free to leave a positive or
negative comment down below or even
better reply to the comment of one of
your fellow viewers one more thing
before you leave you have just watched
an episode of fun fun function I release
these every Monday morning Oh 800 GMT if
you liked this episode you should check
out this playlist with more episodes
like this one I am mpj until next Monday
morning please
stay curious</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>