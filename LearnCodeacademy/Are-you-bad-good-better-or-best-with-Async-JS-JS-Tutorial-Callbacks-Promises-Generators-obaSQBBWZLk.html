<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Are you bad, good, better or best with Async JS? JS Tutorial: Callbacks, Promises, Generators | Coder Coacher - Coaching Coders</title><meta content="Are you bad, good, better or best with Async JS? JS Tutorial: Callbacks, Promises, Generators - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/LearnCodeacademy/">LearnCode.academy</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Are you bad, good, better or best with Async JS? JS Tutorial: Callbacks, Promises, Generators</b></h2><h5 class="post__date">2014-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/obaSQBBWZLk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so in this video we're going to be
handling JavaScript async operations
which is a really confusing to a lot of
developers on how to do it in a good
clean way and it can get pretty
complicated you'll have to excuse me if
I sound like I'm about to run out of
breath at some point because I have a
slightly bruised rib which means that I
can't breathe in fully so but the code
must go on so let's get into async
JavaScript and the two second
description of that is for those of you
who are newer to JavaScript a sink is
anytime you start something that
completes later on javascript allows you
to say hit an API and then not lock up
your program you can actually say start
the API and move on with my code and
when the API returns our response say
our tweets from the back end then we can
continue processing code and we didn't
lock up our application the users click
events and drag events are all still
going to get processed so that's what
async means
that's why javascript is awesome but it
can also get complex so I'm going to
give you four ways of handling this
there's the good way the better way the
best way and the awesome way which is
the brand-new way and let's get into it
this plunker address will be in the
description so you guys can go look at
this code later and so here we go let's
look at the first way of doing 3 async
operations all in a row so I'm turning
on the callbacks these are all all
pieces these code are going to do the
exact same thing you can see again when
I run it it fires there you go got
profile got tweets got friends so every
time something comes back it says this
and then spits out its information let's
look at that code for this example were
going to use jQuery because everybody
knows jQuery if you're on the back end
doing nodejs
the exact same principles apply and so
let's get into it this code right here
is the callback way of doing it it's a
mess just opening this makes you want to
run for the ibuprofen because you feel
the headache coming on and it's only
three operations it's not this super
complex thing going on we're just doing
three things in a row we're fine firing
a get to the profile JSON since we don't
have a back-end we can't really hit a
profile API
so I just have a static JSON file here
that will give us the exact same
response so we're getting the profile
JSON on success of that we are you know
doing the two things we need to do
saying hey got profile and spitting that
out and then we're moving on we're
starting up the next Ajax request which
gets our tweets JSON tweets passing it
our ID and so then success happens by
the way this doesn't really do anything
since we don't have a back-end server
but in theory the backend would take our
ID and give us our tweets but no matter
what we do it's always going to give us
this tweets JSON so then it fires this
and then on the success of that we do
our two things and we start up our third
Ajax request and I just can't go on it's
bad for several reasons we've got the
Pyramid of doom look don't a fork don't
know why hit the button we have the
Pyramid of doom going on right here as
you can see pyramid of doom and it's
also called callback hell it's just a
mess this is a very bad bad shape in
JavaScript you don't want to see that
and then we're also having to handle our
error here handles the air for this Ajax
request here handles the air for this
Ajax request and here we're having to
handle errors at each step of the way
this is terrible so let's look into how
we can clean this up I'm going to kill
this script turn this one on and the
exact same thing just took place in the
exact same way let's look at the code
for this this code is called clean
callback so we can move a next step
forward by abstracting out the callbacks
into their own function so here we fire
up our first Ajax and then we're going
to for success we're going to run the
get tweets function and for error we're
just running the handle error function
right away you notice it looks a lot
cleaner it goes top to bottom instead
top to inside to outside mess so here
we're able to go fire our first one get
tweets get tweets does it's two things
kicks up our next ajax which will fight
will do get mentioned user and then
handle the in any errors so you'll
notice we're able to reuse our handle
error function that's a lot cleaner and
also it kind of just goes in order do
this then get our tweets then get
mentioned user
and on the success of get mentioned user
I didn't abstract this function out into
its own we're just going to do our two
final things and be done it's still kind
of messy I still don't like this in a
lot of ways it's just a lot of repeated
code it's a lot of code we don't need to
do let's get into the best way of doing
this that is better let's look at best
going to kill you turn you on prove that
this code does the exact same thing yep
let's look at promises promises are
things a lot of developers don't
understand yet so I'm going to show you
the code wow that looks a lot cleaner
that looks a lot better and it's also
confusing if you guys don't know it so
let's look real quickly over to this
file where I explain what promises are
so every a promise basically represents
a future value it's a standard syntax
for anything that has a delayed response
Java Script uses promises pretty much
every good library every library that's
built correctly every every framework
that's built correctly should use
promises should return a promise for
anything that is going to start an
operation and give a value later
so Ajax starts an operation starts
talking to back-end and if you actually
return the value from jQuery AJAX say I
do vary it profile then this is actually
a promise or a deferred object
getprofile doesn't stand for anything
yet it's just a promise it's a it
remembers what the state of this Ajax
request is so when the Ajax request
moves on at some point that Ajax request
is going to go it's either going to
resolve it say when the the get is
successful it's going to resolve it with
your profile data and so then that gets
fired to a then which we'll get into a
second it's either going to resolve it
or it's going to reject it if it fails
it's going to reject it with your xhr
objects your status your error
everything you're used to seeing jQuery
so jQuery either resolves it or rejects
it depending on what they do it will get
passed to your then function basically
if it's a promise
it has a then function to it that's
pretty much what you need to remember is
you can go get profile dot then
so dot then receives two things a
success function and an error function
if it was successful if it was resolved
then it will run this with whatever it
resolved it with as your argument right
there if it was an error then it will
run your error function with whatever
the error arguments were so that's
basically what a Venn or a venable
object is so when you run jQuery you can
actually store that promise
deferred venable object as a name so
there's some cool things that happen
with this one is you notice as soon as
you don't have to do success in error
configuration you can use the simpler
syntax of jQuery git that's a lot nicer
already I can just do git profile JSON
then and I pass it to functions my
success function my error function now
you'll notice right away this is not
necessarily any cleaner or better than
doing a success in an error function in
jQuery if you're only running one thing
there's really not much of a difference
pass its success in error in your object
configuration up here and call it a day
but where then is really begin to shine
where promises really begin to shine is
when you have to chain things because
the then object whatever you return from
that gets passed to the next then you
can do dot then dot then dot then and
whatever this then function returns will
get passed to the next ven function and
so on and so on the cool thing is is if
you return another promise it's going to
wait for that promise to fulfill before
firing the next ven function so we're
going to run get profile JSON it's going
to wait even though we sent it to then
dot then it's going to wait until
profile JSON has been gotten then it
will fire the then function passing it
the profile and then we're going to
start up our next JSON and we're going
to return that promise so then it's
going to wait on that promise
once that promise succeeds it'll fire
the next then function with our friend
here and another thing you can do is the
error proof the error functions will
also chain on down
we all we have to do is add one error
function here at the end so if this
first one errors it'll skip all the
others and fire the last error function
if this one errors then it'll skip down
to the last error function basically no
matter what you do the last error
function gets the error now earlier
earlier versions of jQuery I believe do
not do this correctly but the latest
version of jQuery does do this correctly
so that's pretty much what a promise is
you can see that I can also do something
like this let's say what if you want to
do several things at once
every promise library gives you methods
to do multiple things at the same time
so here we can say let's get profile
let's fire that up
let's also start the get friend process
so they're both running right now and we
can do a jQuery dot when and put them
both in so it's going to wait for both
of these to succeed and then it's going
to fire the function and you can see
that it's giving us our profile and our
friend right here and these are arrays
of the arguments that would normally be
passed to a success function so if
you'll remember a successful jQuery
thing passes it gives it your data and
then it gives it your status and then it
gives you your xhr object your jquery
xhr object so for the data we just want
to get profile dot 0 so when they've
both completed then we can get our
profile right here and we can get our
friend right there and then handle any
errors that were passed on from either
of these if any of them fails then we
consider it a failure so jQuery dot when
is awesome bluebird has that queue has
that when has it lots of times they're
like they're considered dot all I
believe Bluebird is is promise dot all
when is when dot all and I believe Q is
Q dot all and so that's pretty much what
that is let's so let's look back at our
promises J s so you see here we're
getting our profile JSON and then we're
running this do the two things we need
to do and return the get tweets JSON
it's going to wait on that it's going to
fire this then
and then it's going to do the two things
we need to do and return the friend J
saw and promise so then it's going to
wait on that promise
and fire the last thing which is to
mention that our friend has been
received and then as the last thing here
I'm going to do the handle error
function so if any of these errors
anywhere along the way then the error
will get handled it will fire this
handle error function so there you go
that's promises it's way nicer way less
code way more stable but if you look at
it and you're honest with yourself it's
still kind of messy
it still is just a lot of dot then
return then it still feels like
programming should make more sense so
let's look into a new thing which is
coming in JavaScript six es6 harmony
which you can actually start using today
using google tracer which will convert
your JavaScript to es6 harmony let's
look at generators you can see I'm going
to turn this on the only thing you have
to do to start using tracer is you have
to include tracer the tracer javascript
in your page and then whatever
JavaScript you enter you just have to
give it the type of module so your
browser won't run it but tracer will
pick up on it tracer will convert it and
then it will run it so let's look at
generators j/s hold your breath because
this is going to be really cool here we
go profile there's this funky yield word
in here we're basically getting the
profile and then we're doing something
with it and then ver tweets equals get
tweets and then do something with it and
then ver friend
equals that and then do something with
it and you're done I mean look at that
that is clean that is readable that is
beautiful the only thing that might look
confusing at first is this command
because we're using a promise co-routine
object we're using what's called
generators es6 generators and my next
video is going to describe those in
detail and show you how awesome those
are and but basically you're able to
yield this thing anytime you put yield
it's going to wait on a promise so
we can treat it just like a normal thing
we can say their profile equals this and
move on but it's actually going to wait
for us to get the profile before moving
on and then later on we can save their
tweets equals this and it's going to
wait for the tweets to actually fulfill
before we move on the beauty of it all
is it's still happening asynchronously
it's not blocking your code it just
looks like it's blocking your code so it
makes a lot of sense I'll leave you
there for that let's go into generators
in the next video which comes out
tomorrow and the generators video we're
going to cover a lot of these the cool
ways that these es6 generators are
working behind the scenes hope this
video made sense for you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>