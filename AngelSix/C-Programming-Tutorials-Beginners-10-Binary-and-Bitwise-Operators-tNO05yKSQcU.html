<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>C# Programming Tutorials: Beginners 10 Binary and Bitwise Operators | Coder Coacher - Coaching Coders</title><meta content="C# Programming Tutorials: Beginners 10 Binary and Bitwise Operators - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/AngelSix/">AngelSix</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>C# Programming Tutorials: Beginners 10 Binary and Bitwise Operators</b></h2><h5 class="post__date">2016-12-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tNO05yKSQcU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in the last video we used a bitwise
operator in the tech tac toe game to
invert a boolean so say we had a value
like this and we wanted to toggle
between true and false in the game it
was between player 1 and player 2 you
could do if is true which is a bit of it
let's rename that call it a so it's not
confusing so if a is true then a is
false else a is true and the equivalent
of that using a bitwise XOR operator was
to simply do a and XOR it with true and
I mentioned that this simply inverts a 2
if it's true it becomes false if it's
false it becomes true it's a neat little
trick you can also formally know if you
can just do a is not a I just tend to
use the axel just cuz it looks cooler so
there's there's quite a few uses of
bitwise operators and I said I'd explain
them in the next video so that's what
we're gonna do so all bitwise operators
work on binary on a single bit and the
named bitwise so you don't work in bits
in c-sharp it was very rare that you do
you work in bytes so you know the lowest
thing you can typically make as a byte
so you can be one two should go up to 7
I leave 8-bit so I'll tell you how you
better obviously so if we did eight bits
in the calculator you can see here I've
switched to programmer mode and then
click this little dot which is the bit
toggling keypad you can see there
there's 8 bits so this will show us what
we can get up to 2 5 5 knob to 8 I was
thinking of bits so this can be up to
255 and
anymore when it complains so when you're
working with binary you're not working
with like a bike here you're working
with eight bits as it states and that
means eight individual one and zeros so
you can't create a bit there's no way to
just create a bit you have to work with
you know your variables but you
manipulate the bits inside of of this
variable so binary as effectively as I'm
sure most of you know is just a 0 and a
1 so a binary is this it's the 0 or the
1 and that's that's all binary as it
simply means yes or no true or false you
know it's a very singular thing so
that's all there really is to cover with
binary you just have to bear in mind
that bitwise operators work on each
individual bit of your variable they
don't work on the whole value all they
work on each individual bit and there
are four types and Seashore
so you've got the and the or the actual
and the not so you can these are sort of
helpful names I've given them to help
you think of them the and is both the or
is either the X or you can either think
it stands for exclusive or you just
think of it as different and the not is
inverting so I'll get straight into this
let's first do a variable I give it
value 25 let's keep this sir similar to
a table of written let's do 25 and say 7
now result equals a and B
and let's write that to the output
window
I must press f5 to run this let's see
what the result is at first you might
have to format this value so we can see
it in binary house if we actually tell
the console to stop so result shows 1
now this is displaying decimal we can
use this helper convert dr string you
pass in a byte in this case which is
fine for what we're doing we're never
going to work above 255 in this example
and you can cast it to base so binary is
base 2 so if we do this we get the
result 1 so we want to we want this to
be because we're gonna be working on a
byte which is 8 bits we want to pad this
out to always be a digits so it shows us
somewhere to the calculator it shows you
know these 8 bits we've got one like
that you really wanted to see 0 0 0 0 0
0 0 1 so it's always the same length so
I'll simply pub this string out so I
think it's string dot pad or do you just
do it afterwards pad there which won't
cut the left-hand side total width wants
to be 8 the character wants to be a 0 so
anything that's not going to value as a
0 and there we go we have like a nice
result of what the result of the binary
operation is so let's just improve this
slightly more let's remove that copy and
paste you want an output a then B and
then
we want to output the operation we're
gonna do and in this case it's an unsub
in and I'm not sure how that's gonna
loop let's have a look that looks ok so
you can see that on that but then it's
really it's a bit too spaced out so
let's move the end to up here let's
change this just to some lines and there
we go you can see a nicer a grid so you
can see down so this first one is the
binary of a which is the number 25 so in
the calculator we put 25 in as a decimal
then we look at the bits you can see
here it's 1 0 0 1 1 and they got 1 0 0 1
1 now in binary that because it's a 0 &amp;amp;
1
when you construct your data so in this
case a byte or an integer the first part
is 0 or 1 so this is 0 or 1 and you'll
see that's happening if you move to the
next bit you'll see it's 2 so it's it's
0 or to the next bit 0 or for the next
bit 0 or 8 so the way binary works is
you double every time so this is 1 this
is 2 this is 4 less she's 8 this is 16
32 you got the gist 64 128 256 so when
you move along these bits you make 25 by
putting 1 then you don't put a 2 you
don't put a 4 he put an 8 and 16 so 16
plus 8 plus 1 she did the 16 plus the 8
plus the 1 and you'll realize that
effectively in binary any numbers
possible because you've started with the
least possible number here and in terms
of whole numbers so it's a 0 or 1 the
next one is double so it's a 2 so
anything in between that you can get 1 2
or
you move up to the next one for you got
falling go back 1 2 5 or you can go up 1
2 sector I can go all to 7 so you can
see that through binary any numbers
possible so this number 25 displays as
bits like this number 7 is the first 3 4
2 &amp;amp; 1 and then we're gonna end the 2 and
you can see here the reason we got the
answer 1 and I've done a little truth
table in word so the and operator a and
B and the result per bit so every bit so
you can see the and as it states will
only be true if both values are 1 so
hence the name and you know both so you
can see here 1 &amp;amp; 0 are not the same 1 &amp;amp;
0 not the same 0 &amp;amp; one's not the same
the only ones that are the same as this
one and one so hence the output simply
becomes 1 there that's the only pair of
bits that match and that's the reason
that 25 and 7 become one as an answer so
that's what the end is doing it's
comparing the bits of these two
variables and then the result is the
binary of where both bits are the same
so we can change this to say 25 and 24
press f5 and you can see there these two
bits are now the same which is the 16
and the eight and then the one on the 25
is different so the answer is going to
be 24 so there's there's the and in sort
of how it works you'll see how they use
later on so that's the appened now let's
change this to or and change the output
to show that we're doing all and you can
see now or works when either one of them
are one so if we just jump back to the
word document the or so that's a one
that's on both the one so it's a longer
one all the author hence the name again
or one all the other has got a warn me
at the results are one so the only time
that it's not one is when both the zero
so it's sort of the the exact opposite
of the end where the only time and true
is run both are want the only time when
or two is run both a zero that's so and
always false so you can see there the
results there 0 0 0 1 or 0 1 1 1 it's
because he how those two work and again
just think of this as if there's a
either one of them is true then the
outputs are also true so you can see
because they've got a 1 there there and
there's one here even though the other
one 0 the ones there the outputs now 25
so the output stayed the same you can do
an XOR which is an exclusive or which
we'll take a look at this first to
explain so exclusive-or is making sure
the different so that's why I give it
the name different so they're both the
same
that means ones or zeros the results
actually going to be 0 false it's only
true when the the different values so
basically when the 0 1 or 1 and 0 so
let's run an exclusive or
and you can see now the answers one
again because the only time the
different is here they're the same
otherwise so let's just change this down
to say seven again and now you can see
the result so this one's different this
one's different this one's different
this one's different
that's the same so you got this new
number which if you count from the left
it's one which isn't on so it's 2 plus 4
which is 6 plus 8 which is 14 plus 16
which is 30 I believe can I do
calculation in my head while recording a
video yep
so the result is 30 so by all
exclusive-or in 25 and 7 you get 30
so again just just keep focusing on it's
always operating on these bits that's
all that's happening that's all that
goes on with these bitwise operators
will come again to how these are useful
sure now let's do a naught which is the
tilde also you can't do a knot on two
values especially a knot is just
inverting a value so that's just invert
25 so you're gonna invert 25 or comment
out this because we're not using B and
it's gone on there that's interesting
what did we do
okay I think this sir to string has gone
strange there look at the result so the
result is aa
I know why because this is an integer we
need to pass this to a byte
we coulda just cast this and results as
a buyer to be honest I don't have it
tonight so we're just forcing these
values to become eight bits by default
as we mentioned in one of the very early
videos when you just type a value it
defaults to a 32-bit integer so then the
result has 32 bits and when we did this
convert string which should only work on
bytes it was getting confused basically
so this that byte that it was expecting
actually received an integer and it went
all strange and partied out too far so
this should fix that issue we should be
able to see there we go so you can see
the the not or the invert there it's a 0
it's a 1 if it's a 1 it to 0 so you flip
around the bits and what that means for
a number is if we copy this into the
calculator that's a 0 0 1 so the the
knot of 25 is 230 and you'll see the
interesting thing here because we're not
in a byte were inverting effectively to
get the inverted value in a similar way
it's the maximum value of the valuable
so a byte is 255 and then it's minus the
value 25 and that gets you the inverted
so the inverted of say 1 to 2 would be 2
5 5 minus 1 to 2 so you should get 1 3 3
which looks like this so we should get 1
0 0 0 0 1 0 1 and you can see that's
what we go so
the knot is like an invert will quickly
jump onto bit my shifting which is
simple enough again and then we'll get
on to these usages so to shift bits
it simply means again if you look at the
calculator if we're to shift left and I
think there's a function in here to do
that here we go left shift you can see
the binary here so you can still see the
numbers here we shift to the left it
literally moves all these over to the
left so that one disappears that goes
these four zeroes all shift that way
this one jumps to there the zero drums
to there this your drums are there so
it's easy to see if we just put the
value one in first so you can see the
binary one and we shift it left and you
can see that's not really working as
expected the thing this calculator just
doesn't do it as I'm expecting or maybe
I'm not using the calculator right but
you chef left one and it jumps one there
just press ENTER so they keep clicking
so you can see it's time you're shifting
left it's it's moving the values to the
left you shift to the right and chaos
shift that to the right that well I'm
not sure how this calculated does this
but effectively shifting to the right
obviously shifts that to there and you
can see what it does is divide the
number by two so as you're going down 32
16 8 4 2 1 so it couldn't be any simpler
when you you bit shift left or right it
physically just moves all the bits left
or right so if you've got one one and
you shift then these are both going to
move that way and that becomes one one
and then one more like that so that's
all it's doing to the bits so let's just
see that in action anyway just to show
you so let's just change this but say
and
I just move up right to the bottom of
the program and now let's ship some
values so it shifts see let's make a new
value stop do 25 for now so you can see
the values and we're going to shift see
I'm gonna shift e by one position I'm
probably not to cast this far to
inviting them so we're shifting left and
you can also specify then that the
number of how many movements basically
how far to the left you go so we're
gonna go one at the time so then that's
gonna become let's output C and the
result is going to be yeah
so we're just gonna shift this by one to
the left now we need a new new line here
too so it's this part here so you can
see there's the number 25 we shift it to
the left once you can see that one has
moved to there the zeros moved to there
that has moved to they're the ones moved
to there so you see what's happening
so we shift it to three times we should
end up with one one zero zero one zero
zero so shifted three times you can see
were right on the edge now so what
happens when we shift out so we are now
go past this point what I believe it
happen is effectively when you bring
stuff in from the right or the left when
you bring in data in the option doesn't
exist it just brings in zeros so you can
see when we shifted this left there's
nothing here to the left so it brings in
a zero similarly when you go right it
should bring in a zero and also when
these go off the end they simply
disappear so let's just test that out
and they basically just lost their the
values just disappeared now there is a
thing I'm not sure what it's called
like the determine the name for what
it's called but effectively I believe
it's like bit rotation or overflow bit
and sometimes you can have when if this
one goes over instead of just going over
it rotates around and comes back to the
start so it's sort of like when you
shift this say to the right one and this
goes off here instead of just
disappearing instead of bringing in zero
you're constantly just rotating the bits
in sort of a circle so this one ends up
being over here and then everything
pushes down and it's like a rotating
circle I only use that when I do
hardware I don't use it when I do C
sharp I never have and to be honest I'm
not even sure what you set up for do
that it's a simple case of googling to
figure out but I've never used it I
never you know required a need for it in
c-sharp it's a lot
or on ARM processors and assembly code
that went out do that type of code
that's when you use sort of rotating
bits for some advanced math operations
but in general when you're shifting left
and right simply think of the data
that's being pulled in that doesn't
exist as a zero and the bits move across
you know left or right and that's all
there is to it you move left you
effectively multiplying the number by
two you move right you're dividing the
number by two so it's sort of a handy
way of multiplication I guess so that's
really all the rest to the bitwise
operators so you can just keep going
over this and having to play with this
or example code to get yourself familiar
with what's happening with these
statements and then we'll just now go
over a few useful uses of bitwise
operators it's hard to think of examples
of how to quick think and I can show you
a few one is to toggle a boolean which
we've done so that's where we have var D
equals true and now instead of using an
even an else statement to change that to
the opposite value you could do d2
exclusive all it with true so you can do
a knot on a bit which we've seen as we
did it up here on a bite it appears you
can't do it on a boolean I use this
exclusive or which is the opposite way
of doing it so an exclusive all means if
they're different it then becomes one if
they're the same it becomes zero so the
reason this works is if you think of D
as your true yeah exclusive all in with
true so they're both true so if they're
both true becomes false then when this
is false you know doing an exclusive or
with a false and a true now a false and
a true becomes a one so the false
becomes true so effectively you're
jumping between these two logical
possibilities because we're always
controlling B B as always one so we get
rid of these because we'd not be as
never zero we're always passing true so
you're working your flip in between then
these two values of true or false are
money 0 its 1 when it's 1 X 0 so it's a
cool little trick to basically toggle
you know with boolean between true and
false which you do a lot in code when
you want to keep track of a certain
state or a certain position of something
and Egypt like the tic-tac-toe game
going between play 1 &amp;amp; 2 so that's a way
to invert billions then your enum flags
now you don't need enemies for this but
again it's the most common usage so when
you're trying to store data and again it
usually comes into play more in embedded
electronics and hardware when you're
really limited on data and every bit is
crucial if you've got about some
software and you've only got eight
kilobytes so eight thousand bytes of
data in the whole program to do
everything you need you don't want to
waste say an integer of 32 bits to store
a true or false value or if something's
you know only got two values possibly no
two possible values zero or one you want
to use a single bit and because again
you have to work in the computers work
in 8-bit 16-bit 32-bit hence 32-bit
architecture and 64-bit in terms of
processors and things that's talking
about the number of you know bits in a
piece of information so if we work in
eight bits you can actually you can see
here on the binary you can store one two
three four five six seven eight
different possibilities of value in a
single byte which is eight bits so you
can independently store and a true or
false for a different value so say you
wanted just create an enum estimate
between core values can't think may not
talk me out let's just give it some
values and I thought oh it's just give
it some colors we won't call it colors
or just leave it to some values and this
could be I don't know a list of colors
that you like and you're not limited to
one
so you can pick any of these red is
going to be zero well I don't know
that'll be one will leave the zero is
nothing and then you could have say blue
it's two and what we're gonna do
you'll notice here now each color is
gonna be one call is gonna be this value
one the next is gonna be - the next is
gonna be four now this is going to be
eight and you'll see the reason why in a
minute so green equals four black equals
eight white equals 16 and equals 32 and
we can go to one to eight yellow equals
64 10 equals 1 to 8 1 2 eights the
maximum so you can see here we've got 1
2 3 4 5 6 7 8 possible values as an
enumerator now we want to store we're
gonna ask the user we're not going to
but you can you know ask the user what
the favorite colors after these which
colors do the alike so they might select
all they might select want they match
like to the mats like none we can store
all those choices in a single byte so
instead of having an array of do they
like pink yes or no D they're like yeah
a yes or no do you like oh and yes or no
and having 8 bytes which is then going
to take up 8 times this so you can end
up taking up 64 bits of data we're gonna
take a 1 so 2 do you know flags you can
then do create the variable sum walking
in your shoes bar some vowels equals
some values so let's choose blue now we
can output this again so that's just
output
the value down here let's get rid of
these for now
now we know there what happens here so
we're gonna output some vowels because
it's an enum we want to cast it to an
integer it well to a byte in this case
it doesn't really matter which sure we
don't go over a bite so we're just
simply going to display what what some
Val's is which is blue so it should
display two as binary which should show
a zero one so you can see what blue is
with 0 1 so we're with this now it gets
interesting when we can do bitwise
operators on enumerators so we do or
some values dart white and what this is
done it's odd the two binary values so
blue is this one white is 16 so here
so when we were old them together the
result is now this because you're
toggling the the or as you know from the
previous example just white is this blue
is this and all in the two together
becomes this because when you look at
the or so long as either one is on then
the outputs on so you effectively added
them together almost you can almost
think of this as sort of adding the
values together so blue and white now if
Y was say this but if white was three
instead of 16 then when we come to try
and reverse this value and it reacts
trapped if they've selected blue or
white you wouldn't know because if they
selected only wifed its it's got the
same bit as blue so the importance is
when you're doing flags of you early
xenon flags is that each value that you
want to keep separate has to be double
of the you know each value they've got
to be at their own bit a single bit or
even if they're not a single bit they
can't interfere so you could have blue
as being these two bits and white has
been these other two so long as the bits
never collide you can do these all
values so if we all blue and white and
let's just run that and see you can see
we've got blue there of two and white of
16 so from that value now if you receive
this value which right now is some value
so let's just cast it straight to a byte
and let's say this value was passed in
or you've loaded it from a file or you
you know you got it from somewhere this
is now just a bite so if we run this
code you can see now it's just to get
rid of the hex or decimal display it's
that it's the decimal this number 18
that's all we know about this some value
with 18 so we need to now know while
what values have this selected so in
order to react struct the enumerators
from this combined value you can check
you have to check each time so if we
want to know if they've selected blue so
we can do
if and then some value and we want to do
some value and some values dot blue and
if both of them now you can't just do in
this case as greater than zero and I'll
have to cast that to a byte because that
one's also abide billion billion what's
going on here just got to group them
maybe there we go so if we do the result
which is this combined value and blue is
greater than zero
or if you want to be more explicit in
case it might not be zero you can do is
equal to the value so if you do the keep
casting to a byte everywhere this is the
value we've been given in and we simply
do an end the value we want as equal to
the value we want then we know they've
selected the value so all we're doing
there as we're taking this value which
is 16 and two um in terms of these
positions we've got the number 18 but
we've got you know the number 16 flag on
the number two we're doing of that value
and the blue which is 2 so then we're
doing if 0 1 and then all zeros and this
number and we know from the truth table
the and will only come out 1 1 both are
1 so in this case because we've passed
in only blue and we're anding we haven't
passed in this so we're now gonna end
this value and this value and because
the only one that stays the same is this
bit this bit gets wiped out so the white
disappears so the result is gonna now be
effectively blue it's gonna be that
exact value because we're only passing
in the exact value so the only output
that could possibly happen is either
everything's off or everything inside
the blue value
he was on that the only possible results
because we've ended so there's no way to
to give outputs of like these these
digits that aren't in blue because the
and won't allow that because they have
to both be one so the result is either
going to be not blue or blue effectively
you've turned into a boolean statement a
true or false so this is how it looks
when you do it it's if the value and
what we're expecting to be blue is blue
it means that blue is contained within
this value there might be other values
and there is because we've got white but
this is how you'd then check for if it's
blue so then we could do
console.writeline
blue was included and we could also do
the same copy and paste change it to
white and if we run this we should get
blue as included while is included if I
change the text it would so you can see
there we've extracted from that piece of
information whether they've selected
blue or white we remove the white we run
only blue was included so you can see
again you can study this and look over
it and go through it multiple times but
this is effectively what you do you do
the value that you've been given you and
it with the expected value and then you
check that that result is the expected
value so these are always the same this
check and this checks always the same
you simply input the value and it and
then compare it with the value expect
and that's how you compact values into
you know a single piece of information
you keep it nice and compact it's good
for options in code as we mentioned you
might have simple yes or no type you
know on or off whether they've got a an
unlocked version or whether they've got
certain options or you know the things
where you want one to compact the
information they're not massively used
but it's it's good to know how they used
on why so that's a numerator flags
the last thing we'll go over there's
many more uses but they get complicated
and again it's something you can
research or we'll go over and the
advanced videos when we get around to
those the last thing we'll go over to
masking so a useful feature of masking
which is similar to what we've done here
in fact we've basically done mask in
here we've covered it but when you mask
a value it's when you want to extract a
certain piece of information it really
is this Union flag so if we wanted to
find say you've got a binary and there's
your 8 8 bits and now you've got say bit
3 so this bit here is the flag we're
interested and this is say the key this
is if the user has say an unlocked
version of the program and you want to
find out with the value that they they
give you so the value is going to be
this so this is the value or this is the
end pot this is the important bit that
we're after and we want to know whether
this bit is selected or not so again
similar to this here what you can do is
you can mask out and what I mean to
simply remove everything around that
value in the input so the first thing
you do is you want to remove everything
that's around it so sort of clear it off
like this so that everything else is
cleared and you're left with whatever is
just the the piece of information you're
after
so you basically wipe out regardless of
value you simply get rid of everything
except what's in the mask and then
you're left with a simple value that you
can then check like this if the value is
the value you're after so you can see
here it's already been done with an and
so to mask out the value you simply pass
in the value you expect which is blue in
this case the important bit which after
this isn't blue in this example it would
be he
for that sites we move it down to there
so if we end this value with blue so
we've added these two together the
result would be all these get wiped out
because this is always zero and this is
zero so everything here becomes
irrelevant and everything here becomes
irrelevant because this anding together
is always gonna wipe them out because
this import to the mass give you well
this is you call this the mask I guess
because you're masking out that we can
accept that value let's call this the
mask the way that a dilute gets raw
input equals a bite of some value blue
the VAR mask equals just do ours
and that's for this case let's change
this to wine for now and then this would
actually be whiter somewhere over here
so it'd get wiped out either way so your
inputs here your mask is here and you're
going to and the two together and the
result is going to be in this case it's
going to be zero because they're not
both want the input didn't target so the
result is gonna be just complete zero
and you can see that by doing import a
must-have we put a breakpoint what do
you that allow you we've run this code
you can see their input is sixteen from
white the mask is too from blue and the
result is nothing because that didn't
match so now if we change it to actually
be blue or in this case that's just
already with blue so there's more in it
to group these together
so now this input is 18 so which is this
so we've got both values the mask is
still just blue but now because we
ordered it with blue this values got a 1
here so now the result is gonna be the
one it's gonna be that exact value
effectively it's gonna be the mask it's
gonna be exactly the value of what the
mask is which you can see here too so
mask is 2 R is 2 so this is exactly this
this is the same thing and what we're
doing is the mask the thing we want to
find out whether it is or not we get
here and then we end it with the input
to clear out everything except the value
that we're looking at and then we and
effectively we and that result of just
that value and then we we know then the
outputs either going to be not the value
or the value it's gonna be the mask or
not the mask there's no other
possibility and that's how you do a
check for you know whether there's a
value inside the bits so that that's
again that really is all of us two
bitwise operators that they can be
confusing because not many programmers
use them there were a lot more used like
I say an embedded electronics are in
heavy mathematics or in graphic
calculations not usually run-of-the-mill
programming not usually just day-to-day
things the only thing is I use day to
day really is this Dogface boolean which
just inverts the boolean between true
and false and sometimes use these in
things like again in ohms the most
common so that's what they are you could
you can read up more and find out when
they used but it's certainly good
knowledge to have they come in handy
when you're doing certain things like it
again if you go back to the tic-tac-toe
video you'll see now where I used the
the or I believe they used when I was
checking some value for whether awesome
and and I was checking of the values
with the same so comparing two values
that should now make sense
and again you can play back with a
calculator toggling bits on and off and
seeing what the values are and you can
also take a screenshot of this and you
can see a UB values and your expected
results per bit and hopefully that will
be enough to get you the knowledge you
need to understand bitwise operators</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>