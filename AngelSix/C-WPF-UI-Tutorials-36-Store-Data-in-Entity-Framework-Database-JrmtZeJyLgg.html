<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>C# WPF UI Tutorials: 36 - Store Data in Entity Framework Database | Coder Coacher - Coaching Coders</title><meta content="C# WPF UI Tutorials: 36 - Store Data in Entity Framework Database - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/AngelSix/">AngelSix</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>C# WPF UI Tutorials: 36 - Store Data in Entity Framework Database</b></h2><h5 class="post__date">2018-03-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/JrmtZeJyLgg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so in this video we're gonna carry on
and store the login token and details
once we've logged into the facetted
server so the last video we logged in
using this login web call here and then
once we've got the data here this is
kind of this huge data is what we need
to store so right now we simply just set
up some few model information and don't
do anything with the token so we're at
the point now where we need to store
information so by default in you know a
Windows application like this we've got
multiple ways we can store data we could
write a text file we could write a a
binary file to do Jason XML database we
can do many many different ways what I'm
going to do is make a database use an
entity framework so that we can write
basic Poco class teachers plain old
class objects normal c-sharp classes to
store the information and and use a nice
little interface and service between
that so we can simply you know say even
pull details without worrying about the
wheel of the database back-end so
running on the database in the Fassett o
wood server and for that we used SQL
Server now the issue with doing that on
a you know a desktop computer say this
goes to your machine or your friends
machines or the general public people
running Windows 10 won't have SQL Server
installed so that's not really an option
for SQL Server the beauty of entity
framework is you don't need any specific
database with one line of code we can
change what database back-end we use it
so now I'm going to pick SQLite or
SQLite I believe it's called and that's
a file in what they'll basically create
a file in this folder
so once we've built and run this
application and you get the end of this
output and this is what you install
we'll literally just end up having a a
database file here word peseta word DB
so that's what we're going to end up
with when we we bill
an SQLite database so we're gonna get to
it
the first thing is we want to this for
Seto would chorus you know all the
chatter word projects so in here the
first thing we really want is a an
interface divining you know basically a
service so we're gonna go and make a
think you could go in I OC interfaces
and we'll add a class well that's going
to be an interface bottle color click
interface then we'll get an interface
will do I client data store um do any
other word really and we get rid of the
namespace stores and retrieves
information about the client application
such as the login credentials messages
settings and so on and in this interface
we will need some properties I don't do
public in that interface we need one
which will be if we have credentials and
the reason for that it will use that too
if I'll that would be a getter only
determines if the current user has
logged in credentials so we'll use that
on application startup to define whether
we should go to the login page runner if
they've got credentials we go to the the
main page you at right now such a page
then we'll have a task just so that
because this is an interface anyone can
implement we should really try and make
everything asynchronous as much as
possible Rob and Shaw datastore async
which is for ensuring the database
exists this is kind of the setup
so again namings we can we can change
the name as and when you know for now I
think that's an okay name make sure the
client datastore is correctly set up
right now setups better that way I need
to keep trying remember to use these
return
turns a task lat well an h1 setup is
complete one more will have at us again
and for now we didn't need these login
credentials so we'll need login
credentials got API model which is for
the web calls we also now need a data
model which is for the back-end store so
we have a folder for data models already
which is kind of not really used
correctly but opted in there for now
we'll clean that up after so I'll call
this login credentials data model and
we'll fill this in with you know what we
need for the model which is basically
the same as the login model so I'll have
a public string and because it's a
database model we'll always have an ID
the unique ID for this data model and
this is the part the unique ID this is
for anything where the data model will
always have an ID so that every item in
the database every row in the database
tables as trackable and manageable is
just something you need for a database
object then we'll have all the same info
as the API model really so we'll have
the first name last name username email
will also have the token as well slip
these in and comment them users username
users first name last name in the email
and they use this a lot it's open as I
have no data model ready for use we go
to model for the login credentials of a
client and we'll take that and it's part
of the interface you want to return that
and we'll call it yet
get login credentials oh it's got some
new intelligence that suggests a name
that's cool that's a new feature in
Visual Studio 15.3 maybe I haven't seen
that ago as that will simply get any
potentials get the stored login
credentials for this client and then
we'll need the reverse if again the
returns returns the login credentials
they exist or not non exist then a lot
of tasks again and we'll have save login
credentials and that will need login
credentials passing in stores the go and
login credentials to the bucking data
store and then that will be returns a
task that we'll finish once save as
complete yeah I think that's it so
there's our interface we now want to
implement this then what we can do is
inject this into our DNA framework
service provider which is our IOC which
right now we've got like here partly an
inject and partly a the new DNA
framework dependency injection so we're
just mixing them together for now and
then we'll clean up afterwards
but basically we'll inject a new service
on startup that will implement this
interface and then we can make use of
that too once we've logged it and call
you know save login credentials and once
we open the app call get fucking
credentials to see if we have them or
not it's that's what we're gonna do with
that so what we want to do here now is
make a new project class lab that
standard is fine for cert Oakwood
relational a relational database and
that should add project I think that's
all we need from now this will need a
dependency for the core because it's
gonna reference core and in here we'll
call this we need to implement that
interface so we'll have a client data
store and we name the class that's
correct
so this class will be responsible for
let's just get the interface here and
pretty much can copy the interface
comment that's fine
so it's longer here and so on in and
this one will use an SQLite database so
this will wanted to implement that on a
client's datastore and so we have
probably properties and interface
implementation and I like to just copy
the interface comments you don't
technically have to do when you export
the comments because they'll get pulled
in from the interface and I know this is
a bit of duplication of comments but I
can't stand seeing you know methods
without any comments on so even though
the tenant could pull through I like to
copy them I know it's a bit of a pain
like I say because then if you edit one
you've got two to edit books just my
preference I like to do that plus then
have the specific implementation decides
to do something slightly different or
you want to add some more specific
information like we did here then you've
got that option so that's that's kind of
how I look at that and the point of all
these comments is obviously for one a
Hugh act report this to inuvik platted
you'll have comments when you type in
any of these codes to it's really good
practice and three it's again your own
well even for reasons threes your own
use
you can read something and forwards if
you ever want to export an API
documentation that somebody can you know
if they're gonna extend on this or say
you make it an API people can read an
API documentation you can generate all
this automatically in a nice MSDN style
documentation so that's that anyway so
the has credentials will simply call get
could ah there's a slight problem we've
got get login credentials as a task so
this cannot be this cannot do that
because we need to await that so I will
make in fact that's also wrong any way
of nailing wrong let me just quickly
check that this is get login credentials
async and this is saved credential
lasing is it's asynchronous what we will
do here is we'll make a new one specific
des method called get login credentials
this will be protecting methods so this
isn't part of the interface where all
this is gonna be a non asynchronous
function so that we can call it from our
property it's not exactly the same thing
you just won't return a task because we
won't need to do a task anyway so we'll
come to that in a second then well in
fact before we can implement this
interface in any way we need to actually
make their entity frameworks let's just
jump onto that for now so we have the
relational I click there
actually what I wanted to do go to there
so in here we need to have the Microsoft
entity framework call the SQLite and you
want to install this package here
install that ok except and there is I
believe there's a bug in this I tried
this earlier even though we have a
package here you know it a c-sharp
dotnet standard library if we were to
reference this which we will
for such a word application now we'll
add a reference to this project because
this is what we're going to make use of
if we were to run this which we'll do
first so you can see the issue it's
going to complain when we finally get up
and running that it can't find it SQL
lights DRL in this application even
though it's referencing this so I'm
pretty sure that's a bug which I'll show
you how to fix after and then we should
really report it to the github repo but
anyway we'll come back to that so in the
relational project will make another
class and this now needs to be the
actual entity framework database of your
the DB context or pull this the client
datastore dbcontext
and then in this wants to implement its
own give you context and this will be
the gateway context for the client
datastore using Instagram work and
SQLite about that's a bit of pointless
piece of information there we've got the
constructor that's fine then obviously
in same as the website project this is
this is effectively you can think of it
as your database you know I know it's
the the poker representation of a
database but that's that's what you can
look at it as so this is a region for DP
sets DP set you can think of as tables
so if we do a public DB set and we now
pass in the login credentials data model
because that's what we want to store and
we'll call this client credentials this
is now a this will be a table then
called login credentials in the database
and this love as many rows as we want to
add of this item will only ever be one
right now but you know that's fine so
the client login credentials then the
constructor for the
complex needs to be different so you
need to pass in DB context options of
the type of this client datastore DB
options so they can be configured and
just cut that down into the base we
don't know anything specific whether we
just need to set up the constructor
correctly and then we'll have a region
for model creating or just override the
model creating configures the database
structure plants belted a structure and
relationships so we can do inside
classes like this that we then make a DB
set we can add specific properties like
say the key here and have you controlled
r2 well in fact you can't hide it there
it's not referenced this doesn't have a
reference to the entity framework stuff
in fact do you think you should stop it
there but anyway the point is you can
add specific ones into here relate into
your entity framework things like I
think is really when they have taught me
that to be honest but I think it's like
it's required or just required and then
max length and things like that and you
can tag your table these are table
columns basically they'll get created
you can tag these were set types of the
unique IDs in the database if they've
got a max length if you want a specific
name things like that you can also do to
this on model creating and then we do
them here X called fluent API and you
can configure it this way if you do it
in the model there don't know what the
names call to put base for this you'll
be tagging it with attributes I don't
like to mix the two so I don't like to
say put a unique key on here but and say
a max length of a username for 30
characters but then inside here start
configuring the the email it has to be a
certain length or certain size I either
like to do it all in here or all in here
and there's reasons I do it in fluent
API one is because
the attributes that you can tag on these
you can't do everything with the
attributes there's limits to what you
can do you can't fully configure a
database table purely from that the
attribute tags are straight away you
can't do everything we need so we'd have
to end up having a split partial
configuration here part of aggression
here which straight away I don't like
what is another reason another reason I
guess is like saying this is in call
this isn't completely unaware of what
your data structure is your relational
data structure it's not even aware
whether it's entity framework it doesn't
really care so you can't go presuming
and tagging this class that's in the
core that's got nothing to do with the
database with database specific tags
because then it's making the separation
the clean separation so with those two
points alone you don't want to configure
the database tables if you all these
data models in the class itself even
though to be more obvious when you were
reading the class because they're men
you know the thing I've just mentioned
so instead you do it here and to do it
you just simply type model builder dot
entity and then you pass in the type of
the DB set so in this case to be this
and you do the entity a now you can
configure weeks like has has key it's
like setting up a unique key primary key
so for that you'd say house key and then
you just have an entry and you'd pass in
ID column so this is now an instance of
the login credentials data model and
you're telling it which property is
there has got the key so they go you
configure set primary key on login
credentials or rather configure login
credentials and then that I'd be like a
little header because you do multiple
things to configure it and then you
would have set ID a primary key and then
you could do dot and then do some more
it has name house annotation things like
that so you can configure a bunch of
stuff if you want it to you can see
you've got you know way more options has
many has one owns property so you can
get a specific property say like
name and then you can do and now you can
say set the column name set the if it's
got a default value the field the length
so things like that has max length so
now we'd say 1 the first name to have a
max length of say 50 and these are
things that I say are important to never
really leave just say these fields has
been n VAR max in like an SQL database
of UL because that means somebody could
make a username that's 2 gigabytes long
ago something stupid like that so we
should get around to setting these limit
top for now though I'm just gonna leave
it out because it's again it's more time
and not the point of this initial
subject so I looked for a to do for set
of limits also you don't technically
this has key because by default entity
framework will look for any property on
a model that's a DB set and if it's
really called ID it presumes that's an
ID column so it actually makes that
automatic way but I like to do it so
it's explicitly to like to see that it's
definitely done I don't like to leave it
to default behavior well so this DB set
now will create if we make use of this
TV set it will create the database for
us it will create it where we want and
how we want and then we can access login
credentials we can add properties to it
and and save to the database and we can
retrieve from it so that's all that's
really needed to you know get the whole
database working so we now drop back to
our datastore which is kind that this is
the helper interface that our
application will be aware of and make
yourself to do what it needs to do we
can now make use of that database
context so we're going to make use of
that context by the dependency injection
of the context so this is going to be
created by our DNA framework service
provider which is just underlined it's
just the built-in net called dependency
service provider and we can then just
say framework services GATT and and get
the service that's got this there's just
normal dependency injection stuff that
we've done
already so what we'll inject this into
the dependency service and then when the
application wants to get hold of this
data store it will be created scoped
because on the line it's gonna be using
a database and just like the website you
want it to be scoped you want to simply
create the database contacts do what you
need and close out as soon as possible
think of it like opening a database
connection you know you want to connect
the database query it for some users say
and then close you don't want to leave
that connection to your database
permanently open because I when you get
say a million users on your website I'm
a million open connections on your
database sort of thing so it's not a
plain and simple but the point is you
want this to be scoped so it will get
created used and disposed rapidly and
the way that dependency injection works
then is you'd inject this when you
create it you you request for it so now
in a constructor we can use constructor
injection and ask for a DB context so
when this class gets created by the
dependency service it's gonna need to be
given a database context which will also
be in the service provider so well I'll
show you all that all mingles together
in a minute and this will be default
constructor the database to use and then
we will have we need protected members
and we'll have protected client date or
DB context and DB context the database
context a client store so that's what we
want so the DB context now set local
Member MDB context equals dbcontext so
when it's created moving out hold of
this database context and now we're good
to go to start using that database
context we have now ensure just like we
get with again the asp.net website to
ensure the database
just took an async there we want to
await the MDB contact dot ensure side of
database start ensure created async and
that will simply make sure that HBase
exists and that's all we need to do so
that's the same thing within the asp.net
core website we're making sure the
database exists first next we have get
login credentials so it's just as easy
for one we've just got get login
credentials here and that's we're not
using async because we want to make use
of the public property which I could
change to a method to be honest so in
fact let's do that let's just make this
a method search cleaner and then we
don't need the double stuff so that
should just be returned and this would
be a Singh
in fact you'll just be a task of billion
pass potentials and it returned that
isn't equal to know about that wouldn't
need to await that now and that would be
a sync delete the duplicate method
whoops and compressed f5 to build so we
have now we don't want to run we have a
new way of doing this which is a task
house credentials so we just go into the
interface and updated the same so
instead of it being a the property it's
now at us the same without complaining
about expected that so has credentials
is now a method will move that into the
methods and there we go so now we just
it's now our method so we can use a task
and we can await it because you can't
wait things in a property it's that all
simply say do we have any longer
financials
if we have we logged in so the the now
get login credentials call will be as
simple as again MDB context dark login
credentials
. first or default and all that's doing
is just like you do on a list this is
getting whether we have you know an item
in here basically the first time in the
database table login credentials you can
see this is get a complain because this
is an asynchronous task just in case we
need to be asynchronous as i mentioned
you want to keep it a synchronous so if
it's not a task have you nothing to
await then you can just do tasks top
from result and return the actual the
value and it will create a task that
simply returns instantly so there's you
know how will we turn that so yeah the
first column in the login credentials
table or know if non exist
that's what the first or default does so
first if we did just first they said
then crash and throw an exception if
there was nothing first or default or
simply return null if there's nothing
and that's what we expect to do here and
that's all there is to getting the
information from the database and it'll
even effectively convert itself to the
login credentials data model cuz that's
how that's what entity firmaments do
employers doing all that magic for you
so it couldn't be any easier it looks
super super simple so then the last
stage is to save the login credentials
so just the same then there's will do a
tiny bit more work here so one thing
you've got a bear in mind is if we're
saving the credentials just to be safe
right now there's only one credential we
could just simply say get the first
credential update it and then save or we
could just remove the first credential
add the new one back and save but just
in case anything goes wrong with the
database or it's manually edited or for
whatever reason I want to clear all
entries in the database table so there's
no locking credentials when we're saving
we delete the first one out the new one
and we can do that there's multiple ways
what you've got a bear in mind is this
it be technically a slower way so also
going to do a say for the login
credentials remove the range and
literally remove the login credentials
so we're telling the login credentials
to remove a range of credentials and
we're gonna pass in whatever range we
have so we're just going to remove all
the entries now this will probably
compute and compile down to an SQL
statement that would execute save that
you know a lot much larger statement we
could go dbcontext our database start
execute what's it called there's
something in here for Pyro's it owner -
helper I think isn't it in an extension
method somewhere you can you can run SQL
directly I don't want the name as it's
an extension method somewhere but it's
an easy group but we could instead
execute directly on the database a
truncate table and then like you name of
login credentials and on top truncate
the table that would be the most
efficient way to clear all entries but
because as I mentioned this should only
ever have one and this is only in a rare
case that something's gone strangely
wrong I don't really care this is
slightly inefficient and say there was
five entries it's gonna run five
statements awesome they don't really
care because he should never happen so
I'm picking the option that's cleaner
code for now that's nice and simple
because this shouldn't actually epital
eat more than one that's that's why I'm
picking an apple yes there is more
efficient ways to drop a whole table of
you know whole row of table so that's
cleaving off any previous credentials
they want to add the new one so that
would be context and you can almost
think of this like just accessing a list
you hardly realize you're accessing and
talk into a database because you're
basically working with a DB set which
acts almost just like a list so you can
just do login credentials stop add is if
we're adding this new login credentials
acting to the list of items and now Save
Changes is what actually commits it to
the database so this is what they're
ultimately commits the you know all your
work to the database from runs the SQL
so we'll await it and we'll have a sink
there and that will save credentials to
the database so that is now again fully
done so the the whole database side is
done next step is we want to add this
relational data as a service to our
Fassett a word application so we'd want
to do that inside app dot zamel dot CS
and then he is the DNA framework we're
using and do we not have a spell checker
file on this shirt let's add one odd
spell checker DNA save so here we don't
omit want this way of injecting your
services of what to use so here we want
to say use client datastore and that's
it that's all we want to be able to well
rather we should have to do and want to
have to do so to do that as we've done
with again the asp.net core website if
you're following that series of videos
we want to make an extension method on
here so we can make this an extension
method and for that we'll call its frame
work construction extension methods nice
line name or in fact we could call
extensions bits more and yet rename the
class so sloops extension methods for
the framework construction and then
we'll see that in a minute I'll come
back to that construction are they using
DNA so extension methods for the
framework construction all extension
methods go in a static class this is
static constructor we don't have and we
will
call this one public static framework
constructions what we want to return so
we can chain them that's how they all
work and we'll call it yuge client
datastore the this turns it into the
extension method so framework
construction is what we want pass them
and that is now an extension method
that's awfully turn framework or
chaining and let's should stop
complaining now so there we go that's
that's a boilerplate extension method
use client data store so we go back to
here control Dottie should find it use
relational so now as part of our setup
when the application starts it or then
call use client data store which will
come into here and now we can inject our
SQLite PF data store and to do that we
use again this is all standard for
injecting a service into our application
so construction dot services and we can
add you know I directly either so every
spot for DB contacts and for them to be
scoped and things there's the helper
method which you've seen again in the
web project ad dbcontext control dot and
then there we are using dependency
injection so we can add a DB context of
client data storage we context and the
reason for that extension method helper
is for one it adds the database context
as a service so it can be found but it
also then expects us to pass in here an
option to configure the database so we
can configure the database at this level
so we build options and now we can
configure and this is where we'll set up
the connection string and then that's
also adds it so it can be scoped so it
gets created so this is just like adding
a service but specific for DB contacts
so they're added nicely so we're gonna
do first we need to tell it what
database to use so we're going to use
the sq
SQLite and that's it control dot and
there we go
so that's why because we added that new
bit package for Microsoft entity
framework order SQLite at the start
that's why we've done that you can add a
package to SQL Server instead and use
SQL Server if you wanted in the only
thing you'd have to change in your whole
application is there's one line and then
everything it's still work but then it
gets stored in an SQL database so that's
the power of entity framework with one
line here you can change you from using
SQL lie to MySQL SQL Server there's a
whole bunch of different database you
can use but your code your underlying
database context all of your calls that
actually do the work like here all this
doesn't change at all not one line of
code changes and to change the whole
package database for the application as
one line here so that's the beauty of
entity framework so for this as I
mention we're gonna use SQLite and the
reason for that is this is a Windows
desktop application so it's gonna run on
client machines normal Windows machines
and we don't want them to have to
install a database server we want it to
be a file based database and that's what
SQLite is so to use SQLite it's asking
for a connection string so let's just
use the configuration option that we
already up set up in our dependency
injection that we already make yourself
and we'll also make use of the helper
method to get connection string which is
specific for databases and this is then
gonna be client data store connection
say and all that's gonna do there we go
there's a look in the configuration
which we set up in the DNA framework
which it will look specifically for a
file called app settings Jason and then
the get connection string as part of the
configuration helper method simply loops
in here for a specific heading called
connection strings souls is doing this
the helper methodists is looking for
that
that's right in a minute oh yeah and
then in here now it's gonna look for
this name that we passed in so that's
all it's doing unless this file here is
the one that's super secret that never
gets shared when you publish your
website this is where all your secret
information isn't it's it's protected
and guarded of you well so you never see
this file so in here now is file in the
database connection string so for an
SQLite database it's data space store
equals and then simply the file name so
this is where we'll do a set own word
OOP DB not only the database that will
get created that name it's that'll be
found by a configuration it will then
tell it to use SQLite and it will use
that file name and this is a relative
path because we haven't provided a you
know you can provide a specific thing
like D forward slash for such a word so
it's an absolute path if you believe it
relative it'll be the same location as
the executable itself
which is where I'm gonna store it for
now Budds we can move that but for now
I'll leave it there
so that's injected that's now available
and we can make use of that in our
application for such a word but we don't
want our for set a word application to
to really be accessing the DB context
and then doing the calls that's why we
made this helper class here the client
data store so that the you know your
word application doesn't have to be
worried about doing database specific
stuff so this is kind of the bridge
between them this I client data store
and that's the reason we did it so we
need the or any part of our application
to also be able to access this interface
this I client data store so to do that
we'll inject add client datastore for
easy access use of the backing data
store make a scope so we can inject the
scoped it'd be context as suppose I
mentioned this is a scope thing that
gets created and deleted as soon as
possible so we're gonna add our
interface in the same fashion so every
time we request it we got a new one of
it's in a you know a set
scope so same as always just use an ad
but this time we'll use ad scope and you
could pass in the object directly but
the thing is we have an interface that
it's a type of but the implementation is
a specific class so we need to pass in
the type to the generic helper they're
saying it's this tab that we want to add
but the implementation will need to
provide that back but we need to provide
a visit scoped so we'll have provider
and this is expected now to return a new
client datastore and this is where our
constructor needs the DB context as you
mentioned and because we're scoped to
get access to the provider of that scope
which is the dependency injection part
so it's you know it's this it's this
construction that services the service
provider overview well so now you can
just do provide it up get service and
just get the client datastore DB context
so effectively you use the the scoped
provider to get the scoped database
context and pass it in to our client
datastore so that's just injecting our
client datastore so when we now try and
access it it will be found and created
in this line what run an effect would
create our client datastore and in
itself also inject in the constructor
the database context after which is
available and get service because we
added it up here so that's kind of this
is all dependency injection stuff the
more we do it the more you'll you know
be familiar with it and ok with it if
you will so that's that so I think we're
finally ready to actually make use of
this
so in here it will now call client
datastore and then we need to actually
ensure the database so we'll set up the
framework this is also the old-school
one that we're leaving in for now so in
theory I think what we should do is
allow this to get created and all
finished down here so that's kind of
your setup done and then here I would
ensure the client data
and that's where now we could do a wait
and we need to get so one thing you
could do is do framework which is the
DNA thing up here you know where's
framework the framework dot provider
gets serviced and I think I added a
helper to DNA framework I'm you see we
need to update the nuga package yeah
three updates let me just update all of
these so I added a helper thing so in
the get series you don't have to do get
service and then pass in a type that's
also update these of need updating yep
date and finally I don't think we have
any new good packages in this one so
that's all up to date right that's good
so we can do framework dot services I'll
tell you add to helper here service so
you don't even need to go framework
provided get service and then do type
off and then rather that's already a
type I client in fact another thing you
still need to do type up you want to do
that they need a new type of and then I
client data store and they'd have to
cast it to an eye client data store so
originally don't had to have done that
to to get what you needed instead of
having to do all that I added this
little helper function service which is
simply like dependency injection IOC get
service and so I just got rid of the get
to keep it short as well so consumed
with legal framework service and then
pass in my client data store and that
will get the client data store
implementation it would spin up this so
we'd hit this so we could actually do
that or go into the constructor here and
see that being spun off
when we hit this so let's start with
that which I think this should now build
and run at least and you can see it so
are coming together so if we can put a
breakpoint there so we hit here and I
just put a breakpoint in here so you can
see that's running so we get to that
line we step over we get into here we
add the database context with the SQL
light we add their scoped service here
and we return we then get to this data
store so which we're now gonna do
framework get service you can see this
hits now the scoped creation of the
datastore which then in turn hits this
scoped creation of the SQL Server
because it's this line now being run and
then once we get that we go into the
constructor of the database contact so
that that's been spun up now as we
expected and then once we've spun off we
then get into the constructor and then
we'll bubble back and we now have an
instance of that class so now we're
ready to use it and this is where we can
now access the login credentials and do
what we like with it so we have this way
of now accessing the client data store
so to make it even easier than doing
framework service we will cut that out a
second and we'll go to the IOC static
class so again we're just going to keep
the name simple and just like we don't
here with all these helpers to IOC get
until we followed replace IOC with our
you know specific one we'll just mingle
them together for now so this wants to
get a client data store and it will be
quiet data store and that'll just be
framework dot service and shortcut to
access the I client data store service
now we can do is feed client data store
so in our code it's nice and simple
anywhere at all and I'm a whole
application now we can do that and we
can do to get login credentials and we
could await that and do what we want
with it so we've now got a clean way to
access the data store and as men
we need to ensure the data store so this
is where we want to do I of CDOT client
data store ensure data store async and
we need to await that so in here
application setup isn't a task right now
so we'll change it to one async task and
rename it to async and now we can await
their that will call the database
creation and then we just have to Bob
will back up to here and we need this
did now be asynchronous so there's a
nice trick in c-sharp 7.2 I believe it
is that we can now do an asynchronous
override even though the original method
isn't asynchronous and all this does is
then wraps this up in a task for us so
it still returns but this is off the
thread of this override return so stuff
you basically don't really need to know
about just truck an async in here so we
can now do a weight here and it you know
that's all you really need to know so we
have and I will do a video on the facing
stuff by the way so I know you don't
know it yet you will want to know it but
in terms of for this video you don't
need to be bothered about that all SAP
it's that yeah that setup part there so
now we await this then it starts then we
set the window this hits here we know
that works now and now we finally caught
ensure datastore so if we were to hit
the insure
done now close that that's working close
that go to ensure datastore here so now
we run the application and open the
folder I just missed it you can see in
the bin folder debug which is the one
we're running debug there's no facetted
word DB file soon as we run the central
created this is where actually we will
probably hit the issue I'm talking about
where it doesn't find there you go
so the type initializer for SQL
connection through an exception the
inner one is DLL not for
with a load SQL light I'm presuming this
is a book I'm a little much research I'm
like okay it's trying to find the SQLite
dll's so if I go to here you can flick
through when you've got Microsoft
updated or SQLite and you've got them
here and we have in total 65 items in
this folder if we go to the relational
bin-debug nothing really different so
that it appears to me let's say I'm done
much research that we have everything we
need in here we've got the SQLite dll's
but it's complaining so in this project
upset a word and this is something you
shouldn't have to do by the way is now
we're gonna have to add a reference to
the SQLite package even though this
application isn't directly making you
sahabat the referenced one here is so
this is not something we should have to
do in my eyes met Bob I know we
shouldn't so if we install this into the
top-level project from out being aware
that there should not have to be done we
should hopefully remove that in the
future if we run it now for one will
just reach a let's folder see many new
items appear so we kind of know it was
physically added so now there's no no
additional physical content there but
now when we ensure creative works and we
now get a database file so this is now
an SQLite database file but that step
there I don't think is needed so what
I've got a feeling is that part of this
package in here helps resolve this
location locating of dll's and and by
adding that it's needed so I'll report
this after the video was a potential
book to the github repo for this and
we'll see if it gets resolved in a bit
doors I'll update you in the future but
for now that's the workaround for that
that I just don't feel is needed so now
we have a database it's simple as that
we've run the application when it starts
up we ensure the database exists and now
we have a database so now let's get to
the point of actually making use of that
and deciding whether we're logged in on
our
so the
app startup here we can remove that
breakpoint on the app start off we go to
a page well basically the reason we go
to a page is because we go here to the
main window and the main window is bound
to the application view model and the
application view model by default right
now is login so that's why we're going
this probably chains out to chat say and
run their the application we'd go to the
chat page so that's kind of the reason
it's working right now we simply set a
page by default and that's where we end
up so if it all went wrong and for some
reason something failed I think we
should still go to a login page but for
now let me just change it to the chat so
you can see actually changing so what we
want to do here is decide set up the
application view model based on if we
are logged in so all we'll do here is do
I have see the application which is the
shortcut to the application view model
and user hubber go to page and this is
now simply expecting a page so we'll
then do IRC client data store doc has
credentials and is that an asynchronous
which is also named wrong a sync client
data store has potentials async this
will also it's async luckily so we can
await that await us potentials if it
does then we'll go to chat otherwise
we'll go to login if we're not logged in
that will probably just want to be
wrapped because it's complaining I
believe because it's not wrapped because
they await well for one it's the async
isn't it now is it fine with doing that
yeah so here now we simply do go to page
and depending on if we're logged in or
not we decide which page to go through
so go to page have credentials charts
otherwise go to login basically so sir
you know you can see the logic so say if
we are logged in on the backs we've done
this back to front oh no we haven't done
about
de chat page otherwise go to login page
and you can see by default the
application view model is set to chat
so this logic should say House
credentials will hit off our datastore
for has credentials which will hit or
power basically gets login credentials
so we should end up on the login page
here so it starts up enters the database
it's quite happy
we've asked if it's got credentials this
goes okay do we have login credentials
return the first or the default it will
then return that it's not and so we
should have didn't really show as much
they're doing that book we should have
now in here current page should be login
and we can't do that because it's inside
the dependency injection so we're on
using these gone to login page so we now
have the presumption that this works
we'll know as soon as we login and then
save the data and get the data out but
you can you can abstract this and play
with it to prove that but that should
work so now we've got the details we
want to save them in this this part here
so this row and I want to commit them to
the actual database so we have the data
get the users data store this in the
client data store so this now will say
we've logged in successfully IOC dot
pland data store got saved login
credentials make a new credentials model
and then here simply passing the user
data email a first name is user data dot
first name last name and you get the
point
literally who's passing all the data and
then user name I'm finally the important
piece that token that we want to make
use of passing the token so that should
now there are wait ducks it's an
asynchronous task I should save the data
and commit it to the physical database
we could pull it back out here to see we
won't leave this piece of code in
we just do this to show you so far
get login details equals I actually got
buy-in top get login credentials and
that needs to be awaited it's a task so
if we run this now and we login
successfully I've got the server running
in the background so I'll just run up
the facade Oh word server you can see as
well this login that's fine you get to
the home page this database is 12
kilobytes exactly which is the table
structure I believe now if we go to here
and we log in so angel 6 class would I
should successfully hit there we've got
the data got the token so we'll run this
save logon credentials this will go to
here it will remove any which there
aren't any it should add them to login
credentials so now we have a local list
of 1 and then we saved to the database
so at that point now that lines run our
database should have changed size which
it hasn't oh maybe we just doesn't run
off through the threads Victor to kick
in or maybe this database isn't going to
change size that easy maybe there's a
small size not sure but I'm pretty sure
the data is in there now so we're gonna
try to pull it back out of the database
you can see we have the data coming back
out so if we now will also have to
update this I think that's actually fine
what run that now and we're in so if we
were to restart the app now this time
this check here has potential return
true and we should end up at the chat
page this time when we starting because
it's saved in the database and there we
go so we're now in the database and I'm
sure you can well we can't get a SQLite
database reader to read this file if you
want to see the info in there but I can
guarantee that data is you know in that
database because we're pulling it out of
it so now we've got the data in there
the issue we'll have is now we've
started off and it opens go to settings
and this is the dummy data that we added
this is the
the fake data well which we should also
remove where do we have that so we don't
get confused that we think it's in some
way real settings view model constructor
rotate remove this so what we need to do
is here in the settings view model
itself we want to really load the
information so it all depends on if we
want to you know load it when we we
start off or whether we let someone else
load the data for us so I'm just going
to make a command and call it global
command loads the settings data from the
client data store in here this probably
load command new relay and it'll be load
and then we just make that function now
log out clear data of our public void
load loads the that's the settings view
model properties based on the login or
based on the data in the client data
store so now if we want to load to set
that up properly in here we can just do
our stored credentials and you can see
our master set of view from anywhere on
the whole application you just do i OC
bank data store and access the data
store
so we'll get login credential async this
will be another as a point we have relay
commands that aren't asynchronous that's
something I haven't really thought much
about actually something we probably
should I think about not that it matters
too much because we'll just we're not
doing anything with it there what you
need to do tasks are run for now we
wanted I'm running a task to do the work
that's okay for the minute because we
need the asynchronous to
you know wait for that and so we will
get these stored credentials and that
will pull in any credentials then we got
less real sex
the option to deleted that thing you
know the original with all the info in
in fact if I caught what I've done I've
done too much work script I've just put
it back in
lalla equals name original text equals
in fact I may just copy and paste from I
haven't paid any mind so this will be
from b2i stored credentials question
mark in case we don't have any so I'll
be a novel and first name and then space
and get rid of that closed down that
will be stored credentials question mark
last name so we set up the first name
and last name there we have name
username also we really have to do here
was to edit this a little bit with the
original up here or whatever it was
did you haven't gone is it not getting
lost here now it's this but we want to
do isn't it this kind of set up here so
we can copy that and you would go
somewhere done the first one there copy
that out cut that remove that there so
this is where we now do store
credentials don't use names email so
there we go that's the setup for loading
the data so we load it in there now and
now in the load here
we just want and then delete this part
we don't need that yet so just recheck
and then we go to page but right before
that now we've logged in and now there
is
some new data we want to load the
setting so now we'll do is e dot
settings that load which will then
simply go in and pull from the database
the safe credentials and set them up so
this time if we run we aren't we already
logged in so it's simply oh there's a
point is while we're already logged in
so this runs if we log in and we set up
the settings page so right now we still
have none because we're already logged
in this settings not load happens once
we log in so load new settings so we
also need to do this load on the app
startup so we can load everything there
and then ensure the client database and
load the new settings so at least it
loads the initial settings and that's
before we then you know setup the page
so now we get in we load the settings we
have a complaint now second operation
started on this context for the previous
completed so we if we not thread saved
to the database requests no we haven't
well because it's a task and yeah so
we're gonna have to thread safe the
database call its interests now we've
got to login credentials loading
actually where they coming from
so house credentials returned that await
the client store has credentials what
Alice has run that because we've awaited
that one to finish so it's not that one
it loaded they're not even sure where
the second ones coming from to be honest
and if we got back to a call stack
second operation starts in this context
oh no hmm hmm
let me just get a play for accessing the
dbcontext is there the breakpoint when
it's created run there so I'll have to
run that again and let's see I'm not
quite sure where the second ones coming
in yet you got one
and you're created so we've hit this
twice oh I should have watched the
breakpoint on whites hit twice so
context awaited so first one is being
called from the task run in the settings
view model to load so we really want
this to be asynchronous correctly so my
little thing that we should be okay with
an invalid statement what we should do
instead is change this to a task and a
weight of all tasks and we await there
and this is load async and we will then
in the method here we lake command as a
load async and its expecting an action
so we'll have an asynchronous one for
now and that will run the task for us so
what this means is when we if we ever
use load from the UI and we click the
button or did some action then this load
would happen asynchronously
that solves this initial problem the
other underlying problem that we'll sort
in the next video I guess is this we
also need to make sure that all these
calls are thread safe to the DV context
that we don't have the exact same call
or the query if you will running at the
same time on the same object so we'll
lock all this off and make sure that
these whole all these calls are using
the async await err which I believe we
already have if not I'll make it I think
avoiding the DNA framework
yeah the async/await so we'll lock this
whole database context off with the
async/await
but for now that should solve this
problem immediately in this you know
specific bit of code it's not going
indefinitely for the load yes we know
because now it needs to load
asynchronously and then these two
weights that load all right try again
still complaining same again here wait a
single load async async' load async that
wasn't right as I wait low dating all
right so now we should open it's logged
in it's loaded the properties that's
that's worked if we were to then delete
the database
so goodbye database start back up it
should create another database so we're
gonna see there creates a new database
and we're back to the login page so now
this will use the logic not from the app
loading but from the login here to then
load so if we then do angel steps
password and login goes to the loads of
the settings another settings page has
got the properties as well so I think
that is everything I would want to cover
here or everything we need to so what we
have now is a database that we can now
store data to through use of this client
data store so when we want to add to
this now and expand on it what we'll
have to do is for an edit the interface
in call so that our for set of word
applications naturally capable of now
you know being aware of it and doing
stuff with it as well as the view models
in core can make use of it and then
obviously change the implementation
itself and here to do the new things to
the database you want to add stuff to
the database just add a new DB set set
up the in the binding to whatever you
want to do and then in the datastore you
have access to those so this is the
starting point now where the application
is self aware it can now log in and
ensure the database it can save the
token so at this point once were logged
in
and we decide to now want to say the
next step is probably either one will be
to actually create this register so we
can sign up and and get that working or
we then start thinking about calling the
getting the chat list and things like
that but to be honest for the chat part
we first need to establish a lot more of
the database we need to create the
structure for having friends if you will
having multiple accounts and having a
link between them and how we link that
there's a lot of thinking to do there so
I'll probably link up the log how to
successfully log out and remove the
token from the server we also need to do
the server code to actually you know we
mentioned in the previous videos
correctly be able to log out for
token-based authentication and then do
the register page so that we can
register an account properly and then
after that we'll start doing the actual
chat and the friends and how we go about
that so as always if i've been useful
and you know you'd like to support me I
do have a patreon page I'll put the link
in the description any comments or
questions or help you need just again
leave the comments and I'll get back to
you but hopefully this was a useful
video and now you can finally log into
facetted awkward
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>