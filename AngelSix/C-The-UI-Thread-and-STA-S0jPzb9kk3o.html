<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>C# The UI Thread and STA | Coder Coacher - Coaching Coders</title><meta content="C# The UI Thread and STA - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/AngelSix/">AngelSix</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>C# The UI Thread and STA</b></h2><h5 class="post__date">2018-04-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/S0jPzb9kk3o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so in this video we're gonna carry on
from the threads video really and start
to talk about something very specific
and and mainly the reason why people get
into trying to understand threads in the
first place the number one driver for
wanting to know you know why you need a
certain thread is typically the issue
with UI and that somebody spins off to a
new thread either realizing it or
inadvertently and then realizing that it
states you know you can't access this
caller because it was created on a
different thread and basically you can't
EDT UI and I showed that example in the
last video on threads but in this video
I want to just before we go into tasks
specifically into very you know deep
dive into tasks I wanted to talk about
and dig deep into this understanding of
why that UI issue comes about and
specifically the thing called a single
threaded apartment which is something
that the UI of window specifically
WinForms and WPF for example have to
abide by and I'm not gonna go into the
reasons why they have to abide by that
I'm simply gonna show you you know the
details of that so we'll start by just
wait until BPF are just to get some code
and then we'll compile this code and
take a look at the output so we'll see
firstly that's we have a fresh to be PFR
control shift and B to build that should
build the application now if we expand
it into a sam'l dot C s we'll see we
have a main function we go to the code
file first you can see there is no main
function you know to application and
you'll also see there's no main function
so the first thing when we're trying to
dig deep into this is that you'll see
this main has been generated for us
because you do have you know inline
compiled code the reason that's been
created and we'll take a look at that in
a second is because the properties of
the abdominal file the build actions set
to application definition as it's all
default it's all set up that way or the
pages or other windows and what
except the pagers build actually so this
app is by default set to a special
option called the application definition
that's what then decides that it's going
to generate automatically we scroll to
the top water generated I'm going to
generate this file for us in order to
start the application and the reason for
that as we discussed in the last video
is all yech sees the maybe some
exceptions but basically all clickable
exe s on a Windows machine typically
work by having a public static main
function if you will really work that
way for as long as I can remember
so it's explicitly looking in the
assembly if you will in the the
executable file for a public static
making that returns nothing this is the
entry point of the application as it's
called so this is the very first line in
your application that Windows will
execute and we can even put a breakpoint
there even though it's auto-generated
code and run and actually hit this
breakpoint and you'll see this will be
the very first and in fact it won't let
me break point into that but the point
is that's your very first line of code
that you know it comes into and the
thing in terms of importance in this
video as you'll see here it's
automatically added this sta thread
attribute and it will you step into that
there's no real documentation in there
but basically the sta stands for single
thread Department and the point of that
is to ensure that this function
specifically because it's tagged on this
function this function should only ever
have everything in this you know
function itself accessed and modified by
this single thread and the point of that
again I don't want to go into too much
detail is basically due to legacy legacy
code and comm interoperability which is
really old so most people that are less
than 30 have probably never even heard
of calm or have very little knowledge of
what it is or why des but back in the
day you know you're talking when C was
around before even C++ was around the
way that things work so the way that
Windows 95 windows 98 and and going
forward to this day Windows 10 still
uses comm it still uses legacy code from
early windows code bases as well as
microsoft office products use their API
is calm
but the point is that the wacom works as
with a single thread so rather the way
you say an exile API talks to a WPF
application that the cross communication
between applications or threatens of
your will happens in a very defined way
and a way that was defined many years
ago
and it's kind of stuck in legacy so I
don't want to go into all the details of
why we have to stick to one thread for
the UI but the underlying reason is
because of that and what that means is
say we took a control on here for a
minute I'll show you some legacy code in
action and we'll just do Bob standard
super quick click event handler will not
bother them and they can that mechanism
here Mike there is a file open dialogue
a rather open file dialog okay what's
going on here I was like what am i doing
Oh open file file bit too early for
doing this new open file dialog you can
see also when we're using this open file
dialog you'll notice the namespace clean
them up is Microsoft Irwin 32 that's a
hint that this is also like a C code so
even though it's actually part of the
WPF framework if you will which is what
presentation framework is this is
actually calling into legacy code so the
file dialog if we step down and do a
little bit of digging we've got a common
dialogue and then that's it that's
there's no real hint here I search it
the slight hint you start getting is you
can see these in pointers which again of
your c-sharp programmer or a fairly new
to programming you've probably never
heard of in pointers or you know how to
deal with them which is a good thing but
this is a way to point to specific areas
and memory typically and you know manage
more lower-level things that we don't
have to worry about these days so that
the Hinton that lessees kind of legacy
starts when you see things like Windows
and in pointers and handlers and message
pumps and who procedures these are all
legacy things
so bottom line like I say is this is
this is now a legacy
calm call ultimately this will boil down
to call in some pre-built DLL that's
installed on Windows that then calls
comm so in order for that to then come
back to as when we save our results
equals Open File dialog dot show dialog
and we want some result we're on this
file now and we click the button keep
joking in the second window still click
the big button
and then we get a browse here so we were
to select say don't know go to some
random files if we've got any nope pick
something from D Drive let's go to get
and let's just open say Eddie to config
and now you see the result comes back
and it's give us true which I shouldn't
have really done I should have then got
the Open File dialog dot file name so
you can see this in order for this to
populate and come back into our code
because this is calling legacy code this
would has to work in comma if you will
so if we were to not be in a single 32
power on the state then this wouldn't
work so to not go too deep into this and
to go off track which is not the point
of what I wanted to do here this is just
kind of a hint to where you know part of
the reason why we need this SDA thread
comes about and it's ultimately the
single answer is the reason that WPF and
WinForms apps need to be sta is in order
to fully support anything that's in the
dotnet framework that will ultimately
call into legacy code that we're not
made aware of directly he doesn't tell
us you know watch out that he's a a comm
objector all this needs this to behave
because by default it automatically
compiles for us makes it you know aware
and then as we'll dig deeper you'll see
that the application specifically that
we inherit from this application is
inherently safe because it handles a
dispatcher object it's it's you know
part of a dispatcher object which then
ultimately follows all the rules to make
sure that we are sta thread safe if you
will but that's not that's not the point
of where I want to go the video I just
want you to understand that the
women's applications and do we prep
application will be in should always be
tagged with sta thread and the reason
for that is to support legacy code that
you know the dotnet framework wants to
call so it can be fully compliant and
there's kind of an example of a legacy
code would happen in there and that's as
far as want to go in terms of telling
you why you need to do that or why it's
automatically done for you in this case
that white Altima means there's anything
on the UI thread so any object like this
button click can't be modified as we
showed in the last video if you're not
on the original thread in terms of the
thread that comes right here when the
application is created so once the
application is created and the or
specifically the UI which should all be
created on that same thread but you know
when you create a new object which is
done again in the initialize components
automatically for us where this is
created so this call here happens here
where all the UI gets created now the
thread that we're on here should be the
only thread that then modifies that you
are and like say I brushed over that in
the last video so that's the reason for
needing the STA thread a little tiny bit
of background without going into too
much depth and then if you really want
to dig you can even Google for you know
SDA threads or single threaded apartment
states reasons and you can kinda read
from there so let's talk a little bit
about what it is to be sta safe if you
will so to follow this requirement of
being best yet and again this is a brief
overview and kind of to give you more of
a point not a technical document if you
will so one of the threads want to talk
or access any objects like the UI
elements like the buttons for example in
an SDA thread environment what they need
to do is to queue up that message via a
message queue so they can be read when
ready because all of the if you have a
single thread to process everything then
you can't come in and tell that thread
what to do as we again mentioned in the
previous video you you've got a single
loop if you will a single function here
say and you imagine this is a single
thread it was pretend were that control
of this thread and now here's our single
infinite threat
so what we do here is say protests on
you i yeah process event handlers and
this is super simple not exactly how it
happens but you kinda get the point
process external messages and then go in
this infinite loop so what I'm kind of
demonstrating here is let's say this
button was clicked well when you click
this button it doesn't necessarily
instantly and stop everything in the
world and come straight into here what
happens when you click the button in
here is that it goes to a dispatcher
objecting gets queued to be handled and
then the ultimate message pump of this
window the thing that is like this
infinite loop that's simply handling all
the messages from the system goes in
this loop and kinda says right handle
these messages handle these messages huh
and it's it's not this way because like
I say they're the caller when you click
pushes a specific event onto the queue
and this is more like a qdq to huge than
a simple pump but it's not that simple
but if in terms of understanding what's
going on you imagine this is a single
thread and somebody else wants to talk
to us they can't come in anywhere
because we're stuck in this infinite
loop doing what we want to do only and
the only way they can talk to us is to
say rat this queue is gonna read
something so this Q is saved got a bar
and again this is not how it works but
this is a point of example so let's
pretend we just have a list I don't know
I keep writing for a minute and objects
something wrong with him this morning so
this would be say message queue
he pulls new list of objects and this
would be say your messages and now in
part of here this say event handlers
blah blah blah whatever we're doing we
would then say get our next message
equals message queue dot first and again
you wouldn't use a list reduce stack or
something else that's purely
demonstration so let's even just go
nasty and just get the first message you
know where we're checking again
pseudocode just to kind of get the point
across so what we do is take the first
message from the queue or the you know
the oldest message and the queue and
then we'd say process the message so you
process text message and that's at the
point where now you'd hand
what the message was and you do
something with it and then you'd remove
it from the queue and then you carry on
your loop or you'd simply protest all
queued messages so when we want to talk
to this together with our application
we'd have to get access to this message
few talaq that we want to handle of a
button click because we've just been
clicked passing the info and that goes
into this message queue and then at the
point in time when the single thread
decides that it's ready so after it's
done whatever he wants to do in access
to that or handle all the messages this
message will eventually get read and
pushed in and that's kind of what's
going on with the sta threads and again
that's really not usable code and very
poorly written is purely a-- trying to
visualize what's happening so our window
has one message pump and you can
actually see that in the Fassett a word
application if you look at the window
resizer
code you'll see that i've hooked into
the message pumps let me just pull it up
for you so you can take a look so as you
can see here in the photo word source
code on github in the source for that a
word window window resize a source code
we have this window procedure this is
the message pump I'm talking about
and we can hook into it by going to the
source initialize we override the source
initialized or rather we hook into it
there and then when the window is
initialized we start using some
commenter operability here around this
isn't calm but this is you know like a
Zico getting the handle of the window
and like you used to do in C++ then
getting the hate wind which again is a
handful again C++ stuff if we got that
handle and we hook into effect with a
message pump so this is sort of if you
know C++ this will look very familiar
otherwise this will look completely
foreign you'll have no idea what's going
on but that doesn't matter that's you
don't need to know that but this is that
kind of message pump I'm talking about
so every single thing that happens in
your window in your do BPF application
will get into here in terms of UI so
everything that happens on the UI moving
the mouse drawing the window clicking a
stylus minimizing and maximizing you
name it that they're all passed in in
this kind of message pump and this is
the window it's talking about which is
our window then the type of message and
some details about the message and then
why
it's been handled and shouldn't be
processed by anyone else so this is kind
of the infinite loop and I make use of
that to do some low-level stuff to make
our custom window work nicely and to
monitor when things have moved and
dragging and dropping a window but this
is the the message pump I'm talking
about so that kind of gives you a a
visual of what the message pump is and
again the reason the SDA thread needs to
happen or rather how and why it needs to
happen is to pass messages into that
message pump because that's how all the
other legacy code works is through a
message pump so the way to communicate
cross-platform all most of you well
between two applications or a modern
application like WPF ona a legacy
application like some Excel API is due
to needing they need to match you need
to you know be able to communicate
successfully to be able to make use of
any old stuff that's on a Windows
machine
so I'd say ultimately as time goes on
that requirement will be removed because
obviously this there's only so far you
want to keep real legacy code in some
system you want to modernize it but
that's where it is right now so in terms
of this message queue were talking about
so now we're ready to say right there a
message needs to be cute to be handled
and so let's start digging into actual
source code and see where this happens
so the message queue handler the other
thing that needs to receive messages
from outside or necessarily not even
outside inside your own application but
we want to talaq to protest something on
the UI on the SDA thread that message
queue handlers called the dispatcher and
basically it's job is to keep messages
and dispatch them to the thread that
it's linked to so a dispatcher isn't
necessarily specific to only sta threads
and UI threads a dispatcher is a generic
mechanism and system that's in code and
if we look at as I mentioned earlier in
the video the app overrides application
and the application is a dispatcher
object and a dispatcher object has a
dispatcher on so ultimately our app has
a dispatcher and then everything that's
created you'll notice then let's have a
look at the main window go to the window
and you dig right deep down you can dig
down to any UI control in WPF
every single one if you dig down you'll
end up getting to a UI element and a UI
element as a visual and a visual is
always a dependency object and finally a
dependency object is ultimately a
dispatcher object so what that means is
every single UI element a window a
button a text box a list everything is a
dispatcher object so every one of those
will have a dispatcher so that we can
cure messages so now if we have a button
and we name the button so we can
actually access it so let's give it a
name my button and you'll I've seen this
in the last video but now it should make
a bit more sense now you can do my
button dispatcher and now if I'm like
this but sure we can dispatch messages
and you'll see get the dispatcher this
dispatcher object is associated with and
we'll talk about more about that after
but now you can see that's where our
begin invoking our invoke methods come
from so execute the specified action
synchronously on the thread
the dispatcher it is associated with so
what that means is the dispatcher is
associated with button it will be linked
to the thread that the button was
created on so therefore any action that
we run inside and voke will run on the
thread that the button was created on
that's ultimately what that statement is
saying and that's how we jump back to
the UI thread as you mentioned in the
last video so the dispatcher is the
thing that getting receives the message
is to be cued and then ultimately runs
that code or tells the thread that the
dispatcher is linked to to run that code
and as we mentioned the WPF our app and
the application is a dispatcher object
as well as every UI element Bennet a
dispatcher object as well so let's take
a look at this dispatcher object source
code so if we pull up the windows-based
source code on reference or Microsoft
comm this is the dispatcher object and
this is the actual source code in
the.net 4.7 point one source code if you
will we don't need to understand much
about it but the point I want to show is
every UI elements including the window
the application everything WPF is
inherent from one of these so we scroll
down to the constructor of this object
which is here you'll see that when it's
created so when the app is created when
the window is created
and the buttons created it will get the
dispatcher which is what we access which
is also a public property that can be
accessed which is visible on here
someone well that doesn't matter anyway
the dispatcher is because we've seen
accessible publicly it's just not
showing here because it's not a it's not
directly a dispatcher object it's you
have to implement it and then expose it
but the point here is the underlying
dispatcher when you create the object is
a dispatcher doctor in dispatcher so if
we take a look at dispatch you're
currently spudger then we have the get
so what happens here is it will say the
current dispatcher is from the threat so
it firstly jumps onto the thread of
officer the current federal ER where are
you calling this so the point of
creation and this is why we say when you
create a button where you create the
bottom way you create the UI is then
locked in the dispatcher is linked to
that is because it then says well from
thread so you don't need to understand
this code the way that it says from
thread you can take a quick look and
we'll talk through it's like lightly if
you will so you're passing the specific
thread and you want to get a dispatcher
and what it first does is it says write
the dispatcher is equal to a possible
dispatcher target if it's null or it's
not on the same thread then it means the
dispatcher needs to be found so it goes
looking for it and the dispatcher isn't
equal to null which means we found one
then if it's still alive we found the
dispatcher and if not we do that and in
return so without going into the depth
of where these possible dispatchers are
and where they get trapped all this
doors is says if we're on a thread with
thread ID of one and we call from thread
and thread IDs one the dispatcher that
we get returned the thing that the
actual dispatcher object that gets
returned is only ever created once per
thread so if we went further and further
lenders code which there's no points I'm
telling you what's going on you can dig
deeper yourself if we were to call Cohen
dispatcher or dispatcher from thread and
we're on the same thread every time
we'll get the exact same object if we
don't then a new ones created so this is
gonna first try and find the dispatcher
that has already been created
on this threat so if we've come in on
thread ID 1 and we've caught called
current dispatcher ever once then that's
just created instance it will
effectively be dis instance that then
gets passed in and is available
otherwise it will then create a new one
so I'm talking in a circle here wheeler
but basically all you need to think
about is if we call current dispatcher
on the same thread we will always get
the same instance of the dispatcher so
every thread has one dispatcher and
that's all this current dispatcher does
it says if there's already a dispatcher
created for this thread I'm gonna return
that instance otherwise I'm going to
create a new one for this new thread and
now anyone else on this thread
requesting it will get that same
instance so it means that a dispatcher
is hard-coded and linked to a single
thread and what that gives us is the
ability to get a dispatcher that
ultimately calls code onto the thread it
was made on a way to effectively send
code to you know that thread so when we
created a new button our dispatcher for
example VAR button dispatcher equals my
button doctor spudger the window the
spot check equals dispatch occurs were
on the window already for if you want it
to be slightly more obvious you can do
this dot dispatcher and but there's the
two dispatchers we can also so far get
dispatcher and that will equal the where
was it dispatcher will have to do the
full name space so we're gonna have to
do because of the spatter objects the
same name we're not to do system dot
window stop threading doctor scratcher
to get the actual start again sense and
looking out Paul from threat that code
we saw and we can say thread common
thread so we're going to manually call
that ourselves as well I'm gonna get
this dispatcher
so this dispatcher and then on top of
that we're also gonna say bar
you vent dispatcher equals four rather
we'll just do sputter and again we're
gonna have to do the time because this
object has of the structure so that's
now gonna be a new thread and then we're
going to do new Fred got start or rather
we're gonna have to wait for it so in
fact we don't wait for what we'll do
we'll get all these here what starts a
new thread and then we'll use them
inside the new thread so now I'll jump
in here for a new thread spudger and
this is really just proving the point in
showing you what I mean to make sure
you're aware this will then be the same
code so I should've just done that so
now we'll get another dispatcher a local
parameter named new dispatch that can't
be declared in the scope because the
name is used and then just run a thread
we want to put that well in fact we
could just do a task here but oh no so
it's better already I declared there so
we set it there makes no difference crit
declared it inside here in fact why
don't just do that now
change the way I'm thinking so now we
have four dispatches and then here we
can now do a check so what we'd say is
if and what I'll show is the button
dispatcher equals the window dispatcher
and the button dispatcher also equals
the this dispatcher
so all those should be true we should
get into here then what we should also
not do is if we say it was importantly
spider equals that a new thread
dispatcher there should not be true so
we shouldn't get into here so we run
that code and we click the bottom then
we should see that the way we've spoke
to that code you flick the bottom have a
dispatcher for the button which we have
one for the window one for this and then
we'll get one for than you thread and
again if you want to see the threads you
can click on the threads you can see
we're in thread ID for the minute and
then we stepped back we can't step
backward Jeff
you would have seen this written facts
let's restore that so you can see or
rather just step over that a minute and
click the button again like it once more
some in the right part so you can see at
this point we're on thread one at this
point we jump to thread six now so we're
on two different threads so we have four
dispatches all these three should be the
same because this dispatcher is on the
same thread as these were created and
these two were created on the same
thread as well and then we've purposely
come off to a different thread and tried
to get it for the common thread which is
ultimately what it does when you
creating you just about your object
these should all be the same so you get
inside here correctly this shouldn't be
the same which it isn't and it jumps
over so the dispatcher you'll be getting
whenever you doing a dispatcher all's it
really is doing is saying the current
thread Oman
so thread cotton thread get me that
thread basically so what that also means
is if you're on a different thread like
in here but then you want to call into
the thread that a certain object you
have access to what's on at the bottom
you can say inside of this thread you
know my button dispatcher and now you
can push messages to it by saying invoke
and then you pass in your actions are
now code in here will run on the thread
that this was created on what you've
shown before so now let's give our a
equals taro something just for 190 of
the Thai code and we run this code and
again we'll inspect the threads window
to see this happening so here's the
bottom you click it the dispatches on
thread one we get into the new thread
which was thread whatever number we
didn't stop there just run this again we
want that one here you get into the new
thread that's that five but then you
dispatch onto here and you'll see now
we're back on to thread one inside this
specific call so we've jumped back onto
the thread that this was created on and
that's the dispatcher in action that's
what we use to jump back to the specific
threads that in this instance you know
you I was created on and that's how you
what's called jump back to the UI thread
and so that's why you'll see all the
solutions saying my button got dispatch
it out and VOC review inside a window
simply dispatch it or invoke or if
you're somewhere completely else in code
you'll see application got current which
gets
and then from that it does dispatcher
which is doing nothing but getting the
exact same dispatcher because this was
created in the main function on the main
thread here so you'll get that and then
let's see invoke so hopefully now when
you see solutions to the problem that I
haven't even shown you to be honest let
me show you the problem new thread and
then we tried to edit the bottom and I'm
jumping ahead a bit with y1 to explain
just quickly to show you the error let's
try and change from UI off the UI thread
click the button get into here new
thread and then you're gonna get this
called and this is typically the reason
why everybody looks at what threads do
they're calling throat can access the
object because it was because of
different thread owns it and this call
will see the exact source code shortly
of why that happens and that's in order
to simply stay strictly valid as an SD a
threat so that the code that you know
the maps or it wrote for this button and
for all the UI there's no reason why I
can't edit the button text the only
reason it can't is because it asked to
add ear to sta thread
principles and that is why then
purposely throws that error to say
that's not following our rules if you
will and then when you get to the
solution you'll see why in a minute this
this is the solution so hopefully at
least know what application current
dispatcher is and where it's coming from
it's basically the apps application
which is a dispatcher object which is a
dispatcher which is created when the
apps created in main which ultimately
means you simply have a dispatcher that
can link to the thread that the stuff
was created on so hopefully with all
those explanations and this kind of
layout in this quick test you you
understand that a dispatcher is nothing
more than an object you can call invoke
on to run some code on the thread that
the object is from was created on if
that kind of tongue twister makes sense
but hopefully should do
so let's dig into that button content
that we just did so just um do let's dig
into the source code of this button
content and you go here and you can't
see the source code it's in there the
DLL so let's just jump online and get to
the source code of this object and let's
see what's happening so you can see here
we've got a button we search for content
and I find it that way cuz all the side
menu here let's just scroll down and
look for content shouldn't see in a
moment in fact I should find it by doing
object complet nope
oh sorry you won't find it important
because buttons a button base and a
bottom base is a Content control when
the content comes from the content
control so a button has a Content
control when we're doing content we're
accessing that and then in here we
should find the content property
so you'll see content property as a
dependency property which allows mvvm to
work but ultimately the content is here
that were setting and you can see that
in the gutter it's fine in the Sattar we
set value so in set value boils down to
the dependency object which is what
everything inhabits from and now to set
the value it passes in the dependency
property which is the content we want to
set an the value and the first thing it
does is say do not allow for in thread
access then this is a no op of the
objects are not assigned dispatchable
basically this calls verify access or if
that passes then it simply sets off a
property change use it off and then the
property gets changed you don't need to
know how that works but basically that
means you can't think you've changed
well the first step to see here is
verify access and we click verify access
and you'll see what it does it gets the
dispatcher of effectively the caller
this is this is the button ful so this
is going to get the buttons dispatcher
which is the thread it was created on if
the dispatcher isn't equal to knowledge
we have one then so basically if the
bottom was created then we should check
so the dispatcher verify access
or then says if not check access throw
this exception and this invalid
operation exception if you were to
follow this down is that message the
caller you know your blah blah blah that
every mess we just saw so the check
access is a simple check and you can see
that this then simply says is the thread
equal to the : thread so that means the
thread of here which is the dispatcher
thread which if you then follow the
dispatcher threat just for completeness
the dispatch of thread the point of
being created is the threads common
thread so all that is when you create
the object it's the common thread so the
dispatcher thread is the confessor is
the thread were created on the same as
the thread that's that's actually
calling the request to change the
content so that boils down to an our
code being is this threat we're inside
off because it uses thread common thread
the same as this so the check is
basically saying if my button dispatcher
dot thread isn't equal to red dot common
thread will get into here and complain
so we put that check ourselves first
this is almost like a check are we on
the UI thread and we click the button we
should get into that if statement
because it isn't which is the check it's
doing for us so we've detected here that
were not on the UI thread of ul were not
valid but instead of us having to do
that code all the time and undo this
check constantly which in theory we
should have to do this will actually
throw if there's an you know an
exception so there's a bunch of helpers
on the dispatcher for or I'll say there
isn't actually there's has helped us
somewhere for if see if I can find it in
fact imagine to be on WinForms I'm
thinking a WinForms answer
so on the WinForms one they used to be a
is is invoked required kind of check
which is doing nothing more than that
check we just wrote but in terms of you
want to be safe and if you're doing
things directly and you're working with
other threads then you can kinda just
call dispatch right in bulk and do your
work to make sure you're playing it safe
and there will be no harm if you already
on the same thread Nicole invoke you're
gonna do no harm you simply gonna be out
of sync with your code because this code
doesn't run it you know necessarily in
sync so the the invoke should directly
cuz it'll it'll call back and lock but
if you want to start doing async code
than your async
you know invoke acing so just keep an
eye on a bit states synchronous or
asynchronous if it's asynchronous then
it's gonna run at the same time as so
yeah the same time your thread so if we
changed this call to be asynchronous
you'll see that we should hit this
breakpoint and then we should hit this
break points because this gets queued up
to be run on another thread
so you hit this first and then after a
while it comes back and hits here so
just be aware of your invoking on
Nanni's non synchronous calls that be
the flow of code is not going to go 1 2
3 4 it's potentially out of order the
invoke though does explicitly state its
it's synchronous so it should lock and
effectively they should always hit
before this and always complete before
that so that will hopefully explain the
direct reason and where they ever comes
from in source code when you try to
change you know content off the UI
thread and it complains that you can't
and that is you know this
that's called to check access which is a
call to verify access which is called by
set value which is called by every item
on a UI element that has you know as a
UI element so in here it's again the
content property so it's basically this
this object they will all call get value
and so they'll call set value which will
then all follow that same procedure so
you'll notice everything the button dot
content and tap stop text and anything
that's UI specific you can go to any
element you know a specific one try
think of a simple one let's go to
that's box base and dependency object
worked over got something hopefully in
here I'm gonna show anything here I
don't have a single object to show I was
a good example and that's because
control anyway you get the points this
everywhere there's a like there for
example border brush property border
brush set value so you try change a
bottle brush border thickness that value
and that's a this is hard-coded in the
source code done that for the reason of
making sure you don't alter these
properties because then once you do
change the dependency property this will
bubble up through mvvm if you will to
handle and notifications and it make
sure all of the the changes that come
from inotify property changed events are
already run on the same thread by
default that's right the for set a word
application you don't see us having to
do any dispatch it invokes anywhere yet
because we're using MBTA so when we bind
a button property when using binding the
binding gets a set value which calls
into the the dependency property in the
dependence of property handles getting
back onto the right thread so a thing
that's not talking about the the layout
of what's happening if you will now
let's break down the application the
construction of the WPF application on a
kind of lower level so as you see this
main is created automatically and that's
gonna do then SDA thread and it's gonna
do all this for us we can override this
and create ourselves so the very
beginning of the application as I
mention it compiles the applauds Amal or
rather compile time it compiles it and
it builds because it's an application
definition here it compiles and creates
that main function which we can see
right here
so if we turn into the build type of
application definition to just page so
now the apps not going to generate a
main so we compile now keeps telling us
because we've got this auto generated
code open program does not contain a
static main function suitable for entry
point because now you can see the main
as doesn't exist and here's their
compiled source and that's because we
changed up to page which is fine so now
what we'll do instead is we'll make our
own main function so we'll do public
static just like we saw and main and
tada our application should now run so
if we will necessarily it will refresh
our auto generated code which can close
now you can see we get into the
application we finishing it closes so
now our WPF application is nothing more
than a blank function so now we can do
whatever we like we can still do VAR
file open dialog equals new file open
dialog today be nice or is it open file
dialog we like it back to front yep it
is we do that - L then we've on this and
we now get whereas the pop-up
disappeared well for one we haven't
tagged this with what we need - which
may change the function of its own force
the SDA thread attributes on there and
then now you can see it works
so without the SDA thread when we were
calling open file dialog it failed to
work so you can see that again we remove
the SDA thread and run and nothing
happens we're still running but the
problem is the open file dialog has no
way to display a dialog for us because
we're not on SDA threads who doesn't
know how to communicate with us so now
you can see there's no nothing's
happening that the applications broken
for the most part and this is using
built in the.net framework
library we're using a function that
shouldn't actually work and the reason
it's the only reason it's working it's
thanks to this s/t a thread so once we
honor this attribute which we'd dig into
but like to say that's not kind of the
point you don't need to go that deep for
understanding this point is that your
entry point to the application is
nothing more than a public static void
main
for any application once you're in there
it simply moves from here to here just
like a console application does it
starts here and once it gets to here the
application shuts down unless new
threads were created here new foreground
threads
so this is our application now we've
changed our entire WPF application to
just open a file dialog and that will
only work when we have SDA threat so
that's kind of a proving point of our
logic so we can now happily say our
thought was right our investigation into
code was right and I always like to do
this whether I do behind the scenes or
live in a video I've literally done this
live in the video to prove my own
thinking if you will this investigate
the code dig deep understand and then if
you have an assumption like I'm trying
to preach here in this whole video that
this sta thread is required for things
to work that are calling you know
lower-level stuff it's ok saying that
but then you guys might assume well no
that's not true so it's always good to
prove that what you're saying is right
as well so if we understand that the way
that this should all work has to be an
SDA thread and that's in order for the
message Punk to work and blah blah blah
then how do we prove it so what we do is
we find something in the dotnet core
library so the dotnet framework library
that is quite clearly starting to have
in pointers who procedures things that
loop to us like you know legacy code and
that's the point I'm saying SDA thread
is to support legacy calls and that's
showing there so by the same principle
if we were to do something that wasn't
sta thread it wasn't legacy code
specific it should still work without
the SDA thread so what should still work
here is if we mimic the original main
function which we can do var on second
what was the
new app something like that new app and
then we can do half cup run and this app
run will dig into let me find the source
code for the app dot run so we can see
what that does
so here's the source code to the
application here's the run the run calls
verify access which is the same form to
make sure on the right thread so if we
work that in fact let's prove that point
and so this verify access is the
dispatcher objects verify access so what
that means if we were to try to run and
the problem here is it's gonna close
instantly though I know the thread will
be on a a new foreground thread so if we
were to do say new thread which will be
a foreground thread and to start it so
the application won't close and again
let's first prove that the case so we've
run this now I'll create a new app that
will start a new foreground thread
remind you that federal finish so we
need to do say good sleep five seconds
so now the application should be in
debug mode with the orange bar at the
bottom for five seconds because it's
running and it's kept alive by this
thread and five seconds later it stops
so because we have a foreground thread
the first case is true the application
stays open now if I'm understanding
correctly if we were to put this in here
our on we've created it on one thread
and we've started on another and the run
source code states that he'll do a
verify access so the first thing we
should do is call our exact same arrow
we saw before of the caller was created
blah blah blah so we're getting the
exceptions that's good so we're
understanding the if you create an app
on one thread it has to be then run on
the other thread and if you remember the
original auto-generated mean it was
obviously that case it's a dot dot new
app app run so if we were to do that now
and run the application the first thing
that should happen is that the
application actually runs now we get our
window back and we got the button back
and in fact that's not running because
oh yeah so the point of that will run
because of the app
is an application which is then trying
to follow all of the sta stuff so even
this is tied hard tied to an SD a thread
so I'm trying to think of something we
can spin up there isn't SDA thread
related just to prove that like I say
that we could didn't theory we run a WPF
application without SDA thread
we just need to simply find something
that can run that isn't you know reliant
on that you know some part of the code
that's not reliant so I mean one is
obviously to come run as we saw on
simply a new thread that does nothing
they keep the application alive that's
kind of the proof almost in itself that
we are running an application although
we're not doing anything exciting we
have an application running then it does
run it does start but we're not getting
any kind of you know graphical feedback
it's kind of show so I think in terms of
GUI obviously almost everything on
Windows as has been engineered that way
WPF win form so we're getting struggle
to find anything we can pop up on the
screen without sta threat because that's
kind of all working in the same region
but I believe we could do it we just
simply have to make something that
doesn't honor SDA threads so we have an
SDA thread that we know is a requirement
now to be a valid application of ul we
can then call hopefully just create a
new app and run the app and that should
never run our dialog and we still don't
gather dialogue so let's take a look at
why that is let's first change us to
just say to change back the compiled of
this to app definition and let's take a
look at the original code we didn't
initialize components the key step there
in fact that might have been the key to
working without sta threads so check
that back in get rid of that change that
back to page so now it's not
auto-generated and now we should run and
see the application first which it does
down here so now let's try out my
original theory of removing the sta
threat which to be honest I think it'll
still spell
No so now it's complaining the calling
thread must be SDA because many you are
components require this so we've got a
forceful thing inside of the main window
and the windows now baked that check so
if we went and looked at the source code
of window we'll find that it's doing
that kind of check so if we were to go
to window might as well look at it for
completeness I can say I'm doing this
live so I genuinely am you know seeing
this happen as we're doing it
that's the static static constructor E
is the public constructor demand or
managed code it's trusted Windows false
initialize by bus layout policy true is
inside a true and then there we go if
it's the dispatcher added to the
internal windows set the window
otherwise non window non app windows ad
so I actually don't see any unless
there's a check in here I also don't see
any over there with the I can see is
doing a check but I can't see anywhere
it's throwing the exception in the
initialize which is interesting and
that's the complete constructor so I'm
actually not sure where that error is
thrown thrown from basically unless I am
on the wrong place here let's see what's
been called from so let's take a quick
look at where it's going from a
constructor of
input manager so this isn't actually
coming from the window constructor this
is coming from the controls in that so
this is coming from the controls inside
of the initialize close that down so
this call is bubbling a bit further down
so it's going into the initialized
components so we were to break here have
thought it broke before though and
that's breaking there but internally
this is going into a constructor the
main window into there which we see but
let's get into creating a control inside
the window constructor but I don't see
inside of the window unless I'm
overlooking something here main window
system that window that window mind the
wrong source code I might well be in the
wrong source code here we are in system
nowhere no I'm in the right one so those
really quite interesting I mean we don't
need to dig into this I'm just getting a
bit curious now as to where this is
actually throwing the error where and
understood that we went into initialize
components and it creates a control and
the control does the check but the owner
was it a private I my overlooking
something silly here was that a private
constructor the window control framework
yet coming to input keyboard navigation
so it's it's this I'm trying to find
this line here we've gone into the
constructor of the window bought then
somehow it's started creating controls
before we've gone into the initialized
components purely curious here like say
this is nothing specific have to
understand there will be a window call
though so
what might be happening actually is the
the map your message pump already going
on with the window that's five in an
event or angle is it just the static
creation that's starting because R
accessing the window in general but I
don't think so we opened up just
anything static so in fact that we are
registering handles here that register
when things happen so one of these might
well be the created event that gets
fired when we are created somewhere so
my guess is one of these static calls is
being fired which is then starting the
creation or the check you know the setup
of the window so we've got event manager
register class or the window
manipulation event I can't see anything
I've taught me had that I can't actually
see the reason why here unless it goes
into there but we haven't seen a step in
so for now I'll leave this one as
something of you guys want to dig into
the source code and find for me but
bottom line is we still can't create
even the main window
because obviously the checks that are
happening it's a balance yeah I just
want to try and get around that to you
know dig a bit deeper into the the
confirmation but no we can't we can't
run a WPF applications UI without sta
thread because obviously rightly it's
important that what we can run and
that'll be pepper plication in the sense
of we don't create an app we simply make
our own code here and even though it's
compiled as a WPF application where we
could do whatever we wanted here doesn't
have to be the SDA thread requirement
comes about due to you know that whole
restriction and the requirement to
follow those sort of guidelines and the
rules so what we've now got is the
replacement so we first we've changed
this to a path a page so there's no
water generated main we've now made our
own main so we're in control of it and
we've repeated what the original code
did which is a new a finish last
components and run so now we're in
control of this so we now know what the
application does it comes in
two main equates the app which we know
creates a dispatcher object and all the
threats and stuff initialized components
is then we could dig deeper but
basically that's reads the sam'l file
figures out or you know what to create
like all the window and the buttons and
things and then the run we'll take a
look at now what happens in the actual
the run code of the application and as I
mentioned we know that the minute this
code returns the application would end
so we know that this run must basically
show the window when the windows closed
it must return and until then it doesn't
so back to the application source code
where we started in and I got a bit lost
in wanting to dig deeper we go to run we
do the verify access which checks for
the thread being on the right thread
which we proved in browser hosted we
don't care about so basically all run
internal so the run internal bearing
files access again some stuff we don't
care about so we scroll down of the apps
and short down we complain the window
isn't equal to null which it is in our
case so we can all that ensure your
patron and then it hosted that so
basically that would do nothing so
ensure patron source callback there's no
kind of lock here so what this would do
is or what this must do is start a
message prompt somewhere that starts a
thread that's in the foreground in order
to keep it alive because this doesn't
actually lock the threat of such this
this is like dawn and dusty WL it comes
in and says Roenick very powers access
if the window isn't equal to null
believe we've seen it is it's not so
this won't run she simply ensures the
hate wind and does that so what must be
happening is the at the point of
creating the application a dispatcher
object
inadvertently creates a dispatcher by
doing current dispatcher and the current
dispatcher would create a new dispatcher
and we didn't exist which then adds a
reference does all this la message only
hit so here we go so this is now the bit
that starts a message pump so a message
pump will then run and protest messages
on a foreground thread basically and it
will create a hook which will then be
the H wind and you can see here look
what we have this is the thing in the
peseta word application I overrode and
this is kind of the message pump that
starts so in the dispatchers constructor
let's have a look at what happens so we
are in static constructor no we want
private constructor over here we got a
yeah so it's a private constructor only
we get references to the thread as we
know and here's something I recognized
so what we do here is creating a new
synchronization context so a
synchronization context without going
too far into this stores the common
thread and starts a message pump and I
never this from when I used to do C++
work so it's kind of it's a new thing
but I know what this is going to be
doing the point of it so it's gonna
start a new message pump ready to
process messages and the synchronization
context is a whole nother thing but I
don't feel it's worth talking about you
know in this context would be doing too
much in this one video if we did that so
I want to try and find the key point
there where the message pump starts if
you will to kind of show you what keeps
the application alive so we go backwards
when I hate wind so we hooked into this
we process messages here it's not in
there
backwards again going to spot Joe's but
Jay new dispatcher internal to go back
to the private thread so we have this
three hundred sections spritzing either
got to create the window window dot
value so a window is a message only
wrapper so this is what's handling it
and then we had a hook to patron wrapper
now so I think what i'm doing here is
digging a bit too deep for i could
explain this but we're gonna waste a lot
of time so what i wanted to show is that
the run call of the this call here is
what's then locking the application and
it does that ultimately as I say by
starting a message pump that stays alive
and what will happen is that we will
have once this application run starts it
will push the initial message on to the
message prompt so when you're making you
app it will make a new dispatcher the
dispatcher will instantly start its own
message pump up you are ready to process
but a massive pool won't start until at
least one message is pushed on it so
nothing will happen
so when we call run it will start that
message from kicking and now the
application won't end until that message
prompt dies and then after that point is
running it can then go and start up and
create the window display the window and
hook into the windows closed event and
when the window closes it ends the
message pumping and therefore it returns
here but looking at their source code I
haven't you know I'm digging into it as
we speak
it's gonna take me probably 20 minutes
to dig around and I don't want to do a
video when you're just watching the dick
around source code to try and find you
know that little bit of code in fact if
we look here I just had to pause the
video and do a quick Lukas it was I'm
gonna drive me nuts otherwise what I
overlooked was wrong we do window dot
run or other app door on
and here we do this run which takes us
to here we do run internal which takes
us to here and we do in here I'm gonna
forget where it was again disk check
over looped the invoke dispatcher and
we're not in the browser I overlook
authority was was in browser if we're
not in browser
it calls run dispatcher run dispatcher
then finds the dispatch calls run and
then ultimately the run finally cause
what I was looking for is push frame and
this push frame simply cooks a message
on to push implementation which goes
that synchronization contexts were
created which ultimately pushes a
message on to the queue if you will so
all this you don't need to fully
understand but what's happening the
thing that keeps the whole application
alive is that when you call up Rony
calls the dispatch are on which pushes a
frame onto the dispatcher message prompt
and that's what then start your whole
dispatcher from running oh rather starts
it running and that's what keeps your
application alive so it might be a
little bit too much detail there but I
wanted to you know try and show that for
completeness of anyone wants to to dig
deeper there's a likely now the
application started and the wrong method
in the application checks have we the
pattern a window we saw it doesn't then
sets up the main window and all the
internal properties of that window that
we went back a few steps back off you
can see this this run internal basically
does a bunch of checks check so we have
an automatic to Windows internals and
then worried doors interestingly the
thing that starts the window if it's not
visible then Ron says right dispatcher
as we mentioned beginning VOC so it
pushes it onto the the message prompt
that doesn't run yet because it runs
here it pushes the window on and says
that we're not visible okay send a
message and then this is the better this
is the message here the call so
ultimately this a little bit of code
wants to run on the dispatchers
priorities that dispatcher will decide
when it pros
is as message as you mentioned that
message loop and then eventually it
would do is a new window show the window
and then return not and that's the
message that's going to go on to the the
message pump so the first message will
be well none less for the first message
this will be put on the queue the run
dispatcher will add that plank frame to
simply start the process that will spin
off start process and then the only
message left on the queue already is to
show the window then the window dot show
is what then locks the application from
closing because it just it doesn't
return until it's closed sort of thing
so that's the the ultimate process
that's happening and you can you can go
deeper from now I'm what I'm trying to
do is give you enough information that
if you want to keep digging you should
be able to really figure out everything
from its port the main point to what I
wanted to cover here is kind of the FDA
thread how the dispatcher is working
where it's coming from
so that's what's happening in a star
topple hopefully you understand the knot
that you can't really you know now that
this application starts it runs here to
get here it hangs here due to the
dispatcher keeping the message pump
alive which then opens the window for
you when the window closes the show
returns that message ends and you know
the application finishes and we've
overwritten how the application starts
to do that so I think that's thus enough
of that I'll briefly touch on the
synchronization context that you will
have seen being created when we created
the dispatcher object see I can go back
to dispatcher anywhere
sputter object dispatcher then when we
current dispatch in you dispatcher we
saw in here the synchronization contact
so just a really brief two-sentence
thing about the synchronization context
so basically the dispatcher is really
very specific to implementing the sta
model for like WPF WinForms and things
like that and it's got a very specific
model to follow and very specific
requirements and that isn't good for
obviously cross-platform and future
growth so to kind of starts separation
of the dispatcher if you will so you
don't have to start referencing
dispatcher you want to start referencing
in using synchronization context if you
will and the synchronization context is
is there to not necessarily replace the
dispatcher but be more cross-platform if
you will so I may do a future video on
synchronization context but ultimately
you can use synchronization context if
you use it correctly and not have to
reference dispatcher and then the
synchronization context if we go to this
you'll see the synchronization context
boils down to a class that doesn't
inherit from anything so there's no tie
to that and if we look through the code
briefly you'll kinda see there's no well
I say you look through the code you
won't make much sense unless you you
know you know how sta works like in a
lot more detail but what I can tell you
is this code doesn't specifically get
stuck or follow any routine there's sta
specific it purely handles
synchronization of messages but in a
more cross-platform way so there's
that's what this synchronization context
is about if you can't see it in code or
again that would take a whole new video
to to talk through so this has been kind
of a very detailed very specific
video and this knowledge is really just
there so you understand more about
what's going on in the application and
you really understand ultimately just
one error which is why you need to run
code that edits the UI on a UI thread so
it's kind of the only purpose of all
this video is that you've now got a lot
of background knowledge you feel more
comfortable in really understanding
where that error come from and in your
code now you're more comfortable you
should know when you tap in my button
got this back drawer dispatcher or
you're going to dispatch it from a
thread or you spending a new thread off
and you're invoking that you feel
comfortable knowing this isn't just a
thing that's called dr. Spach or
where's it come from anything now you
should understand exactly what happened
so this dispatcher got created when I
made my button and the invoke will jump
back onto the thread that the dispatcher
was created on and run you know here and
that's that's really the key pointers to
to know deeply and fully exactly where
this dispatcher comes from as well as
why calling like my button doc contact
content equals something else on a
thread that isn't the the Creator throws
an error and the reason is because it
wants to honor the sta thread and then
ultimately being able to spin off the
application manually so not anything
exactly constructive in this video but
mainly just knowledge that I feel is
very important to just stop you ever
being confused or not understanding
being able to get a thread to run on a
UI thread and so hopefully this video is
useful it's been you know different than
some others that he's really been a very
technical and kind of digging into
source code style video but if you found
it useful and you want to support me how
do have a patreon page
patreon.com/lenguin six I'll put the
link in the description any comments or
questions on the video just you know
post a comment and I'll get back to all
of them and hopefully this video has
been useful</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>