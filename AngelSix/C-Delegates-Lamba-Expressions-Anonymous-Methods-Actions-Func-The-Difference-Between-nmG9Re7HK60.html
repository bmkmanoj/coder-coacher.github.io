<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>C# Delegates, Lamba Expressions, Anonymous Methods, Actions, Func... The Difference Between | Coder Coacher - Coaching Coders</title><meta content="C# Delegates, Lamba Expressions, Anonymous Methods, Actions, Func... The Difference Between - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/AngelSix/">AngelSix</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>C# Delegates, Lamba Expressions, Anonymous Methods, Actions, Func... The Difference Between</b></h2><h5 class="post__date">2017-12-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nmG9Re7HK60" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so in this video we're gonna drop down
to some more basics of programming now
it's not necessarily basics as you know
really simple stuff bought a lot of what
we do in all these videos
a lot of you have started saying you're
not quite sure what certain things are
one of the main confusions is between
basically delegates anonymous methods or
mock anonymous functions actions
functions themselves so there's a lot of
different ways to effectively invoke a
method so in this video we're gonna
cover what a delegate is what an
anonymous method is what a lambda
expression is what an action and a bunk
are and go through them all they're all
basically the same thing
they all just invoke a method or are a
method signature so we'll step through
them one at a time I'll simply explain
exactly how they are and then if you see
me using them in the videos it should
make a lot more sense so we'll first
start off everything really starts with
the delegate you need to know what a
delegate is first so we make one easiest
way to to show this so a delegate is
basically a variable that holds
information about a method so we can
step back one more and do an actual
methods let's say let's just make a
method call it normal method and we'll
take in say just an integer and we'll
turn that integer times two so this is a
normal looking method the input value
returns twice leak and pop value so
they're just a normal method I'm sure
you all know what they are if not then
you should go back to the very basic
videos of c-sharp that I've done so
there's a method that we can make
yourself we also need to put a main
method in this function so can actually
do something so you could say VAR a for
VAR b equals normal method of say 2 so
they should return 4 and if we run this
code we should get you know the value 4
and B that's just a method in itself
that is just you know how you call a
method so you should see now B as four
there so that's all fine I'm sure you
understand those parts so that's
invoking a normal method now the main
purpose of real well I guess the sole
purpose of all the other things you know
lambda functions actions normal
functions delegates it's all aimed at
being able to basically pass in a method
as a variable to another method so if we
had say probably static int another
normal method and we wanted to pass in
this method itself there's a variable
like this or we could even say we're on
another method this is you know however
you might want to do it you can see you
can't really do this you know for one
you can return a value for no to stop
that error but that's basically saying
you can't you know you can't pass a
method into another method so the point
of a delegate is to allow you to do that
so we go back to the top a delegate is
the definition of a method so it's the
return type not necessarily the name you
can call it what you like that's the
variable name it becomes a return type
and the input parameters and that's
basically your delegate so if we make
public delegate and we'll make one to
match this method so it's going to
return an integer and then now the next
thing is the name of if we want to pass
type of method into a function this is
what you can consider the variable name
of this delegate so I'll call this
manipulate we could call it anything you
like this is the variable part of the
name and then in here just like you're
defining a method it's going to expect
an integer so we'll say you know in term
also give it a name so this defines a
method that returns an INT has one in
olympos so by doing that while this
means now we could our normal method
delegate and that can now be you can
make a new instance of the manipulate
delegates as if it's a variable or a
class you know it looks the same way and
now it's expecting the actual if this is
you know a function so that is expecting
it to return an integer and pass in an
integer so we can actually pass it the
normal method signature so this now is a
variable that we can pass into another
function and invoke any will point to
this method so the delegates the purpose
of this delegate is to define a style of
method to expect or expecting a method
that returns an int and acceptin --nt
and then when we create a new version of
it that's what it's going to ask for any
method that returns an int an exception
and so it's allowing us to do that so
now create an instance of the delegate
and we should really put here delegate
defines the signature return type and
parameters so we know what that is
normal method cratons of the delegate
and now what we can do is get the result
so you could say normal results equals
and you take the delegate let's presume
this was passed into a function we don't
need to do that though you lock the
delegate and you can just open the
brackets to call if
will the normal method it will call the
method that you passed in so we pass in
safe three what we should see as we hit
here and here and then we'll get the
result we didn't have build errors
reward bailiffs because of this error
here so what you'll also notice here now
if another method wants to pass in this
manipulate you know or passing a method
of the same style you can now use the
manipulate as the variable so you can
pass a method and so I'll do that in a
moment
so we've hit normal method from that
call so I'll just going to return that
and now this one is going to create a
new instance of the normal method it
won't invoke it it'll simply store it in
this delegate that's now got access to
the target of UL that knows where to go
this normal method so it's going to
expect when we invoke this it's gonna
call this method which it now does and
the input should be three which it is
and then our result will be six so the
delegates purpose is to define what a
variable at what a method you know its
signature s which is the return type in
inputs and the point of then doing that
so that you can now pass around methods
to be called as if the variables so now
we could just do you know run another
method and passing the normal method
delegate to get another result so this
would be parts of delegates as a
variable so if we run that one you can
now see what able to pass in the dal get
were created into another function that
can then make use of that function and
return the result which didn't actually
return the result because we as a point
run another method them as we return 0
so we should actually then return the
method and then we actually expect input
so we've passed in the method but then
we also need the value so we'd say for
in
case and weed out here the number to
pass in and we do such a thing like that
so this is just all you know sample code
to show you what the pointer is to be
able to pass methods in we're not doing
anything special with them but it shows
that the ability of now being able to
pass a method as a variable of you will
choke it around so accepting method and
importer and then of we run this this
time we should get 8 because we passed 4
in and it boils down so we step in
you'll see and I'll run the method it'll
pass the 4 into a method that will jump
into the normal method and then that a
little bubble up and return to the 8 so
that's the this was a long time we I
wouldn't know when maybe see sure
4 5 3 I don't know it was a good while
ago when you were able to create
delegates to do this kind of thing so
natural progression then says well if I
want to simply pass a method into a
function to manipulate a value in a set
way I don't want to have to necessarily
always create a function like this and
then have to define you know a method in
my class to simply pass in a method you
know quickness basically is the same
thing there's not one tough to into a
equals one or a bit of examples we say
you know a list of stringing a equals
new list of string and that that's not
drying was repeating yourself so that's
why they introduced things like var so
it can interpret from the right hand
side you don't have to double up your
code so the same thing with the next
phase which use anonymous methods is
simply always aimed at reducing that
amount of code you have to write and
code you have to type so the next thing
is an anonymous method and that is
basically a delegate that looks like
this and it returns a delegate so to do
an anonymous method
we can do let's say we will have to
specify the type this time because an
anonymous method doesn't return the type
it's the point it's anonymous you need
to tell it what you know it should turn
into so we want to create just like this
we're doing this exact line here so we
can actually copy and paste this for now
so you can see the you know the changes
so it dreams us to anonymous method
delegate and now instead of having to do
a new delegate of you know that type and
then pass in the method to this function
what you simply want to say a times two
you know that's all you want to do you
don't have to define anything else so
first you can get rid of the whole new
manipulate new method and you can
replace it with an inline anonymous
method so to do that you have to start
with delegate the word delegate in here
is now your input so I'll say int a and
then the open and closed brackets like
you're in a function and now in here so
this is this is like you've done you
know normal method of URL open and close
name so we want to visualize it like a
method all she's done is replace the
name of the method with their word
delegate and then that now looks like a
standard looking you know it looks
exactly like this that's part of the
code and in fact you even put the return
equals two in there so this is just a
copy and paste of this part of code you
don't bother saying enters the return
type because it's interpreted from the
fact that you returned in there and you
change that to the word delegate and
that's how I delegate looks and that
you'll see it's going to complain you
can't assign an anonymous method to an
implicit valuable because it doesn't
know what it is the whole point is it's
nonnamous it is to know what you're
expecting so just like this is actually
returning a manipulate delegate an
anonymous method returns a delegate so
we know it's going to be able to be a
doctor because it's there it simply
needs to know the signature of what it's
expected to return so for that we just
say if what we want it to be the
manipulate signature so these two lines
are identical and the only difference is
now we've got to manipulate delegate
which simply says a function that
returns int
and passes inland and we can create that
delegate now that's delegate here using
this anonymous method so we tell us it's
the delegates we have an import of a and
then by doing return here it's inferred
from the fact that you buy an integer
times by two that the return type is an
integer so this then satisfies the
signature if we were to say return true
then it's going to complain because the
manipulate over the plane there cannot
convert from boolean to int because this
signature is expecting you know an
integer return value so this is the
anonymous method I'll get done exactly
the same there we copy and paste the
result wine you can then do say
anonymous result and that's just invoked
by calling the exact same thing and now
if we run this to confirm we should get
it returning six because it would be
calling that method and then if you want
to really see actually calling that
method you just clunk this on a new line
put a breakpoint in there and you'll see
it hit once we call the method so it's
not hit yes we call the method it goes
in you tend to type and gives us the
result so this was the first stage at
improving quickness to you know Instant
eight or make use of delegates so now
you can just create a delegate do what
you want them and there you go you have
an hour a function as a variable that
you can pass in without having to say
it's now a new manipulate and then it's
this function now by defining this
function out it's not in line with your
code either so if this is very in line
to doing some kind of calculation you
can see it right here as opposed it
being jumping back and forward between
methods so they're the first two steps
which is delegates and anonymous methods
now again you can reduce this more and
you can we want to also get rid of this
delegates the requirement for a delegate
definition because 90% of the time well
in fact all all the time it's basically
a function that either returns a value
or returns void so doesn't return and
that accepts a certain number of inputs
and
so that moves us on to the next thing
which is a lambda expression so lambda
expressions basically in my definition
again just this is what I I am red
anything up about them I simply made use
of them when they come out I've
experienced them and I've formed my own
opinion of what I think the definition
is so you might want to read Microsoft's
official documentation and you know if
you're really keen about what words
really mean I'm one that just likes to
do the code I don't really care too much
about the name so my understanding of a
lambda expression basically anything
that starts with that on the left right
value so you'll see what I mean by that
in a minute
basically they can return a delegate
which we've just seen him we know what
it is now so a method that can be
invoked or when this is something I
won't cover in this video quizzes a
separate topic that I'd like to do
there's a lot more advanced or it's
giving it in an expression of a target
it can be compiled and then executed so
I will give you a brief explanation of
an expression just see not left in the
dark basically an expression is you can
think of it as this anonymous delegate
or a method is in itself the actual
method if you will for the most part it
points to the method and you can invoke
it like this Concordat an expression is
another step back it basically it's a
written explanation of what a method is
in code but then you can manipulate it
in code and then you can compile it into
actual executable code and run it and
hence why I wanted to do another video
on it because it's not that simple to
explain or to just state explicitly but
if we made that an expression instead
you could then say in code expression
dot properties dot add boolean and then
compile and now you've changed the
actual signature of a method or you can
even change the return type and then
execute it so and that's
threatens more of a here's the import is
a method but now we can change it in
code manipulate it and then run it as a
different method but I won't go into
that in this video we'll stick with just
lambda expressions as they're fully
enough the called lambda expressions but
as in the return type of delegate so a
lambda is if we do manipulate again we
want the variable type just like an
anonymous method it's gonna need to know
the return type for now so this is gonna
be a lambda delegate and this is again
basically you could think of as copy and
paste of this I just wanted to make a
manipulator legate and just like the
delegates a here let's show you how it
turns codes so now with it a lambda
expression which sometimes people think
lambda expressions are called anonymous
methods and they're not this is the this
is an anonymous method when you have
delegate there a lambda expression you
can now delete the word delegate you can
delete the brackets if you like don't
need the brackets changed up a you can
delete the curly brackets on the return
you don't need those and instead of
those you do or a state in here which is
this special symbol so here is your
lambda expression cut down as as clean
as you can get as small if you can get
all that will help there use a local
function what's that gonna suggest in
TSO don't need that so this parts a
lambda expression basically and it means
you look for the you know the equals
greater than the left hand side is then
the return that well not necessarily the
return type it's the inputs and the
right hand side if you don't specify
curly braces which you also can you
don't need to specify return it simply
assumed that he's your inputs and then
this is your output so same as this
there's your input
there's your output so that's one way of
doing a lambda expression and that gives
us it returns the delegates as we
mentioned so it's returned a delegate
and it's satisfying the manipulate
delegate it's passing in an integer and
it's returning the value and we don't
even specify the type the types been
inferred from the this so we now have
Intel
on the a as an integer because of this
method so this lambda expression is
actually figuring out from the fact that
it's been assigned to and manipulate
that this is an integer that's really
integers come from so we've removed the
requirement to specify the type here
when we know it must be at I based on
what it's expected to return so again
it's just further cleaning up it's it's
just removing every little bit of you
know but that we don't need basically so
we were to change this this is break
more than this book in fact let's just
do manipulate to swap and show this but
we did boolean or I'll say long so it's
still gonna works and we didn't
manipulate to here you should see now
that a is a long and now you can't
convert when you tabs to Long's together
it's going to give you a long number and
it's still expecting an integer to
return so you can change that to long as
well but you can see now it's inferred
from this delegate and that's how it's
working so there's the lambda expression
again as normal plum the results equals
lambda delegate just the same say
passing five we can call this and we
should get 10 as the output so there we
are that's the again yet another way to
do this is sort of the this is what
you'll see me doing a lot in code in
fact a hell of a lot so then I'll do it
slightly different as well as two ways
to visually write a lambda that's one
with nothing at all
nice away so a nicer lambda is that you
can put in your brackets around your
parameters inputs so it looks a bit more
like a function as well and you can also
do the function curly braces here when
you do that though you've also after
then physically type return and the
point of needing to do that
is because then once you put curly
braces in you breakout it is a function
so you could say var a equals or rather
say VAR c equals to return c times a
times 2 so as soon as you go from an in
line single you know statement that must
be the return value that's why you don't
need the word return as soon as you put
curly braces in you can now write a
whole function in here so it can't
naturally infer what the return value is
you after then type it like a regular
function so this is still exactly the
same when it's not acting different
something on that but if we remove that
do that this is exactly the same as this
one it's just a different visual way of
writing it and the fact that we've now
put curly braces in it means that we
then have to specify the turn type but
now we're also free to make a more
complicated function so these are the
exact same things to both lambda
expressions the both return in a dollar
get there is nothing different about
that and then we just call that and then
we can see that I'll be 12 because it
will call you know into that function
will always pass the same number and
change the values but you can see what
it's doing so there's the 12 so these
are lambdas now this is what I'm saying
people you often think is called an
anonymous method so the lucky out has
made an anonymous method here or this
enormous method this isn't I know
technically in sense of the definition
of the word it's it looks anonymous and
it returns a method in terms of a
delegate book this is the the official
you know this is the older anonymous
method this was a first thing that was
made so delegates come first I believe
then you know anonymous methods they
could do lambdas and then the last part
of this now so this is this is really
the cleanest
shorteez way to define a variable to
pass it into a function or a method to
be able to pass into function or still
left with this annoying variable here
let's manipulate in this delegate so the
final step of this is to remove that as
well so the own
also just to quickly show you on the cam
return
expression so as we mentioned it can
return an expression because we're
having to tell it what type of thing it
is to return next erection we just
literally have italic to expect an
expression I'll manipulate and then we
can just do the same signature and there
we have now an expression and then from
the expression you can do all kinds of
things you've got the body the
expression the name the parameters that
are all editable and you can also then
compile it which will compile down for
delegate so at this point we're back
down to manipulate delegate and then you
could have invoked this as normal you
just do that or to make it look a bit
nicer
you call them VOC but that's a like say
another top because the expression side
of things so now we want to remove this
requirement for manipulating we just
want to keep it super clean and be able
to pass it in as a function so the final
thing is what's called actions and func
saw action and functions however you
ought to call them and also an action is
so action is just another laughter
rather is just a delegate so we can do
public delegate void and we'll say my
action so this is now what we say is the
action and as you can see it's just a
delegate that returns nothing and has no
input so instead of having to define a
delegate a valuable type for a function
that's simply going to execute and
return nothing we can do this and then
we could do for my vote or rather my
action and then we could make it with an
anonymous method to do something so N
equals two you don't need to do anything
with it it doesn't return any time
my action so this is how this is now
just the same as all these other ones
you know you've got your action delegate
and it's a function along the function
so if you've got a lambda lambda
expression you can't do this version
when there's no inputs because you know
what's it gonna do you're just gonna
look like that so you have to put your
blank brackets in so that's how we do
the action now the whole point like I
say is to remove the need to do this you
know to specify a type of return type a
type of delegate so instead of doing my
action for this specific one there's
already a built-in one flip flip fold
action so you don't need to define a
delegate if it's returning nothing you
also don't need to define delegates if
it's returning nothing and also having
inputs you know whatever the inputs are
it doesn't matter so all these things
now you know can be add all this lot now
doesn't have to be defined in this way
it can all be done via this action
built-in action which you can see you go
to the signature as exactly as I say
it's as a delegate void option just to
delegate all it is but it's now just
simply built-in so you don't have to
type it so now when you want to run a
key over all the creative valuable of a
method of any signature really you don't
need to create delegates there's rarely
a case when you actually need to specify
delegate now you can do an action or the
alternate one is basically func is just
a delegate with a return type so again
if we were to do a public delegate int
myfunc and then you can also pass in
variables but mix you know that's
optional and can be whatever we like so
this is all the func addenda bean so if
we wanted then to do my funk
you could then pass in here to do my
funk delegate that we've made let's now
expecting a return type so
returned to or rather they don't need to
return to if we're not in the brackets
so now that's how we do a function
that's expecting an integer but like say
instead of having to make these two
things this one's just now a funk that's
expecting a return type of int and
that's now the same thing so we've we've
used these special cases to get rid of
the need for these two things here so
I'll leave those in just for visual but
now you don't need those if we wanted to
get rid of this manipulate and we don't
have to make that anymore
this is returning the type so it's a
function and it's got one integer so if
we wanted to replace manipulate with how
you know we didn't make that say we
didn't actually make that valuable and
we wanted to do it another way we could
say replace manipulate with a punk so
all you do there replaces manipulate
type funk it's got you know plenty of
overloads to pass in a ton of bag all up
to 16 inputs and one output which you
should never pass more than that into a
variable into a function anyway at that
point you should create a class with the
values in so we have an important than
an output to the input as an integer the
outputs also an integer and now we have
a func delegate and as normal don't
result is then the func delegate so now
you can see even though we have to type
this you know it is its auto created for
us you know so we've got rid of the need
to actually create the manipulate
delegate in our code we don't have to do
this now we don't have to do these all
on could technically be deleted and you
can make use of them I think if I
remember rightly you can also do so it
looks cleaner do a variable or let's try
this want to delegate and then the
lambda expression I believe you can pass
in the expected types and maybe not
you cannot assign under expression to
implicit no so you can't do that yes you
still have to always you know specify
the type at least so that is where we're
up to with actions and function so let's
clean this up an action is a delegate no
input and there you turn drive and
that's how you would do it an action my
action or action delegate and it just
does something so that's fine now it's
complaining because it's not used but
that's because this is your sample code
then a function yeah on this based on
funk we're separately because we're
talking about the exact variable taps my
bunker is just a delegate with a return
fire in fact that isn't right either not
no input with no return type and you
know input because as mentioned if you
want to have an action that has input we
could do action that's going to expect
an integer
uncle action to and this is now going to
expect an input of egg so now evolved B
equals a times to just do something with
that value and what you complain about a
local name B it's already using the
scope I must use be somewhere else so
the other thing when you are doing
inline things like this you can make use
inside of here of the stuff outside so a
really useful thing here say this action
delegate we can actually make use of say
this lambda delegate here we can make
you feel it inside our and over counter
oh you again lambda delegate so I
thought we could so we can that will
call inside of this delegate the target
that we've just defined in this scope
that's the benefit of doing in line as
well and so this complaint here about B
it's because we must have B already
defined that the very top were called
this method B so
normal method invoked result so now we
can do be there so you have to be aware
of when you're doing this kind of layout
much why that's gone like follow that's
where you know is weird I've never seen
that coloring before or not that is
hunts interesting anyway I want to play
with this now what's that doing I have
no idea where let's come Brown somebody
might know that can inform me I've got
no idea why this things turn brown so
yeah you've got your action that you can
invoke a method do what you like you can
then also create an action that accepts
an integer as an input or whatever as an
input you can change it to whatever you
like you have a string int boolean and
then you get out my string my int my
pool and then you could say you need
access to them there there's a boolean
there's an integer as a string so you
know there's all those ways of defining
it but bottom line is you should not
have to now make oh I know whites come
Browns because about the search open up
here mystery solved
so you don't have to ever define a
delegate you know there's a rare case
now you'll ever have to do this so you
can simply pass it in you don't have to
do delegate anymore you don't have to do
return types you can move to lambdas so
it all becomes a lot cleaner and you
know you're down to doing it this small
and simple now let's say we wanted to
put it in a bit more of a a real-world
scenario let's make a class so we'll do
a public static class I'll pose for now
probably the static string and what
we'll do is we'll mimic the link
expression we use a lot which you say
get first or default or where or less
you know all the lambda expressions we
use the link expressions so let's say
get first or default which is natural
you know it does the thing and in this
we will pass in will do this so it's an
extension method so we can just call
their variable and then dots so I'll
show you what this does in a minute a
list of safe strings items so there's
the input that we want to find the
federal defaults and then we now want
the action to actually find the first or
defaults how it works so in this case
now we'll expect a function with an
input of a string because we're going to
pass it the each item string and we want
to return whether it's matched or not so
it's going to be two and boolean will
call this fine much so now in this
function here we can do for each bar
item in items so we'll look through each
item and then for each one we can say if
fine much and we pass in the item itself
the string and it's going to return a
boolean so if this function that we will
pass into this function if this accepts
the string and decides that it's the one
at once it's matching its gonna be
turned true then we'll return the item
because we're expecting to return you
know the item if it gets all the way to
the end and nothing's bound you return
nor say because first or default would
be expected to return null as opposed
crash so this kind of mimics what the
first or default would do if we then
come up here and marek the first or
default link expression and we would
then do first of all Chris markings so a
new list of string new array and in here
we'll just have to say a B C D F and G
so that's just a list of items now what
we typically do is we say items dot
first or default and if we did first or
default and added the link expression so
this is the original one that ours you
can see it's expecting exactly what
we've passed in a function
that accepts a string and returns a
boolean on the call and a predicate so
this is exactly the same as our
signature in fact we should be able to
f12 into it you'll see that this will be
anonymous this will be generic rather
but same thing so it's it's like this
one here
so it's returning a string that we've
passed in it's got a list in this case
now you numerable of string then that'll
still be string so it's that signature
there that basically matches so the way
you've called that would then be to it's
expecting now and you can see this is
now expecting a function of a string in
a boolean but we've seen how we make
them because for example there's a
function of an Internet so this is how
you make them just a lambda expression
so whenever you see in here that's
expecting a func
also need to bear in mind is it the last
one is always the return type in a funk
so it's expecting to return a boolean
and you've got one input of string so
you need to create a let's say we do it
on a separate line so it's super clear
so it's expecting a string that we turn
to boolean which we call a a for now so
this would be my string on this case
what we're going to call it items you
can call that anything and we'll say
return if the item equals equals C and I
notice a string and you should do string
dot equal to anything else but this is
just an example so that we've defined a
method that's just literally gonna say
and again if you want this to visually
look clear you could do item I think you
can also explicitly state you know it
dates a string just for clarity if you
want to really visually see it and then
you can turn it into the function style
of our lambda expression so you knew
that way so it's just visually easier to
see initially now you've boiled this
down to simply being a method so again
if you really want to go to visualizing
it it would just be a function that
returns a boolean
that's called say much it accepts a
string called item and we say return
activity because equals C so all we're
doing as ultimately made
in a function like this that says does
match this item does the item equal C as
we mentioned as we went through this
video though as you step down these
progressive stages you'll see that you
don't need the method itself does matter
you can use delegate so for that you'd
just delete you know this part and you'd
have a boolean or rather not and that
you'd delete this part you got an item
string and then you return you know you
simply step down what we've done through
the video and you'll boil down to this
being your lambda expression delegate if
you will you can get rid of that then
because you know it's a string it's
implied get rid of those braces you
don't need them and because we're doing
a single line return you get rid of that
and that's where you boil down to this
statement so then when you see me doing
statements like this you can you can see
that by looking you've spotted this so
you go out to lambda expression so the
left side is inputs which means with our
single input called item and the right
side with no curly braces means that the
statement itself should return it's a
natural returnable statement so it ends
in a result so by doing item equals
equals see the result is a boolean so
this becomes you know a function that
has an input of string and returns a
boolean you could then pass this in now
to first or default the original form
and say found item equals first or
default a a and if we run this it should
look this list and it should return that
C instance so we got items with seven
things in and when we call found items
it's going to call first or default and
it's found C and then again if you want
to see actually happening just simply to
break this out to function put a
breakpoint in and then run it again and
when you hit the first or default now
you can see it's iterating over so first
out and a doesn't match no so it's gonna
call again be no gonna call again C and
then it's found and it returns so that's
making use of a function a lambda
expression you can also then reduce this
further than you typically do because
then this is how you get rid of this
finally you now just take the actual
statement let's boil it back down to its
smallest part here's a statement you now
put that entire statement and you pass
it straight into the function so now you
end up with a super clean looking single
line of code that gives you the first
item and that is you know this is where
the real benefits of the whole lambda
expressions come in you now down to
these one-liners but hopefully now this
will make a lot more sense to you know
what I write when I write things like
this and you just you can kind of tell
that what we doing were expecting an
item out of here and if the item matches
but you're not quite sure what the
left-hand side is what the right hand
side is do the names matter why
sometimes I'll do the curly brackets and
sometimes I don't
so now hopefully this will clear up all
that mess so this is calling the built
in link first or default and you'll now
see in order to if you wanted to make
your own functions like this you can now
call our method so to call our method we
can do the found item still it found out
and - and this time we should have get
first or default here and that's our
method and the reason we can do you know
items dot get first is simply because
this is a extension method so the
extension method has to reside inside of
a static class that's why we made this
static and the method itself has to be
static and then the first parameter I
don't really have to be the first
actually has to be the first it doesn't
have to be the or maybe does as a
problem to modify this which is not on
the yeah so this always has to be on the
first parameter and by doing this all's
it means is instead of doing here which
you'd expect alphas dot you get first or
default items and then whatever you can
now replace you can move the first item
to the start of the method and call it
directly without the namespace and
the class name so it's it's a way that
he knows if for any variable that's of
this type
when you press dot on any variable that
type you should be presented with this
method it's just a quicker way of
invoking it and that's all like
extension method is so we invoke our
method called get first or default and
then you'll see ours will accept the
exact same function here so we can now
call the same thing that as the default
one and you can see yours actually doing
that so we've got a bunch of strings we
pass in this lambda expression here so
we go in you can see we've now got a
much that's our expression we just
passed in and we've got the bunch of
items so we'll look through each item
which is a then we'll call find much and
this will actually now call into this
method here which will do exactly the
same checks that's now running that and
I'll loop to until it finds it and then
it will return it just the same so
that's making use and this is like a
real world use this is what you do do
and what I do a lot where you pass in
you know you're expecting functions to
run so you can do certain things so
that's like a I'd say a real world
example if you wanted to go further down
and make this more like the original
just for the sake you can do generic
classes which I think I've done a video
on generic classes already so you could
change this to say to you dolt
which is just a name we've given and if
you put the angle brackets here this
means now this isn't a variable input so
it can be any type at all you replace
the input of the values coming in and
the return type with it basically you
make use of you place everywhere that
said string with T result and you're
expecting this result to be passed in
via the method now you can't return null
on an unknown item so what you can do
instead is return the default of the
item itself which is you know a default
of then string which is then no and now
you have a method where you could have a
bunch of strings you could have a bunch
of intz
item intz and this could be Papa can
shoot there and just do innumerable
range 1 to 10 it's a list that's a lot
of quick awaited in that one just all
just a list of numbers but now it's
filled with 1 to 10 and we could also
call our our same method but this time
with integers so if we passed in item
intz it would get that and it'll also
return and now this is gonna say
naturally change because it knows that
the items is integers so he knows now
the input isn't integer so now it's
expecting say item is greater than 4 so
now it should return 5 and that's the
exact same call now so this will now
handle strings and integers so now what
we've done is broken out the logic of we
have a list of items that we want to
pick the first one that matches a
certain predicate and that's kind of the
point there so now with the exact same
method and all this logic about the
logics the same whether it's a string
and integer or anything else if you want
to find the first item that match you
something you always want the items you
always want the thing that's gonna find
the match you always want to loop the
items you always want to try and find
the match and return it and if you don't
you want to return the default so
there's a logic here now is reusable and
the the variable of matching a specific
type of item is passed up to the caller
and then they can simply pass in the
smallest bit of code that does that
check and that's where you get all these
kind of benefits so we're getting past
the the point of the video there though
hopefully this is cleared up what
delegates are which is the signature of
a method so the return type and the
inputs anonymous methods which are this
style delegate open/close which are now
there's no there's never a point to use
these by the way there's never ever a
reason anymore to need to use anonymous
method so they're to show you you know
how it was done then we now know what
our target is but again you should
rarely ever have to actually make a
delegate because you can now use actions
and functions like you know this from
can action not like this I've made this
just to show
you what they effectively are and then
you've also seen a lot using lambda
expressions to create those delegate
actions and functions and both styles
have simply you know the cleanest one or
the smallest one and then the more
expandable one and like I say the more
explicit if you really wanted to and you
know passing in tax just to visually see
it more and that should have cleared up
you know what is the difference and the
change between delegates anonymous
functions actions you know all all of
them are I take Altima the same thing
for the most part actually delegates are
the signature of of the the other things
and then the anonymous methods the
actions the functions are all the same
thing ultimately they boil down to
running a method and so hopefully that's
cleared off you know what these are
and now future videos you might have
been you're simply looking at them and
knowing what the deal but not fully
understanding hopefully now it's it's
really clear and you can start making
use of these yourself and once you start
using them you never go back yet you'll
see how much of my code is is one line
as of you know functions actions all
combined together so they're really
really useful for nice clean and easy to
interpret code as usual any comments
questions just let me know and I'll get
back to you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>