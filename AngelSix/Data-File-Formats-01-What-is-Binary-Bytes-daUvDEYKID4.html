<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Data File Formats: 01 - What is Binary &amp; Bytes | Coder Coacher - Coaching Coders</title><meta content="Data File Formats: 01 - What is Binary &amp; Bytes - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/AngelSix/">AngelSix</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Data File Formats: 01 - What is Binary &amp; Bytes</b></h2><h5 class="post__date">2017-06-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/daUvDEYKID4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so this is the first and a new series of
videos aimed at really specifically file
formats storage of data and just data in
general and it's not really the c-sharp
beginners library of UL this is going to
be more specific to you know data so I'm
creating a new playlist that's going to
be called file formats and data and this
is the first click after that so as
software developers you'll have
knowledge of you know c-sharp or C++ or
another language and you'll know about
byte typically some people will know
about integers at least you know numbers
and strings and characters and sometimes
they mess with bikes but really it's a
fundamental principle you need to
understand as a developer is how is data
stored how is your code created what you
know what forms everything and I'm sure
you'll have all heard of what binary is
in terms of if you're buying it zero and
ones and it's what makes up everything
in a computer that type of statement but
in terms of what it truly means and
applying that to real results and
understanding of what it is we need to
dive a little bit deep so I've made this
application binary viewer the source
codes in github so we just check out my
github link in the video you can get the
full source code to this it's just a
quick mock-up for a real quick
visualization of what values are in you
know specific strings or something just
to get a visual idea so we'll start at
the beginning with what is binary and
binary is basically as I'm sure you know
is zeros and ones so that means it's
either it's either yes or no on or off
like a boolean value then that's the
only possible States and the reason
people say binary makes up you know all
of computers and how processors work and
everything else is because at the end of
the day a processor is made up of
billions of transistor gates and and
again transistor gates can either allow
the flow of electrons or they can block
the flow of electrons so therefore they
have to define States the you know
they're either passing electricity or
the not so there's where there zero and
one comes from and then when a process
has got billions of those it forms a
state mechanism through some very
complicated hardware design which form
stack registers and pointers and
effectively all you're doing is
controlling the flow of electrons
through a huge circuits and that's all a
computer is has this intelligent
transferring of gates and awning and
often and gates and that's what your
computer program does is it it controls
not necessarily the processor but
ultimately it does it boils down through
you know the drivers and then through
the OS and the kernel and into the
processor itself so ultimately it's it's
an on or off status which is what binary
really means in terms of data format
then as you can see in this view here
this white one is the binary and again
it's 0 and 1 so when you save files
you'll have we create a new file call it
test test and we do the word test and
save and then we right click on
properties and you'll be able to see
them when the property is finally pop up
you've got four bytes so means this
there's four bytes in that file and we
wrote the word test so these will be the
bikes inside the file and again we
haven't got to buy it yet but a byte of
you simply Google what it is is it's
eight bits and another word for binary
in computer terms is a bit because of
bitters again and on over and off so
binary and bits are really
interchangeable for the most part in
computer terminology that they're not
the same thing so binary refers to the
actual you know the state to be beamed
by an I mean a bit refers to a single
bit of a binary format and so that boils
down to well if binary is zeros and ones
and you've got other formats like you
can see here we got decimal and
hexadecimal
and a ski here for utf-8 you've got
different formats that can be
represented by bits and by binary so in
computers will will stick to computer
terminology now we won't go outside of
the computer realm bot binary the zeroes
on one that's fairly clear but you don't
tend to work with with binary bits in
computers you don't sit there in your
computer code and typically write zeros
and ones it leads rare that you do that
you tend to write at a higher level in
terms of bytes so the first thing we
need to do is step up from binary to a
byte and as I mentioned the bike is
basically 8 bits so you can see here a 0
0 1 0 1 1 1 0 so there's 8 bits there
and that forms a byte so a byte is
basically 8 bits and then what you need
to understand in terms of bytes is well
at what what is a byte that in terms of
its value is it 0 0 1 0 1 1 1 so it's at
4 is the 4 1 so then the value of that
byte is you know the number 4 you need
to understand the structure of a binary
sorry of a byte so the way a by it works
is you have these 8 bits and it's got an
order which is almost always from the
right hand side working up to the left
and it starts with again it's a 0 and a
2 and a good way for this to be shown is
with the calculator so if you open up
the calculator and go to program and
then click this little dot here we're
now in a binary view and what you can
see is we've got 8 bits here so we just
work with just these 8 bits and you can
see here is the decimal display you know
the number its value it so we turn on
the first bit you can see the values
want we turn on just the second bit the
values 2 we turn on just the third bit
the values 4 and if we carry on 8 16 32
64 1 2 8 and you can see the result here
so what you've got a few things here
this order in terms of the smallest
betters on the right-hand side so it's
over here that is called the least
significant bit so the best order so
from left to right or right to left
whichever side the value is worth worth
less has called the least significant
bit abbreviated LSB and the other side
so over here is called the most
significant bit that MSB so when you
hear the terms LSB and MSB or you know
least significant bit most significant
bit it's talking about whichever side
you're starting from you know working
that way and so we say the third most
significant bit it means this one here
so from there in three so hopefully
that's fairly clear as you've got some
an order because the order is important
you can see the first one is one the
next one's to the next one's for and
that order it's important and luckily
it's nearly always this order it's
nearly always right-to-left in terms of
the structure of the the bite and then
that really brings us on to I guess
we'll we'll step back before we go for
it well now let's carry on with this and
then we'll explain more about other you
know interpretations like buying a
decimal and things so you have the byte
order and then it's okay so what is the
value and you might have clicked in now
that every time we're going along the
value is doubling and that's important
so what that means is and there's a
reason for it as well so the first bits
one the next bits twice that it's to the
next bit is twice that of for the next
bit twice of eight so what that means is
with a combination of these say four
bits here if you turn on this bit every
single variation of this is a unique
number because it's doubled every time
so if you were to double a number every
time then turning on the bit below it
will only add half of the previous bit
so we turn on that it'll add it to three
you'll never get two to four which means
you'll never get to the third
bit that is four so you can't turn on
anything below the bit that you're
talking about and reach that value
you'll always be one bit short so we
turn on eight then without for 2 and 1/2
it you're going to get 15 you're never
going to get 16
you can't ever reach the that bit so
that's why binary and this format is
this way so that you can always have
every possible value between the most
significant value times 2 so the most
significant value is 1 to 8 so you
double that 2 to 5 6 and you can get 256
different values up to the maximum of
255 because of the fact that with zero
is a value as well so there's 256
different possible numbers you can form
from just these 8 bits so you can find
every number from that and then you can
work it out based on the fact that you
know every number as it moves along
doubles so that's the format of a bag so
say we want to put a set value in a byte
like we want to put 116 in the byte well
the first thing is you could you could
do it out in your head or you can use
the computer it doesn't really matter
it's just to show you know how that
would represent so the maximum that's
128 so it doesn't matter so we move that
go to the next one so 64 116 is more
than that so add the next one yeah we
still haven't got too high so other next
112 are still within it of the next 120
is too much so turn it off add the next
one and 116 so we've reached 116 now so
that's how we've we've got the exact
number and that's a fairly quick way of
just doing it just for helping you
understand pick a number work from right
to left turning on each bit if you're
turning on the best and the numbers too
high then you simply turn it off move
down and carry on and you can you can
figure out then any possible number in
binary and you can represent it in
binary and then that's how you store
your basic values and a byte which is 8
bits as you now know if you turn them
all on can represent 256 different
numbers
that's again why you'll see in some
computers same as memory ram hard drives
file storage everything you'll notice is
what's called base to so it's a factor
of two's so you will never seen RAM in a
computer and what will you get you'll
either get one gig you'll get two gigs
you'll get four gigs you get 88 16 gig
32 gigs 64 gigs same with SD cards and
other things so now you realize why the
size of storage and most things on
computers are factors off to so that you
always have to be able to and they're
not only factors of 2 they're
effectively part of this binary
structure so they've always you know 8
or 16 you don't tend to get say 24 or
you know 12 or intermediate values you
tend to stick with a single base value
and the same goes for graphics when
you're making say images for computer
games you tend to find out that they
want the bitmaps
he's a 256 by 256 or 512 by 512 and
that's because if you go higher up the
scale you can see got 512 we've got 2 5
6 and that boils down to again the way
that DirectX works in the way that your
graphics card works and that's because
the graphics card is again built on on
bits of the same factors so you'll tend
to get say a 64 bit graphics card that
it's got a memory to handle graphics in
chunks it can process a chunk of 64 bits
nice and easily and 64 bits goes into
the 2 5 6
as you step down so again everything of
your one-room why in general you see
these these numbers the 2 5 6 - 1 - 8
wide why the iPhone solves a 128 gig
hard drive and not 113 it's all based on
binary so based on this this
factorization and as I mentioned that's
called a base 2 so that's enough on
binary and bytes then we'll move up to
more about the basis and displaying that
information in different ways so you can
see here we've got bin for binary opt
for octal
four decimal and hexadecimal and then
bin is binary as we mentioned as as
zeros or ones and this is called the
base so numbering systems in terms of
how you represent values per unit so
this is a unit a single item here this
is another units but basing on a single
unit is how you do your base numbering
system so binary as we mentioned as zero
one so it's a base two as what this is
called what we count in what everybody
will generally know is you come from you
know zero to nine or one to ten as you
call it whatever you like you your
numbering system our numbering system as
the numeral system the zero you've got a
number to represent a number have
actually and we have zero one two three
four five six seven eight and nine and
that's it that's we form every possible
number as you can see here using those
values so no matter what number we have
how large it is we only ever have
between zero and nine as the characters
as the values in the system so between
zero and nine there art any unique
representations of a number and for that
reason decimal is called base ten and
decimal comes from the Latin for Decimus
which means ten so the reason it's
called decimal is because it's basically
inherited from the lacking for ten and
there's ten possible different symbols
to represent a value in decimal so if we
went to this we can see here's our our
ten possible values to represent you
know a value in a single unit so when
you put a you know a decimal place in a
point and and move on that that's
completely different thing it's it's
basically that the single unit of
representing a value because the dot
doesn't have a value it has a
significance so decimal is base ten
binary space to so you may have guessed
it octal is basically base eight and you
can see it's grayed out eight and nine
so now octal values can only have
representations up to seven or zero to
seven
so we were to represent say what you
think and be can in octal it's actually
8 in decimal so the way it works is
you've got seven which is final or
rather if we do it this way we go to
decimal and do 8 and how is that
represented in octal basically we can't
represent 8 here because we've only got
up to 7 on the scale so let me move to
the next bit and starts again so it
becomes one similar to binary so it's
one on this significance and 0 but it's
it's in place so this has a power of the
base which means if you've shifted over
to the left then this value is worth the
base which is seven if you will it's
eight but it's zero to seven so it's
that it's the value of seven plus now
another one which is eight so we were to
go nine on decimal then we shall get to
here and then we go to say a hundred
you've got 144 so again you can play
with these values but they're the base
of it is your well here yeah joke there
but the base of it is that it it's the
base value and they've you know decimal
then really you know these other values
it's simply a case of you represent a
number
the reason 10 in decimal is 10 is
because obviously you can only go 0 to 9
so then you have to move over and then
when you write 10 you know that 10 is 1
above 9 and 9 is the maximum of the base
of this system the space 10 so you
simply if there's there's nothing here
it's the lowest representation or it
doesn't really matter what this
representation is based on how far you
are over to the left it's it's this
number then Plus you know that the basis
before that make up those values to form
that result and that's it'll be
confusing at first but if you get into
your head that all of these are exactly
the same it's simply how you represent
that value using a different base then
you'll understand and then moving on to
the more complicated one and something
that software developers have probably
heard of as hexadecimal
or hex and again this is quite a unique
word so Hector is the Greek for six or
the Greek for attaching to something to
to make it an inform of six and then as
we discuss decimal a decimal which is
the coming from Latin of Decimus forms
the second half so hexadecimals actually
a combination of Greek and Latin and it
simply means 6/10 which is opposite way
around 16
so hexadecimal has 16 possible
representations of a value and as you
can see here you've got 0 to 9 which
from 10 of them and then you've got 6
letters from the alphabet which start at
a being then effectively 10 then 11 12
13 14 and 15 so in terms of order of
significance starts at 0 goes 1 2 3 4 5
6 7 8 9 and it goes ABCDEF so a
hexadecimal of a will represent 10 in
binary and then in octal a lobster
represent the first part 8 and then
you've got your next one so in order to
fit in 10 in to octal you need one here
which is 8 plus 2 here which is then
attend so that's how you represents and
a 10 of you will 11 is b12 is C and
again this is just something you want to
play with it and see so you've got this
total 8 here to visualize this and I
also made this little program to help it
for you to be able to type and C values
quicker and easier and I'll expand on
this but this was to me just a quick way
to visualize more than one value and
also this is going to be very useful
when we come to do the peseta word
application emoji symbols which are
stored in a Unicode and you need to
fully understand the the order inside
there so I hope that covers the base
system and you'll hopefully understand
now when somebody says you know our
numbering system is a base 10 system you
know what that means it simply means
that a single unit a single digit in
that system can represent up to 10
possible values
matter what these symbols are that's why
we can then chocolate is in these
symbols could be a and B it doesn't
matter the base system simply states
that you have whatever the base value is
that many different symbols that
represent a value and that they go in an
order so this is worth you know the
first amount this is the second the
third the fourth they have significance
so that's nine is worth
hopefully nine where is this a is worth
you know ten different values of you
will that's what the base system is
binary is simply a base two system and
then we also have these again the least
significant bit and the most significant
bit naturally in our Decimal System and
in most systems again you can see here
it's actually the the order of these
bits is important so we had instead of
say 1001 or else a bad example
let's do say 501 while the order from
left to right is important because
that's them 501 which means it's it's
this binary if we were to reverse the
order this would be a hundred and five
so even though you naturally think of it
as just obvious and a number what you're
seeing here is again a most significant
bit on the left and at least significant
bit on the right so even this system has
a byte order in terms of most
significantly significant the same as
binary so our own decimal system also
has a byte order and that's important
you need to know which which side of the
you know the actual value is the most
significant bit because the where the
numbers are placed is of importance of
what the value is such a byte order as
well and then really on top of that
we'll do further videos on this and
we'll go more in now we understand bytes
and based systems we'll start digging
into what makes up bytes you know how to
represent bytes in different ways and
and then going into the programming
specific side of things with what data
types are made up of so we have I made
this program here so that we could see
all their values and long ago
so if we wanted say a hundred and
decimal to be displayed we can see the
zero one one zero zero one zero zero so
if we tablet into here I made this
program recognize binary values so as
I'm typing it will to put by the time I
get to the end of making a binary it now
knows I type this binary so what you can
see here is you've got the binary value
its then got the decimal value in blue
of 100 and then got the hexadecimal
value in gray of 64 and I haven't
bothered showing the octal value because
it's just so rarely used it's you know
what it is there's no real need for
seeing it but in terms of computers and
strings and all the other things you'll
see you will always see hexadecimal
you'll always work in decimal and you'll
always work you know you'll want to know
what the binary is and then this green
is the visible representation of that
byte as a string and then you'll see
this drop down here as we've got
different styles of strings in terms of
how those values are stored which we'll
get into later in another video on going
into specifics of strings but this
programming here so you can see as you
type you can see what you know what is
the letter T in terms of a by time and
computer while the letter T is
represented by the number 116 which is
this binary and this hexadecimal so you
can see that's what the letter T is and
then est so just helps you visualize
these and then we'll go into you know
why this is in another video so that's
mostly all of the binary done let's just
jump over to this table here and this is
now specific software so now you know
what a byte is you should understand
this range so from 0 to 255 as we spoke
about and you'll now understand why that
range is so if we went back to the
calculator you'll see that you know now
a binary a byte is 8 bits so you should
now be able to we just clear that off
you rotate these 8 bits that make up one
byte so then you max out the values you
get the 2 5 5
which is here in the decimal so you know
that's why you've got 0 to 255 now a
boolean interesting because it takes up
2 bytes and I'll explain that in a
separate video but a boolean is only
true or false
so really you only need one bit to
represent a boolean of true or false
because effectively it says binary if
it's true or false but computers don't
work or at least at the higher level
when you're in software development you
don't work in bits you don't you can't
make a data type of a single bit you
just can't do that because of how data
is aligned and how you interact with the
processor itself so your computer
processor will be likely 64 bit and they
used to be 32 bit and the way that you
then work in assembly code is typically
in bytes bytes or the least amount of
data you typically work with and what
you'll do is if you want to set a single
bit you'd actually send a full byte with
masking off all the other bits to only
represent it so you'll never see a bit
as a size in software development so
you'll always be working in byte so
really a boolean should be 1 by so
simply you only need to use one little
bit in the whole of the bike to
represent it so I'll explain why that's
- in another video an integer is 2 bytes
and that shows and this is - 30 mm -
plus 30 mm and this is because in an
integer you get all in most numbers on
any numbers you can have what's called a
signed version or an unsigned version
and when we say signed we're referring
to this minus sign that's why it's
called signed or unsigned so this table
doesn't show the signed or unsigned but
this an integer by default is a signed
integer and this sign again needs to be
represented somehow so a signed integer
what it does is it takes two bytes which
is all the way up to here so by it is 8
bit and this is the next a bit so we
turn them all on so we turn on every bit
in the two bytes
then turn on to show that you see 65535
which is 36 because of the zero so
that's the maximum amount of possible
values we can have what you can see here
this is half of that and the reason for
that is because you might want a
negative number so in order to represent
whether it's got a negative number or
not they use the most significant bit in
that byte array so if you remove that
because that that mode doesn't include
the value of the number this simply
indicates if it's negative or positive
you now got 32,767 which is this value
here and if this bit gets turned on or
off it simply tells you whether it's
plus or minus so that's why you get this
this range here an unsigned integer the
same as all these others if you're on
signle mm value simply means that the
value cannot be negative it is always
positive and so you can then use this
bit to represent up to the maximum value
so if you're not interested in negative
values and you want to store larger
numbers in a smaller amount of data then
you can opt for for creating unsigned
versions of the numbers so that's what
that is again long gave them 4 bytes so
exactly the same principle just max out
all of these values and you'll get there
you know why you've got the maximum in
that number which is the 4 million in or
not for millions for 4 billion whatever
that number is large number you remove
the sign there and you have this value
here so that's how it works and then as
you go the more by to add the larger the
number can be for that reason and then
data is represented in by it simply
because you need to store you know the
date information so data is typically
stored in say seconds from epoch or
things are as different versions of data
began would will focus on specifics of
all these formats in separate videos to
go into depth and the one we'll focus on
next two strings because they are
strings are basically arrays they are
lists of characters and a character
there's a tricky one to explain so
characters are you would have thought of
them as one byte in terms of between 0
and 255 which is how they worked when we
had character charts of ASCII which is
here so when the original keyboards come
out and the original tally terminals for
typing and communication in general when
the whole computer personal computer
ever started you have to represent the
keys on the keyboard
abcdefg you have to represent them with
a value a type a you can see that value
here is 97 B is 98 c is 99 and that
carries on
so the simply adds up this is called
while the reason say 102 represents the
letter F is because this is called the
ASCII table and this was formed many
many years ago and it was basically to
represent
English characters on the keyboard and
we only used between 0 and 127 so we
only use the first 7 bits of the bike to
represent you know to 127 different
values and if we type in ASCII into
Google and we should find ASCII table
here jumping ahead a little bit but it's
so you know you can see here the decimal
a hex and the octal and then the
character here so we looked at their
letter a that we put in here you can see
that the decimal value is 97 and you can
see what I'm talking about when it only
goes up to 127 so this was originally
the only value of the initial computers
when they first come out the ASCII table
was formed and it was to represent
everything we needed to in order to
communicate digitally so we had like
vowel to make a sound we had a backspace
to delete things a tab to make a fixed
spacing you know you're all these values
and as well as all than the English
characters and you know a significant
amount of symbols in what we tend to use
so this was the start of the ASCII table
and that's why characters when we're
talking about characters as an English
word you would expect a character to be
something on a keyboard almost
character a symbol whereas that it was
originally a single bite but obviously
this cannot encompass a Chinese
characters or more values in terms of
any symbols emoji faces or mathematical
symbols that are all now possible to be
represented here so you've typed in
character map on your computer you can
open up this character map and you can
see all these symbols that are part of
now a way to represent the value on a
computer and the stored as bytes and
that there's lots of them and these
certainly go beyond as you can see the
value there is hexadecimal that's 2
bytes long so it's fe8 B so what you
find on computers now is and certainly
and c-sharp a character is actually 2
bytes and that's so we have more than so
are type C test and changes the utf-32
or not utf-8 to Unicode you can see that
then the light of T is represented by
two bytes and it's simply that the this
fighters are used in in standard
characters that don't go outside of that
range so the reason characters are 2
bytes and software is because you'll see
you need to them represent things
outside of these basic symbols and order
to do that you need more than you know
one byte and then again there's no
reason to store say you have a value
greater or a symbol greater than what
can fit into two bytes of data then
there's these formats that started
happening that allow you to represent
values far in advance of the maximum
value of two bytes so if you go back to
your binary and you simply clear off the
binary and you want to know what the
maximum value of two bytes is so she
can't remember it then you're tagged in
here and you'll get 65536 or 535 with
the zero so what you'd think with two
bytes you could only represent that many
possible different
on a keyboard what you think could be a
lot but we've already filled this we've
gone beyond this amount of symbols if
you imagine you've got the Chinese
symbols you've got Russian symbols
you've got English symbols you've got
emoji faces you've got non-printable
characters that represent things you've
got artistic symbols you soon fill that
but instead of keep expanding so every
single byte in the file every single
character like the letter T has to then
take up three bytes or four or in the
extreme of utf-32 you know the taking up
four bytes for every single character
which means that your file you can
imagine just the word with you know test
test written twice you've got all these
bytes in utf-32 as opposed a ski that's
only got this amount you don't want to
just keep expanding the amount of bytes
that every character takes up so that's
why these formats were created that
helped condense that and I won't go into
that in this video because that's going
to be an in-depth video on on specific
file formats and how they work but
hopefully that was a good overview and
an in-depth detail of what binary is
what base systems are how they form
bytes and then in general a quick Lukas
you know why a byte of 1/16 represents
four like tootsie due to you know an
ASCII table that shows the letter T as
that value up here so again I'll
continue to do more videos on this and
I'll go deeper and deeper into binary
and file formats and why things are and
it will be very detailed but hopefully
it's it's knowledge that I feel every
prof programmer should have is what is a
binary what is a decimal what's a
hexadecimal how is the file that I've
just saved made up and why is it
structured that way you know the deep
understanding that you generally won't
be given so any comments any anything
you'd like to see you again and if you
don't understand simply leave a comment
and I'll get back to you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>