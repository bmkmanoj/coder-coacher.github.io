<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>.Net Core - Server Client Web API HTTP | Coder Coacher - Coaching Coders</title><meta content=".Net Core - Server Client Web API HTTP - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/AngelSix/">AngelSix</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>.Net Core - Server Client Web API HTTP</b></h2><h5 class="post__date">2018-02-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/N5zQRCGdJk4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">certain this video we want to make the
communication between our four SATA
words server that we've started to make
that we can certainly create a user and
sign in and how to the mate and the
actual for SATA word chat application so
in order to do that to make the
communication we're going to make an API
which in essence is just a bunch of
these web controller actions that the
client can call through HTTP calls and
get a response so basically a
bi-directional HTTP communication that's
all really a you know an API is between
the server and the client so we're gonna
get started with that so the first thing
I want to do really though is to make
the actual the web client code in DNA
framework so it's universal for any
project and just do a generalized web
client communication and then start to
bake in things like the JSON format in
HTML format in response codes things
like that so the first starting point is
we can press f5 on this pasetta word
server application and the website
should spin up another thing say hello
world
I think the Welcome page just ensures
the database if we've got no settings
makes them and then we turn the view and
the view is hello world so yeah they
should just open up and say hello world
basically and there we go I'm just turn
on that so we don't blind everybody
there we go so this is the server that
we've already made so far so that's up
and running and working so I'm just
gonna add another for now just to you
know sure what's going on I'm gonna add
a call here so just gonna have a public
action will have the return type we are
going to return an actual object because
this is an API call so let's just pick a
random object let's just use the
settings data model and just call this
test
and we'll just specify a route for now
of test so we hit up our site called
tests now we return and instead of
returning a view here we're gonna return
an object we this expecting a setting
day tomorrow
so just return a new one piny calls some
ID name Luke value 10 so that's an
object this is a controller action
that's simply returning an object now
you might wonder how how this is gonna
return a webpage if you will because
this is a requested HTML request well
you don't have to return a page so I
actually Salters generically anything
it's simply a result this goes through a
whole process in MVC to end up becoming
a page if it there's going to be a page
and the return view is what then creates
a specific result call the view results
that ends up being rendered as a plain
text or a HTML document but you can
return any kind of object and you don't
have to specify an object if you specify
a generic class then effectively what
you return instead is an object result
and then you can return a new object
result and you can pass in an object so
that's what's really happening here
we're not passing in a view result we're
returning a an object result and then
the object result goes through a bunch
of getting slightly ahead of you know
the explanation here but basically this
goes through a bunch of converters and I
believe it's called content negotiation
so once we pass this off to MVC to
return to the client it goes through
content negotiation and this will pick a
bunch of input for matters or in this
case output format is going back out to
the client and the built-in ones are
Jason and plain text so by default MVC
already adds adjacent content negotiator
and if it's an object and that right now
that's the only negotiator we've bear
the only output format we have this will
get rendered as Jason by default so we
don't have to do this though object
result return object
results the only time you'd want to do
that is if you're potentially returning
different classes or different models so
at any point you want to be a certain
you know a different model but we're
just going to return the settings data
model
so we'll just go back to what we had
which is that and we'll first run this
and let's see if we just hit up
localhost forward slash test then yes I
know what miss the new well here we go
then we should get this object returning
a JSON string so there's the hello world
forward slash test and you can see now
we hit that nickens Jason so we could
press f12 in Firefox to get the network
open reload and then you can see is the
call and we click it there's what we
made the call to test it went as a get
and the drug this up the response from
our server was that the content type is
Jason so that's why it's told us which
is now picked and used to Jason we
requested with us except header by
default the seizures Firefox they will
accept text HTML XHTML or XML as default
but as I mentioned because there is no
XML output formatter and you can't it
doesn't by default formats objects as
HTML because you can't convert an object
to HTML so those get ignored so
effectively all these accepts or not
processable by the object result so it
falls back to the built in one which is
Jason and that's why we end up with this
JSON result and then you can see the
response here and there's the raw
payloads this is what ends up coming
back to us directly this string here and
that's Jason so that's what's happening
there now with MVC and with the api's
but you notice we don't specify here
Jason we simply say an object so it
gives the flexibility to the clients the
caller
in the browser or in our client app to
actually request different formats like
here so we could click Edit and we send
and in the accept header we could type
in application forward slash XML and
then comma and now we're gonna ask for
XML as well as the rest and click send
and you'll see here now the type is
still come back is Jason but we did
request X M up and that's because by
default MVC only has a jason and a plain
text output output format so what we'll
do in order to show you this mechanism
that's optional way of converting this
data to multiple formats as we will
actually add a XML format err
so we go to the solution we go to the
start up and we do it in this add MVC so
in the add MVC call we want to add a
specific option so if we open the
constructor you can see we can do a
setup action so in that we'll just do
we'll just pull options and then in here
we've now got a bunch of options or what
you can do is options dot you've got
input for matters and you got output for
matters so input for matters will be
when we accept and we might as well they
accept and what what coming in so we'll
say model so that's an input format to
we're now asking when the client calls
this route we want them to pass as our
model and again we're not specifying
where it's coming from so that's down to
the import for matters to resolve and
then the output format is the return
value of the server to the core so in
the input for matters we'll add a new
XML serialize input formatter and it's
called yep
and that's a built-in formatter that
they provide copy and paste change to
output for matters and obviously change
that to output format all right so with
that in now have we run this again this
should now get picked up when the client
requests in the way the client requests
are certain for matters are shown here
is this accept header so this is a head
of an HTTP and this accept this this
specific string of details application
portrait XML text for HTML this is
called a mime type so we were to go to
google and type mime types and you can
see this is the in get the loads of
different pages go wherever really to
find them and you can see here these
these mime types and then you can search
for jason say and it's saying that's the
lion type so this is where it's being
pulled in from XML all have loads
because XML is kind of used on a lot of
different places that's probably gonna
be the generic XML okay application
let's find it that way there we go
so just the generic XML which is a w3c
standard as well so this if you want to
find out different formats and do your
own then you can pass different mine
types in we don't really need to know
much about them you've got XML we've got
Jason and we won't even use XML either
will allow it but which there's no need
we can do it all in JSON which is less
heavy on the amount of content being
sent back so now if we return this
because we're requesting XML the content
negotiation for the output formatter you
know the thing we turn in data back to
is now has XML that will be found and it
should pass through the XML output
formatter and then we turn hopefully XML
so not yet so why do we not have accept
XML edit and let's just remove the
others send there we go so the others
were interviewing
so because we've requested to accept XML
specifically you know it's the only
header we've now been returned XML
you're not seeing it up here because it
simply doesn't display XML by default so
this is the old page but you can see
here the types XML and if we go to this
request and go to the response you can
see it is XML it's there this is what
was returned it just doesn't show it up
here so don't get confused thinking it
hasn't loaded x marks it seemed right
here it has and you can see what I
mentioned about the file size so the is
transferred 335 bytes compared to Jason
that transferred 191 because obviously
Jason's a lot smaller on that the
notation than XML is so that's how we
request a specific format back from our
server but by default it will do Jason
anyway so in theory we should have
add-in to our calls when we do the
client application Jason to be you know
plain nice and then it's Jason wasn't
the default format it will always be if
it's available it will be 10 Jason for
us so we will add this one we may get
two requests that we want Jason you know
sending so that gets us the the calls
back from the server with you know Jason
coming backwards what we want to do now
though is figure out I'll show you how
well can't really show you in this one
how to send the data that way but we
actually want to send some information
to the client and that's part of the
this import so the import format above
processes data so when we make our web
client we will actually send this data
through the body of the HTML request and
then we'll extract it from that and pass
it through the jason import formatter so
we have that done now let's jump to the
DNA framework so any a let's start now
and add new folder called web and we'll
start by making some actual web requests
with a built in web request so we can't
call our class web request
to.net poor thing already but we want to
it's very similar we want to make helper
methods to do it easier so we'll call
ours web requests let me move the
surplus stuff public static because
we're not going to create an instance of
this provides HTTP calls for sending and
receiving information from a HTTP server
and then in here we'll start where the
public static is going to be
asynchronous and we want to return a
HTTP web response which is just the
built-in web response from the system
net dot web request thingy lives in a
minute so that's what we want to return
and we're gonna do a post so what we
have when we do the web calls is here
when you just hitting enter and loading
these pages these are if you can see
where are we here the request method is
get which basically means there's it's
just a request on the oil this is the
only piece of information we're sending
there is no body there's no content
being sent it's just the Ale and again
can pass in some data by doing which or
publishing on some websites and mainly
all the times not necessarily now is
like you know question mark ID equals
something and you can pass in data like
this and then you can do and name equals
something else type of thinking and you
can form data in here but it's
inherently insecure so you never really
use gets for sending data it's a rare
instance when you use gets the only time
you'll use a gap to send data there's
things like in emails when you get your
email to say oh please verify your email
address and they'll email you a link and
when you click that link it'll be some
website question mark confirm ID equals
and then big long number sort of thing
and that's just a unique ID that's been
passed in so they can pull them from
simply you clicking a button and it's
just a lot of single use one-time key if
you will to verify that's that's
probably
most active use case for a get what we
want to do there when we're doing
communication between the Fassett our
word application and the website is we
don't use get we use post and a post
simply means the content like the the
information that we want to send to the
server we write to in the stream of the
body of the actual request which you
can't see on just you know Firefox when
you open it and just press Enter there's
nowhere to put the body content in you
know you just typing up here this is the
response body when you see the actual
return value or you see the website
itself this is a response body but we're
sending a request body we're sending a
you know a bunch of basically just raw
data to the server that's all you need
to really think of it us you send a web
request and then we write data like you
write to a file you write data to the
web stream and the server receives that
and that's called the body so we're
gonna do a post because like I said
that's the the default way that I would
send data to a server so we'll call it
post than anything I think because it's
asynchronous one piece of info needs the
ill you know what where do we want to
send it to so in our case will be our
local host forward slash test then we
mentioned we want to send data to the
server or optionally send data so thus
allowing object to come in and it's you
know it's optional so maybe don't
parties just know and then we will also
want to add a known tag so we can send
the data in JSON say but let's at least
add XML we'll start adding an option so
we can see realize this as XML and send
it as XML or serialized is Jason just to
give you guys a way to see how to extend
if you wanted to send this object in
some other way than Jason so for that we
are well add and let me think about this
what we are probably just a constant I
think
still to say because it's just gonna be
an enol no content types let's go and
then this will be probably anon known
content types and we will then pass in
JSON and XML so known types of content
that can be serialized in practice known
serializers known contents you realizes
is probably a better name because it's
specifically for serializing the
information sent to a server so known
types of pumps like a materialized and
sent to a receiver just to be honest
with you use it for anything else the
data should be serialized mastication
and the serialization in case you don't
know and i'll that's probably not the
technical word for the you know the word
serialize but in terms of what we use
him for here to serialize to jason and
to serialize to and then really encode
it always end up being a string so as
you saw in here the response this is a
see realized jason strings it's just a
string with another that is jason so to
serialize you take an object like the
actual settings data model and you
serialize it to their string when you
deserialize you do the opposite you take
the string like this and you convert it
back to a settings data model so when
we're sending the data we're going to
serialize to a JSON string send it in
the web request as a JSON string in the
body and then the server would DC
realize that string and serialize it
back into this data model so that's how
it's working the same here this is an
object that we will not we but MVC using
the output formatter
c realizes this object into
Jason string and that's what then gets
written to here that's how it's worth
that way so serialization and
deserialization are going from an object
to a string and a string to an object
but as I mentioned that's probably not
the technical term for well I know it's
assumed in the technical term just the
words you realize but in this context
that's the the simplest way to explain
what we're talking about so when we
symbolize two XML will do the same thing
we'll take the object and we'll see
realize to an XML string and this is XML
so you'd see realized you know as you've
seen something similar to that so it
could be serialized to XML one probably
change that to two so what pattern that
isn't again an option and then we'll
call that one probably return I'll not
beat it oh yeah so this is for what we
expect to be returned so we want a
response from the server of a certain
type say and then we'll also want the
send type as well so by default you
jason will probably put the sent type
first so we'd have a that's the right
place yep we'd have the sent I and
return type so as in what do we want to
see realize this content in JSON or XML
and what content do want to be turned
you've cut having the same what will
leave the flexibility you might want to
send it injection written in XML or you
know whatever so we'll leave that as an
you know an open option but again we'll
only use Jason but I'm adding it so you
can see how it's done post a web request
to an L and returns the raw HTTP web
response
the old opposed to the content post the
format to serialize the content into the
expected type of content to be returned
from the server
that's our call but start with the
basics so we'd have first want to create
the web request you go start somewhere
so I have a request and it's a web
requests got create HTTP and then it's
simply Austrian it also that's a good
start so we can have requests while
creates a request ready to be sent but a
make a post request or a post request
type and method yes so post request
method and that should be how so this is
the other thing that's quite annoying it
wants a string for the method and yet in
built to in fact before I complain too
much what's to delve exposed yet how
there we go and yeah so that will do
originally I think this was like a
sealed class that we couldn't access so
here's the bunch of ways to to call well
these ones here it's like so the default
is get when you simply type a nil into a
browser
a post is to send the data in their body
and then you've got things like pot
delete important delete to similar this
simply a method type that the server can
extract and say oh they they've called
the certain oil but the type is the
elite so they're expecting to delete and
that's if you use delete port post get
you've created them what's called the
restful api which probably seems
gotiya it's the you know restful we like
to type you like that I don't use that I
don't bother with that
I don't like for one sending an Earl to
delete something and the Earl you're
sending is just HTTP Co on localhost for
slashing my /data for it's not the type
to be delete this is now going to delete
data and yet there's no obvious sign in
debugging or visual or anything that
this is actually a delete request so for
that man you know that reason alone and
I never bother with restful api is as
people call them I simply use post and
get and then I'll make my ill state the
obvious so my ill will be localized
forward slash delete those from my
approach like data whatever you know you
it sits in the oil so it's obvious
what's happening I don't want to have
the same oil but simply this changing to
delete that you can't see anywhere other
than that line of code that's kind of
doing some different actions so we won't
be doing restful api and at the same
time is also in a need there's nothing
you don't have to follow everything that
the industry shows you or tells you or
there's a big hack about certain names
don't you know don't concern yourself
going on must know that or it's a big
thing I need to know it's it's not
there's there's a million different
technologies and names and acronyms
coming up all the time but don't worry
yourself with them just you know as long
as you can do what you need to do you're
good to go so we're just going to
basically use we're making an API in the
sense that you see here we're sending
posts and we're getting data back so
that's all we need to do so that's all
we're gonna do so as we mentioned in the
where are we in here when we requested
XML in our headers we accept application
actor Mountain this is a mime type so
what we need to do is set the
appropriate yep slightly above Gooden
spell appropriately set the appropriate
return type so we want to sully accept
header and that I believe is just a
string so we want to send it send it we
want to set it now to the mind type
based on the known content serialize
serialize ur so we need this is where we
will need a helper class because I
believe the
well in fact we'll just make our own
forever simply is the the mindtap's just
a big long list of known basically big
long list of strings like you've seen on
a website with the extensions and a
return typeof a string' and that is not
anywhere yet exposed that I know of in
the in the dotnet core framework so
we're gonna have to clone that and I
believe I've kept a link to show you
where it is in dotnet core framework so
I'm just open up the browser this is
just routing the source code of dotnet
call it a consumer in the.net core core
FX which is the dotnet core framework in
the system net class and they've got
this thing called HTTP known header
names so oh sorry this is I'm going off
track here this is another thing I was
gonna talk about as the known headers
will come to this one what I'm on about
is the mime types so if you typed into
Google mime types dotnet course a
there's a lot of people that will well
this one's a someone had made a class
for that but there's a lot of places
where people are saying how I'll just
get a mime type like you know from an
extension to a mime type flat we want an
XML to an application for sauce XML and
what you'll find when you read is like
this is a classic one it's just a very
long list of minds
so asp.net which were not referencing in
our dotnet core library has this class
here that we could make use off by
creating a new one and then pass in an
extension and then returning these but
the bottom line is these there's no real
place in code right now in dotnet core
where we can just say well we've got XML
we want to be to an application for a
source XML you could do it through
extension and through reference in this
class or cloning this class book you
know for now for what we need what we're
going to do is just specifically which I
don't like doing what specifically just
make a class that will return the set
ones we want to know
we just want we've got right now to
known serializers we've got JSON and XML
so we'll just do them make a class that
returns application for its last JSON or
application for us XML and even though
it's just a mime type and the are
constants in a sense I'm not going to
bother importing a huge list of
constants into this for now so I'm just
going to shortcut this instead make an
extension method so known content
serialize as tensions and we will remove
the junk as usual this would be public
static extension methods for known
content see realizes and in here are
public static we want to string or say
to mind string and hopefully this
knowing serializer and we'll do a case
or a switch rather on the sterilizer
default if we don't know it we will
return was widely classed as the generic
mind time if something unknown in w3c
standards which is an octet stream
that's simply a just technically attack
but that's become used as the generic
unknown and we have Jason we will turn
the known application for slash Jason
and if we have XML will return
complication XML and will comment all
this takes a known serialize it tie and
returns the 9ty associated with it
serialize ER
switch on the serializer Jason XML
unknown so there we go
we'll also add I see this works I don't
whether this works on control dot and
add to dictionary a thing that adds to
the actual dictionary of Visual Studio
yeah not to here so we don't want to use
that I don't think we could on do that
now though so serialize has gone into my
dictionary somewhere else but for now I
know it wouldn't typically be entered
slightly add it to there and XML and
Jason will add just show my spell
checker doesn't highlight owes us
invalid words so we close and reopen
that they should now stay valid or not
did that not save yeah so what's up
complaining about
I hope the kisses unknown actually
gotten them with us see that should that
should be ignoring it cuz we got Jason
in there I don't gonna ignored files I
put in the wrong place room clear in old
words XML jason serializer
there we go close reopen there we go
so all this is doing is like say taking
an enum so we can hard type a specific
type of expected civilizer
and then get it to give us a mime type
that a web request note so that's all
we're doing there so now in this except
we can easily take the return type and
do dot to mine string now and all that's
done is basically set of its Jason
return application durational or eyes
application XML for XML but done it in a
nice clean way so that's out of the way
then we have a look to set the
so the content-type which is the send
type so we could set the content type to
manufacturer just set it as just the
same so content type equals send typed
up to mine string I'm just thinking if
if we don't pass daydrian you know
contents null then setting there well I
guess it doesn't really matter in that
case so you if you suddenly know content
it doesn't really matter what you tell
it you're sending so it will just
default to JSON or whatever is passed
and it won't make a difference that's
fine so we tell the server what type of
content we're sending
we must set the content length which
tells the server because we're going to
write to a stream and it's a we could
fail we could miss bytes we could
anything could happen
we need to tell the server how many
bytes we are expecting to send before we
send them
so if content is null then the set on
content length to 0 so they request dot
content length is 0 otherwise and now we
have the option here to serial is based
on the send type so we could do a helper
function here but because we've just got
to for now I'm just gonna switch edge
whenever else statement in fact if
content doesn't know we've only got to
touch it has to be an own type for now
so that's fine yes I'll just do an if
statement for now for simplicity so if
some type equals equals jason and then
to be honest which one that we should do
I'll save sentai because equals XML and
even though there's no other option we
should also do an else in place
currently unknown and we should probably
at that point throw an error what we
have now we have yeah we have no error
handler at the minute so I want to throw
a specific error handler so let me just
put doing
because as we have in a framework
perception types I don't want to go off
in this video and start making exception
handling stuff but what I want to do
here and this is the way we want to make
conscience going forward is the way to
report errors in things we will
basically throw an exception but we'll
throw a specific exception with a
specific exception error code if it's an
you know an expected like here it's
currently unknown so we'll return it a
specific exception a DNA exception with
a human readable string that says you
know we don't currently know the seven
type serializer but then we'll send a
hard coded error code specific to this
one exception it can be thrown nowhere
else in our all application it'll just
be an integer say the number seven and
if that's thrown in unique testing and
in any of the tests and you want to do
you can call this function Pat it in an
unknown type and expect to be thrown an
error with an error code of seven for
instance and that's how you need type it
so a unique test but for now I don't
want to go down that rabbit hole so I'll
just put it to do here for now
which is fine so otherwise now serialize
to Jason or serialize to XML so to
serialize to jason jason string is the
serialize result jason converts control
dot use Newton's off that jason and
civilize the object and then just pass
in the content and that's it so
serialize content to create a string and
that's that was it as easy as it was why
is I still complaining about Jason even
though we have ignored words Jason maybe
we just need to close and reopen web
requests there we go
so we've got the string now we just want
to set the content in fact we could
split this up into now we want to have
more content string equals and part
within
yeah that's fine condoms drink create
content - right now in here all we have
to do is set a conference string that
way if it's XML though we'll have a bit
more work on our hands
not much but a little bit more we have a
new XML steely Eliza I don't use XML
much so try to think type of content and
we do that
it's very what you'd like that well we
know we've got content get the time yeah
yeah that's it so we create a civilized
now we can't just do dot serialize with
data you see and this which is annoying
you have to create a right you gotta
pass in a string so it's kind of
annoying so what we do instead is we
make a valuable for the serializer so
create XML serialize and we'll just pass
in we'll make a memory stream just an
in-memory stream memory stream memory
string from extreme equals new memory
stream and we want the encoding of the
string by default to be utf-8 so we'll
get the bikes and I my thinking is all
my doing
oh yeah so you got a puss pipes into the
memory stream I am thinking about so you
want to get the bytes from the object oh
wait now now I'm thinking of the other
way around here this is for
deserializing
- it's back to a string
we want to we're trying to serialize to
a string on so we have the raw string
right with new and that's a thing yeah
thing right it issues it here at Emmaus
serialize a dot serial ah he's going
slow here so I mean to think this one
through so it's a string right and we
want to write to and the up there we go
and now the object is the object there
we go so if we pass on the writer that's
it create a string writer to receive the
serialize string to realize the object
to a string extract the string on the
writer so now the content string will
equal the string writer dots which
there's stop automatically doing the
wrong thing and write the darts just
drink I think so I think that's how we
do the XML serialization notice Jason's
nice and easy that's why we use it
XML is a little bit more messy so
between those and they'd like to haven't
tested the share presume this will work
but the basic idea is we need to set the
contents of the request the content
passed in what we want to send to the
client at the server so if we have no
content we don't do anything if we do
have content when we expect to send it
as Jason we serialize to Jason's at this
otherwise we set it based on XML
otherwise we throw an error there which
we haven't done yet so after we've done
that after we've basically created the
the string will then just want to write
it to the body and this is where the
post comes in so now write content
- body stream
- HTTP body stream to make it clear so
to do that we do another using because
we need to dispose of the streams so
request screen equals and they have to a
way to the request the HTTP the web
request think we made above here natural
web request so we await the get request
stream acing so we ask for the stream
you know - now we've set up all the
headers we've set up there except the
content type the length the method we
can now request the stream you have to
do that first so that the server knows
how to respond because it can affect the
stream so we get the request stream on
top of that then we need to create
another one stream writer this time
stream writer and the stream will be the
request stream and then with both of
those we just do awaits screenwriter
because now this is a way that we can
write to the body stream but it's
connected to the quest reom I'm really
fun to name this stream right because it
keeps going to the wrong case
streamwriter dot write async and I think
hopefully that sets a string something
to write by people yep there so we can
just pass on the content string so write
the content by the stream so that would
be that comment you get your body stream
one thing I don't like about this is a
clearly indents the comments in the
wrong passionate it's in does comments
to that but then in density use into
there so if we were to say I was a tag
you can see and that's fixed enough so
create a screen writer from the body
stream and then I like to do the
progressive dots until we get to the
call so that right to the body stream so
the final thing make sure I'm inside the
right thing you know so we've written
the content so this can be
region set up this is setting up headers
this can be run content and now we can
simply return the request dot get
response
so now Google get response will send the
whole request to the server and we'll
get a response it will return there by
default of web response we want to
return HTTP web response because we know
it's HTTP because we've created HTTP
there so that will be as HTTP web
response and we just returned the
response return the raw server response
so this will be a generic HTTP we need
to add to their on ignored words so this
is now a generic post call so we can
make use of this and Culver and then get
a response from the server and we'll
take it one step further after that so
let's now let's close this project and
open up or rather just open up project
solution and it will close this one so
we go to the Fassett o-word source and
for set a word save everything we've
done and what I'll do again because we
are in then we using the nougat package
of the minute right click properties
browse will uninstall our DNA framework
on install then we will right click the
solution add existing project well add
back in the current framework we're
working on right now this is what we
have before we add the new bit package
and then in the references we will
to add a reference back so this should
all build now still yes up builds so
we're now in a position where we're in
the facetted word application it starts
or produced something here so we can now
call web requests post async and we can
post say HTTP localhost forward slash
test or I think it's localized problem
5,000 or slash test everything else is
optional so content types types blah
blah blah so we should just be able to
it first for results equals four in fact
for nine and async task es let's just
shoot a strong pacing put that in and a
people's results somewhere to breakpoint
on so if we run this application now but
first we've run the server of the server
is running we can break point here to
see and we can break points here to
check and press f5 so the server's
running so we should have that end point
active and we hit I should hit this and
we'll step through it you know it will
step into the code for the first run so
you can see it going line by line so f11
into this so the set up we want to
request an HTTP call to here localhost
5000 process tests of course we're on a
sink so I'll just break point in f5 to
that there we are then the method we
want to be post so that gets set up as
post the except wants to be jason so it
should turn into application for a sauce
jason the content type is Jason so same
thing now we want to write the contents
there's no content so it says content
lengthen no and now it requests from the
server so as soon as we hit this line we
should get the rich Bach well the server
should hit its breakpoint
ah or not so we've got a result because
in fact we have no result what went on
there
I D status waiting for activation
okay what went on there let's have a
look at the close that now close that
okay so what's waiting for activation
that's new to me
oh I'm gone we haven't awaited it will
wait the request to get the results that
help so if that's all the way through
but then we just returned from post
dating for that awaiting it so this time
we just press it and we should get all
the way to the end and just if we kept
the other one we just can't say yeah so
we've hit this break point now we've got
no data we returned and we should have a
result now from the server and then you
can see we know about the utf-8
character sets the content length is
minus one content tag has given us Jason
all the set of information was on
Firefox it's a post method this time now
the server is bonded okay and the
content though that you can't see here
is in the stream it's returned as a
stream so you can't just see that
because it's a method but we have the
result so we know we've got a result to
the state's codes okay with your status
code 200 so we've now got a response
from the server and that response is
this response here so it's this this
exact response and we will have got this
response back but this is in the
response stream that we have to extract
so you can see we've had all these same
head as we've got this haired oh we've
got the cast all got the chunked info
we've got all that information come back
we've got the status code okay so we're
getting an exactly the same response
through this call so now we're talking
from the Fassett a word application to
the server and we've simply hit that
Earl we haven't passed in any data yet
so we will now welcome as well and pass
on some data so the content let's just
class in its expecting a settings we
just did this as a demo so a settings
data model but we don't have that in the
peseta word application it isn't shared
so I'm just going to
copy this class in for now and she'll
get down here if I can put it there
we don't need key don't need comments we
just mimicking the same poco plus so now
this is the comic Mpho it's expecting so
if we were to pass in the new settings
data model ID equals on client name
equals pazatto
word you know just passing any info
value it was ha and there we go so we
passed this in well step do that once
more to show you the e
jason serialize are working so we go
into the request we do the normal stuff
but this time we have content so now the
content type is Jason so it's gonna do
the content string serialized contents
it's gonna see realize this objects that
we just made you have to ignore this one
stepping through its own code is wrong
and now we've just jumped over there as
well back to where we are so another
content string as you can see is the
JSON string so this is now going to get
written in the stream to the server so
it's rewrite to the stream there and
then we send it to the server the server
should now we jump over to the server
should now have got that but what I
think you'll notice is the model is
still not it's not pulled in so even
though we've sent it to the server
yeah we haven't the server hasn't
received it and the reason the server
hasn't received it is another thing that
you need to be aware of is the import
for matters and the content negotiation
so the output format that happens on the
accept header and knowing it knows what
tired to serialize to the input though
because when you don't specify a
specific route or a specific request
method like say HTTP POST and even if
you do this input can come from multiple
places
so it could come from cookies it could
come from the oil itself as we mentioned
with like their local host for us
attached question mark marble equals
blah blah blah so it can come from the
query string it can come from the body
which is why we wanted to come from it
can come from form data so there's
multiple places where this data can come
from and simply by saying there's the
data and we'll pass it in as the body
the body unfortunately is not the
default place where it looks for that
data so in order to Tallaght that we're
expecting this data to come in from the
body we've already told it what the
content type is going to be because
we've set the where are we we've
actually set up the content type here so
the server knows that we're sending
Jason because we've told it but it
doesn't yet know where it's coming in
from so to force this data to be found
from the body which is where it comes in
because that's where we're at it - we do
here we get the request stream which is
the body stream if you will I call it
the body stream anyway so that the
stream of the request we're at it to
that then we want to tell this with a
attribute coming from body like that
so if you put there square brackets from
body in front of this we run that server
again nothing else has changed and then
we run the client up again so that's now
running let's go - is that a word and we
run this one again we should now send
that request off to the server don't
want to break print there and now in
here this is a server hopefully there we
go we've now got the info from our
client so from clients utter word hack
so we've received data and this went
through the input formatter
so we said it's coming from the body the
content tactiles is it's jason and then
the content negotiation says well it's
Jason and it's an import format so it
looks for the the import format us which
has already got Jason in and it looks
for the Jason serializer import
formatter passes it into that the Jason
serialize are converted back to this
object using Jason convert
deserialize and we end up with the datas
that's kind of what's happening so now
we've got the data from the client we
send data back and as you see the
results come back but the data is again
in a stream that we now need to pull it
out of so that's the last step to making
this kind of initial communication so on
the web request side we now have this
post async which is good and we just
want to make another function now so it
will first be exactly the same as this
function so we will copy I'm just
thinking like the description will be
basically the same so we'll copy the
whole signature of the method paste it
so we now have an identical method the
difference is we are we want to post the
returned information back into an object
so all to do for that as well make a
generic method we'll call it T response
so CID generic I've done a video on
generics so postal web requests or nil
and returns the and returns a response
with the expected data type of the
expected data type everything else stays
the same so the first step to that is
make the standard protocol first this
will be server response will await the
post async caller Bob
so the non generic one to pass
everything in and that's all of it so we
get the normal one all this method does
now is call this method so that now we
get a HTTP web response so from that we
want to create a result you know what
we're expecting to return because this
is now a structured host we're gonna say
we expect this data called settings data
model and we need to know that succeeded
or failed or you know what's gone on we
are gonna need some return tag for that
so we'll create something we'll call it
I don't know where
request result or something we weren't
when Constance was go here to make a
class where the request results and
we're doing that because we want to be
able to return things like whether it's
successful or not if it failed why it's
it's now a more detailed response it's
not a raw HTTP server response it's
gonna be our specific response that we
figure out what's going on and if it's
returned the right type and thing so
this will be a a web response from a
call to get specific data from these
from a HTTP server first one we want top
flow as we mentioned is it's successful
every call was successful if it wasn't
successful we want an error message if
something failed what was the message
who failed this is the error message in
fact successful can then simply be if
every message isn't equal to naught
because you might want to set it to a
blank error message in case it fails so
we have the error message then we'll
have the HTTP status code we'll want
that's a useful piece of information
that's like the two hundred of it was
okay or not so we'll keep that from the
original response status code all our
status description because that comes in
with the the wrong response and it's a
I'm guessing it's a human readable
status you know ok succeed on authorize
so it's useful information that will
pass in
we'll want the again more useful info is
content type the type of content
returned by the server that'll be a mime
type so we put potentially convert that
to our type but we'll keep it raw for
now then we'll want the headers so we'll
have where it's web had a web pedicle
action there we go so that's all the
headers passed in and the headers are
the as we've seen multiple times now
that the headers from the response are
he a response headers that's a
collection of those all the response
headers same with Matt one cookies so
let's get the cookies and I'm doing all
these because we're not necessarily
using all these right now but as it
grows this is a bad man this is a
completely generic web request class I'm
making this is useful information if you
want to use the you know the higher
version to basically deserialize the
response into something but you still
want to access to you know remote a lot
of the key data that comes in with the
raw response so any cookies sent in the
response will have the raw server
response so that's the body
goodnight one that we can turn out we'll
pass it in but if say that's a huge
amount of data that'll all go into
memory in RAM on this machine so we may
not want to always receiver but for now
again keep it simple it's good for now
and then we can refine later
so the drawer is the raw server which
balanced body and finally we'll have the
object itself that we deserializing
the server response
the actual server response as an object
so that's the whole class that we'll use
but because that's not you know a tie
we need that class so we can simply pass
every result back if you will but we
once again sing class and we'll use
generics again to have a type and that
will inherit the web request result so a
in fact is the same thing about response
from a call to get specific data that to
get called to get a generic object data
to get generic object data to get
specific data so yeah the type of data
to serialize the raw body into the
serialize is not a word again apparently
request we hold so all you want to do
for this one is do a public new server
response and that's what we build it
yeah so all we're doing is taking a
normal class where you can have just an
object in case you don't know the type
but if you do know the type and you pass
the type in it will then make it a nice
helper property that can return it as
that set type so you'll see that in use
in a second
that's the underlying object to be
specified doesn't technically cast and
that's a while it does cast so though we
have now a results that we expect to
return so that was a bit long-winded
just to get the starting boast of what
we want to return but now we can return
the web request result now and now we
want the T response so we expect a
specific type to be returned that
matches this type
so now we'll have a response type based
on the response we passing again this
will make more sense when we call the
method but you'll see that's that will
now help us to construct a response so
we can create a result
so first we'll just make a general
result which is just this class but
instead of doing new web requests
results because what you'll see is
there's a web request result r/t
response and then we typically fill in
you'd start by saying the state's
successful States failed rollout not
that say you've got like a content type
the content heart would then be server
response dot content type headers would
be server response headers and all
that's like every single time you want
to make result so we'll make use of what
we did in the last video which is we'll
do this but we'll make it from an
extension method so though server
responds and we want to say create web
request result to say and it'll need to
know the T response so it needs to know
what type to create it out of and that's
it's a lot like an extension method note
to help with this so we'll make another
class and web for HTTP web response
extensions remove that remove that
public static class extension methods
for C HTTP web
response and we'll that will work in a
minute once we have the extension method
yes and then what did we call it paste
that in a second
all that that C response
and that will be a web request results
she responds from retaining and then you
just return a new thing and the
extension will pass an HTTP web response
control dot in for the namespace server
responds that's a basic extension method
returns a web request result populated
pre-populated with the HTTP web response
information the type of response to
create a server response return and you
where the best result content I had us
now can fill on the rest so the server
response door cookies right we have raw
server response we'll get down a minute
server responses the things status codes
server response stop status code status
description I'm pretty sure it has one
so every response star status
description yeah baseball got stuck
spacebar kick in stock status
description
it's now left with aromatic riches up to
the caller to set the server response
will naturally be what will fill by in
based on the type later said both of
them I'll get filled in the raw sort of
a response though we can get so we can
do and what we won't be turn it there
then because results equals the response
we should only expect to get a recycle
stream that we can open if the server
has returned a two hundred I think for
now and presume unless it returns the
status of okay it's trying to tell us
something which potentially mark which I
would say always means you're not going
to have a response body so I'd say read
in the response body yeah my Spaceballs
properly messing up at the minute change
that so if we got a successful response
so if that's really annoying this is
definitely got a W space button so if
not successful if status code one second
I'm trying to fix this keyboard there we
go just the space pocket in stock so
everybody's all dot status code is okay
so the two hundred then we will read in
the response and like I say we might
change this in future but for now that's
what I think we need so we'll do it
using far we've spawned stream equals
server response tour get response stream
then we need to do the same again screen
reader new stream reader response stream
so open the response stream get a stream
reader and then read in the response
body so now the result dot roll response
will be dream reader dark read to end
and I think that is it so that will
create us a I have to return the result
our creators a result nice and easy and
a lot likes tension method so we can now
do create web response result there we
go so this should now convert our
initial raw HTTP web response into this
nicer web request response and it should
also have read out the body now so we
then just assess return the result for
now and call it and we'll breakpoint on
it and see what happens so the app now
instead of calling post async and raw
also need to do a sailor expecting it to
return a second's data model like that
and now in this call because we've
passed in now settings data model there
we get it here with past settings data
model into here so therefore we create
this object that's got now a server
response of that type in the return
result and it won't have anything yet we
don't set it but it's there as a type
but what we do do is then read the raw
server response so when we run this
resume in the server still running yeah
there should at least now or read the
body out for us and also give us like I
say this nice plus that we've made to
setup information on it so we hit here
this is the server we don't need to see
the server being hit now we've seen it
being hit so got the server response as
we've seen before and the result now has
the content type in it the cookies
where
on our error message nine we've got all
the headers so we've got all the four
pieces of info and now we've got the raw
server response which has been read from
the body so you can see the info here
finally has come from the serf of what
we want so the last step now is to
convert that up to our original class
this now settings data model so that we
can simply make a request to the server
like this pass it in an actual class and
get returned whatever class you want in
one single call and all you have to do
is tell it that the end point that we're
asking for so this is the start of
making that you know as you can now see
the communication between the client and
the server so we can now say if we're
sending a message we could just say new
message model and the idea is our ID the
name is whatever the message is what we
want and we can send that info to the
server it can store it in the database
send it off all the pushing
notifications to the people that message
went to and return back a model that
says whether it succeeded or not and
whatever info all within a single line
so this is what we're building it up to
so we have that response we've got the
result so now like I said we want to
convert this to an actual well a Jason
DC little I say or deserialize it based
on the the expected you know civilizer
so what we want to do first here is now
we've got the result it might not have
succeeded so if the response in fact the
response might be no would it ever be no
I don't think glug be not now pretty
calm again of it happened to be normal
we'll fix it to that point so if the
response status code is not 200 so if
result dot state is present equal to
okay
in this instance like I say we can
change it as we go but I'm gonna presume
call failed and we'll give it a reason
and won't have it to do to localize the
string in a minute localized string so
we'll set the results dot every message
to
so ever returned unsuccessful state
status code so basically something other
than 200 so we'll pass that info into
the message as well server response
we're status code and server response
dot description takes at least a
informative piece of information that
can be given out we've done so that'll
just return the result now the failed
world so this is the check if it
succeeded or not based on the status
code every succeeded then we want to now
convert or deserialize raw response I
guess that's like we've got it response
so we don't have a response then I think
the only thing left to do is return the
result again so if we have content to
serialize or if we have no content to
deserialize so if result dot raw
response dot and then this is where I'll
make a helper function as well so how we
have to do string dot is null or empty
and then you pass in the string as I
mentioned in the last video with
extension methods I don't like doing
this way around I want to do we saw doc
response doc is no more empty makes much
more sense so we'll just quickly make
another helper method so strings class
string extensions remove extension
methods for Strings public that the
boolean is no or empty this string
return thing got as nor empty content
there's two empty string is null or an
empty string the string and then we
might as well just copy and paste that
and do the other the other one is null
or white space or there's null or an
empty string or just white space that'll
do for now let's now we should be able
to do that which we do so if we have no
content to visualize if it's normal
empty then just return result done
otherwise this Y is the serialize still
showing as do you see realized I
shouldn't be showing as a typo yeah okay
so now we just want to deserialize the
result so this is where I'll have the
switch again for now or simply the we'll
have to try and catch this because this
could fail and then this is where we'll
throw you know our expected well in fact
we don't want to throw here we'll just
catch an exception but the deserialize
would fail so instead of throwing in
this case it's an expected potential
failure so if deserialize failed then
set error message because they're
expecting a results that can be failed
so will not fail for different reasons
so in this case the result would be all
the error message there is all welted
deep serialize server response to the
expected try and then they can gain the
rest of the information from the natural
object and then
we turn the result again not that it
masked a fall through but to make sure
we go to result there so in here now we
simply want to check if the did we call
it the content the sent app says the
response so it's the return type what we
wanted to see realize so if return fire
equals equals Jason we do Jason I'll see
if return type equals equals next man we
do that else and this case we'll do
similar to the other one where it's an
unknown D serializer basically so we
would copy and paste that and we would
change the message to unknown type and
then return type or not you realize
server response to expected tax so
that's kind of again if we don't know
the type to return and then we know to
come into here so Jason or Iceland
account Jason XML no so we have Jason
it's again nice and easy so the one
thing we do want to do is share or if
the server response time was not Jason
so we also want to check as you as we've
seen on the websites we can request
first a XML but it return Jason when it
wasn't set off so just simply requesting
to the server that you want Jason
doesn't necessarily mean you've got
Jason back so it should check if the
service told us the content type so it
our server response dot content type dot
to lower if that contains because again
that the return type contains
application JSON but it's got character
sat at the end so we can simply say if
the content type contains our
mine will will presume it's the right
type so if it contains the known
serializers Jason in fact we've got the
return type return type doctor mine
string and that we can actually we can
make that universal for all of them to
do a check so don't do this check every
time so we caught that actually we want
to deserialize first we check check of
the server type was not the expecting
type so this would be if it's not
contained within the content type so
we're saying if if the server returns
content type here like application Jason
but we've said to be application XML so
if it doesn't contain it within the
content type we're going to say hang on
there's an error the server didn't
respond you know didn't reply with the
expected type so fail due to unexpected
return type so it could be server that
did not return data in expected type and
then we can also pass in the type that
it did return so you could say a
expected received and that will be
server response content type and this
would be return type dot to mine string
so then we'd give you no information
back to the caller that's obvious so
that's a protection to make sure first
the type should be of the type we're
expecting it to be before we try to
deserialize and then deserializing is
just as easy as the other one it's
literally one line so it would be result
dot server response equals
Jason convert dot deserialize object as
the expected tide and the string value
is obviously now the result dot raw
service box the serialize jason string
and that's it
again the XML is a little bit more work
if we if I can remember where we've got
the upper two miles serialize where I
can just copy and paste most of it so we
do that copy and paste
they often the same request so we will
have in here it's similar like it's not
the same create the serializer this time
though it will be type r t response and
then create the string right will now be
memory stream create a memory stream for
the raw string data there's a memory
stream and factors almost no point copy
and paste in there the result dot server
response equals now the xml serialize
dot deserialize and will pass in there
hang on then put the data in the memory
stream but that's probably get it so you
serialize thing to do every time a
string so the memory stream info
actually passing that the info this will
be d and coding in to Tahlequah perform
at our string is which by default should
be utf-8 and the yeah bikes from the
result draw a response string
so basically convert the utf-8 string
into bytes that can go into the memory
stream that can now be read in to
deserialize which will go back to a
string but unfortunately that's the way
we do it
do you realize this except generics know
this utilizing objects you just need to
cast it to a expected to response so
that should deserialize xml as well I
know we're not using that but that's
fine for now so if we run this now we
should have basically the finished
result if you will so we hit this now
and we step over that we know the
response so we have the response we get
the result we now see the result with
the Jake's name because that's what we
requested the state's code is okay so
it's fine it's not empty so it comes
into here it's now it'll look at the
content type which is application for
sauce Jason with character set but our
return type is Jason so it should be
included so it passes that logic then it
goes to it Jason and it DC realizes the
royal response which is that string into
the server response object which is now
back up to a full object and then
returns the result so what we're now
left with from that fall is we actually
have a server response that's got a
settings data model that's got the info
from the server so that is now we've
made that call and we can now do result
dot server responds dot and now we've
got the hard-coded
you know info from the server we're back
to c-sharp classes so that's kind of the
whole web structure there it'll get
improved and added but that's the
starting point now where we can log in
from this application so when we click
the login button now we can construct a
login data model pass the info in the
username and the hashed password that
the user sent and send it to the server
and get a response and see if the server
returns us with an access key so this is
the starting point to now finally get
these two things communicating so let's
just do a quick change on this to just
show you the XML let's make sure the XML
this works
so we can have the posix cent type to be
XML and I think that won't matter so we
can send it as XML and we should still
get the result back just fine because
our server has an XML input civilizer
and the content header will get set
correctly so everything should just
simply work and the result should still
come back yes you can see there it all
went through as XML by going to enter
here post the data serialize and then it
did this so we we were to restart this
you'd see that it comes into this call
here and we see realized the content and
then it writes this to the server so it
writes this string now instead of the
JSON string and we set the content type
here to XML so the service handled that
for us fine which is what we expect it's
an Atlas check if it can return the XML
as well so we'll change the return type
to XML and again one that with the same
object but on either side it will now
return XML data so that would be the
result it's fine response now we expect
this time to have xml the response says
we have xml which is correct so this
time we go to the xml gets a serialize
and memory stream and destabilizes it
and obviously the wrong response from
the server was this so it sent back XML
again and that's still worked and
deserialized into the same object so the
bottom result is there we've technically
just communicated via XML but nothing in
our code has to change other than we
told it to do that we can also really
quickly test the server the our fail
logic if you will so let's just comment
out these
so we don't handle XML and spin this up
and then in the word application let's
not make you fail on send let's at least
send the expected type of Jason let's
just simply ask for XML back and this
should fail to send XML back because
well it won't it'll send JSON back by
default as we saw but our logic should
catch the fact that we've we've got a
result that doesn't match so another
content type is return JSON you can see
but we're expecting XML so this is now
I'm going to error out we're going to
return and our result is gonna say
successful successful true is wrong why
is it successful let me just go to I
think I must have done my logic
back-to-front successful is if it equals
not not if it doesn't equal nor Wonka
there we go
so the other message is not successful
good job would check that so we have the
post we get the result and it's now a
successful false and the message is
server does not return the expected type
expected XML received Jason so I'd say
that's a pretty success I'll Boop I've
moved that all the way this never goes
back way expected to now mmm ending me
man II don't know I've got to fix that
laughter so hopefully that was useful
for seeing now effectively how we
communicate between a client application
and a server and that you can see every
single part of it that's this web folder
is in essence the whole wall and it all
just boils down to this this class here
so again there's no mystery about it
there's no complexity but what we've
done is constructed it and then built it
into a nice set of helper methods so it
keeps it easy and clean on the client
that now the client can make one single
web request like this one liner to get
you know information back from
the server and you're literally sending
a class and you return in a class or the
other way around you send in a class for
attending the class so it makes it
really easy to work with so again as
usual any comments and questions let me
know in the video in the comments below
and also I'll just mention I have now
got a patreon patreon let me know how
you pronounce that I'd say probably
patreon so I've got a patreon page if
you want to support what I'm doing I'll
leave their link in the description you
know every little helps so if you feel
this was useful you can you know support
me on the patreon as well so any
comments or questions let me know and
hopefully this was useful</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>