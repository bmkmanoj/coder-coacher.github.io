<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>C# WPF UI Tutorials: 34 - Application Log to File Logging Logger | Coder Coacher - Coaching Coders</title><meta content="C# WPF UI Tutorials: 34 - Application Log to File Logging Logger - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/AngelSix/">AngelSix</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>C# WPF UI Tutorials: 34 - Application Log to File Logging Logger</b></h2><h5 class="post__date">2017-12-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/GO-ADMgoTus" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so following on from the last video we
had lead login to the application so now
from anywhere in your application you
can do IOC log without log and we also
added some color so if we just run this
you'll see we've now got this color this
color comes in from an extension so if
you go to tools extensions and you
search for vs color out what I think
it's called and install this one you
don't have to well this is the extension
we've made the color work with naturally
otherwise you just get the text not the
color it's now can log to console debug
I think there's the - we made let's just
share ya the console on the debug we're
not going to write a file so not to
write a file we need to actually Pat out
the application all a bit more first and
actually make a file manager to read and
write to the file system so that's what
we're gonna do in this video
one thing I've added in advance just
because I don't want to waste time
explaining the writing this code for a
simple single task and trying to explain
all these specifics I can do this
potentially in a separate video but it's
it's just off topic right now for what
we're trying to do so we have here a
class of added so you can just pull this
from the source code called async/await
ER and you've seen in code we've done
lock and this basically prevents
anything more than one item from running
this code while there's a lock so if you
call a blogger six times
all on different threads the first one
will hit this lock and then go inside
and now all the other five threads will
sit and wait outside until this is done
so this basically make sure this is
thread safe you know only one thing can
ever access this at a time now the trick
comes where this is synchronous so it's
not returning a task it's not inside and
await it's not asynchronous so it's just
a synchronous task anyway or a
synchronous function being run so it's a
different kind of thing than when we
have a task so we're looking at any
function where we have a task in the
application
like just the animation say where we
have this task the caller needs to await
the task for it to complete otherwise it
will carry on without it and this is
just a synchronous development so it
bubbles up to the point where you know
this caller is then calling async even
though it's void meaning that the thing
calling do animation won't wait for it
to finish because this is only await in
itself so then these callers won't await
to let's all hit here italic to do an
animation and carry on but that's kind
of slightly off-topic but basically
you've got synchronous and asynchronous
tasks and in general asynchronous you
know run off to the side if you will
unless you await them so you can't
diffuse a lock on an async is the bottom
line you can't just say inside this
asynchronous thread we did you know lock
and then you'll see this complaint
basically cannot wait inside the body of
a lock statement so and it won't you do
lock you can't then use asynchronous
code so what I've done with the async
await err is allow you to do this bit
the lock and instead of doing lock you
can do await async a waiter and it's in
there dot await async and then what
there's now doors instead of passing in
an object to lock I've simply passed in
a string so you just make a unique
string so this could be what you could
do is say name off and then this
function you just got to make sure that
you know the key there the string is the
unique thing so that anything accessing
this this same string you know anything
saying await async with the exact same
string what actors have your lock in the
same object and please replace that
there and then in here is your task to
actually run so this is right under your
asynchronous task
like that and then there's also an extra
option that you can't do with a lock and
this is potentially allowing more than
one element through so you could have a
lock that let's say three or four tasks
to run at the same time and then simply
waits otherwise so by default it's one
so then this will just go inside here
and basically that axe is like a lock so
this will await just like anything else
in the await statement and it won't get
to here until it's done and this will
sit and wait of 6 threads hit this at
the same time a synchronously wanted get
in do this task which could go on for a
lot longer and the others had sit and
wait until it's done so that's the point
of the async await us to simply allow
you to lock asynchronous threads and
like I say I could go over this in
another video but the key to it is using
the semaphore slim which is basically an
asynchronous Locker and then when we
call the async await there's one to get
a result from one to just run a task we
lock ourselves first using a semaphore
for our own a waiter to make sure this
call itself locks correctly because
we're checking if there's already a key
that we've passed in so we can a self
lock check if there's a key if not we
make one and add one we then release the
lock on ourselves so it frees up the you
know the call then we get the semaphore
for the specific key we passed in and we
wait for it to be finished then we run
the task that's expecting and when the
task finishes we release the lock so
that's kind of how it works in a really
quick overview and I've also added a
logger using our i/o seed logger of
anything crashes but then to carry on
through our window just catch the error
and ignore it allow it to propagate off
but at least make sure we logged it so
I'm not going to great detail on this
but you can either read the code and
comment and I'll reply or I'll
potentially do a future video on it but
ultimately all you need to know is when
you want to do a lock on an async thread
that's what we'll be using so that's
that's that little bit out of the way
let me just make sure this file hasn't
changed
so we've done that now we want to lock
to a file we'll need to start with
something that can write the files
before we can lock the files so let's go
ahead and create a new folder and call
this file creatively I've already got on
full file just include the folder and
now in here add a class will call this
file manager then we want to add this to
a OC and then it users commented on a
new short but I delete the unused using
statement so you can actually press ctrl
or G which I didn't know which is cool
that's a lot quicker so I'll have a file
manager handles reading writing and
rereading the file system this will want
to have an interface of what we want to
do so it will be in IO C interfaces and
let's add a new class they're called AI
file manager and this would be public
interface file manager or copy the
comment and in this file manager what do
we want to do we will have just put one
in for now I think I'll have a task
right all text to file say and the text
and we can have we don't need to put all
just write caps to file the async
because it's a task
path or text or text or path down and
which way around to put those probably
text because we're saying write text to
file so to kind of keep it in order with
the the name of the function so text
path and then we'll do a boolean for
everyone for pen data or not and will
default it to false and that gives the
ability to you know write to the end of
the file or simply overwrite the file
that's the text to the specified file
path or specify the path and X plus bad
file and well I say we don't want to go
to complex text to write the path to -
right - there's a lot twos in that
sentence it was the path of the file -
right - if true right the tapri facility
and put the file otherwise overwrite any
existing file so that's the function we
want to implement copy that paste that
in public facing task and now we want to
actually do this code so one thing we
want to start doing that we've got the
logger it's thinking about catching all
exceptions everywhere and the
application logging them correctly and
recovering however we like because
that's again off topic and really a
separate video we'll do exception
caching later so I'll just put to do
here to add exception capturing and then
we're just not going to bother with
exception caching for now then we want
to lock this call because we're dealing
with a file you know a specific file so
we want to make sure only one task and
access the file at the same time
otherwise you'll get a you know a system
error that you can't do
so use this new async/await er and we
don't need to return a value because
basically if it succeeds it will work if
it fails we want it to crash and bubble
up and then we handle the thing calling
this then handles the crash see if it's
an expected crash and you know it did we
don't know how the caller wants to
behave if we were to return a boolean
simply a success or failure that's not
much information so if it failed well
what did it fail on then you have to
start returning a boolean and then
passing in a ref for say an error which
you can't do in a sync anyway so that
will complain that you can't pass a
referent so then you will be stuck with
them potentially making a topple here
that returns a boolean of success and a
string of result and then it just starts
getting messy like that and then what's
a string error gonna do for the caller
function how is say when we make unit
tests in how is unit testing give me
make use of a string how's it going to
know if we failed simply because the
files in use it's not descriptive it's
not in any way helpful so we don't just
want to return success or failure we
want it to work if it succeeds and crash
if it fails and then in the crash error
codes that we make we can be very
specific to why crushed and then unique
testing and users and our code can
handle that much better
but like I say exception handling we'll
do next not in this video so for now
it'll either work or the whole
application will just crash it's
basically the point
so the async/await it will await we just
want to await a task we've got no
results oh it's the await async the key
wants to be unique so we could just pass
the path in but really what if something
else is handling a path whatever we've
got a delete file path or something else
so what we'll do is do name of and then
this function and then plus that path
just so it makes a string that says
write text to file a thinker than the
path itself so it's unique so that will
lock any caller that calls the write
files rating or to be honest because if
we want to delete a file writer file we
actually want it to be the same file
that were locking we only want to ever
perform action on one file at a time
change this to file manager and then
every call inside a file manager that
deals of the file will make this same
key using this kind of you know
specifics we should also normalize and
it resolved path potentially so if
somebody passes in a path that says C
test and file and another one passes in
C test some file then that's not you
know it's got a result the same thing
effectively but our lock won't work and
you know we want normalize it so that
you basically have this so a large
normalizing near the end and all will
just drop it in you know in the next
video is part of the exception caching
but basically all it pretty much look
like path equals path doctor place /with
backslash and then potentially trimming
the ends off
we have white spaces either side and
doing an absolute path but you don't
really want to that's that's not really
normalizing absolute path is resolving
so they're being normalized which would
be that and then the be a resolved what
you do apart as it could get full path
and that will resolve you know any
relative putts inside there so we'll
make that the end potentially but what
we also want to do here is this would be
a switch based on which platformer on so
we're on Windows you go to back slash e
over on Mac all and actually go forward
slash but again we'll come back to that
but let's work through this first so we
haven't normalized the path what we will
do then you want the tasks to run itself
so then we'll make a anonymous lambda
function there and now it's expecting
that task to run and in here now so
we've
block the file like the threat to this
file sir only one method can pass on
file
that's better long no block the threat
and lock the task simple enough does we
know what we're doing we're locked into
a single call now in here because we are
the reason I'm making this a task as
well is because this is an interface
that we can replace in the future and if
we don't start doing asynchronous stuff
and then in future we move to a UWP and
their file management is all
asynchronous we wouldn't then be able to
call this in a way to correctly get
yourself in a mess so really want to
start making all kind of calls and all
functions asynchronous and then we
simply want to run an asynchronous or
everyone want to run a synchronous call
which is what we need because we have
say file dot write all text you can see
to avoid it's just simply you call it so
that's a synchronous call if we want to
do that but inside of this asynchronous
call all you have to do is return path
start run or awaked a stop run because
we've taught the async there so you then
do the task top run and then you run
your task in here so it looks like a
little bit of extra both this is but
this is it so that in future if it did
become asynchronous say we then had a
function that was actually a waiting
here like say just tripped a stop delay
but say this was getting the file stream
when it was awaiting after that over
here then you wouldn't need the task run
you just then do that and then do your
file rattleball a lot so it's all based
on if you need a synchronous in the
future we have it available in the
interface and then our unique testing
can also handle that so we want to be
asynchronous because everything going
forward becomes asynchronous is that you
know kind of the new way of doing things
so you can correctly await and handle
tasks and a non-locking synchronous
fashion and so turn or than the
synchronous file access as a new task
and that's just simply because it needs
to be because this is an asynchronous
Locker and the interfaces are
synchronous as we mentioned so we've
done that we also want to here is
another note we'll do a lot of stuff to
come back to and I see dr. task dot log
log log in we have faster run logs to
the logger on failure so another thing
you have to be aware of is when you have
a task and the way that we handle this
is we're going to crash if you know if
anything goes wrong we'll crash we want
to really the call of this to do a
try/catch and lock the error but say
this is an asynchronous call to write
text to file and say in our app here
we're going to use that and we just did
little to make one for now just to show
you so we were then calling right
texture file it's going to complain for
one that we're not asynchronous because
you know when a thing here we're not
waiting so it's gonna warn us that this
will pass through which you don't always
get that warning it depends where it is
and what it's doing is you know like
certain places
it just won't complain because you
didn't notice your synchronous anyway
but you get this error or this warning
rather we just ignore it
well this means as it knows that this
thread has called this but we're not
awaiting it so ultimately that means
that if this crashed or we learn through
an error here if this task itself or
crash which will crash this because it's
awaiting the task which will crash this
call a thread but the problem is this
call of thread is off it's not in sync
with this synchronous thread so that
boils down to meet you know if we had a
crash in heat and we weren't awaiting
then that error is gone it doesn't exist
it won't be found it won't crash for
application nothing will happen so to
show that we could actually do throw a
new argument exception if we run this
now and we see here and we see here and
here and then we run your farm we get to
here so we call it and now see step pass
perfectly fine and the application will
carry on we then throw here which
bubbles up to nowhere has disappeared
and now we carry on with the application
and the application runs then because
I've added a lager here though to our
and this is why I've done it to our
async Locker this is why we've got the
exception appearing because you know
I've added it to our lager but you can
see the applications running so this was
a release application and you know a
users using it all all your users are
using it you'd be unaware that something
has just gone wrong and that could be an
important thing and usually is so if you
just failed to save the user settings or
you've sent a message and it failed
silently and the user thinks you've sent
the message it's not good so the lesson
here is really to make sure we we log
and catch or at least behmen when we log
the error so they're not silent and they
don't just disappear into nothing and
what just unaware of them and when you
work on tasks and you start doing this
async task it's very very easy to simply
not wait one of the tasks or to do a
task top run to purposely get off thank
you you're in a synchronous thread and
you want to run something in the
background you sometimes just do a task
trun to break out the way of it but then
what that means is if that task ever
failed you're never going to know about
that area so again slightly off on a
tangent but then this note if we make
IOT Taran then instead of just doing
tasks top run what we do is do a try
this would go inside
catch exception
and then we do IRC got logger dot lock
and we'd lock the exception so at least
and then we've throat to carry on and
then have anything did crash at least
we'd have it in our log file regardless
of whether our code awaited or not so
it's just that extra bit of backup that
if things start going wrong silently we
have some logs somewhere - you know
debug the issue so that's what we'll do
after there for that reason even though
this will technically log we want to get
rid of using tasks top run everywhere
and make sure we we always call that our
our IOC tasks run so that we have some
kind of login baked into the you know
he's just a fallback basically safety
so finally we bake down to the simple
task of writing a file so we want to
write this text to a file and that's the
easy part
so rather large message it's a file so
we've done the interface so that we can
inject it into IOC then we've
implemented it we've got the function
we've locked it so that a single call
will only ever get in here and then
because we're actually synchronous will
we've jumped onto a task to make it
asynchronous for now and then finally
the actual work involved here is just to
make a file stream or cast it to attach
writer so we can just call right and
send in some text we want a new stream
writer and we'll open the file so we
open the file stream with the path and
we expect it to and now this is you've
got append so this will say opens a file
if the exists if it exists and sticks to
the end or creates a new file sup is if
we want to append so we will have append
question mark
power mode dot append otherwise we say
we want to I guess create the file or
override it so that will be specify our
business and should create a file after
exists it should be overwritten so
that's the one so basically if we want
to append we'll open it as an append if
we want to otherwise we want to create
an override it's that one
so this opens a file stream then we pass
that into a stream writer because that
expects a stream so that we can write to
that stream we've just opened and then
we simply cast it to a text writer so
that we have the dot write function on
there so finally we can then do file
stream dot right and now we can simply
pass in the string value as one of the
overrides and that should be all there
is to it so that would be the test value
the using all the using statement does
we don't know is disposes of the
variable inside using so this statement
here is exactly the same as doing of our
file stream equals this far right file
stream dot dispose but slightly
different because what I'll do is do a
dry finally basically to make sure that
it will always dispose even if this
crashes so a finally statement means
that if you try to do this and after
that would be there if you tried to do
this and it failed or crashed here you
wouldn't yum caught the exception
because we haven't put a caption but
disregarding that either way on success
or fail this will always run so no
matter what happens here once you've
created it it always gets disposed and
that's all I using statement does it was
exactly this this is exactly the code
that runs and so that's just a shorthand
way of making sure we dispose of this
file stream once we're done that will
write the file and that's it so that's
the file manager so if we go to I of C
now let's get this chopped into IFC so
we will have a file UI lager then we'll
have five here shortcut to access the I
file manager file file file and then we
want to go to where are we
the app sam'l and here we want to move
that one off run the logger to come
first they don't they bang you
I let's bind the file after the logger I
think that's fairly low in terms of its
high priority it's low on their order we
want it to come in pretty quick behind
the file manager so now we pass in a new
file manager and now everywhere in our
application we can do iOS you file to
write to file so if we did IFC dot file
dark bright text file some text and we
do tests txt not sure whether for go I'm
think it will go to this folder so we
will see so we run this we write some
texture file and have we gone here nope
so we will probably have gone to either
one on nope all we've done for the bin
output may be depend on by the default
thing is basically the default path
because we passed in a relative path I
cannot see it anywhere
so did we succeed for an information
application start in set to statement go
into the statement nothing actually be
one so oh yeah we didn't await it so as
I was saying this is how easy it is
we've we've called that function yet
there's no warning that we need to await
it so we've hit here but we haven't the
weighted it yet so this is an example of
exactly where I was saying if this
function crashed it wouldn't go anywhere
so file doesn't exist yet simply because
we haven't actually run the function
it's it's gone a synchronous so we hit
there and now hits here so now when we
write the file it should appear
I'm guessing either in here
nope or in here then you must be in here
there we go there's the test file and
there's some text and then we might hit
you a second time there we go
so if we were to now pass in say the
append into here and say let's attend
the text of the file so we'll just say
FN true and say some other text and this
will appear on the same line but now if
you run the application and then check
out the file and we should have now some
text some other text so we can see the
file right to file is working so we can
do this now wherever we want to write to
a file it's that's the file manager side
done we've added the thing there we
should also in when we come through
exception caching which again is the
next video we want to wrap everything
everywhere so like even the start of a
call you'll actually end up doing try
and I capture around the whole thing and
then login the error or displaying it
you know we can't be covered from that
of the application fail to star but we
could at least either write to a log
file but it might be a log file it
crashed so in this specific specific
instance here where we're unsure of
anything we just explicitly type some
code that maybe displays them a message
straight to the user so they can you
know raise the book to us but again
that's the the next video we don't want
to go into that in this one so we've
done all that the only thing we now need
to do is to make a file logger that then
makes you to this file writer and we can
add it and then log two files so if we
go to logging and we make another
implementation call this file logger and
then we get rid of that probably with
the class file logger
I lager logs to a specific file control
dot to implement the function and analog
here we want to add a public string file
path to this logger a path to write the
log file to so that will get a set up
logging methods and then we also want
the constructor and in here we want to
always pass in a file path because we
need to know where we're logging to
otherwise we can't do anything and then
we just set the public property to that
so they can be changed afterwards and
access publicly as well that's the
constructor and now the log so again
here now we've boiled down to ultimately
log into a file we mentioned that we
should try catch everywhere you know
again this is boils down to exceptions
so what would you do with the file
logger failed we would we wouldn't
necessarily try caps this call we'd want
to try catch at the uppermost levels so
you don't want to all your code have try
catch and every function that's not what
I'm saying it's more about that
everywhere that then is the top level so
like the application is the top level so
he had want to try catch and then
anything inside there doesn't matter
because it's caught and then when you do
specific calls like inside of say click
event on your view model to change to
another page you'd want to try caps that
command and then if that fails log
correctly you know so that's but again
likes a whole new video so in here we're
not going to try and catch any of us
because ultimately our
log factory would be the one to catch
any others inside of the log here so it
would lock them for each one it would do
a try and catch inside of here and log
out too
you know it would do its own logging
because the the one key thing is of the
logger itself fails you can't log the
error so you have to have some real
low-level code that simply should never
fail and just as a basic logging which
would probably be either directly to the
user or to a console or you know however
we want to do that we'll come to that so
now to log to a file with new IOC dot
file dot write text and the text would
be the message applause I'd say an
environment and right environement dot
new lion so the each message goes on its
own line the path would be the file path
that we should be logging to and append
should be true so write the message to
the log file and now we want to make use
of that file logger so if we go back to
here where we make the log factory we do
a base log factory which already
contains the the debug output and then
in here we also want to you can't do
that we can you can't initialize that
way we could technically pass in allow
this to pass in a new constructor and
we'll do that so beta log factory that
accepts say an array of AI loggers so bi
logger array and these would be loggers
to add constructor with extra bloggers
vloggers to add Lily factory on top of
the stock loggers already included
so this would them be
loggers dot for in fact you do it for
each on an array nothing you can't no we
can think about this we can pass this in
as the default constructor just simply
pass it and there's no by default don't
move that up to there get rid of that so
we still have one constructor them so
other cons for Walker add any other
subclass then and then we just do a
loggers so we actually have some for
each logger and loggers blogger like so
so if loggers isn't suitable not and
this would add each logger so now what
we can do and that bit easier way of
keeping it in there kind of single line
inside of here we just do new array and
we've then passing a new file logger
pass the path and for now so this would
then create a base factory don't really
looking shorten this anymore I don't
know we can't let them know unless it's
come further notice that's the shortest
way we can do that so create a new array
and then pass in the file logger so
that's how we pass in one and then you
just pass in another with you know say
there was two he's passing another one
like so not add two of them so we add
the file logger and then the key here
now is it's expecting a path where do we
want to make this log file so this will
boil down again to something else to do
so to do and this will be add
application settings we can set edit a
large location so we'll do this in
another video for now we'll just
literally for it in the relative path so
we'll go where we originally had it
for now just log to the path where this
application is running it's as simple as
that
so we now go to this is where we're
running from we delete the test and we
just run this it should now bind we
don't actually but we should have that
application starting actually so that is
now up and running we should have a new
file called a log which we do you can
see is now logged to a file and there's
a new line ready for the next lock does
that have the time and date no it
doesn't so the one thing we want to add
to there is I thought we'd added that to
all logs is the time and date for you
know with the log messages so I guess
that depends on the view if you want
that everywhere or whether we add it to
the file manager you know that the file
log so we could specifically say in the
file log here we want to write get
calling time for in time equals and we
can have it with the now-now time is
basically in your current machines local
language so whatever your machine set to
look so I'm in the UK so that's the UK
time if whatever reason you wanted the
universal time so it's the same anywhere
like so you're doing it based on
searching or filtering or you know
comparing UTC is universal time so it's
will use the local time for a log file
and what they were to string some let's
see if I can remember the string value I
think everything you've got day a month
I thinks the capital I always get this
wrong and yeah so that would be like day
month year so in order for you to sort
correctly you'd have your first month
day another minute minutes our second
and maybe that's correct just complain
just a spelling I'll just go spell
checker in here so I think that's just
complaining because it thinks it's a
spelling yeah so let's just hit that and
let's see if that's actually right
so the current time is like nine
probably from 9:00 in the morning see
where we've hit we have so this the
month is twelve the year 10:17 the day
is a sick that's correct
48 wrong that would be not sure forty
eight nine fifteen or we are nine forty
eight fifteen oh yeah it's right then I
just need to make sure put the hour in
the minute they're out way around of
health so our mini second so that should
give us you know a current time
correctly so then we have the full
sorted date and time so we will now
append that to the log so what we will
do here is make a new string or port the
current time at the start which will
always be the same length as well which
is handy and then the file and I've done
the stuff I'm way around the messages at
the start it goes here by the message so
with that then the message then new line
so now the file Locker has got the time
we could also set a boolean here if you
wanted so probably boolean log time ever
true loves the current time with each
message and again you can put this in
the log based log factor in have it
logged everywhere or you could do it
individual if it makes no difference we
can tweak this as we go however we want
and by default I'll have this set to
true I want to lock the time
and then we have we will do lock time
question mark all of that
or rather lock time question mark will
be current time in confusion out we want
to go into here really this whole thing
let's make it cleaner let's move this
out before time log spring equals log
time question mark if it is then we want
the current time otherwise we want the
blank string then all you have to do is
pass that variable in here so there we
go drat the message and this would be
prepend each time which is a log if
desired now if we run that and the
application spins up we now go to the
text file and we now have the time of
each lock which makes more sense
especially in a file log so that's
really the file login done let's go back
to a few things prepend I thought was a
word please and I'm sure depends a
single word I'm gonna make it single
word so we are in call it's right click
what you can also add as well which I
find handy is extensions installed and
have a look for visual studio spell
checker and then this highlights the
purple things in your comments to make
sure you don't miss typos if the certain
words that we use as developers like
prepend time chose a singular word I'm
going to make it one you can right click
on your project add and then spell check
a file and go to ignored words and add
whatever word you don't want to be flat
you're not like prepend
and save the file they won't show
instantly sometimes just closing and
opening the files and off for then it to
go away but then it keeps your
spellcheck incorrect like this SS as
well it's just annoying so we'll double
click an ad SS because that's for our
string and then closed and open then it
should go away did I not save or did I
not add okay it's not adding to their I
can't add two letters okay and I add it
through didn't know that before it's
just going to edit that's manually then
see if it'll work that way now does it
work
no it just completely ignores two
letters okay so we all get rid of that
little thing but I'm not overly not too
bothered about you know I've been in
there I'm going to do ignore all in the
global you know the global file I guess
that'll work it's a different
configuration but you know it's not
specific to your project it's specific
globally I think I might be a bug in the
spell checker thing that you can't add
two letter words and less it explicitly
tells you that's all
spell check correctly so there's also a
way when we type things like to do like
this there's a reason I do exactly this
capital letters and the colon and it's
because you can't pull them up as lists
I'm just gonna find out where and I'm
guessing it's in maybe where are we is
something like tasks in one of the
windows haven't used in a long while
task list their control backslash T and
now you can see throughout your whole
project you can see our two do's and
where they are so now we could we could
use this to flick through and go out add
exception handling which we want so
normalizing
so we can add the normalizer or again we
want to make this useful
everywhere so I think the file manager
should have the normalize path so we'll
go into here that for a fact we know
isn't going to need to be asynchronous
because it's simply messing with a
string and that never is you know you
can make it smart judgment as that that
is not going to be asynchronous so this
is happy to just be a normal function
with a string or at a string and we'll
call this normalized path and then the
path will go in normalize is a path
based on the current operating system a
path to normalize and then we will copy
that entire thing and we will paste it
here probably normalize string and then
we'll simply do a switch on our part
number where I was a bad one to check
for checking for the run time don't note
with you somewhere else sure we have
have we never switched for an operating
system yet oh yeah we are I'm forgetting
we are in call here
so another see only works on Windows at
the minute but that's the point of the
core is now dotnet standard so this will
work on Linux and Mac so we should start
switching for which OS run
so our architecture we switch on and
then we check over on not the
architecture we want the platform is OS
platform we can't do a switch on that so
instead we'll do if the OS platform is
OS platform not Windows then return-path
dot replace any forward slashes and this
is going to be used specifically for
files because we're in file manager so
URLs don't matter so basically on any
path you want to replace a forward slash
with a backslash and we also want to
trim both ends to make it blank and what
to complain about now expect a closure
of what oh top the if statement
otherwise we will presume what we know
then or either on Mac or Linux right now
so if it's that way around then it's the
exact opposite we want to make any back
slashes forward slashes so everyone
Windows plays any forward slashes with
back ever
on the next Mac in place any should do
that instead of Lee place any for
look-back
so I would normalize code its then in
here we can now normalize path and we
could also do Anna absolutely so we just
do normalize path and then we want to we
don't need to resolve path here but it
will help with the locking in case
somebody passes in a relative path that
boils down to the exact same path
resolve to absolute path resolved path
and same again file manager we will add
resolve pass now this is doesn't matter
which platform you're on it does the
same because we're already calling a
dotnet call built-in function resolves
any relative elements of the path to
absolute the path to resolve and salute
then we will place it there we also want
to wrap no we don't need to probably
strange partner to resolve the absolute
path we simply turn path dot you get
full path and that's it because we will
call in a built in net standard function
anyway now we've normalized resolved
exception captioners next video we can
do the IOC dot a stop run we can of also
just double check this works and we've
passed in a relative path but now we
should be able to see in there we've got
no /e so that won't change will resolve
in that now and you'll should see now
it's now resolved to my exact folder so
now when we do the async await the key
is now going to look like that so you
know it's it's got the file manager name
prefixed and then the whole path so no
matter how you access this file it's
been resolved and made absolute so we'll
always be there's no other way to point
to this file so you can make sure this
lock always works on that file then so
that's that we can now add the all out
the IFC toss top run as well just so
that when we may want to call say this
was being called this tossed out run
outside of any kind of a weight we also
love the error so for that's just yet
another IOC interface so that we can
again replace it for unit testing or
anything else
and this will be AI task manager I guess
and then we always add anything else
that is to do with tasks and Lord
anything to do with tasks I simple and
we will have test our own returns a task
so tasks run and it will mimic this
exact thing so it's going to pass in an
action or a return value which doesn't
actually return funnily enough it's not
showing the return value on that but we
can pass in a cancellation token we'll
add these as we need so right now we
will do tasks top run for just an action
and we will pass in a cancellation token
in fact with you just go to if this
works you can do these tasks runs here
and you can do all of them
so you just copy the entire thing so
we've got all of the runs oh we got the
comments as well we just run us so all
of nope they aren't correct comments
anyway nasty we will keep the summary we
have to change these though so they
haven't copied in the correct format so
I will basically move all these comments
over like this for each of these and
then skip ahead in the video students
watch me just fixing these comments okay
so that's all that done all's I've done
is remove the public static from the
start and then moved all the comments
into proper summary comments the funny
thing you'll find is the dotnet standard
comments are actually spelt wrong as
well which I always
I usually spell cancelled with two L's
but it's actually a single one so the we
should really report that - they get
hope that they've spelled it wrong in
their tasks run so that's all that done
that's basically a clone of the
functions in the tasks run that we want
to be able to provide then we will now
make an implementation of that so again
for now because you just got the core
project will just make a folder called
tasks and then here will now make the
task manager and then remove that remove
the extra stuff the class task manager
and then we'll go into the copy comment
I'm not going to copy the comments on
these because they're all inside the
interface otherwise we'll get huge as
well for every one of these then we want
to do we'll make a helper function so
these can be first the task methods
these all go down
private halfa methods and then in here
with one to love the error so log error
and it would be again exception of e^x
the logger gets the call stack so we
don't need to worry about that it will
find out you know where it was called
from for us as we just want to log the
exception which would be IFC blogger
blog and it would be what this catch do
we want to catch there no it's fine
there it's fine for now because we know
it's in the task manager it's just
simply a verbose log that we know it's
come from somewhere awesome thing in
here is that we're going to read the
origin of this log message is going to
be this file not you know really any
kind of source
but that's fine for the ology will
simply pass the details in or the ever
lock will give us more details anyway
about the error so it should be fine
each of these functions then would just
be in fact we would have these are all
tasks no not the same so got a task and
a task of T result so we'd have to sort
of I'd love to try catch on everyone so
we'll just say try run and we've passing
the function and in here dry run if we
did a private task return dry run
perfect ass dry run and we want to
accept oh no we have to accept every
single thing definitely nope ok so
easier than that it's just going to be
rough everyone in a dry caption log it
so in here we will do an on expected
error expected error occurred running a
IOC dot class stop run and the error is
yep message the info is another class as
debug but it's like really low or
whether we want to class it as an actual
error because it depends on if you you
know you expecting an hour anyway so I'm
gonna keep it as debug like low level
and then if this is a be hunting for
average you can find you know errors by
simply logging everything so logs the
given over to the log factory
and I think that's it for their and then
for each of these calls now we want to
mimic the exact same thing so we want to
do try tasks run function just literally
pass it straight into the you know the
underlying normal task top run that we
want to run but then we want to log the
error try and run the task blog the
error but then write which is normal and
the reason we we throw it is so that you
know anyone calling to stop run if they
are expecting it to crash in a certain
way which we will be this will you know
make sure that still happens so we don't
change the flow of code we simply
intercept it log it and carry on and
then we can copy and paste this as much
I don't like copy and pasting it's
probably the quickest way here because
otherwise you have to make a helper
function that passes in different things
every time and then we just need to make
sure we pass in the same parameter
straight down and then and then we'll
see this in action because we'll make
you crash to chat it does
you know do its job and I'll show you
why you know in a situation where it
will be useful to show you that it's
it's gonna be handy down the line as
your application grows because there
trust me when this gets thousands and
thousands of lines long the last thing
you want to be doing a searching for a
task that's crushed silently that you
can't find anywhere right that's all of
them done so they are basically just
calling the normal stuff now about the
task manager IOC we need to add it to
the IFC as a shortcut so give that AI
task manager task
test manager I feel put to the test
manager and then in the application just
save that in the application here we now
want to bind to the base factory
furthest which means the base factory
can't make use of the task would that
ever need to though add logo every move
log of log notes are synchronous so he
always ought to bear in mind as well is
in in the case of setting off sometimes
the well the only place you couldn't do
it is in the Constructors of things that
are in the IOC so like the you know the
file manager couldn't seize this order
the file managers constructor couldn't
get access to the IOC UI manager because
it's not an injected yeah so you just
have to think about this order on very
first spin up so I was just making sure
the log factory didn't need to do any
tasks in the constructor which it
doesn't so we're fine so IOC kernel dot
buying I task manager constant new task
manager our task manager so now we
search for tasks run anywhere we call it
which is quite a lot of places already
and we want to replace this with IOC
Tartar on and make sure we make use of
that everywhere so it's just pin this or
in it add that so we've done that now I
have C dot Taran and now we just make
sure we don't lose in the actual call
which is the task manager so that in
fact we only use it in two places which
use one here and one where we were using
it so that's all in and replaced
so now let's show you where it would be
of use so in here we'll log twice if we
through because this will log it and
then pass up and this also logs in case
you know they used differently so let's
just go into the app again at the start
here and let's just say
this bit of code here or rather that's
not track accurate let's just say we did
exactly what we were mentioning before
where we do IOC got tasks top run and we
were running some kind of tasks ooh and
awaiting so this now is going to
complain or in fact it doesn't even
complain again so it's not complaining
that it's gonna run off the threat which
is this is the whole point I keep
mentioning of how easy it would be to
get a silent error so you could then
just say throughout so this is your code
crushing and whoops
so something crashes and we run this
code and your application won't crash so
you if we weren't logging there she'd be
unaware of any kind of issue and things
might appear to be normal and then
ultimately your you know state is out of
sync so the application spun off at all
looks okay the only reason it hit there
is because I have my exceptions turned
on here so that's the only reason we
even saw the you know that but in terms
of it running in general this is what
you'd see you'd see nothing out of the
ordinary wherever we then go to the
folder our log should have caught that
exception so bin-debug now log now
should say oops in it
yeah which it doesn't sort see why so
let's hit this and let's restart so we
get into here we I have seed up tossed
up run so it's good to task manager and
it should be a faction I should be
calling I think so we should be calling
this one here unless this is doing some
kind of precompilation but we should hit
there why is this not calling into our I
would call it into
so it's getting into the top on here so
we get there this should run the
function and crash shoot doors oh and
it's not even ha so that's not quite
working as expected is this because of
how the anonymous action has been run
because that's not synchronize that
should of Court that's interesting
so if we hit here we run I know why so
slight changed there and that's the key
to it is we're returning the task
directly to the caller so this will
never this isn't awaiting so even though
it's a task we aren't awaiting so what
we need to do is change these to
asynchronous and instead of returning we
await and that will bring them in line
with this threat and then this threat
will catch so now if we run and then
we'll change that for every function but
that's what we need to do and in fact
it's not even a function so it shouldn't
have done that one but there's the throw
and now we've caught it here which is
oops and then we log it and carry on so
now if we open off the logger we now
have an unexpected error occurred
running tests are on but not be null
oops
and so we log you know we logged the
error and this error would actually say
something a bit more specific we could
take this further and have the if we do
the where's the logger how we have on
here all these origins we could get all
of those so we get more info we could
dump them into every function so we
could copy last like so and we'll do
this because then it gives us you know
better detail then the log exception
would have to be file path
or averaging filepath line number like
cell we would have to pass all these
into the task manager as well just the
same and I don't think we do defaults
though and again all this extra work
will pay off you know ultimately once
we've done this let's have a look at the
logs I know we did something specific to
the log factory for make that work yeah
that's fine so what's this complaining
about but then back in a minute
you put the back in yeah there we go so
dude just copy and paste it into these
so go to every one of these paste in the
caller and this will give us more detail
than we get as well so we now know where
the original source is coming from not
where the log of the crash is coming
from which is always going to be the the
task so we took them in then we will get
the comments from the log factory so
they match and in every one of these
will dump even more comments which in
Perham section and lactate mat seemed
like a hell of a lot of work but this
will always benefit you down the line
where it's gonna say the first air you
ever encounter that's unexpected this
will pay for itself
because you'll have as much detail as
you need almost as if you're debugging
locally so we do that for every task we
change everyone to a weight instead of
return make our log error have the same
stuff
make up even the same comments for those
again and here the exception for log and
now in here we can then pass in the new
origin file path and line number so it
passes through from the original caller
so we can test that first on one which
is this one now I hope we can't until
we've pasted this in for everyone so
they match the interface again and then
we'll come back and add the you know the
return that await statements instead of
the returns but let's just check this
works first writes no it should be
implementing the interface again we run
we should get a crash login this time it
tells us that it should have come from
this IOC dot a star on funnily enough
which wouldn't boil to start off because
we just run it inside but typically this
would have been that you wouldn't do
this you would have been running inside
of it a task already in fact now it's a
point you'd have been running in there
all the time
so we might have to bake that further
off so now an error occurred in oh they
get us caught it so it's bubbled up to
now the app sam'l on startup call
instead of the task manager dot log
error so that was a lot more specific we
now know the ever come from line 33 and
on start off in apps Amal so it come
from exactly here you know technically
it's come from the run you know the
thread but that's that's enough it's got
us to the line of code where it's
starting sim got at the function name
that it's inside off so that's the
information we need so now when
something crashes we know exactly where
and why for and the date and time so I
think that covers file logging you can
go further and potentially make tennis
into a markdown file so don't know how
long we've been running for but we keep
fairly easily out of markdown file
or even a flag to turn it into markdown
style but will you know we will do that
right now is you don't really have a
markdown walk file it's a lot of files
typical just text them but that's the
file logging done
so again now anywhere we do a log it can
log to file so hopefully that was useful
next video will probably now look at
exception handling catching all the
other exceptions doing the to do for
application settings so we can start
storing settings moving into some JSON
synchronization serialization rather and
basically again getting this application
ready for being complete when the
server's done so all this growth in all
this IOC and all these managers and
things are the preparation work to get
this application you know ready for all
ah so again any comments let me know but
hopefully this has been another useful
video</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>